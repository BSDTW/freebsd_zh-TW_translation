<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org" />
<title>進階主題</title>
<meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.79" />
<link rel="HOME" title="FreeBSD 5.X、6.X 常見問答集" href="index.html" />
<link rel="PREVIOUS" title="FreeBSD 冷笑話集" href="funnies.html" />
<link rel="NEXT" title="感謝" href="acknowledgments.html" />
<link rel="STYLESHEET" type="text/css" href="docbook.css" />
<meta http-equiv="Content-Type" content="text/html; charset=Big5" />
</head>
<body class="CHAPTER" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#840084"
alink="#0000FF">
<div class="NAVHEADER">
<table summary="Header navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<th colspan="3" align="center">FreeBSD 5.X、6.X 常見問答集</th>
</tr>

<tr>
<td width="10%" align="left" valign="bottom"><a href="funnies.html"
accesskey="P">Prev</a></td>
<td width="80%" align="center" valign="bottom"></td>
<td width="10%" align="right" valign="bottom"><a href="acknowledgments.html"
accesskey="N">Next</a></td>
</tr>
</table>

<hr align="LEFT" width="100%" />
</div>

<div class="CHAPTER">
<h1><a id="ADVANCED" name="ADVANCED"></a>Chapter 18 進階主題</h1>

En-Ran Zhou

<div class="QANDASET">
<dl>
<dt>18.1. <a href="advanced.html#LEARN-ADVANCED">如何能學習更多有關 FreeBSD
內部的東西？</a></dt>

<dt>18.2. <a href="advanced.html#HOW-TO-CONTRIBUTE">如何能為 FreeBSD 出一份力？</a></dt>

<dt>18.3. <a href="advanced.html#DEFINE-SNAP-RELEASE">SNAP 和 RELEASE 是什麼？</a></dt>

<dt>18.4. <a href="advanced.html#CUSTREL">要怎麼作出自己的 release？</a></dt>

<dt>18.5. <a href="advanced.html#MAKEWORLD-CLOBBERS">為何 <tt class="COMMAND">make
world</tt> 會把原來裝的 binary 檔都換掉了？</a></dt>

<dt>18.6. <a href="advanced.html#CVSUP-ROUND-ROBIN">Why isn't cvsup.FreeBSD.org a round
robin DNS entry to share the load amongst the various CVSup servers?</a></dt>

<dt>18.7. <a href="advanced.html#BUS-SPEED-DEFAULTED">在系統開機時，出現 “(bus speed
defaulted)”。</a></dt>

<dt>18.8. <a href="advanced.html#CTM">在網路頻寬有限的情況下，我也可以跟上 current
的發展嗎？</a></dt>

<dt>18.9. <a href="advanced.html#SPLIT-240K">是怎麼把發行版本中的檔案切成一個個 240k
的小檔案的？</a></dt>

<dt>18.10. <a href="advanced.html#SUBMITTING-KERNEL-EXTENSIONS">我在 kernel
中加了新功能，我要把它寄給誰？</a></dt>

<dt>18.11. <a href="advanced.html#PNP-INITIALIZE">ISA
的隨插即用卡是如何偵測及初始化的？</a></dt>

<dt>18.12. <a href="advanced.html#MAJOR-NUMBERS">我為某設備寫了驅動程式，能不能給它一個
major number？</a></dt>

<dt>18.13. <a
href="advanced.html#ALTERNATE-DIRECTORY-LAYOUT">關於更動目錄放置的原則？</a></dt>

<dt>18.14. <a href="advanced.html#KERNEL-PANIC-TROUBLESHOOTING">如何在 kernel panics
時得到最多的資訊？</a></dt>

<dt>18.15. <a href="advanced.html#DLSYM-FAILURE">為什麼 dlsym() 不能操作 ELF
執行檔？</a></dt>

<dt>18.16. <a href="advanced.html#CHANGE-KERNEL-ADDRESS-SPACE">我要如何增加或減少 kernel
能定址的空間？</a></dt>
</dl>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="LEARN-ADVANCED" name="LEARN-ADVANCED"></a><b>18.1.</b> 如何能學習更多有關
FreeBSD 內部的東西？</p>
</div>

<div class="ANSWER">
<p><b></b>目前市面上還沒有探討作業系統內部的書是專為 FreeBSD 而寫 的。然而，許多一般的
UNIX 知識都可以直接應用在 FreeBSD 上。附 加一點，仍然有相關的書是專為 BSD 所寫的。</p>

<p>請參考 Handbook 的<a href="../handbook/bibliography-osinternals.html"
target="_top">作業系統內部之參考書目</a> 。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="HOW-TO-CONTRIBUTE" name="HOW-TO-CONTRIBUTE"></a><b>18.2.</b> 如何能為 FreeBSD
出一份力？</p>
</div>

<div class="ANSWER">
<p><b></b>請參考這篇文章 <a href="../../articles/contributing/article.html"
target="_top">Contributing to FreeBSD</a> 來提供您的建議。如果您能幫忙那就更歡迎了！</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="DEFINE-SNAP-RELEASE" name="DEFINE-SNAP-RELEASE"></a><b>18.3.</b> SNAP 和
RELEASE 是什麼？</p>
</div>

<div class="ANSWER">
<p><b></b>目前有三個活躍/半活躍的分支在 FreeBSD 的 <a
href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">CVS Repository</a>
(古早分支已經幾乎沒在更新了，因為通常只有三個活躍的發展分支)：</p>

<ul>
<li>
<p><tt class="LITERAL">RELENG_5</tt> 即 <span class="emphasis"><b
class="EMPHASIS">5-STABLE</b></span></p>
</li>

<li>
<p><tt class="LITERAL">RELENG_6</tt> 即 <span class="emphasis"><b
class="EMPHASIS">6-STABLE</b></span></p>
</li>

<li>
<p><tt class="LITERAL">HEAD</tt> 即 <span class="emphasis"><b
class="EMPHASIS">-CURRENT</b></span> 也就是目前的 <span class="emphasis"><b
class="EMPHASIS">7.X-CURRENT</b></span></p>
</li>
</ul>

<p>與上面其他兩個分支相比，其實 <tt class="LITERAL">HEAD</tt> 並不是真正 的 branch
tag，它只是個 symbolic constant，代表 “<span class="emphasis"><b
class="EMPHASIS">current (尚未分支的發展中版本)</b></span>”，通常我們會簡寫為
“-CURRENT”。</p>

<p>就現在而言，“-CURRENT” 就是指 7.X 的發展； 而 <tt class="LITERAL">5-STABLE</tt>
分支(<code class="SYMBOL">RELENG_5</code>)是在 2004 年 10 月從 “-CURRENT” fork 出來的；
<tt class="LITERAL">6-STABLE</tt> 分支(<code class="SYMBOL">RELENG_6</code>)是在 2005 年
11 月從 “-CURRENT” fork 出來的。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="CUSTREL" name="CUSTREL"></a><b>18.4.</b> 要怎麼作出自己的 release？</p>
</div>

<div class="ANSWER">
<p><b></b>請參照 <a href="../../articles/releng/article.html" target="_top">Release
工程</a> 文章說明。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="MAKEWORLD-CLOBBERS" name="MAKEWORLD-CLOBBERS"></a><b>18.5.</b> 為何 <tt
class="COMMAND">make world</tt> 會把原來裝的 binary 檔都換掉了？</p>
</div>

<div class="ANSWER">
<p><b></b>沒錯，就是這樣子。如名字所示，<tt class="COMMAND">make world</tt>
會重新編譯系統內建的每個 binary
檔，這樣在結束時就可確定有個一致且乾淨的環境(所以要花上好一段時間)。</p>

<p>在執行 <tt class="COMMAND">make world</tt> 或 <tt class="COMMAND">make install</tt>
時，如果有設 <tt class="LITERAL">DESTDIR</tt> 這個環境變數，新產生的 binary 將會裝在 <tt
class="LITERAL">${DESTDIR}</tt> 下同樣的目錄樹中。但在某些修改 shared library 和重建
binary 的無特定情況下，這樣做可能會使 <tt class="COMMAND">make world</tt> 失敗。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="CVSUP-ROUND-ROBIN" name="CVSUP-ROUND-ROBIN"></a><b>18.6.</b> Why isn't
cvsup.FreeBSD.org a round robin DNS entry to share the load amongst the various CVSup
servers?</p>
</div>

<div class="ANSWER">
<p><b></b>While CVSup mirrors update from the master CVSup server hourly, this update
might happen at any time during the hour. This means that some servers have newer code
than others, even though all servers have code that is less than an hour old. If <tt
class="HOSTID">cvsup.FreeBSD.org</tt> was a round robin DNS entry that simply redirected
users to a random CVSup server, running CVSup twice in a row could download code older
than the code already on the system.</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="BUS-SPEED-DEFAULTED" name="BUS-SPEED-DEFAULTED"></a><b>18.7.</b>
在系統開機時，出現 “(bus speed defaulted)”。</p>
</div>

<div class="ANSWER">
<p><b></b>Adaptec 1542 SCSI 卡允許使用者用軟體調整匯流排的存取速度。 早期的 1542
驅動程式試圖將它設成可用的最快速度，但後來發現在一 些機器上不能用，所以現在要在 kernel
設定中加 <code class="SYMBOL">TUNE_1542</code> 這個選項來啟動這個功能。在支援的機器
上用這個選項會使硬碟存取更快，但在不支援的機器上有可能會毀掉資料。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="CTM" name="CTM"></a><b>18.8.</b> 在網路頻寬有限的情況下，我也可以跟上 current
的發展嗎？</p>
</div>

<div class="ANSWER">
<p><b></b>是的，藉著 <a href="../handbook/synching.html#CTM" target="_top">CTM</a>
您就可以<tt class="LITERAL">不用</tt>下載全部的程式碼。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="SPLIT-240K" name="SPLIT-240K"></a><b>18.9.</b>
是怎麼把發行版本中的檔案切成一個個 240k 的小檔案的？</p>
</div>

<div class="ANSWER">
<p><b></b>以 BSD 為基礎的較新系統有個 <code class="OPTION">-b</code> 選項
可以把檔案以任意數目 byte 切開。</p>

<p>這裡是 <tt class="FILENAME">/usr/src/Makefile</tt> 中的一個 例子：</p>

<pre class="PROGRAMLISTING">
bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)
</pre>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="SUBMITTING-KERNEL-EXTENSIONS"
name="SUBMITTING-KERNEL-EXTENSIONS"></a><b>18.10.</b> 我在 kernel
中加了新功能，我要把它寄給誰？</p>
</div>

<div class="ANSWER">
<p><b></b>請參考 <a href="../../articles/contributing/article.html"
target="_top">Contributing to FreeBSD</a> 中的文章，以了解要如何提供您的程式碼。</p>

<p>同時也謝謝您的關心！</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="PNP-INITIALIZE" name="PNP-INITIALIZE"></a><b>18.11.</b> ISA
的隨插即用卡是如何偵測及初始化的？</p>
</div>

<div class="ANSWER">
<p><b></b>由 Frank Durda IV 所寫： <code class="EMAIL">&#60;<a
href="mailto:uhclem@nemesis.lonestar.org">uhclem@nemesis.lonestar.org</a>&#62;</code></p>

<p>簡單的說，當主機發出是否有 PnP 卡的詢問訊號時，所有的 PnP 卡 會在幾個固定的 I/O port
作回應。所以當偵測 PnP 的程式開始時，它 會先問有沒有 PnP 卡在，接著所有 PnP 卡會在它讀的
port 以自己的 型號 # 作回答，這樣偵測程式就會得到一個 wired-OR “yes”
的數字，其中至少會有一個 bit 是打開的。然後偵測程式會要求型號 (由
Microsoft/Intel指定)小於 X 的卡“離線”。再去看是 否還有卡回答同樣的詢問，如果得到 <tt
class="LITERAL">0</tt>，就表示沒 有型號大於 X 的卡。 現在程式會問是否有型號小於 <tt
class="LITERAL">X</tt> 的卡，如果有的話，程式再要型號大於 X-(limit/4) 的卡離線，然後重覆
上面的動作。用重複這種類似 semi-binary search 的方法，在某範圍內
找個幾次後，測程式最後會在機器中區分出所有的 PnP 卡，搜尋次數也 遠低於一個個找的 2^64
次。</p>

<p>一張卡的 ID 由兩個 32-bit(所以上面是 2&circ;64) + 8bit 偵錯碼 組成，第一個 32 bits
是用來區分各家廠商的。這些廠商從來沒有出來澄
清過，但看來應假設同一家出的不同種類的卡的廠商 ID 有可能不同。用 32 bits
只來表示不同廠商的想法實在有點過頭了。</p>

<p>第二個 32 bits 則是型號 #、乙太網路位址、或一些使這張卡獨特的 資料。除非第一個 32 bits
不同，否則廠商不可能作出第二個 32 bit 相
同的兩張卡。所以在一台機器中可以有同樣的好幾張卡，然而他們整個 64 bits
還是會都不一樣。</p>

<p>這兩個 32 bit 絕對不可以全為零，這才能使得最開始 binary search 中的 wired-OR
會得到一個非零數字。</p>

<p>一旦系統區分出所有卡的 ID，接著會經由同樣的 I/O port 一個個重
新啟動每張卡，接著找出已知介面卡所需的資源、有哪些中斷可以使用等
等。所有卡都會被掃描一次，來收集這些資料。</p>

<p>這些資訊接著和硬碟上的 ECU 檔案、或 MLB BIOS 裡的資料結合在一 起，通常是綜合 ECU 和
MLB 裡的 BIOS PnP 資料，這些週邊並不支援真正 的 PnP，然而偵測程式在檢查 BIOS 和 ECU
資料後，它可以避免 PnP 週邊 和那些偵測不到的相衝突。</p>

<p>接著再度拜訪這些 PnP 週邊，這次會把可用的 I/O、DMA、IRQ 和記憶
體映射的位址都指定給它們。這些週邊就會出現在所指定的地方，直到下一
次重新開機為止，不過也沒有人說不能把它們隨時移來移去。</p>

<p>上面有相當多的簡化，但你應該已經了解大致的過程。</p>

<p>Microsoft 把表示印表機狀態的幾個主要 port 拿來作 PnP，他們的
邏輯是沒有一張卡會在這些地方解碼作相反的 I/O cycles。但是我找到 一款早期仍在評估 PnP
提案時的 IBM 原廠 printer board，它的確去解 對這些狀態 port 的寫入資料，但是 MS
“說了就算”。所以 它們的確有對印表機狀態 port 寫入，還有讀取該位址 + <tt
class="LITERAL">0x800</tt>、和另一個在 <tt class="LITERAL">0x200</tt> 及 <tt
class="LITERAL">0x3ff</tt> 之間的 port。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="MAJOR-NUMBERS" name="MAJOR-NUMBERS"></a><b>18.12.</b>
我為某設備寫了驅動程式，能不能給它一個 major number？</p>
</div>

<div class="ANSWER">
<p><b></b>這要看你是否打算將這個驅動程式公開使用，如果是的話，請把它的
原始碼送一份給我們，還有 <tt class="FILENAME">files.i386</tt> 修改的 部份、kernel
設定檔樣本、以及用來產生設備檔的 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">MAKEDEV</span>(8)</span></a>。
如果你不打算公開、或因為版權問題而不能公開的話，我們有特地保留 character major number 32
和 block major number 8 給這方面的使用，
直接用這兩個就好了。不論如何，我們都會很感激你能在 <a
href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers" target="_top">FreeBSD
technical discussions 郵遞論壇</a> 發表驅動程式的消息。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="ALTERNATE-DIRECTORY-LAYOUT" name="ALTERNATE-DIRECTORY-LAYOUT"></a><b>18.13.</b>
關於更動目錄放置的原則？</p>
</div>

<div class="ANSWER">
<p><b></b>在回答關於更動目錄放置的原則方面，我在 1983 年寫好目前的作法
後就沒有再改變過，這種方式是針對原先的 FFS 檔案系統，後來也沒有 對它作任何更動。它在避免
cylinder group 被填滿這方面做得相當成功， 但是就像有些人已經注意到，它和 find
就配合得不大好。大部份的檔案 系統是由那些用 depth first search(aka ftw) 產生的 archive
製造出 來，解出來的目錄 inode 會橫跨好幾個 cylinder group，如果以後要做 depth first
search 的話，這是最糟糕的情況之一。如果我們知道總共
會產生多少目錄的話，解法是在做任何存取/寫入動作之前，在每個 cylinder group
上先造出(所有目錄數/cylinder greoup 的數目)這麼多
的目錄。很明顯的，我們必須要有根據地去猜這 個數字，就算一個像 10
的很小固定數目也會使效率以級數成長。區分 restore (即解開上述的 archive)
和一般檔案操作的方法可以是(現在用的演算法可能要更敏感)： 如果一些目錄(最多 10 個)都在 10
秒內產 生的話，那麼就把這些目錄 聚集在同一個 cylinder group。不管怎樣，
我的經驗指出這是一個已經 充份實驗過的部份。</p>

<p>Kirk McKusick, September 1998</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="KERNEL-PANIC-TROUBLESHOOTING"
name="KERNEL-PANIC-TROUBLESHOOTING"></a><b>18.14.</b> 如何在 kernel panics
時得到最多的資訊？</p>
</div>

<div class="ANSWER">
<p><b></b><span class="emphasis"><b class="EMPHASIS">[這節是從 Bill Paul <code
class="EMAIL">&#60;<a href="mailto:wpaul@FreeBSD.org">wpaul@FreeBSD.org</a>&#62;</code>
在 FreeBSD-CURRENT <a href="support.html#MAILING">mailing list</a> 上發表的信中節錄，
Dag-Erling C. Sm&oslash;rgrav <code class="EMAIL">&#60;<a
href="mailto:des@FreeBSD.org">des@FreeBSD.org</a>&#62;</code>
修正了打字錯誤、再加上括弧裡的注解。]</b></span></p>

<pre class="PROGRAMLISTING">
From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: Ben Rosengart
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org
</pre>

<p><span class="emphasis"><b class="EMPHASIS">[Ben 發表了下面的 panic
訊息]</b></span></p>

<pre class="PROGRAMLISTING">
&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault
</pre>

<p>當你看到像這樣的訊息時，只把它拷一份送上來是不夠的。我在上面 特地標明的 instruction
pointer 值相當重要，不幸的是它會因設定而 不同。換句話說，這個值會跟你用的 kernel image
檔而變動。如果是用 某個 snapshot 版本的 GENERIC kernel，也許其他人可以追蹤到出問題
的函式，但如果你是用自訂的 kernel，那麼只有 <span class="emphasis"><b
class="EMPHASIS">你</b></span>才能告訴我們問題出在那裡。</p>

<p>要做的事包括這些：</p>

<div class="PROCEDURE">
<ol type="1">
<li class="STEP">
<p>把 instruction pointer 的值記下來。注意在前面的 <tt class="LITERAL">0x8:</tt>
在這個情況中並不重要，我們要的是 <tt class="LITERAL">0xf0xxxxxx</tt>。</p>
</li>

<li class="STEP">
<p>當系統重新開機後，執行這道命令：</p>

<pre class="SCREEN">
<samp class="PROMPT">%</samp> <kbd
class="USERINPUT">nm -n /(造成 panic 的 kernel 檔案) | grep f0xxxxxx</kbd>
</pre>

其中 <tt class="LITERAL">f0xxxxxx</tt> 就是記下來的 instruction pointer
值。有可能不會剛好找到完整的這個字串， 這是因為 kernel symbol table 裡的各個 symbol
只是函式的進 入點，但 instruction pointer 所指的位址有可能是在函式內的
某一處，而不一定在開頭。所以如果找不到整個字串，那麼把 instruction pointer
值的最後一個數字拿掉，再試一次： 

<pre class="SCREEN">
<samp class="PROMPT">%</samp> <kbd
class="USERINPUT">nm -n /(造成 panic 的 kernel 檔案) | grep f0xxxxx</kbd>
</pre>

如果這樣也找不到，那就把另一個數字去掉再找，一直重複到找到 為止， 結果是一串可能造成
panic 的函式列表。這樣比直接找到 出問題的函式來得差，但至少好過什麼都沒有。<br />
<br />
</li>
</ol>
</div>

<p>我常常看到人們顯示一大片 panic 訊息，但很少看到有人花一點時間 把 instruction pointer
和 kernel symbol table 中的函式比較一下。</p>

<p>要追蹤出造成 panic 原因的最好方法是先做出 crash dump，然後用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a> 在上面做 stack
trace。</p>

<p>不管是那一種，我通常是用這個方法：</p>

<div class="PROCEDURE">
<ol type="1">
<li class="STEP">
<p>寫好 kernel 設定檔。如果你需要用 kernel debugger，在設 定檔中加上 <tt
class="LITERAL">options DDB</tt> 這個選項。
(當我懷疑有出現無窮迴圈時，通常會用這個來設定中斷點。)</p>
</li>

<li class="STEP">
<p>用 <tt class="COMMAND">config -g <tt class="REPLACEABLE"><i>KERNELCONFIG</i></tt></tt>
做出用來編譯的目錄。</p>
</li>

<li class="STEP">
<p><tt class="COMMAND">cd /sys/compile/ <tt class="REPLACEABLE"><i>KERNELCONFIG</i></tt>;
make</tt></p>
</li>

<li class="STEP">
<p>等待 kernel 編譯結束。</p>
</li>

<li class="STEP">
<p><tt class="COMMAND">make install</tt></p>
</li>

<li class="STEP">
<p>重新開機</p>
</li>
</ol>
</div>

<p><a href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">make</span>(1)</span></a> 將會製造出兩個
kernel。<tt class="FILENAME">kernel</tt> 還有 <tt class="FILENAME">kernel.debug</tt>。
<tt class="FILENAME">kernel</tt> 將會被安裝到 <tt class="FILENAME">/kernel</tt>，而 <tt
class="FILENAME">kernel.debug</tt> 可用來給 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a> 當作 debugging
symbols 的來源。</p>

<p>要確定能抓到 crash dump，先編輯 <tt class="FILENAME">/etc/rc.conf</tt> 將 <tt
class="LITERAL">dumpdev</tt> 指 到 swap 分割區。這樣 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">rc</span>(8)</span></a> 會用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">dumpon</span>(8)</span></a> 來啟動 crash
dump，你也可以手動執行 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">dumpon</span>(8)</span></a> 在 panic
之後， crash dump 可以用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">savecore</span>(8)</span></a>
存起來；如果 <tt class="FILENAME">/etc/rc.conf</tt> 裡有設 <tt
class="LITERAL">dumpdev</tt> 那麼重新開機後 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">rc</span>(8)</span></a> 會自動執行 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">savecore</span>(8)</span></a> 把 crash
dump 存在 <tt class="FILENAME">/var/crash</tt>。</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> FreeBSD 的 crash dump 通常和機器裡的實際記憶體一樣大，就 像如果有 64MB
記憶體，crash dump 大小就是 64MB。所以要確定 <tt class="FILENAME">/var/crash</tt>
下有足夠的空間，或是可以手 動執行 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">savecore</span>(8)</span></a> 把 crash
dump 放到另一個空間較夠的 目錄下。另一種也許可以限制 crash dump 的方法，是在 kernel
設定檔中用 <tt class="LITERAL">options MAXMEM=(foo)</tt>，將 kernel
可用的記憶體限制在合理的大小。舉例來說，如果你有 128MB 的記憶 體，但是可以限制 kernel
只能用 16MB 的記憶體，這樣 crash dump 就是 16MB 而不是 128MB 了。</p>
</blockquote>
</div>

<p>一旦發現有了 crash dump，就可以用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a> 來做 stack
trace ，如下所示：</p>

<pre class="SCREEN">
<samp class="PROMPT">%</samp> <kbd
class="USERINPUT">gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</kbd>
<samp class="PROMPT">(gdb)</samp> <kbd class="USERINPUT">where</kbd>
</pre>

<p>要注意可能會出現好幾個螢幕的可用資訊，你可以用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">script</span>(1)</span></a>
把所有輸出都存起來。用包括所有 debug symbol 的 kernel 來除錯，這 樣應該可以直接顯示 panic
是發生在那一行。通常是由下往上讀 stack strace，這樣才能一個個追蹤出有哪些動作引到
crash。也可以用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a>
把各種變數或結構的內容印出來，以檢查系統 crash 時的 實際狀態。</p>

<p>好啦，如果你有第二台電腦而且有夠瘋狂，可以將 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a> 設定
成遠端除錯。這樣你可以在一台機器中用 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">gdb</span>(1)</span></a>
去除錯另一台裡的 kernel，可以執行的包括設定中斷點、在 kernel 原始碼中一步步執行等
等，就像在一般使用者程式上除錯一樣。由於沒有什麼機會為除錯而設置
兩台並鄰電腦，所以我還沒有這樣玩過。</p>

<p><span class="emphasis"><b class="EMPHASIS">[Bill 補充："我忘了提到一點：如果你有啟動
DDB 而 kernel 也已經進入除錯器，可以在 DDB 命令列下打 'panic'，強迫產生 panic (還有 crash
dump)。也有可能在 panic 階段時再進入除錯器， 如果這樣的話，輸入
'continue'，接著它就會完成 crash dump。" -ed]</b></span></p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="DLSYM-FAILURE" name="DLSYM-FAILURE"></a><b>18.15.</b> 為什麼 dlsym() 不能操作
ELF 執行檔？</p>
</div>

<div class="ANSWER">
<p><b></b>在 ELF 一系列的工具中，內定是不會讓 dynamic linker 看到執行 檔裡定義了哪些
symbol。所以 <code class="FUNCTION">dlsym()</code> 沒有辦 法用藉由呼叫 <code
class="FUNCTION">dlopen(NULL, flags)</code> 取得的 handle，用它去搜尋有那些 symbol
一定會失敗。</p>

<p>如果你想要用 <code class="FUNCTION">dlsym()</code> 找出某個 process 的主執行檔中有哪些
symbol，則要在 link 時對 ELF linker (<a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ld</span>(1)</span></a>) 加上 <code
class="OPTION">-export-dynamic</code> 這個參數。</p>
</div>
</div>

<div class="QANDAENTRY">
<div class="QUESTION">
<p><a id="CHANGE-KERNEL-ADDRESS-SPACE"
name="CHANGE-KERNEL-ADDRESS-SPACE"></a><b>18.16.</b> 我要如何增加或減少 kernel
能定址的空間？</p>
</div>

<div class="ANSWER">
<p><b></b>預設值是，FreeBSD 3.x 的 kernel 可以定址的空間是 256 MB 而 FreeBSD 4.x 可以到 1
GB。如果是網路負荷相當重的伺服器 (例如大型 FTP 或 HTTP 伺服器)，你也許會發現 256 MB
可能不大夠。</p>

<p>所以，要如何增加定址空間呢？要從兩方面著手。首先首先告訴 kernel
本身要保留較大空間給自己。其次，既然是在定址空間的最上 面載入
kernel，所以還要調低載入的位址，才不會和前面定址的範圍 重疊。</p>

<p>增加 <tt class="FILENAME">src/sys/i386/include/pmap.h</tt> 裡的 <tt
class="LITERAL">NKPDE</tt> 就可以達成第一個目標。1 GB 的定址空間會 像這樣：</p>

<pre class="PROGRAMLISTING">
#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif
</pre>

<p>要算出 <tt class="LITERAL">NKPDE</tt> 的正確值，將想要的空間大小 (以 megabyte
為單位)除以 4，接著單 CPU 機器減 1， 雙 CPU 則是減 2。</p>

<p>要解決第二個問題，必須自行算出 kernel 被載入的位址：求出 0x100100000
減掉定址空間大小的值(以 byte 為單位)，如 1 GB 大小就是 0xc0100000。把<tt
class="FILENAME">src/sys/i386/conf/Makefile.i386</tt> 裡的 <code
class="SYMBOL">LOAD_ADDRESS</code> 設成這個值﹔接著在 <tt
class="FILENAME">src/sys/i386/conf/kernel.script</tt> 中，將 section 列表最前面的
location counter 設成相同的值，如下：</p>

<pre class="PROGRAMLISTING">
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }
</pre>

<p>然後重新編譯您的 kernel。您可能會在執行 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ps</span>(1)</span></a>、<a
href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">top</span>(1)</span></a>
這類的程式時碰到問題﹔<tt class="COMMAND">make world</tt> 應該就可以解決 (或把改過的 <tt
class="FILENAME">pmap.h</tt> 複製到 <tt class="FILENAME">/usr/include/vm/</tt>
下，再手動編譯 <tt class="FILENAME">libkvm</tt>，<a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ps</span>(1)</span></a> 還有 <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">top</span>(1)</span></a>)。</p>

<p>注意：kernel 所能定址的空間大小必須是 4 megabytes 的倍數。</p>

<p>[David Greenman <code class="EMAIL">&#60;<a
href="mailto:dg@FreeBSD.org">dg@FreeBSD.org</a>&#62;</code> 補充：<span
class="emphasis"><b class="EMPHASIS">我認為 kernel 定址空間大小應該要是 2
的乘冪，但不大確定這一點。舊的啟動程式會動到 high order address bits，記得它假設至少有
256 MB。]</b></span></p>
</div>
</div>
</div>
</div>

<div class="NAVFOOTER">
<hr align="LEFT" width="100%" />
<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="funnies.html"
accesskey="P">Prev</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Home</a></td>
<td width="33%" align="right" valign="top"><a href="acknowledgments.html"
accesskey="N">Next</a></td>
</tr>

<tr>
<td width="33%" align="left" valign="top">FreeBSD 冷笑話集</td>
<td width="34%" align="center" valign="top">&nbsp;</td>
<td width="33%" align="right" valign="top">感謝</td>
</tr>
</table>
</div>

<p align="center"><small>本文及其他文件，可由此下載：<a
href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p>

<p align="center"><small>若有 FreeBSD 方面疑問，請先閱讀 <a
href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
&#60;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&#62;。<br />
關於本文件的問題，請洽詢 &#60;<a
href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&#62;。</small></p>
</body>
</html>

