<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=big5">

<title>Debian 參考手冊 - Debian指南</title>

</head>

<body>

<p><a name="ch-tutorial"></a></p>
<hr>

<p>
[ <a href="ch-install.zh-tw.html">上一頁</a> ]
[ <a href="index.zh-tw.html#contents">目錄</a> ]
[ <a href="ch-preface.zh-tw.html">1</a> ]
[ <a href="ch-system.zh-tw.html">2</a> ]
[ <a href="ch-install.zh-tw.html">3</a> ]
[ 4 ]
[ <a href="ch-woody.zh-tw.html">5</a> ]
[ <a href="ch-package.zh-tw.html">6</a> ]
[ <a href="ch-kernel.zh-tw.html">7</a> ]
[ <a href="ch-tips.zh-tw.html">8</a> ]
[ <a href="ch-tune.zh-tw.html">9</a> ]
[ <a href="ch-gateway.zh-tw.html">10</a> ]
[ <a href="ch-edit.zh-tw.html">11</a> ]
[ <a href="ch-vcs.zh-tw.html">12</a> ]
[ <a href="ch-program.zh-tw.html">13</a> ]
[ <a href="ch-gnupg.zh-tw.html">14</a> ]
[ <a href="ch-support.zh-tw.html">15</a> ]
[ <a href="ap-appendix.zh-tw.html">A</a> ]
[ <a href="ch-woody.zh-tw.html">下一頁</a> ]
</p>

<hr>

<h1>
Debian 參考手冊
<br>第 4 章 - Debian指南
</h1>

<hr>

<p>
本章為那些初涉 Debian 世界的新手指出了基本方向。如果你接觸 Unix-like
系統已有一段時間，就能了解我底下說明的部份。請將此文件當成實戰測試吧。
</p>

<hr>

<h2><a name="s-first"></a>4.1 準備開始</h2>

<p>
從安裝 Debian
到電腦之後，您需要學會一些技巧才能活用它。讓我們給您一些簡單的練習。
</p>

<hr>

<h3><a name="s-login-root"></a>4.1.1 用 root 登入 shell 提示符號</h3>

<p>
在開機的過程中，您會看到圖形或文字介面的登入畫面(基於安裝的套件)。為了簡化說明，如果您看到的是圖形登入介面，請按下
Ctrl-Alt-F1 [<a href="footnotes.zh-tw.html#f3" name="fr3">3</a>]
切換到文字介面的登入模式。
</p>

<p>
假設您的主機名稱為 <samp><var>foo</var></samp>，那麼登入提示符號則類似：
</p>

<pre>
     <var>foo</var> login:
</pre>

<p>
輸入 <samp>root</samp>，按下 Enter 後並輸入安裝過程設定的密碼。Debian 系統跟
Unix 一樣，密碼是分辨大小寫的。接下來系統會出現一個問候訊息並留下 root
提示符號等您輸入指令。 [<a href="footnotes.zh-tw.html#f4" name="fr4">4</a>]
</p>

<pre>
     <var>foo</var> login: root
     Password: 
     Last login: Sun Oct 26 19:04:09 2003 on tty3
     Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux
     
     Most of the programs included with the Debian GNU/Linux system are
     freely redistributable; the exact distribution terms for each program
     are described in the individual files in /usr/share/doc/*/copyright
     
     Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
     permitted by applicable law.
     
     root@<var>foo</var>:root#
</pre>

<p>
透過 root 命令提示符號，您就準備進行系統管理了。root
帳號稱為超級使用者(superuser)或特權使用者(privileged user)。使用 root
帳號，您可以達成：
</p>
<ul>
<li>
<p>
讀、寫和移除任何系統上的檔案而不需考慮權限
</p>
</li>
<li>
<p>
能夠設定系統上任何檔案的擁有者和權限
</p>
</li>
<li>
<p>
設定任何系統非特權使用者的密碼
</p>
</li>
<li>
<p>
登入到任何帳號而無需輸入密碼
</p>
</li>
</ul>

<p>
分享 root 密碼來取得 root 帳號是非常不好的方法。請使用如 <code>sudo(8)</code>
的軟體就是一個較好的方式來分享管理者權限。
</p>

<p>
先登入非特權帳號再進行管理動作是值得學習的 Unix 習慣。等需要 root 權限時再使用
<samp>sudo</samp>，<samp>super</samp>或<samp>su
-c</samp>來取得特定的功能。請參閱 <a
href="ch-tune.zh-tw.html#s-sudo">更安全的工作環境 &ndash; <code>sudo</code>, 第
9.2.4 節</a>。 [<a href="footnotes.zh-tw.html#f5" name="fr5">5</a>]
</p>

<hr>

<h3><a name="s-newbiefix"></a>4.1.2 針對新手設定的最精簡環境</h3>

<p>
我認為學習電腦系統就像是學習一套外國語言。雖然學習指南很有幫助，但您需要去練習並使用這些工具。這個情況下，我建議額外安裝一些套件來輔助，例如
<code>mc</code>, <code>vim</code>, <code>lynx</code>,
<code>doc-linux-text</code> 和 <code>debian-policy</code>。 [<a
href="footnotes.zh-tw.html#f6" name="fr6">6</a>]
</p>

<pre>
     # apt-get update
      ...
     # apt-get install mc vim lynx doc-linux-text debian-policy 
      ...
</pre>

<p>
如果您已經安裝這些套件，則執行上述指令就不會重新安裝。
</p>

<hr>

<h3><a name="s-newuser"></a>4.1.3 增加帳號</h3>

<p>
系統安裝完畢，通常會添加一個普通用戶帳號，而該帳號會收到寄給 root 的信件。 [<a
href="footnotes.zh-tw.html#f7" name="fr7">7</a>]
如果您不想使用這個特殊帳號來練習以下的指令則必須建立一個新的使用者帳號。
</p>

<p>
如果新的帳號為 <samp><var>penguin</var></samp>，請輸入：
</p>

<pre>
     root@<var>foo</var>:root# adduser <var>penguin</var>
     ... 回答完所有的問題
</pre>

<p>
就會建立該帳號了。 [<a href="footnotes.zh-tw.html#f8" name="fr8">8</a>]
在進行下面的步驟前，我們先學習一些基礎。
</p>

<hr>

<h3><a name="s-sw-console"></a>4.1.4 切換虛擬主控台</h3>

<p>
在未調整過的 Debian
系統中，總共有六個獨立的虛擬終端機。也就是說您可以在文字介面的主控台中使用六個可切換的
VT-100 終端機。按下左邊的 Alt 加上 F1&ndash;F6
可以切換到另外一個終端機。每一個虛擬終端機允許不同的帳號登入且不受其他終端機影響。多人環境是
Unix 偉大的設計且容易讓人上癮。
</p>

<p>
如果您不小心在執行 X 視窗系統的機器按下
Alt-F7，則主控台螢幕會切換到視窗介面，按下 Ctrl-Alt-F1
就能回到文字主控台。試著練習切換不同的主控台並跳回到原來這一個來習慣這些特性。
</p>

<hr>

<h3><a name="s-shutdown"></a>4.1.5 如何關機</h3>

<p>
和其他現代的作業系統一樣，系統檔案會快取到記憶體中，在切斷電源之前 Debian
系統需要完成特定的關機程序才能維持檔案的完整性。使用 root
提示命令列來執行以下的關機指令：
</p>

<pre>
     # shutdown -h now
</pre>

<p>
這是多用戶模式下的關機命令。如果是單一使用者模式，請執行以下的命令：
</p>

<pre>
     # poweroff -i -f
</pre>

<p>
您也能按下 Ctrl-Alt-Delete 來關機。 [<a href="footnotes.zh-tw.html#f9"
name="fr9">9</a>]
</p>

<p>
等待螢幕上顯示 &quot;System halted&quot;
之後切斷電源。如果在BIOS和Linux中開啟了 APM 或 ACPI
，系統會自動切斷電源。詳情參閱<a
href="ch-install.zh-tw.html#s-apm">大記憶體和關機自動斷電, 第 3.8.4 節</a>。
</p>

<hr>

<h3><a name="s-playtime"></a>4.1.6 把玩時間</h3>

<p>
現在您可以大膽地使用 Debian
系統而不用擔心任何危險，因為您使用的是非特權帳號：<samp><var>penguin</var></samp>。
[<a href="footnotes.zh-tw.html#f10" name="fr10">10</a>]
</p>

<p>
我們來試著登入 <samp><var>penguin</var></samp>，如果您在 root
命令提示列，請按下 Ctrl-D [<a href="footnotes.zh-tw.html#f11"
name="fr11">11</a>] 結束 root 的動作回到登入提示符號。現在請輸入新建立的帳號
<samp><var>penguin</var></samp> 及密碼。 [<a href="footnotes.zh-tw.html#f12"
name="fr12">12</a>] 您就會顯示以下的提示命令列。
</p>

<pre>
     <var>penguin</var>@<var>foo</var>:<var>penguin</var>$
</pre>

<p>
從現在開始，底下的範皆使用簡化的命令提示列來說明。我將會使用
</p>
<ul>
<li>
<p>
<samp>#</samp> : root 命令提示列
</p>
</li>
<li>
<p>
<samp>$</samp> : 非特權帳號的命令提示列
</p>
</li>
</ul>

<p>
我們將以最簡單的方式 <a href="#s-mc">Midnight Commander (MC), 第 4.2 節</a>
和適當的方法 <a href="#s-unixlike">Unix-like 工作環境, 第 4.3 節</a> 來學習
Debian 系統。
</p>

<hr>

<h2><a name="s-mc"></a>4.2 Midnight Commander (MC)</h2>

<p>
Midnight Commander (MC)是 Linux 主控台和其它終端環境中的 GNU
&quot;瑞士軍刀&quot;。對於新手來說，選單式的控制會比傳統 Unix 指令好上手多了。
</p>

<p>
使用這個指令來流覽 Debian 系統。這是最好的方式來學習。請使用方向鍵和 Enter
鍵來流覽主要的檔案系統。
</p>
<ul>
<li>
<p>
<code>/etc</code> 以及子目錄。
</p>
</li>
<li>
<p>
<code>/var/log</code> 以及子目錄。
</p>
</li>
<li>
<p>
<code>/usr/share/doc</code> 以及子目錄。
</p>
</li>
<li>
<p>
<code>/sbin</code> 和 <code>/bin</code>
</p>
</li>
</ul>

<hr>

<h3><a name="s-mc-enhance"></a>4.2.1 加強您的 MC</h3>

<p>
為了使 MC 在離開時改變工作目錄，您需要修改 <code>~/.bashrc</code> (或
<code>/etc/bash.bashrc</code>, 由 <code>.bashrc</code> 呼叫)，使用
<samp>-P</samp> 選項，就像在說明頁面 <code>mc(1)</code> 中的敘述。 [<a
href="footnotes.zh-tw.html#f13" name="fr13">13</a>]
</p>

<hr>

<h3><a name="s-mc-start"></a>4.2.2 啟動 MC</h3>

<pre>
     $ mc
</pre>

<p>
在 MC 中可使用選單來完成所有的檔案操作，只需要使用者小小的嚐試一下就行了。按下
F1 顯示說明視窗。您可以搭配方向鍵和功能鍵來使用 MC。 [<a
href="footnotes.zh-tw.html#f14" name="fr14">14</a>]
</p>

<hr>

<h3><a name="s-mc-fm"></a>4.2.3 MC 的檔案管理功能</h3>

<p>
預設狀態是兩個目錄面板列出檔案列表。另一種好用的模式是將右邊視窗設定為
&quot;information&quot; ，以查看檔案存取權限等資訊。下面是一些基本的按鍵。如果
<code>gpm</code> daemon 在運作的話，你還可以使用滑鼠。 (在 MC
中進行剪下和貼上操作時別忘了按下 shift 鍵。)
</p>
<ul>
<li>
<p>
F1: 說明選單
</p>
</li>
<li>
<p>
F3: 內建的檔案檢視器
</p>
</li>
<li>
<p>
F4: 內建的編輯器
</p>
</li>
<li>
<p>
F9: 啟動下拉選單
</p>
</li>
<li>
<p>
F10: 離開 Midnight Commander
</p>
</li>
<li>
<p>
Tab: 在兩個視窗間移動
</p>
</li>
<li>
<p>
Insert: 標記檔案以方便多檔案的操作，如複製
</p>
</li>
<li>
<p>
Del: 刪除檔案 (小心&mdash;以 MC 設定為安全刪除模式。)
</p>
</li>
<li>
<p>
方向鍵：就是方向鍵
</p>
</li>
</ul>

<hr>

<h3><a name="s-mc-cl"></a>4.2.4 MC 的命令列技巧</h3>

<ul>
<li>
<p>
任何 <code>cd</code> 命令會改變所選畫面的目錄。
</p>
</li>
<li>
<p>
Ctrl-Enter 或 Alt-Enter 會將檔案名稱複製到命令列上。配合 <code>cp</code> 或
<code>mv</code> 命令使用來做命令列的編輯。
</p>
</li>
<li>
<p>
Alt-Tab 會顯示出 shell 的檔名擴展以供選擇。
</p>
</li>
<li>
<p>
可指定 MC 兩個目錄視窗的起始目錄；例如 <samp>mc /etc /root</samp> 。
</p>
</li>
<li>
<p>
Esc + <var>數字鍵</var> == F<var>n</var> (也就是說， Esc + `1' = F1 等等。 Esc
+ `0' = F10)
</p>
</li>
<li>
<p>
Esc 鍵 == Alt 鍵 (= Meta ， M-) ；也就是說，輸入 Esc + `c' 就等於 Alt-c
</p>
</li>
</ul>

<hr>

<h3><a name="s-mcedit"></a>4.2.5 MC 的編輯器</h3>

<p>
內建編輯器的剪下－貼上方式很有意思。按 F3 標記起始點，再次按 F3
標記終止點，而中間的選取部分會高亮度顯示。然後你可以移動游標到某處按下 F6
，被選取部分就會移到該處。如果你按下的是 F5 ，選中部分就會複製到該處。 F2
會儲存檔案， F10 是退出，所有方向鍵的作用則和它們的名字一樣直觀。
</p>

<p>
可用編輯器直接打開某個檔案：
</p>

<pre>
     $ mc -e filename_to_edit
     $ mcedit filename_to_edit
</pre>

<p>
雖然它不是多視窗編輯器，但你可利用多個 Linux
主控台來達成相同的效果。要在視窗間進行複製動作，可使用 Alt-F<var>n</var>
來切換虛擬主控台，然後使用 &quot;File-&gt;Insert file&quot; 或
&quot;File-&gt;Copy to file&quot; 將一個檔案中的內容複製到另一個檔案。
</p>

<p>
可指定任何外部編輯器來取代內建的編輯器。
</p>

<p>
許多程式使用環境變數 <samp>EDITOR</samp> 或 <samp>VISUAL</samp>
來決定使用哪個編輯器。如果你用不慣 <code>vim</code>，可在
<code>~/.bashrc</code> 中加上幾行來指定使用 <samp>mcedit</samp> ：
</p>

<pre>
     ...
     export EDITOR=mcedit
     export VISUAL=mcedit
     ...
</pre>

<p>
我推薦設定為 <samp>vim</samp> 。習慣 vi(m) 是件好事，因為在 Linux/Unix
世界裡你總找得到它們。 [<a href="footnotes.zh-tw.html#f15" name="fr15">15</a>]
</p>

<hr>

<h3><a name="s-mc-view"></a>4.2.6 MC 的檢視器</h3>

<p>
非常聰明的檢視器。它是在文件中搜索詞句的利器。我總是用它在
<code>/usr/share/doc</code> 目錄下找檔案，用它來瀏覽大量的 Linux
資料是最快的方法。檢視器可以像這樣直接啟動：
</p>

<pre>
     $ mc -v filename_to_view
</pre>

<hr>

<h3><a name="s-ma-auto"></a>4.2.7 MC 自動啟動特性</h3>

<p>
在檔案上按 Enter，會啟動相關的程式來處理該檔案。這是 MC 的一個極方便的特性。
</p>

<pre>
     executable:        執行命令
     man, html file:    將檔案內容導向 (Pipe) 至檢視軟體
     tar, gz, rpm file: 像子目錄般的瀏覽其內容
</pre>

<p>
為了使這些文件特性生效，不要將可閱讀的檔案設成可執行檔。可使用 MC
的檔案選單或使用 <code>chmod</code> 來改變檔案屬性。
</p>

<hr>

<h3><a name="s-mc-ftp"></a>4.2.8 MC 的FTP虛擬檔案系統</h3>

<p>
MC 可通過 FTP 來存取網路上的檔案。按 F9 轉到選單列，輸入 `p' 啟動 FTP
虛擬檔案系統。以 <samp>username:passwd@hostname.domainname</samp> 格式輸入 URL
，遠端的目錄就會像本地端目錄一樣顯示出來。
</p>

<p>
試著流覽 <samp>http.us.debian.org/debian</samp> 中的 Debian 檔案。請參閱 <a
href="ch-system.zh-tw.html#s-ftparchives">Debian archives, 第 2.1 節</a>
了解這些是如何組織起來的。
</p>

<hr>

<h2><a name="s-unixlike"></a>4.3 Unix-like 工作環境</h2>

<p>
雖然 MC 能幫助你完成許多事情，但是學會如何從 shell 命令列執行指令並熟習
Unix-like 環境是非常重要的。 [<a href="footnotes.zh-tw.html#f16"
name="fr16">16</a>]
</p>

<hr>

<h3><a name="s-sp-keys"></a>4.3.1 特殊的組合鍵</h3>

<p>
在 Unix-like 環境中，有許多組合鍵有特別的意義。 [<a
href="footnotes.zh-tw.html#f17" name="fr17">17</a>]
</p>
<ul>
<li>
<p>
Ctrl-U: 清除一行中游標之前的文字。
</p>
</li>
<li>
<p>
Ctrl-H: 移除游標前的一個字元。
</p>
</li>
<li>
<p>
Ctrl-D: 結束輸入。(如果您在 shell 下，就會跳出該 shell)
</p>
</li>
<li>
<p>
Ctrl-C: 終止正在執行的程式。
</p>
</li>
<li>
<p>
Ctrl-Z: 暫時停止程式。 (將該工作放到背景，參閱 <a
href="#s-cmd-back"><samp>command &amp;</samp>, 第 4.3.10.1 節</a>)
</p>
</li>
<li>
<p>
Ctrl-S: 停止輸出到畫面上。(類似 Scorll Lock) [<a
href="footnotes.zh-tw.html#f18" name="fr18">18</a>]
</p>
</li>
<li>
<p>
Ctrl-Q: 回復輸出到畫面上。
</p>
</li>
</ul>

<p>
預設的 shell 是 <code>bash</code> ，它能記住使用過的命令 (history-editing)
和命令列擴展 (tab-completion) 的功能來輔助互動式的使用。
</p>
<ul>
<li>
<p>
up-arrow: 開始收尋過去的命令。
</p>
</li>
<li>
<p>
Ctrl-R: 開始漸進示收尋過去的命令。
</p>
</li>
<li>
<p>
TAB: 擴展要輸入的檔案到命令列上。
</p>
</li>
<li>
<p>
Ctrl-V TAB: 輸入 TAB，而不是命令列擴展
</p>
</li>
</ul>

<p>
其他重要的組合鍵：
</p>
<ul>
<li>
<p>
Ctrl-Alt-Del: 重新啟動/關閉系統，參閱 <a
href="ch-install.zh-tw.html#s-post-inst">其它主機安裝提示, 第 3.8 節</a>。
</p>
</li>
<li>
<p>
Left-click-and-drag mouse: 選取並拷貝至剪貼簿。
</p>
</li>
<li>
<p>
Click middle mouse button: 將剪貼簿內容貼至游標處。
</p>
</li>
<li>
<p>
Meta-key (只針對 Emacs) 是設定在左邊的 Alt。有些系統會使用 Windows-key 當
Meta-key。
</p>
</li>
</ul>

<p>
為了在 Linux 文字主控台中使用滑鼠，您必須使用 <code>gpm</code> 服務。 [<a
href="footnotes.zh-tw.html#f19" name="fr19">19</a>] 參閱 <a
href="ch-install.zh-tw.html#s-gpm">滑鼠設定, 第 3.3 節</a>。
</p>

<hr>

<h3><a name="s-unixcmds"></a>4.3.2 基本的 Unix 指令</h3>

<p>
我們來學一些基本的 Unix 指令吧。 [<a href="footnotes.zh-tw.html#f20"
name="fr20">20</a>]
試著由非特權帳號<samp><var>penguin</var></samp>來執行下列的指令：
</p>
<ul>
<li>
<p>
<samp>pwd</samp>
</p>
<ul>
<li>
<p>
顯示目前的工作目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>whoami</samp>
</p>
<ul>
<li>
<p>
顯示目前的使用者
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>file <var>foo</var></samp>
</p>
<ul>
<li>
<p>
顯示<var>foo</var>檔案的型別。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>type -p <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
顯示執行檔<samp><var>commandname</var></samp>的檔案路徑。
</p>
</li>
<li>
<p>
<samp>which <var>commandname</var></samp> 也是相同功能。 [<a
href="footnotes.zh-tw.html#f21" name="fr21">21</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>type <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
顯示執行檔 <samp><var>commandname</var></samp> 的資訊。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>apropos <var>key-word</var></samp>
</p>
<ul>
<li>
<p>
找出與 <samp><var>key-word</var></samp> 有關的說明文件。
</p>
</li>
<li>
<p>
<samp>man -k <var>key-word</var></samp> 也具有相同功能。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>whatis <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
顯示指令<samp><var>commandname</var></samp>的單行敘述。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>man -a <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
顯示指令 <samp><var>commandname</var></samp>的說明 (Unix 風格)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>info <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
顯示指令 <samp><var>commandname</var></samp> 較豐富的說明 (GNU 風格)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls</samp>
</p>
<ul>
<li>
<p>
列出目錄的內容。 (非點開頭的檔案和目錄) [<a href="footnotes.zh-tw.html#f22"
name="fr22">22</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -a</samp>
</p>
<ul>
<li>
<p>
列出目錄的內容。 (所有的檔案和目錄)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -A</samp>
</p>
<ul>
<li>
<p>
列出目錄的內容。 (幾乎所有的檔案和目錄，也就是略過 &quot;<code>..</code>&quot;
和 &quot;<code>.</code>&quot;)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -la</samp>
</p>
<ul>
<li>
<p>
列出目錄下所有的檔案和細節資訊。參閱 <a href="#s-file-system">Debian
的檔案系統, 第 4.5.2 節</a>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -d</samp>
</p>
<ul>
<li>
<p>
列出目前目錄下所有的目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>lsof <var>foo</var></samp>
</p>
<ul>
<li>
<p>
列出以開檔的 <samp><var>foo</var></samp> 狀態。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mkdir <var>foo</var></samp>
</p>
<ul>
<li>
<p>
在目前的目錄下產生新目錄: <samp><var>foo</var></samp>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>rmdir <var>foo</var></samp>
</p>
<ul>
<li>
<p>
在目前的目錄下移除目錄: <samp><var>foo</var></samp>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd <var>foo</var></samp>
</p>
<ul>
<li>
<p>
切換目錄到目前目錄下的 <code><var>foo</var></code>
或是<samp>CDPATH</samp>變數所定義的目錄下的目錄。參閱文件<code>builtins(7)</code>
中的 <code>cd</code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd /</samp>
</p>
<ul>
<li>
<p>
切換到根目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd</samp>
</p>
<ul>
<li>
<p>
切換到使用者的家目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd /<var>foo</var></samp>
</p>
<ul>
<li>
<p>
切換到絕對路徑為<code>/<var>foo</var></code>的目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd ..</samp>
</p>
<ul>
<li>
<p>
切換到上一層目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd ~<var>foo</var></samp>
</p>
<ul>
<li>
<p>
切換到家目錄中的 <samp><var>foo</var></samp> 目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd -</samp>
</p>
<ul>
<li>
<p>
切換到先前的目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>&lt;/etc/motd pager</samp>
</p>
<ul>
<li>
<p>
使用預設的 pager 顯示 <code>/etc/motd</code> 的內容。參閱 <a
href="#s-cmd-stdin"><samp>command &lt; <var>foo</var></samp>, 第 4.3.10.9
節</a>。 [<a href="footnotes.zh-tw.html#f23" name="fr23">23</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>touch <var>junkfile</var></samp>
</p>
<ul>
<li>
<p>
建立一個空檔案：<code><var>junkfile</var></code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cp <var>foo</var> <var>bar</var></samp>
</p>
<ul>
<li>
<p>
複製一已存在的檔案：<code><var>foo</var></code>
並命名成：<code><var>bar</var></code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>rm <var>junkfile</var></samp>
</p>
<ul>
<li>
<p>
移除 <code><var>junkfile</var></code> 檔案。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mv <var>foo</var> <var>bar</var></samp>
</p>
<ul>
<li>
<p>
更名一已存在的 <code><var>foo</var></code> 檔案成 <code><var>bar</var></code>
檔名。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mv <var>foo</var> <var>bar/baz</var></samp>
</p>
<ul>
<li>
<p>
移動一已存在的 <code><var>foo</var></code> 檔案到新的位置且更名成
<code><var>bar/baz</var></code>。<code><var>bar</var></code> 目錄必須存在。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 600 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
設定一已存在的檔案：<code><var>foo</var></code>
的權限為其他帳號皆不可讀和寫。(任何人皆不可執行)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 644 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
設定一已存在的檔案：<code><var>foo</var></code>
的權限為其他帳號皆可讀但不可寫入。(任何人皆不可執行)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 755 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
定一已存在的檔案：<code><var>foo</var></code>
的權限為其他帳號皆可讀但不可寫入。(任何人皆可執行)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>top</samp>
</p>
<ul>
<li>
<p>
全螢幕顯示程序的資料。輸入 &quot;q&quot; 終止。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps aux | pager</samp>
</p>
<ul>
<li>
<p>
使用 BSD 風格顯示全程序的資料。參閱 <a href="#s-cmd-pipe"><samp>command1 |
command2</samp>, 第 4.3.10.2 節</a>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps -ef | pager</samp>
</p>
<ul>
<li>
<p>
使用 Unix system-V 風格顯示全程序的資料。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps aux | grep -e &quot;[e]xim4*&quot;</samp>
</p>
<ul>
<li>
<p>
顯示全部 <code>exim</code> 或 <code>exim4</code> 程序。執行 <samp>man
grep</samp> 來閱讀 <code>grep(1)</code> 學習正規式表示法。 [<a
href="footnotes.zh-tw.html#f24" name="fr24">24</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps axf | pager</samp>
</p>
<ul>
<li>
<p>
使用 ASCII art 輸出顯示全程序的資料。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>kill <var>1234</var></samp>
</p>
<ul>
<li>
<p>
砍掉 pid 為 <var>1234</var> 的程序。參閱 <a
href="ch-tips.zh-tw.html#s-kill">中止一個進程, 第 8.5.1 節</a>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>grep -e &quot;<var>pattern</var>&quot; *.html</samp>
</p>
<ul>
<li>
<p>
收尋並顯示目錄下所有副檔名為 <samp>.html</samp> 的
&quot;<var>原型</var>&quot;。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>gzip <var>foo</var></samp>
</p>
<ul>
<li>
<p>
使用 Lempel-Ziv coding (LZ77) 壓縮 <code><var>foo</var></code> 成
<code><var>foo</var>.gz</code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>gunzip <var>foo</var>.gz</samp>
</p>
<ul>
<li>
<p>
解壓縮 <code><var>foo</var>.gz</code> 產生 <code><var>foo</var></code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>bzip2 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
使用 Burrows-Wheeler block sorting text compression algorithm 和 Huffman coding
(比 <code>gzip</code> 壓縮率更高) 來壓縮 <code><var>foo</var></code> 成
<code><var>foo</var>.bz2</code>
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>bunzip2 <var>foo</var>.bz2</samp>
</p>
<ul>
<li>
<p>
解壓縮 <code><var>foo</var>.bz2</code> 產生 <code><var>foo</var></code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvf <var>foo.tar</var></samp>
</p>
<ul>
<li>
<p>
解開 <code><var>foo</var>.tar</code> 保存檔。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvzf <var>foo</var>.tar.gz</samp>
</p>
<ul>
<li>
<p>
解開 gzip 壓縮檔：<code><var>foo</var>.tar.gz</code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvf --bzip2 <var>foo.tar.bz2</var></samp>
</p>
<ul>
<li>
<p>
解開 bzip2 壓縮檔：<code><var>foo</var>.tar.bz2</code>。 [<a
href="footnotes.zh-tw.html#f25" name="fr25">25</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvf <var>foo</var>.tar <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
打包目錄 <code><var>bar</var>/</code> 成 <code><var>foo</var>.tar</code>
保存檔。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
壓縮和打包目錄 <code><var>bar</var>/</code> 到
<code><var>foo</var>.tar.gz</code> 保存檔。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
壓縮和打包目錄 <code><var>bar</var>/</code> 到
<code><var>foo</var>.tar.bz2</code> 保存檔。 [<a
href="footnotes.zh-tw.html#f26" name="fr26">26</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz | pager</samp>
</p>
<ul>
<li>
<p>
使用預設的 pager 來顯示壓縮檔 <code>README.gz</code> 的內容。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz &gt; foo</samp>
</p>
<ul>
<li>
<p>
建立 <code>foo</code> 檔案而內容為已解壓縮的 <code>README.gz</code>。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz &gt;&gt; foo</samp>
</p>
<ul>
<li>
<p>
附加已解壓縮的 <code>README.gz</code>的內容到 <code>foo</code>
檔案。(如果該檔案不存在，請先建立。)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>find .  -name <var>pattern</var></samp>
</p>
<ul>
<li>
<p>
使用 shell <samp><var>原型</var></samp> 收尋相符的檔名。(速度較慢)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>locate -d .  <var>pattern</var></samp>
</p>
<ul>
<li>
<p>
使用 shell <samp><var>原型</var></samp>
收尋相符的檔名。(使用定期產生的資料庫，較快)
</p>
</li>
</ul>
</li>
</ul>

<p>
請先使用上述的指令當作測試來探勘系統目錄。如果您有任何指令上的問題，請閱讀說明文件。比如說，這些指令是好的出發點：
</p>

<pre>
     $ man man
     $ man bash
     $ man ls
</pre>

<p>
現在使用 <code>vim</code> 的好機會，請按下 F1。您應該會看到至少前 35
行。然後實作線上測驗，將游標移至 <samp>|tutor|</samp> 並按下 Ctrl-]。參閱 <a
href="ch-edit.zh-tw.html">編輯器, 第 11 章</a> 了解更多編輯器。
</p>

<p>
請注意，許多從 GNU 和 BSD 來的 Unix-like
指令皆有簡潔的說明，您可以使用以下其一的方法叫出來(有些情況是不用加任何參數)：
</p>

<pre>
     $ <var>commandname</var> --help
     $ <var>commandname</var> -h
</pre>

<p>
也順便練習一下<a href="ch-tips.zh-tw.html">Debian技巧, 第 8
章</a>的範例來練功吧。
</p>

<hr>

<h3><a name="s-cmd-exec"></a>4.3.3 The command execution</h3>

<p>
相信您現在比較清楚如何使用 Debian 系統了。我們來探勘 Debian
中更進階的指令技巧。 [<a href="footnotes.zh-tw.html#f27" name="fr27">27</a>]
</p>

<hr>

<h3><a name="s-cmd-simple"></a>4.3.4 簡單的命令</h3>

<p>
一個簡單的指令是以下的排列
</p>
<!-- ol type="1" start="1"  -->
<li>
<p>
變數宣告 (額外的)
</p>
</li>
<li>
<p>
指令名稱
</p>
</li>
<li>
<p>
參數 (額外的)
</p>
</li>
<li>
<p>
導向 (額外的：<samp>&gt;</samp> , <samp>&gt;&gt;</samp> ,<samp>&lt;</samp> ,
<samp>&lt;&lt;</samp> ...等)
</p>
</li>
<li>
<p>
控制運算子 (額外的：<samp>&amp;&amp;</samp> , <samp>||</samp> ;&lt;newline&gt;
, <samp>;</samp> , <samp>&amp;</samp> , <samp>(</samp> , <samp>)</samp>)
</p>
</li>
</ol>

<p>
對於置換和引用，參閱 <a href="ch-program.zh-tw.html#s-clprocess">命令列操作, 第
13.2.6 節</a>。
</p>

<hr>

<h3><a name="s-cmd-env"></a>4.3.5 指令執行和環境變數</h3>

<p>
典型的指令執行是使用下述的 shell 指令列： [<a href="footnotes.zh-tw.html#f28"
name="fr28">28</a>]
</p>

<pre>
     $ date
     Sun Oct 26 08:17:20 CET 2003
     $ LC_ALL=fr_FR date
     dim oct 26 08:17:39 CET 2003
</pre>

<p>
在這裡，<code>date</code>是前景工作。至於環境變數 <samp>LC_ALL</samp> 是指：
</p>
<ul>
<li>
<p>
第一個指令未設定 (系統預設是跟 <samp>C</samp> 一樣) <samp>LC_ALL</samp>
</p>
</li>
<li>
<p>
第二個指令將 <samp>LC_ALL</samp> 設成 <samp>fr_FR</samp> (French locale)
</p>
</li>
</ul>

<p>
大部份的指令在執行時不會比環境變數更早執行。對於上面的範例來說，你也可以這樣做：
</p>

<pre>
     $ LC_ALL=fr_FR
     $ date
     dim oct 26 08:17:39 CET 2003
</pre>

<p>
當你看到這裡時，輸出的結果是受到環境變數的影響而產生 French
的文字。如果您想要環境變數也影響到子程序(舉例來說，當使用 shell script)，您必須
&quot;export&quot; 它：
</p>

<pre>
     $ export LC_ALL
</pre>

<hr>

<h3><a name="s-cmd-path"></a>4.3.6 指令收尋路徑</h3>

<p>
當您在 shell 輸入指令時，shell 會 <samp>PATH</samp>
這個環境變數中列舉的目錄來找指令。<samp>PATH</samp> 同時也是 shell 的收尋路徑。
</p>

<p>
在預設安裝的 Debian 下，使用者的<samp>PATH</samp>
不會包含<code>/sbin/</code>。所以當您需要從 <code>/sbin/</code> 執行一些像
<code>ifconfig</code>的指令時，您必須修改 <samp>PATH</samp>
的值並包含該路徑。<samp>PATH</samp>通常是設定在 <code>~/.bash_profile</code>
之中，參閱 <a href="ch-install.zh-tw.html#s-bashconf">Bash 設定, 第 3.2
節</a>。
</p>

<hr>

<h3><a name="s-cmd-opt"></a>4.3.7 命令列參數</h3>

<p>
部份的指令需要額外的參數才能執行，這些參數通常是以 <samp>-</samp> 或
<samp>--</samp> 開頭並透過指令來呼叫。
</p>

<pre>
     $ date
     Mon Oct 27 23:02:09 CET 2003
     $ date -R
     Mon, 27 Oct 2003 23:02:40 +0100
</pre>

<p>
這裡的參數 <samp>-R</samp> 會改變 <code>date</code> 的輸出結果而變成 RFC-2822
相容的字串。
</p>

<hr>

<h3><a name="s-cmd-wild"></a>4.3.8 Shell wildcards</h3>

<p>
有時候您希望能同時處理相同類別的檔案但不想一個一個輸入時，shell
<strong>wildcards</strong>的 &quot;檔名原型擴展&quot; 就能解決這樣的問題。
</p>
<ul>
<li>
<p>
<samp>*</samp>
</p>
<ul>
<li>
<p>
符合任何 0 個或更多個的字元。
</p>
</li>
<li>
<p>
這不符合檔名以 &quot;<samp>.</samp>&quot; 開頭的檔案。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>?</samp>
</p>
<ul>
<li>
<p>
只符合一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[...]</samp>
</p>
<ul>
<li>
<p>
只符合括號中的一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[a-z]</samp>
</p>
<ul>
<li>
<p>
只符合<samp>a</samp> 和 <samp>z</samp> 中的一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[^...]</samp>
</p>
<ul>
<li>
<p>
符合括號中沒有列舉的一個字元(&quot;^&quot;並不包含)。
</p>
</li>
</ul>
</li>
</ul>

<p>
舉例來說，思考一下底下的範例：
</p>

<pre>
     $ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
     $ echo *.txt
     1.txt 2.txt
     $ echo *
     1.txt 2.txt 3.c 4.h
     $ echo *.[hc]
     3.c 4.h
     $ echo .*
     . .. .5.txt
     $ echo .[^.]*
     .5.txt
     $ echo [^1-3]*
     4.h
     $ cd ..; rm -rf junk
</pre>

<hr>

<h3><a name="s-cmd-return"></a>4.3.9 指令的傳回值</h3>

<p>
每個指令會回傳 exit 狀態當成回傳值。
</p>
<ul>
<li>
<p>
如果指令成功執行完成的話，則回傳值 = 0。
</p>
</li>
<li>
<p>
如果指令因錯誤終止，則回傳值不為 0。
</p>
</li>
</ul>

<p>
執行後的回傳值可經由 <samp>$?</samp> 環境變數來存取。
</p>

<pre>
     $ [ 1 = 1 ] ; echo $?
     0
     $ [ 1 = 2 ] ; echo $?
     1
</pre>

<p>
請注意，shell 使用邏輯計算回傳值時，<strong>success</strong>的話就當成邏輯
<strong>TRUE</strong>。這並不是那麼直覺，因為<strong>success</strong>有代表
<strong>zero</strong> 的意思。
</p>

<p>
參閱 <a href="ch-program.zh-tw.html#s-shell-cond">Shell 條件式, 第 13.2.5
節</a>。
</p>

<hr>

<h3><a name="s-cmd-typical"></a>4.3.10 標準的指令順序</h3>

<p>
我們試著記憶底下的 shell 指令用法。閱讀過這些用法後也請參考 <a
href="ch-program.zh-tw.html#s-shell-param">Shell 參數, 第 13.2.3 節</a>, <a
href="ch-program.zh-tw.html#s-shell-redirect">Shell 重導 (redirection), 第
13.2.4 節</a>, <a href="ch-program.zh-tw.html#s-shell-cond">Shell 條件式, 第
13.2.5 節</a> 和 <a href="ch-program.zh-tw.html#s-clprocess">命令列操作, 第
13.2.6 節</a>。
</p>

<hr>

<h4><a name="s-cmd-back"></a>4.3.10.1 <samp>command &amp;</samp></h4>

<p>
該 <code>command</code> 指令是在 <strong>背景</strong>中的子 shell
執行。背景的工作允許使用者在一個 shell 中執行多個程式。
</p>

<p>
背景程序的管理包含了 shell 本身的 <code>jobs</code>, <code>fg</code>,
<code>bg</code> 和 <code>kill</code>。請閱讀 <code>bash(1)</code> 中的
&quot;SIGNALS&quot;, &quot;JOB CONTROL&quot; 和 &quot;SHELL BUILTIN
COMMANDS&quot;。 [<a href="footnotes.zh-tw.html#f29" name="fr29">29</a>]
</p>

<hr>

<h4><a name="s-cmd-pipe"></a>4.3.10.2 <samp>command1 | command2</samp></h4>

<p>
<code>command1</code> 的 standard output 是餵給 <code>command2</code> 的stand
input。兩個指令可以<strong>同時</strong>執行。這就叫作
<strong>pipeline</strong>。
</p>

<hr>

<h4><a name="s-cmd-list"></a>4.3.10.3 <samp>command1 ; command2</samp></h4>

<p>
<code>command1</code> 和 <code>command2</code> 是按照順序地執行。
</p>

<hr>

<h4><a name="s-cmd-and"></a>4.3.10.4 <samp>command1 &amp;&amp; command2</samp></h4>

<p>
<code>command1</code>
先被執行。如果成功的話，則<code>command2</code>也會<strong>依序</strong>的執行。<code>command1</code>
<strong>和</strong><code>command2</code>皆成功執行，則傳回 success。
</p>

<hr>

<h4><a name="s-cmd-or"></a>4.3.10.5 <samp>command1 || command2</samp></h4>

<p>
<code>command1</code>
先被執行。如果不成功的話，則<code>command2</code>還是會<strong>依序</strong>的執行。<code>command1</code>
<strong>或</strong><code>command2</code>其一成功執行的話，則傳回 success。
</p>

<hr>

<h4><a name="s-cmd-stdout"></a>4.3.10.6 <samp>command &gt; <var>foo</var></samp></h4>

<p>
將<code>command</code>的結果重導到<samp><var>foo</var></samp>檔案。(會覆寫)
</p>

<hr>

<h4><a name="s-cmd-stdout2"></a>4.3.10.7 <samp>command &gt;&gt; <var>foo</var></samp></h4>

<p>
將<code>command</code>的結果重導到<samp><var>foo</var></samp>檔案。(會附加)
</p>

<hr>

<h4><a name="s-cmd-stderr"></a>4.3.10.8 <samp>command &gt; <var>foo</var> 2&gt;&amp;1</samp></h4>

<p>
將<code>command</code>的 standard output 和 standard error
重導到<samp><var>foo</var></samp>檔案。
</p>

<hr>

<h4><a name="s-cmd-stdin"></a>4.3.10.9 <samp>command &lt; <var>foo</var></samp></h4>

<p>
將<code>command</code>的 standard input
導到<samp><var>foo</var></samp>檔案。試試看以下的例子：
</p>

<pre>
     $ &lt;/etc/motd pager
      ... (the greetings)
     $ pager &lt;/etc/motd
      ... (the greetings)
     $ pager /etc/motd
      ... (the greetings)
     $ cat /etc/motd | pager
      ... (the greetings)
</pre>

<p>
雖然四個用法皆顯示同樣的結果，但最後的例子會再跑一次 <code>cat</code>
指令，這會多浪費一些資源。
</p>

<hr>

<h3><a name="s-cmd-alias"></a>4.3.11 指令別名</h3>

<p>
您可以為常用的指令設定別名。例如：
</p>

<pre>
     $ alias la='ls -la'
</pre>

<p>
現在，<code>la</code> 會以長清單格式來列出所有的檔案，也就是 <samp>ls
-la</samp> 的縮寫。
</p>

<p>
您可以使用 <code>type</code> 指令來辨識真正的路徑。例如：
</p>

<pre>
     $ type ls
     ls is hashed (/bin/ls)
     $ type la
     la is aliased to `ls -la'
     $ type echo
     echo is a shell builtin
     $ type file
     file is /usr/bin/file
</pre>

<p>
這裡的 <code>ls</code> 是最近被查詢到的，然而 <code>file</code> 並沒有，因此
<code>ls</code> 是 &quot;hashed&quot;，也就是說 shell 有一個紀錄可以快速找到
<code>ls</code> 的位置。
</p>

<hr>

<h2><a name="s-text-process"></a>4.4 Unix-like 文字處理</h2>

<p>
在 Unix-like 系統上有一些常用的標準文字處理工具。
</p>
<ul>
<li>
<p>
不支援正規表示法的：
</p>
<ul>
<li>
<p>
<code>head</code> 輸出檔案的第一行。
</p>
</li>
<li>
<p>
<code>tail</code> 輸出檔案的最後一行。
</p>
</li>
<li>
<p>
<code>sort</code> 排序文字檔行列。
</p>
</li>
<li>
<p>
<code>uniq</code> 刪除已排序的檔案中重複的資料。
</p>
</li>
<li>
<p>
<code>tr</code> 轉譯或刪除文字。
</p>
</li>
<li>
<p>
<code>diff</code> 行與行的檔案比較。
</p>
</li>
</ul>
</li>
<li>
<p>
支援基本的正規表示法 (BRE)：
</p>
<ul>
<li>
<p>
<code>grep</code> 依照收尋原型來收尋文字。
</p>
</li>
<li>
<p>
<code>ed</code> 是個最原始基本的編輯器。
</p>
</li>
<li>
<p>
<code>sed</code> 是串流資料編輯器。
</p>
</li>
<li>
<p>
<code>vi</code> 是全螢幕編輯器。
</p>
</li>
<li>
<p>
<code>emacs</code> 是全螢幕編輯器。
</p>
</li>
</ul>
</li>
<li>
<p>
支援擴充的正規表示法(ERE)：
</p>
<ul>
<li>
<p>
<code>egrep</code> 依照收尋原型來收尋文字。
</p>
</li>
<li>
<p>
<code>awk</code> 支援簡單的文字處理。參閱 <a
href="ch-program.zh-tw.html#s-awk">Awk, 第 13.3 節</a>。
</p>
</li>
<li>
<p>
<code>perl</code> 幾乎所有的文字處理皆能達成。參閱 <a
href="ch-program.zh-tw.html#s-perl">Perl, 第 13.4 節</a>。
</p>
</li>
</ul>
</li>
</ul>

<p>
參閱 <a href="ch-tips.zh-tw.html#s-perl-i">Regular-expression substitution, 第
8.6.13 節</a>, <a
href="ch-tips.zh-tw.html#s-scrp-snip">精巧的管道指令輔助script, 第 8.6.18
節</a> 和 <a href="ch-tips.zh-tw.html#s-perl-mad">輕巧的 Perl Script, 第 8.6.20
節</a> 取得更多 script 範例。
</p>

<hr>

<h3><a name="s-regex"></a>4.4.1 正規表示法</h3>

<p>
正規表示法是用在許多文字處理的工具上。有點類似 shell wildcards (參閱 <a
href="#s-cmd-wild">Shell wildcards, 第 4.3.8 節</a>)，但卻更複雜與強大。
</p>

<p>
正規表示法可用文字或<strong>metacharacters</strong>來描述比對原型。metacharacter
是具有特殊意義的字元。有兩種主要的類別：BRE 和 ERE，端看您使用的文字工具(<a
href="#s-text-process">Unix-like 文字處理, 第 4.4 節</a>)決定。
</p>

<p>
對 EREs 來說，<strong>metacharacters</strong> 包含 &quot;<samp>\ .  [ ] ^ $ * +
?  ( ) { } |</samp>&quot;。這個表示法意思是：
</p>
<ul>
<li>
<p>
<samp>c</samp>
</p>
<ul>
<li>
<p>
符合非 metacharacter &quot;<samp>c</samp>&quot;。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\c</samp>
</p>
<ul>
<li>
<p>
符合字母 &quot;<samp>c</samp>&quot;。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>.</samp>
</p>
<ul>
<li>
<p>
符合包含換行的任何字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>^</samp>
</p>
<ul>
<li>
<p>
符合字串的第一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>$</samp>
</p>
<ul>
<li>
<p>
符合字串的最後一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\&lt;</samp>
</p>
<ul>
<li>
<p>
符合文字的開頭。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\&gt;</samp>
</p>
<ul>
<li>
<p>
符合文字的結尾。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[abc...]</samp>
</p>
<ul>
<li>
<p>
這個字元列表符合 &quot;<samp>abc...</samp>&quot; 中任何一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[^abc...]</samp>
</p>
<ul>
<li>
<p>
這個字元列表符合非 &quot;<samp>abc...</samp>&quot; 中任何一個字元。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r*</samp>
</p>
<ul>
<li>
<p>
符合 &quot;<samp>r</samp>&quot; 這個敘述 0 次以上的文字。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r+</samp>
</p>
<ul>
<li>
<p>
符合 &quot;<samp>r</samp>&quot; 這個敘述 1 次以上的文字。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r?</samp>
</p>
<ul>
<li>
<p>
符合 &quot;<samp>r</samp>&quot; 這個敘述 0 或 1 次的文字。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r1|r2</samp>
</p>
<ul>
<li>
<p>
符合&quot;<samp>r1</samp>&quot; 或 &quot;<samp>r2</samp>&quot; 敘述之一的文字。
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>(r1|r2)</samp>
</p>
<ul>
<li>
<p>
符合&quot;<samp>r1</samp>&quot; 或 &quot;<samp>r2</samp>&quot;
敘述之一的文字並以 <strong>bracketed</strong> 表示法處理。
</p>
</li>
</ul>
</li>
</ul>

<p>
在 BREs 裡，<strong>metacharacters</strong>：&quot;<samp>+ ?  ( ) { }
|</samp>&quot; 是無作用的，取而代之的是倒斜線的 &quot;<samp>\+ \?  \( \) \{ \}
\|</samp>&quot;。所以說，使用 BREs 時，<samp>(r1|r2)</samp> 必須像
<samp>\(r1|r2\)</samp> 用倒斜線隔開。雖然 <code>emacs</code> 也支援 BRE，但改用
&quot;<samp>+ ?</samp>&quot;
來當作<strong>metacharacters</strong>。所以不需要使用雙引號來隔開。參閱 <a
href="#s-replaceex">置換表示法, 第 4.4.2 節</a>
了解這些<strong>metacharacters</strong>組合怎麼使用。
</p>

<p>
舉例來說，<code>grep</code> 可以使用正規表示法來收尋文字：
</p>

<pre>
     $ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                         GNU GENERAL PUBLIC LICENSE
                         GNU GENERAL PUBLIC LICENSE
       Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</pre>

<hr>

<h3><a name="s-replaceex"></a>4.4.2 置換表示法</h3>

<p>
在置換表示法中，底下的字元有特別的意義：
</p>
<ul>
<li>
<p>
<samp>&amp;</samp>
</p>
<ul>
<li>
<p>
顯示符合正規表示法的字串。(<code>emacs</code>下請用 <samp>\&amp;</samp>)
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>
<samp>\<var>n</var></samp>
</p>
<ul>
<li>
<p>
顯示第 n 個符合正規表示法的字串。
</p>
</li>
</ul>
</li>
</ul>

<p>
如要使用 Perl 置換字串，請改用 <samp>$<var>n</var></samp>
代替<samp>\<var>n</var></samp>和<samp>&amp;</samp>。因為後兩各在 Perl
中是無意義的。
</p>

<p>
舉例說明：
</p>

<pre>
     $ echo zzz1abc2efg3hij4 | \
       sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&amp;=/'
     zzz=1abc2efg3hij4=
     $ echo zzz1abc2efg3hij4 | \
       sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
     zzzefg3hij4===1abc
     $ echo zzz1abc2efg3hij4 | \
       perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
     zzzefg3hij4===1abc
     $ echo zzz1abc2efg3hij4 | \
       perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&amp;=/'
     zzz=&amp;=
</pre>

<p>
請特別注意各處理工具在置換時所使用的<strong>分隔</strong>符號，以及軟體如何用正規表示法比對這些文字的方式。
</p>

<p>
在編輯器中使用這些表示法也可以用來移動游標和置換文字。
</p>

<p>
請閱讀以上這些指令相關的說明文件。
</p>

<hr>

<h2><a name="s-unixfile"></a>4.5 Unix-like 檔案系統</h2>

<p>
在 GNU/Linux 和其他 Unix-like
的系統上，<strong>檔案</strong>是有組織地放置在<strong>目錄</strong>下。 [<a
href="footnotes.zh-tw.html#f30" name="fr30">30</a>]
全部的<strong>檔案</strong>和<strong>目錄</strong>被整理放在一個階乘和樹狀的<code>根目錄</code>(/)。
</p>

<p>
這些檔案和目錄可以放在不同的硬體裝置上。<code>mount(8)</code>
指令能掛載硬體裝置並加入到這巨大的檔案樹系統上。反過來說，<code>umount(8)</code>則可以卸載這些裝置。
</p>

<hr>

<h3><a name="s-file-basics"></a>4.5.1 Unix 檔案基礎</h3>

<p>
以下是一些基礎觀念：
</p>
<ul>
<li>
<p>
檔案是大小寫相異。也就是說 <code>MYFILE</code> 和
<code>MyFile</code>是<strong>不同</strong>的檔案
</p>
</li>
<li>
<p>
根目錄以 <code>/</code> 表示。可別把 &quot;root&quot; 跟 root
帳號搞混了喔。參閱 <a href="#s-login-root">用 root 登入 shell 提示符號, 第
4.1.1 節</a>。
</p>
</li>
<li>
<p>
每個目錄皆可用字母或符號來命名，但就是不能用 <code>/</code>。 [<a
href="footnotes.zh-tw.html#f31" name="fr31">31</a>]
根目錄是一個例外，它的檔名：<code>/</code>(叫做 &quot;斜線&quot; 或
&quot;根目錄&quot;)且不能更名。
</p>
</li>
<li>
<p>
每個檔案或目錄皆設計成 <strong>fully-qualified filename</strong>,
<strong>absolute
filename</strong>或<strong>path</strong>，必須有順序地輸入路徑才能切換到最後的目錄。以上三者是同等的意思。全部的絕對路徑以
<code>/</code> 開頭且每個檔案或目錄的路徑都包含 <code>/</code> 符號。第一個
<code>/</code>是目錄的名稱，其餘的皆為分隔符號以便區分檔名的每個部份。
</p>
<p>
以上的說明容易造成混淆。請看一下底下的範例：
</p>
<pre>
     /usr/share/keytables/us.map.gz
</pre>
<p>
這是一個完整的檔案名稱，有些人也稱作 <strong>path</strong>。但大部分都只用
<code>us.map.gz</code> 來當作檔名。 [<a href="footnotes.zh-tw.html#f32"
name="fr32">32</a>]
</p>
</li>
<li>
<p>
root 目錄有幾個分支，例如 <code>/etc/</code> and
<code>/usr/</code>。這些子目錄底下有更多的子目錄，例如
<code>/etc/init.d/</code> 和 <code>/usr/local/</code>。總括來說，這就叫做
<strong>目錄樹</strong>(directory tree)。
</p>
<p>
您可以想像一個絕對路徑是從該樹的根(<code>/</code>)延伸到最後的分支(檔案)。您也曾聽過別人稱為<strong>家族</strong>樹，所以每個子目錄都有其<strong>父母或祖先</strong>，而路徑就是檔案完整的起源。
</p>
<p>
至於相對路徑並不是以 root(/) 目錄開頭。您必須牢記 <code>../</code>
代表上一層的目錄。
</p>
</li>
<li>
<p>
至於硬體裝置是沒有任何目錄對應的。這跟 CP/M, DOS, 和 Windows
中的所有檔案是以硬體裝置(例如，<samp>C:\</samp>)開頭的檔名不同。請參閱<a
href="#s-file-system">Debian 的檔案系統, 第 4.5.2 節</a>。
</p>
</li>
</ul>

<p>
有興趣的話可以參閱<code><a
href="file:///usr/share/doc/debian-policy/fhs/fhs.txt.gz">Filesystem Hierarchy
Standard</a></code>，該文件詳細說明了階層式檔案系統的細節。您要記住的是底下這些目錄的用途：
</p>
<ul>
<li>
<p>
<code>/</code>
</p>
<ul>
<li>
<p>
<code>/</code> 代表 root 目錄。
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/etc/</code>
</p>
<ul>
<li>
<p>
所有的系統設定檔案皆放在該目錄下。
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/var/log/</code>
</p>
<ul>
<li>
<p>
所有的系統日誌檔皆放在該目錄下。
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/home/</code>
</p>
<ul>
<li>
<p>
該目錄包含了非特權帳號的所有家目錄。
</p>
</li>
</ul>
</li>
</ul>

<hr>

<h3><a name="s-file-system"></a>4.5.2 Debian 的檔案系統</h3>

<p>
同於 Unix，Debian
系統提供了一個檔案系統，能夠統一化所有硬碟，儲存媒體，主控台或透過串列埠遠端存取硬體的動作。
</p>

<p>
Debian 系統中每個檔案，目錄，named pipe
或硬體裝置都有一個<strong>inode</strong>
的資料結構，記載該檔案的相關屬性，例如:使用者所擁有
(擁有者)，屬於那一個群組，最後存取的時間等。參閱 <code><a
href="/usr/include/linux/fs.h">/usr/include/linux/fs.h</a></code> 了解 Debian
GNU/Linux 系統中的 <samp>inode</samp>結構的意義。
</p>

<p>
將硬體統一化成檔案的表示法是非常有用的，這允許我們可以使用相同的方法來存取完全不同的硬體。
</p>

<p>
全部的檔案可以存放在一個硬碟，或者 20
個硬碟，有些硬碟甚至是分散在網路上不同的電腦。您無法想像在查詢檔案或目錄時，所有的指令都能正常運作且不用理會真正的檔案是放在哪一個實體裝置上。
</p>

<hr>

<h3><a name="s-file-perm"></a>4.5.3 檔案和目錄的存取權限</h3>

<p>
檔案和目錄的存取權限對下面三種使用者分別定義：
</p>
<ul>
<li>
<p>
檔案擁有者 <strong>user</strong> (u) ，
</p>
</li>
<li>
<p>
檔案所屬群組的使用者 <strong>group</strong> (g) 和
</p>
</li>
<li>
<p>
所有使用者 <strong>other</strong> (o) 。
</p>
</li>
</ul>

<p>
對檔案來說，每個權限分別對應到一些可做的動作：
</p>
<ul>
<li>
<p>
讀取<strong>read</strong> (r)：查看檔案的內容
</p>
</li>
<li>
<p>
寫入<strong>write</strong> (w)：對檔案作修改
</p>
</li>
<li>
<p>
執行<strong>execute</strong> (x)：把檔案當作指令來執行
</p>
</li>
</ul>

<p>
對目錄來說，每個權限分別對應到一些可做的動作：
</p>
<ul>
<li>
<p>
讀取<strong>read</strong> (r)：列出目錄的內容
</p>
</li>
<li>
<p>
寫入<strong>write</strong> (w)：在目錄中加入或刪除檔案
</p>
</li>
<li>
<p>
執行<strong>execute</strong> (x)：存取目錄中的檔案
</p>
</li>
</ul>

<p>
在這裡，
目錄的<strong>執行</strong>權限不只代表允許讀取目錄內的檔案，也代表允許看到它們的屬性，像是檔案大小和更動時間等。
</p>

<p>
使用 <code>ls</code> 來顯示檔案和目錄的權限資訊 (和更多其他的資訊).  請參閱
<code>ls(1)</code> 。當使用 <code>ls</code> 的 <samp>-l</samp>
選項，則會依下列順序來顯示相關資訊：
</p>
<ul>
<li>
<p>
<strong>檔案型態</strong> (第一字元)
</p>
<ul>
<li>
<p>
<samp>-</samp>: 一般檔案
</p>
</li>
<li>
<p>
<samp>d</samp>: 目錄
</p>
</li>
<li>
<p>
<samp>l</samp>: 符號連結
</p>
</li>
<li>
<p>
<samp>c</samp>: 字元狀置節點
</p>
</li>
<li>
<p>
<samp>b</samp>: 區塊狀置節點
</p>
</li>
<li>
<p>
<samp>p</samp>: 命名的管線
</p>
</li>
<li>
<p>
<samp>s</samp>: 通訊端
</p>
</li>
</ul>
</li>
<li>
<p>
檔案的存取<strong>權限</strong>
(之後九個字元，依序是擁有者，群組，其他，各三個字元)
</p>
</li>
<li>
<p>
檔案的<strong>硬連結個數</strong>
</p>
</li>
<li>
<p>
檔案<strong>擁有者</strong>名稱
</p>
</li>
<li>
<p>
檔案所屬<strong>群組</strong>名稱
</p>
</li>
<li>
<p>
檔案<strong>大小</strong> (以 bytes 為單位)
</p>
</li>
<li>
<p>
檔案的<strong>目期和時間</strong> (mtime)
</p>
</li>
<li>
<p>
檔案的<strong>名稱</strong>。
</p>
</li>
</ul>

<p>
在 root 帳號下可使用 <code>chown</code>
改變檔案的擁有者。要改變檔案的所屬群組，可以用檔案擁有者或 root 的身份來執行
<code>chgrp</code>。要改變目錄的存取權限，可以用檔案擁有者或 root 的身份來執行
<code>chmod</code>。控制<code>foo</code>檔案的語法是：
</p>

<pre>
     # chown <var>newowner</var> foo
     # chgrp <var>newgroup</var> foo 
     # chmod  [ugoa][+-=][rwx][,...] foo
</pre>

<p>
請參閱 <code>chown(1)</code>, <code>chgrp(1)</code> 和 <code>chmod(1)</code>
以取得更多資訊。
</p>

<p>
舉例來說，如果要改變目錄的擁有者為 <var>foo</var> 以及群組為
<var>bar</var>，請用 root 帳號執行以下指令：
</p>

<pre>
     # cd /some/location/
     # chown -R <var>foo</var>:<var>bar</var> .
     # chmod -R ug+rwX,o=rX .
</pre>

<p>
有 3 個更特殊的權限位元：
</p>
<ul>
<li>
<p>
<strong>set user ID</strong> (s 或 S 取代擁有者的 x)，
</p>
</li>
<li>
<p>
<strong>set group ID</strong> (s 或 S 取代群組的 x) 和
</p>
</li>
<li>
<p>
<strong>sticky bit</strong> (t 或 T 取代其他使用者的 x) 。
</p>
</li>
</ul>

<p>
在這裡，如果設定這些特殊權限設定後蓋住了原本顯示的執行權限的話，則 <code>ls
-l</code> 的輸出就會用大寫來表示。
</p>

<p>
在可執行檔上設定 <strong>set user ID</strong> 的話，會以這個檔案擁有者的身份
(如 <strong>root</strong>) 來執行這個可執行檔。同樣地，在可執行檔上設定
<strong>set group ID</strong> 的話，會以這個檔案的群組身份 (如
<strong>root</strong>)
來執行這個可執行檔。因為這些設定會導致安全性上的問題，要打開它們的話要格外小心。
</p>

<p>
在目錄上設定 <strong>set group ID</strong> 的話，會使用類似 BSD
的檔案建立規則，也就是在此目錄中建立的檔案都會屬於此目錄的<strong>群組</strong>。
</p>

<p>
在目錄上設定e <strong>sticky bit</strong>
可以防止非檔案擁有者來刪除此目錄中的檔案。在一些大家可以寫入的目錄，如
<code>/tmp</code>
或是在允許群組寫入的目錄下，為了要保持檔案內容的安全，不只要關上檔案的<strong>寫入</strong>權限，還要在目錄上設定
<strong>sticky bit</strong>
。不然的話，任何擁有目錄寫入權限的人都可以刪除檔案，並且建立一個新的同名檔案。
</p>

<p>
這裡有些關於檔案權限的有趣例子。
</p>

<pre>
     $ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
     crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
     -rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
     -rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
     -rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
     $ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
     drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
     drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
     drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
     drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
     drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</pre>

<p>
另外的辦法是使用數字並搭配 <code>chmod(1)</code> 來設定檔案權限。數字模式使用 3
到 4 數字寬的八進制數字。每個數字皆有其代表意義：
</p>
<ul>
<li>
<p>
第一個選擇性數字：<strong>set user ID</strong> (=4), <strong>set group
ID</strong> (=2) 和 <strong>sticky bit</strong> (=1) 的總合。
</p>
</li>
<li>
<p>
第二個數字：針對 <strong>user</strong> 的 <strong>read</strong> (=4),
<strong>write</strong> (=2) 和 <strong>execute</strong> (=1) 權限的總合。
</p>
</li>
<li>
<p>
第三個數字：同上，但針對於 <strong>group</strong>。
</p>
</li>
<li>
<p>
第四個數字：同上，但針對 <strong>other</strong>。
</p>
</li>
</ul>

<p>
這聽起來很複雜，但其實是相當簡單的。如果您觀察<samp>ls
-l</samp>的結果就能發現前面幾行(2-10)是代表檔案權限(請用二進制，&quot;-&quot;表示
&quot;0&quot;，&quot;rwx&quot;表示&quot;1&quot;)。這些數字如果用八進制來代表檔案權限的話，相信您一定能夠了解。
[<a href="footnotes.zh-tw.html#f33" name="fr33">33</a>] 舉個例子，比如：
</p>

<pre>
     $ touch <var>foo</var> <var>bar</var>
     $ chmod u=rw,go=r <var>foo</var>
     $ chmod 644 <var>bar</var>
     $ ls -l <var>foo</var> <var>bar</var>
     -rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
     -rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</pre>

<p>
預設的檔案權限遮罩可使用 shell 內建的 <code>umask</code>
來設定。參閱<code>builtins(7)</code>。
</p>

<hr>

<h3><a name="s-timestamp"></a>4.5.4 時間戳記</h3>

<p>
在 GNU/Linux 檔案中，有三個時間戳記：
</p>
<ul>
<li>
<p>
<strong>mtime</strong>：修改時間 (<samp>ls -l</samp>) ，
</p>
</li>
<li>
<p>
<strong>ctime</strong>：狀態改變時間 (<samp>ls -lc</samp>) 和
</p>
</li>
<li>
<p>
<strong>atime</strong>：最後存取時間 (<samp>ls -lu</samp>) 。
</p>
</li>
</ul>

<p>
注意， <strong>ctime</strong> 並不是檔案建立時間。
</p>
<ul>
<li>
<p>
覆寫檔案會改變檔案的 <strong>mtime</strong> ， <strong>ctime</strong> 和
<strong>atime</strong> 全部的時間戳記。
</p>
</li>
<li>
<p>
改變檔案權限或擁有者的話，會改變檔案的 <strong>ctime</strong> 和
<strong>atime</strong> 時間戳記。
</p>
</li>
<li>
<p>
讀取檔案會改變檔案的 <strong>atime</strong> 時間戳記。
</p>
</li>
</ul>

<p>
要注意的是，在 GNU/Linux 系統中，即使只是簡單的讀取檔案，通常也會為了要更新
<strong>inode</strong> 中的 <strong>atime</strong> 而導致寫入的動作。如果以
<samp>noatime</samp>
選項來掛上檔案系統的話，就可以略過這個動作而使讀取的動作加快。請參閱
<code>mount(8)</code> 。
</p>

<p>
使用 <code>touch(1)</code> 中的指令來改變檔案的時間戳記。
</p>

<hr>

<h3><a name="s-links"></a>4.5.5 連結</h3>

<p>
有兩種方法可以把一個叫 <var>foo</var> 的檔案關連到另一個檔名 <var>bar</var> 。
</p>
<ul>
<li>
<p>
<strong>硬式連結 (hard link)</strong> 是現存檔案的一個別名 (<samp>ln
<var>foo</var> <var>bar</var></samp>) ，
</p>
</li>
<li>
<p>
<strong>符號連結 (symbolic link)</strong> ，或是 &quot;symlink&quot;
，是一個特殊的檔案，它指向另一個檔案的名稱 (<samp>ln -s <var>foo</var>
<var>bar</var></samp>) 。
</p>
</li>
</ul>

<p>
下面的例子顯示了在使用 <code>rm</code> 指令後，連結數的改變和一些微妙的差異。
</p>

<pre>
     $ echo &quot;Original Content&quot; &gt; <var>foo</var>
     $ ls -l <var>foo</var>
     -rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
     $ ln <var>foo</var> <var>bar</var>     # 硬式連結
     $ ln -s <var>foo</var> <var>baz</var>  # 符號連結
     $ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
     -rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
     lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
     -rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
     $ rm <var>foo</var>
     $ echo &quot;New Content&quot; &gt; <var>foo</var>
     $ cat <var>bar</var>
     Original Content
     $ cat <var>baz</var>
     New Content
</pre>

<p>
就像上面的例子所顯示的，符號連結的一般檔案存取權限為 &quot;rwxrwxrwx&quot;
，而實際的存取權限均由它們所指向的檔案來決定。
</p>

<p>
<code>.</code> 目錄是連結到其所出現的目錄，所以任何新目錄的連結數都是由 2
起跳的。而 <code>..</code>
目錄是連結到其所上層目錄，所以目錄的連結數會隨著子目錄數目而增加。
</p>

<hr>

<h3><a name="s-fifo"></a>4.5.6 Named pipes (FIFOs)</h3>

<p>
named pipe
是類似管線的檔案。您可以輸入資料到這個檔案，然後他會輸出到別的地方。因此他也就作
FIFO(First-In-First-Out)：第一個送入管線的資料也是第一個送出管線的資料。
</p>

<p>
如果寫入 named pipe 時，寫入的程序並不會中斷直到該管線讀入為止。如果讀取 named
pipe，讀取的程序會一直等待直到資料讀取完畢才停止。管線的大小永遠是零，因為它並不儲存資料，它主要是連結兩個程序，就像
shell 的
<samp>|</samp>。但是，自從管線被命名之後，兩個程序不需要在同一行執行或同一個使用者執行。
</p>

<p>
試著執行以下的例子：
</p>

<pre>
     $ cd; mkfifo mypipe
     $ echo &quot;hello&quot; &gt;mypipe &amp; # put into background
     [1] <var>5952</var>
     $ ls -l mypipe
     prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
     $ cat mypipe
     hello
     [1]+  Done                    echo hello &gt;mypipe
     $ ls mypipe
     prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
     $ rm mypipe
</pre>

<hr>

<h3><a name="s-sockets"></a>4.5.7 Sockets</h3>

<p>
socket 有點類似 named pipe (FIFO) 且允許程序與程序之間可以交換資料。針對 socket
來說，這些程序不需要在同一個時間執行或者同一個父程序產生的子程序。這是 inter
process communication 的 ENDPOINT。網路上不同的主機透過 socket 也能夠互換資料。
</p>

<hr>

<h3><a name="s-device"></a>4.5.8 Device files</h3>

<p>
任何的硬體或虛擬裝置，例如硬碟，顯示卡，螢幕或鍵盤等，皆視為裝置檔案。<samp>/dev/console</samp>，主控台是最常見的虛擬裝置。
</p>

<p>
裝置有兩種型別：
</p>
<ul>
<li>
<p>
<strong>character device</strong>
</p>
<ul>
<li>
<p>
一次存取一個字元。就是說存取該裝置最小的資料單位元是字元(byte)。
</p>
</li>
</ul>
</li>
<li>
<p>
<strong>block 裝置</strong>
</p>
<ul>
<li>
<p>
一次存取較大單位的裝置稱為 block。硬碟就是一個 block 裝置。
</p>
</li>
</ul>
</li>
</ul>

<p>
您可以讀寫裝置檔案，即使是這些檔案可能採用二進制而讓人難以理解。直接寫入資料到這些檔案有時候是測試硬體是否已經連線的好方法。例如，您可以列印文字檔到印表機裝置：<code>/dev/lp0</code>或送指令到連接數據機的串列埠上：<code>/dev/ttyS0</code>。但請小心操作，也許會造成重大的損壞。所以要特別小心。
</p>

<hr>

<h4><a name="s-devnull"></a>4.5.8.1 <code>/dev/null</code> 類別</h4>

<p>
<code>/dev/null</code>
是一個特別的裝置檔案，它會捨棄所有寫入的資料。如果您不需要某些資料，直接丟到
<code>/dev/null</code>。它基本上就是個黑洞。如果您讀取<code>/dev/null</code>，您會馬上得到
end-of-file (EOF) 字元。
</p>

<p>
<code>/dev/zero</code>
也是一樣，差別在於讀取時會得到<samp>\0</samp>字元(不是數字 0 喔)。參閱 <a
href="ch-tips.zh-tw.html#s-dummyfile">空檔案, 第 8.6.34 節</a>。
</p>

<hr>

<h4><a name="s-node"></a>4.5.8.2 裝置節點編號</h4>

<p>
執行 <code>ls</code> 您就可以得到裝置節點的號碼：
</p>

<pre>
     $ ls -l /dev/hda /dev/ttyS0 /dev/zero
     brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
     crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
     crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</pre>

<p>
請看底下說明：
</p>
<ul>
<li>
<p>
<code>/dev/hda</code>
的主要裝置號碼：3，次要號碼是：0。只有<samp>disk</samp>群組中的使用者可以讀寫它。
</p>
</li>
<li>
<p>
<code>/dev/ttyS0</code>
的主要裝置號碼：4，次要號碼是：64。只有<samp>dialout</samp>群組中的使用者可以讀寫它。
</p>
</li>
<li>
<p>
<code>/dev/zero</code> 的主要裝置號碼：1，次要號碼是：5。任何帳號皆可讀寫它。
</p>
</li>
</ul>

<p>
在舊式的系統上，安裝過程會使用 <code>/sbin/MAKEDEV</code> 建立裝置節點。參閱
<code>MAKEDEV(8)</code>。
</p>

<p>
較新的系統上，<code>/dev</code> 下的檔案系統是經由類似 <code>/proc</code>
的檔案系統自動產生。
</p>

<hr>

<h3><a name="s-procfs"></a>4.5.9 <code>/proc</code> 檔案系統</h3>

<p>
<code>/proc</code> 檔案系統是虛擬的檔案系統，紀錄著系統資訊和執行中的程式。
</p>

<p>
許多人常常因為 <code>/proc/kcore</code>
太大而傷腦筋。該檔案的大小跟您電腦安裝的記憶體一樣大。它主要用來進行核心偵錯，但本身並不存在任何地方，所以請別擔心它的容量大小。
</p>

<p>
參閱 <a href="ch-kernel.zh-tw.html#s-proc-sys">透過 proc 檔案系統調整核心, 第
7.2 節</a> 和 <code>proc(5)</code>。
</p>

<hr>

<h2><a name="s-xtuto"></a>4.6 X Window 系統</h2>

<p>
請參閱 <a href="ch-tune.zh-tw.html#s-x">X, 第 9.4 節</a>。
</p>

<hr>

<h3><a name="s-xstart"></a>4.6.1 啟動 X Window System</h3>

<p>
X Window 系統會跟著 <code>xdm</code>-like
等圖形登入軟體執行時啟動，或者在主控台輸入：
</p>

<pre>
     $ exec startx
</pre>

<hr>

<h3><a name="s-xmenu"></a>4.6.2 X Window 系統的選單功能</h3>

<p>
自從 X
環境提供了許多的視窗管理器之後，他們的使用者介面都有些許的差異。請牢記按下右鍵會帶出系統選單。該功能一直都有。
</p>
<ul>
<li>
<p>
要取得 shell 命令列，點選選單中的 Xterm：
</p>
<ul>
<li>
<p>
&quot;XShells&quot; --&gt; &quot;XTerm&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
至於圖形化的網頁瀏覽器，點選選單中的 Mozilla：
</p>
<ul>
<li>
<p>
&quot;Apps&quot; --&gt; &quot;Net&quot; --&gt; &quot;Mozilla Navigator&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
至於圖形化的 PDF 瀏覽器，點選選單中的 Xpdf：
</p>
<ul>
<li>
<p>
&quot;Apps&quot; --&gt; &quot;Viewers&quot; --&gt; &quot;Xpdf&quot;.
</p>
</li>
</ul>
</li>
</ul>

<p>
如果您找不到 menu，請安裝相關的套件。參閱 <a
href="ch-package.zh-tw.html#s-apt-install">體驗 Debian 套件管理, 第 6.2
節</a>。
</p>

<hr>

<h3><a name="s-xkeys"></a>4.6.3 X Window 系統的鍵盤順序</h3>

<p>
底下是執行 X Window 系統時重要的組合控制鍵。
</p>
<ul>
<li>
<p>
Ctrl-Alt-F1 到 F6: 切換到其他的虛擬終端機 (從 X window, DOSEMU 等)
</p>
</li>
<li>
<p>
Alt-F7: 返回 X window 畫面
</p>
</li>
<li>
<p>
Ctrl-Alt-minus: 降低 X window 的解析度 (這裡的 minus(-) 是指數字鍵上的減號)
</p>
</li>
<li>
<p>
Ctrl-Alt-plus: 提高 X window 的解析度 (這裡的 plus(+) 是指數字鍵上的加減號)
</p>
</li>
<li>
<p>
Ctrl-Alt-Backspace: 終止 X Server
</p>
</li>
<li>
<p>
Alt-X, Alt-C, Alt-V: 同於 Windows/Mac 上的剪下，複製，貼上。在某些程式如
Netscape Composer 需改用 Alt 來代替 Ctrl。
</p>
</li>
</ul>

<hr>

<h2><a name="s-cmd-study"></a>4.7 後續的學習指南</h2>

<p>
現在，我推薦您閱讀 <code><a href="http://www.tldp.org/guides.html">The Linux
Documentation Project: Guides</a></code> 網站上主要的引導書籍：
</p>
<ul>
<li>
<p>
&quot;The Linux System Administrators' Guide&quot;,
</p>
<ul>
<li>
<p>
此書包含了如何讓系統永不停機，使用者帳號管理，備份，系統設定等觀念。
</p>
</li>
<li>
<p>
套件：<code>sysadmin-guide</code>
</p>
</li>
<li>
<p>
檔案： <code><a
href="file:///usr/share/doc/sysadmin-guide/html/index.html">file:///usr/share/doc/sysadmin-guide/html/index.html</a></code>
</p>
</li>
<li>
<p>
網址：<code><a
href="http://www.tldp.org/LDP/sag/index.html">http://www.tldp.org/LDP/sag/index.html</a></code>
</p>
</li>
</ul>
</li>
<li>
<p>
&quot;The Linux Network Administrator's Guide, Second Edition&quot;,
</p>
<ul>
<li>
<p>
這是一本駕馭 Linux 網路管理的參考手冊。
</p>
</li>
<li>
<p>
套件： <code>(not available)</code>
</p>
</li>
<li>
<p>
檔案： <code><a href="(not%20applicable)">(not applicable)</a></code>
</p>
</li>
<li>
<p>
網址： <code><a
href="http://www.tldp.org/LDP/nag2/index.html">http://www.tldp.org/LDP/nag2/index.html</a></code>
</p>
</li>
</ul>
</li>
<li>
<p>
<em>Linux: Rute User's Tutorial and Exposition</em>
</p>
<ul>
<li>
<p>
管理 GNU/Linux 系統的精裝版線上書籍。
</p>
</li>
<li>
<p>
作者： Paul Sheer
</p>
</li>
<li>
<p>
由 Prentice Hall 發行
</p>
</li>
<li>
<p>
套件: <code>rutebook</code> (從 <samp>non-free</samp>)
</p>
</li>
<li>
<p>
檔案: <code>file:///usr/share/doc/rutebook/</code>
</p>
</li>
</ul>
</li>
</ul>

<p>
參閱 <a href="ch-support.zh-tw.html">Debian 的技術支援, 第 15 章</a>
取得更多的學習資源。
</p>

<hr>

<p>
[ <a href="ch-install.zh-tw.html">上一頁</a> ]
[ <a href="index.zh-tw.html#contents">目錄</a> ]
[ <a href="ch-preface.zh-tw.html">1</a> ]
[ <a href="ch-system.zh-tw.html">2</a> ]
[ <a href="ch-install.zh-tw.html">3</a> ]
[ 4 ]
[ <a href="ch-woody.zh-tw.html">5</a> ]
[ <a href="ch-package.zh-tw.html">6</a> ]
[ <a href="ch-kernel.zh-tw.html">7</a> ]
[ <a href="ch-tips.zh-tw.html">8</a> ]
[ <a href="ch-tune.zh-tw.html">9</a> ]
[ <a href="ch-gateway.zh-tw.html">10</a> ]
[ <a href="ch-edit.zh-tw.html">11</a> ]
[ <a href="ch-vcs.zh-tw.html">12</a> ]
[ <a href="ch-program.zh-tw.html">13</a> ]
[ <a href="ch-gnupg.zh-tw.html">14</a> ]
[ <a href="ch-support.zh-tw.html">15</a> ]
[ <a href="ap-appendix.zh-tw.html">A</a> ]
[ <a href="ch-woody.zh-tw.html">下一頁</a> ]
</p>

<hr>

<p>
Debian 參考手冊
</p>

<address>
CVS, 週一 六月 16 21:20:48 UTC 2008<br>
<br>
Osamu Aoki <code><a href="mailto:osamu#at#debian.org">osamu#at#debian.org</a></code><br>
Asho Yeh <code><a href="mailto:asho#at#debian.org.tw">asho#at#debian.org.tw</a></code><br>
<a href="ap-appendix.zh-tw.html#s-authors">作者, 第 A.1 節</a><br>
<br>
</address>
<hr>

</body>

</html>

