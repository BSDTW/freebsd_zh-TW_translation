<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 13. SQL Statement Syntax</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="functions.html" title="Chapter 12. Functions and Operators"><link rel="next" href="pluggable-storage.html" title="Chapter 14. Pluggable Storage Engine Architecture">
<style>
<!--
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	
	}
span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
span.GramE
	{}
-->
</style>
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="sql-syntax"></a>
	第13章：SQL語句語法</h2></div></div></div><div class="toc"><p><b>
	目錄</b></p><dl><dt><span class="section"><a href="sql-syntax.html#data-definition">
			13.1. 數據定義語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1. 
				ALTER DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.2. 
				ALTER TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.3. 
				CREATE DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.4. 
				CREATE INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.5. 
				CREATE TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.6. 
				DROP DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.7. 
				DROP INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.8. 
				DROP TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.9. 
				RENAME TABLE語法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#data-manipulation">
			13.2. 數據操作語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#delete">13.2.1. 
				DELETE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.2. 
				DO語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.3. 
				HANDLER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.4. 
				INSERT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.5. 
				LOAD DATA INFILE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.6. 
				REPLACE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.7. 
				SELECT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">
				13.2.8. Subquery語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate">13.2.9. 
				TRUNCATE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.10. 
				UPDATE語法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#basic-user-commands">
			13.3. MySQL實用工具語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.3.1. 
				DESCRIBE語法（獲取有關列的訊息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.3.2. 
				USE語法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#transactional-commands">
			13.4. MySQL事務處理和鎖定語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.4.1. 
				START TRANSACTION, COMMIT和ROLLBACK語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">
				13.4.2. 不能回滾的語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">
				13.4.3. 會造成隱式提交的語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoints">13.4.4. 
				SAVEPOINT和ROLLBACK TO SAVEPOINT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.4.5. 
				LOCK TABLES和UNLOCK TABLES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.4.6. 
				SET TRANSACTION語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">
				13.4.7. XA事務</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#database-administration-statements">
			13.5. 資料庫管理語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">
				13.5.1. 帳號管理語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">
				13.5.2. 資料表維護語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-option">13.5.3. 
				SET語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.5.4. 
				SHOW語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">
				13.5.5. 其它管理語句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#replication-sql">
			13.6. 複製語句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">
				13.6.1. 用於控制主伺服器的SQL語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">
				13.6.2. 用於控制從伺服器的SQL語句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sqlps">
			13.7. 用於預處理語句的SQL語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
		本章介紹了<span>SQL</span>語句的語法。<h2 class="title"><a name="data-definition"></a>
		13.1.&nbsp;數據定義語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1. 
			ALTER DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.2. 
			ALTER TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.3. 
			CREATE DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.4. 
			CREATE INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.5. 
			CREATE TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.6. 
			DROP DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.7. 
			DROP INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.8. 
			DROP TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.9. 
			RENAME TABLE語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-database"></a>13.1.1. ALTER 
			DATABASE語法</h3></div></div></div><a class="indexterm" name="id2890117"></a><a class="indexterm" name="id2890126"></a><a class="indexterm" name="id2890135"></a><a class="indexterm" name="id2890145"></a><a class="indexterm" name="id2890156"></a><a class="indexterm" name="id2890166"></a><pre class="programlisting">ALTER {DATABASE | SCHEMA} [<em class="replaceable">db_name</em>]
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em>
  | [DEFAULT] COLLATE <em class="replaceable">collation_name</em>
</pre>
			<p><span>ALTER DATABASE</span>用於更改資料庫的全局特性。這些特性儲存在資料庫目錄中的<span>db.opt</span>檔案中。要使用<span>ALTER 
			DATABASE</span>，您需要獲得資料庫<span>ALTER</span>權限。</p>
			<p><span>CHARACTER SET</span>子句用於更改預設的資料庫字元編碼。<span>COLLATE</span>子句用於更改預設的資料庫整序。在<a href="charset.html">第10章</a>：<a href="charset.html" title="Chapter 10. Character Set Support"><i>字元編碼支援</i></a>中對字元編碼和整序名稱進行了討論。</p>
			<p>資料庫名稱可以忽略，此時，語句對應於預設資料庫。也可以使用<span>ALTER SCHEMA</span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-table"></a>13.1.2. ALTER 
			TABLE語法</h3></div></div></div><a class="indexterm" name="id2890293"></a><a class="indexterm" name="id2890302"></a><a class="indexterm" name="id2890312"></a><pre class="programlisting">ALTER [IGNORE] TABLE <em class="replaceable">tbl_name</em>
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    ADD [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em> ]
  | ADD [COLUMN] (<em class="replaceable">column_definition</em>,...)
  | ADD INDEX [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        PRIMARY KEY [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        UNIQUE [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [FULLTEXT|SPATIAL] [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        FOREIGN KEY [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
        [<em class="replaceable">reference_definition</em>]
  | ALTER [COLUMN] <em class="replaceable">col_name</em> {SET DEFAULT <em class="replaceable">literal</em> | DROP DEFAULT}
  | CHANGE [COLUMN] <em class="replaceable">old_col_name</em> <em class="replaceable">column_definition</em>
        [FIRST|AFTER <em class="replaceable">col_name</em>]
  | MODIFY [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em>]
  | DROP [COLUMN] <em class="replaceable">col_name</em>
  | DROP PRIMARY KEY
  | DROP INDEX <em class="replaceable">index_name</em>
  | DROP FOREIGN KEY <em class="replaceable">fk_symbol</em>
  | DISABLE KEYS
  | ENABLE KEYS
  | RENAME [TO] <em class="replaceable">new_tbl_name</em>
  | ORDER BY <em class="replaceable">col_name</em>
  | CONVERT TO CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | DISCARD TABLESPACE
  | IMPORT TABLESPACE
  | <em class="replaceable">table_options</em>
  | <em class="replaceable">partition_options</em>
  | ADD PARTITION <em class="replaceable">partition_definition</em>
  | DROP PARTITION <em class="replaceable">partition_names</em>
  | COALESCE PARTITION <em class="replaceable">number</em>
  | REORGANIZE PARTITION <em class="replaceable">partition_names</em> INTO (<em class="replaceable">partition_definitions</em>)
  | ANALYZE PARTITION <em class="replaceable">partition_names</em>
  | CHECK PARTITION <em class="replaceable">partition_names</em>
  | OPTIMIZE PARTITION <em class="replaceable">partition_names</em>
  | REBUILD PARTITION <em class="replaceable">partition_names</em>
  | REPAIR PARTITION <em class="replaceable">partition_names</em>
</pre>
			<p><span>ALTER TABLE</span>用於更改原有資料表的結構。例如，您可以增加或刪減列，建立或取消索引，更改原有列的類型，或重新命名列或資料表。您還可以更改資料表的評注和資料表的類型。</p>
			<p>允許進行的變更中，許多子句的語法與<span>CREATE TABLE</span>中的子句的語法相近。其中包括<span><i><span>table_options</span></i>修改，選項有<span>ENGINE, 
			AUTO_INCREMENT</span>和<span>AVG_ROW_LENGTH</span>等。請見</span><a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
		TABLE語法」</a>。</p>
			<p>儲存引擎不支援有些操作，如果進行這些操作，會出現警告。使用<span>SHOW WARNINGS</span>可以顯示出這些警告。請參見<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22節，「SHOW 
		WARNINGS語法」</a>。</p>
			<p>如果您使用<span>ALTER TABLE</span>更改列規約，但是<span>DESCRIBE<span>
			<i>tbl_name</i></span></span><span>提示您列規約並沒有改變，則可能是因為<span>MySQL</span>忽略了您所做的更改。忽略更改的原因見</span><a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1節，「沉寂的列規格變更」</a><span>。例如，如果您試圖把<span>VARCHAR</span>列更改為<span>CHAR</span>列，此時，如果資料表包含其它長度可變的列，則<span>MySQL</span>仍會使用<span>VARCHAR</span>。</span></p>
			<p><span>ALTER TABLE</span>運行時會對原資料表進行臨時複製，在副本上進行更改，然後刪除原資料表，再對新資料表進行重命名。在執行<span>ALTER 
			TABLE</span>時，其它用戶可以閱讀原資料表，但是對資料表的更新和修改的操作將被延遲，直到新資料表生成為止。新資料表生成後，這些更新和修改訊息會自動轉移到新資料表上。</p>
			<p>注意，如果您在執行<span>ALTER TABLE</span>時使用除了<span>RENAME</span>以外的選項，則<span>MySQL</span>會建立一個臨時資料表。即使數據並不需要進行複製（例如當您更改列的名稱時），<span>MySQL</span>也會這麼操作。對於<span>MyISAM</span>資料表，您可以通過把<span><span>myisam_sort_buffer_size</span>系統變數設置到一個較高的值，來加快重新建立索引（該操作是變更過程中速度最慢的一部分）的速度。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要使用<span>ALTER TABLE</span>，您需要獲得資料表的<span>ALTER, 
			INSERT</span>和<span>CREATE</span>權限。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>IGNORE</span>是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。如果在新資料表中有重複關鍵字，或者當<span>STRICT</span>模式啟動後出現警告，則使用<span>IGNORE</span>控制<span>ALTER 
			TABLE</span>的運行。如果沒有指定<span>IGNORE</span>，當重複關鍵字錯誤發生時，複製操作被放棄，返回前一步驟。如果指定了<span>IGNORE</span>，則對於有重複關鍵字的行，只使用第一行，其它有衝突的行被刪除。並且，對錯誤值進行修正，使之盡量接近正確值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在一個<span>ALTER TABLE</span>語句裡寫入多個<span>ADD, 
			ALTER, DROP</span>和<span>CHANGE</span>子句，中間用逗號分開。這是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。在標準<span>SQL</span>中，每個<span>ALTER 
			TABLE</span>語句中每個子句只允許使用一次。例如，在一個語句中取消多個列：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHANGE
			<i>col_name</i></span><span>,
			<span>DROP <i>col_name</i></span></span>和<span><span>DROP 
			INDEX</span>是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MODIFY</span>是<span>Oracle</span>對<span>ALTER 
			TABLE</span>的延伸。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLUMN</span>只是自選項目，可以忽略。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span><span>ALTER 
			TABLE <i>tbl_name</i> RENAME TO <i>new_tbl_name</i></span>並且沒有其它選項，則<span>MySQL</span>只對與</span><span>table
			<span><i>tbl_name</i></span></span><span>相對應的檔案進行重命名。不需要建立一個臨時資料表。（您也可以使用<span>RENAME 
			TABLE</span>語句對資料表進行重命名。請參見</span><a href="sql-syntax.html#rename-table" title="13.1.9. RENAME TABLE Syntax">13.1.9節，「RENAME 
			TABLE語法」</a><span>。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			column_definition</span></i></span>子句使用與<span>CREATE TABLE</span>中的<span>ADD</span>和<span>CHANGE</span>子句相同的語法。注意，此語法包括列名稱，而不只是列類型。請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span><span>CHANGE
			<i>old_col_name</i> <i>column_definition</i></span>子句對列進行重命名。重命名時，需給定舊的和新的列名稱和列當前的類型。例如：要把一個<span>INTEGER</span>列的名稱從<span>a</span>變更到<span>b</span>，您需要如下操作：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE a b INTEGER;</b></span></span></pre>
			<p>如果您想要更改列的類型而不是名稱，<span> 
			CHANGE</span>語法仍然要求舊的和新的列名稱，即使舊的和新的列名稱是一樣的。例如：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;</b></span></span></pre>
			<p>您也可以使用<span>MODIFY</span>來改變列的類型，此時不需要重命名：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 MODIFY b BIGINT NOT NULL;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>CHANGE</span>或<span>MODITY</span>縮短列長時，列中存在有索引，並且縮短後的列長小於索引長度，則<span>MySQL</span>會自動縮短索引的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當您使用<span>CHANGE</span>或<span>MODIFY</span>更改列的類型時，<span>MySQL</span>會盡量把原有的列值轉化為新的類型。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span>FIRST</span>或<span>AFTER
			<span><i>col_name</i></span></span><span>在一個資料表行中的某個特定位置新增列。預設把列新增到最後。您也可以在<span>CHANGE</span>或<span>MODIFY</span>語句中使用<span>FIRST</span>和<span>AFTER</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>AFTER COLUMN</span>用於指定列的新預設值，或刪除舊的預設值。如果舊的預設值被刪除同時列值為<span>NULL</span>，則新的預設值為<span>NULL</span>。如果列值不能為<span>NULL</span>，<span>MySQL</span>會指定一個預設值，請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP INDEX</span>用於取消索引。這是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。請參見<a href="sql-syntax.html#drop-index" title="13.1.7. DROP INDEX Syntax">13.1.7節，「DROP 
			INDEX語法」</a>。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列從資料表中被取消了，則這些列也從相應的索引中被取消。如果組成一個索引的所有列均被取消，則該索引也被取消。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果一個資料表只包含一列，則此列不能被取消。如果您想要取消資料表，應使用<span>DROP 
			TABLE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP PRIMAY DEY</span>用於取消主索引。註釋：在<span>MySQL</span>較早的版本中，如果沒有主索引，則<span>DROP 
			PRIMARY KEY</span>會取消資料表中的第一個<span>UNIQUE</span>索引。在<span>MySQL 
			5.1</span>中不會出現這種情況。如果在<span>MySQL 5.1</span>中對沒有主鍵的資料表使用<span>DROP 
			PRIMARY KEY</span>，則會出現錯誤訊息。</p>
			<p>如果您向資料表中新增<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>，則<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>會被儲存在非唯一索引之前，這樣<span>MySQL</span>就可以盡早地檢查出重複關鍵字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ORDER BY</span>用於在建立新資料表時，讓各行按一定的順序排列。注意，在插入和刪除後，資料表不會仍保持此順序。當您知道多數情況下您會按照特定的順序查詢各行時，可以使用這個選項；在對資料表進行了大的改動後，通過使用此選項，您可以提高查詢效率。在有些情況下，如果資料表按列排序，對於<span>MySQL</span>來說，排序可能會更簡單。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您對一個<span>MyISAM</span>資料表使用<span>ALTER 
			TABLE</span>，則所有非唯一索引會被建立到一個單獨的批裡（和<span>REPAIR TABLE</span>相同）。當您有許多索引時，這樣做可以使<span>ALTER 
			TABLE</span>的速度更快。</p>
			<p>這項功能可以明確激活。<span>ALTER 
			TABLE...DISABLE KEYS</span>讓<span>MySQL</span>停止更新<span>MyISAM</span>資料表中的非唯一索引。然後使用<span><span>ALTER 
			TABLE ... ENABLE KEYS</span>重新建立丟失的索引。進行此操作時，<span>MySQL</span>採用一種特殊的算法，比一個接一個地插入關鍵字要快很多。因此，在進行成批插入操作前先使關鍵字禁用可以大大地加快速度。使用<span>ALTER 
			TABLE ... DISABLE KEYS</span>除了需要獲得以前提到的權限以外，還需要獲得<span>INDEX</span>權限。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>Innodb</span>儲存引擎支援<span>FOREIGN 
			KEY</span>和<span>REFERENCES</span>子句。<span>Innodb</span>儲存引擎執行<span>ADD 
			[CONSTRAINT [<i>symbol</i>]] FOREIGN KEY (...) REFERENCES ... (...)</span>。請參見<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4節，「FOREIGN 
			KEY約束」</a>。對於其它儲存引擎，這些子句會被分析，但是會被忽略。對於所有的儲存引擎，<span>CHECK</span>子句會被分析，但是會被忽略。請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>。接受這些子句但又忽略子句的原因是為了提高相容性，以便更容易地從其它<span>SQL</span>伺服器中導入代碼，並運行應用程式，建立帶參考數據的資料表。請參見<a href="introduction.html#differences-from-ansi" title="1.8.5. MySQL Differences from Standard SQL">1.8.5節，「MySQL與標準SQL的差別」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><span>InnoDB</span>支援使用<span>ALTER 
			TABLE</span>來取消外部鍵：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>yourtablename</i></span> DROP FOREIGN KEY <span><i>fk_symbol</i></span>;</span></pre>
			<p>要瞭解更多訊息，請參見<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4節，「FOREIGN 
			KEY約束」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>忽略<span>DATA 
			DIRECTORY</span>和<span>INDEX DIRECTORY</span>資料表選項。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您想要把資料表預設的字元編碼和所有字元列（<span>CHAR, VARCHAR, 
			TEXT</span>）改為新的字元編碼，應使用如下語句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> CONVERT TO CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>警告：前面的操作轉換了字元編碼之間的列類型。如果您有一列使用一種字元編碼（如<span>latin1</span>），但是儲存的值實際上使用了其它的字元編碼（如<span>utf8</span>），這種情況不是您想要的。此時，您必須對這樣的列進行以下操作。</p>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 BLOB;</span></pre>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;</span></pre>
			<p>這種方法能夠實現此功能的原因是，當您轉換到<span>BLOB</span>列或從<span>BLOB</span>列轉換過來時，並沒有發生轉換。</p>
			<p>如果您指定<span>CONVERT TO 
			CHARACTER SET</span>為二進制，則<span>TEXT</span>列被轉換到相應的二進制字串類型（<span>BINARY, 
			VARBINARY, BLOB</span>）。這意味著這些列將不再有字元編碼，接下來的<span>CONVERT 
			TO</span>操作也將不適用於這些列。</p>
			<p>要僅僅改變一個資料表的預設字元編碼，應使用此語句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> DEFAULT CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>詞語<span>DEFAULT</span>為自選項。如果您在向資料表中新增一個新列時（例如，使用<span>ALTER 
			TABLE...ADD column</span>）沒有指定字元編碼，則此時使用的字元編碼為預設字元編碼。</p>
			<p>警告：<span>ALTER 
			TABLE...DEFAULT CHARACTER SET</span>和<span>ALTER 
			TABLE...CHARACTER SET</span>是等價的，只用於更改預設的資料表字元編碼。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>InnoDB</span>資料表在建立時，使用了<span>.ibd</span>檔案中的自己的資料表空間，則這樣的檔案可以被刪除和導入。使用此語句刪除<span>.ibd</span>檔案：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> DISCARD TABLESPACE;</span></pre>
			<p>此語句用於刪除當前的<span>.ibd</span>檔案，所以應首先確認您有一個備份。如果在資料表空間被刪除後嘗試打開資料表格，則會出現錯誤。</p>
			<p>要把備份的<span>.ibd</span>檔案還原到資料表中，需把此檔案複製到資料庫目錄中，然後書寫此語句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> IMPORT TABLESPACE;</span></pre>
			<p>見<a href="storage-engines.html#multiple-tablespaces" title="15.2.6.6. Using Per-Table Tablespaces">15.2.6.6節，「使用按資料表的資料表空間」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_info()</span><span> 
			C API</span>函數，您可以瞭解有多少記錄已被複製，以及（當使用<span>IGNORE</span>時）有多少記錄由於重複關鍵字的原因已被刪除。請參見<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34節，「mysql_info()」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>也可以用於對帶分區的資料表進行重新分區，功能包括新增、取消、合併和拆分各分區，還可以用於進行分區維護。</p>
			<p>對帶分區的資料表使用<span><i><span>partition_options</span></i></span>子句和<span>ALTER 
			TABLE</span>可以對資料表進行重新分區，使用時依據<span><i><span>partition_options</span></i>定義的分區方法。本子句以<span>PARTITION 
			BY</span>為開頭，然後使用與用於<span>CREATE TABLE</span>的<i><span>partition_options</span></i></span>子句一樣的語法和規則（要瞭解詳細訊息，請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>）。註釋：<span>MySQL 5.1</span>伺服器目前接受此語法，但是不實際執行；等<span>MySQL 
			5.1</span>開發出來後，將執行此語法。</p>
			<p>用於<span>ALTER TABLE ADD 
			PARTITION</span>的<span><i><span>partition_definition</span></i></span>子句支援用於<span>CREATE 
			TABLE</span>語句的<span><i><span>partition_definition</span></i></span>子句的同樣名稱的選項。（要瞭解語法和介紹，請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>。）例如，假設您有一個按照以下方式建立的帶分區的資料表：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999)</span></pre>
			<pre><span>);&nbsp;&nbsp;&nbsp; </span></pre>
			<p>您可以在資料表中增加一個新的分區<span>p3</span>，該分區用於儲存小於<span>2002</span>的值。新增方法如下：</p>
			<pre><span>ALTER TABLE t1 ADD PARTITION p3 VALUES LESS THAN (2002);</span></pre>
			<p>註釋：您不能使用<span>ALTER TABLE</span>向一個沒有進行分區的資料表新增分區。</p>
			<p><span>DROP PARTITION</span>用於取消一個或多個<span>RANGE</span>或<span>LIST</span>分區。此命令不能用於<span>HASH</span>或<span>KEY
			</span>分區；用於這兩個分區時，應使用<span>COALESCE PARTITION</span>（見後）。如果被取消的分區其名稱列於<span><i><span>partition_names</span></i></span>清單中，則儲存在此分區中的數據也被取消。例如，如果以前已定義的資料表<span>t1</span>，您可以採用如下方法取消名稱為<span>p0</span>和<span>p1</span>的分區：</p>
			<pre><span>ALTER TABLE DROP PARTITION p0, p1;</span></pre>
			<p><span>ADD PARTITION</span>和<span>DROP 
			PARTITION</span>目前不支援<span>IF [NOT] EXISTS</span>。也不可能對一個分區或一個已分區的資料表進行重命名。如果您希望對一個分區進行重命名，您必須取消分區，再重新建立；如果您希望對一個已分區的資料表進行重新命名，您必須取消所有分區，然後對資料表進行重命名，再新增被取消的分區。</p>
			<p><span>COALESCE PARTITION</span>可以用於使用<span>HASH</span>或<span>KEY</span>進行分區的資料表，以便使用<span><i><span>number</span></i></span>來減少分區的數目。例如，假設您使用下列方法建立了資料表<span>t2</span>：</p>
			<pre><span>CREATE TABLE t2 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR (30),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; started DATE</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY HASH(YEAR(started))</span></pre>
			<pre><span>PARTITIONS (6);</span></pre>
			<p>您可以使用以下命令，把<span>t2</span>使用的分區的數目由<span>6</span>個減少到<span>4</span>個：</p>
			<pre><span>ALTER TABLE t2 COALESCE PARTITION 2;</span></pre>
			<p>包含在最後一個<span><i><span>number</span></i></span>分區中的數據將被合併到其餘的分區中。在此情況下，分區<span>4</span>和分區<span>5</span>將被合併到前<span>4</span>個分區中（編號為<span>0</span>、<span>1</span>、<span>2</span>和<span>3</span>的分區）。</p>
			<p>如果要更改部分分區，但不更改所有的分區，您可以使用<span>REORGANIZE 
			PARTITION</span>。這個命令有多種使用方法：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把多個分區合併為一個分區。通過把多個分區的名稱列入<span><i><span>partition_names</span></i></span>清單，並為<span><i><span>partition_definition</span></i></span>提供一個單一的定義，可以實現這個功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把一個原有的分區拆分為多個分區。通過為<span><i><span>partition_names</span></i></span>命名一個分區，並提供多個<span><i><span>partition_definitions</span></i></span>，可以實現這個功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>更改使用<span>VALUES LESS THAN</span>定義的分區子集的範圍或更改使用<span>VALUES 
			IN</span>定義的分區子集的值清單。</p>
			<p>註釋：對於沒有明確命名的分區，<span>MySQL</span>會自動提供預設名稱<span>p0, 
			p1, p2</span>等。</p>
			<p>要瞭解有關<span>ALTER TALBE...REORANIZE 
			PARTITION</span>命令的詳細訊息，請參見<a href="partitioning.html#partitioning-management" title="18.3. Partition Management">18.3節，「分區管理」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>多個附加子句用於提供分區維護和修補功能。這些功能與用於非分區資料表的功能類似。這些功能由<span>CHECK 
			TABLE</span>和<span>REPAIR TABLE</span>等命令（這些命令不支援用於分區資料表）執行。這些子句包括<span>ANALYZE 
			PARTITION</span><span>,
			<span>CHECK PARTITION</span>,
			<span>OPTIMIZE PARTITION</span>,
			<span>REBUILD PARTITION</span></span>和<span>REPAIR 
			PARTITION</span><span>.</span>每個選項均為一個<span><i><span>partition_names</span></i></span>子句，包括一個或多個分區名稱。需要更改的資料表中必須已存在這些分區。多個分區名稱用逗號分隔。要瞭解更多訊息，或要瞭解舉例說明，請參見<a href="partitioning.html#partitioning-maintenance" title="18.3.3. Maintenance of Partitions">18.3.3節，「分區維護」</a>。</p>
			<p>以下例子展示了<span>ALTER TABLE</span>的使用。首先展示資料表<span>t1</span>。資料表<span>t1</span>採用如下方法建立：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE t1 (a INTEGER,b CHAR(10));</b></span></span></pre>
			<p>把資料表<span>t1</span>重新命名為<span>t2</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 RENAME t2;</b></span></span></pre>
			<p>把列<span>a</span>從<span>INTERGER</span>更改為<span>TINYINT 
			NOT NULL</span>（名稱保持不變），並把列<span>b</span>從<span>CHAR(10)</span>更改為<span>CHAR(20)</span>，同時把列<span>b</span>重新命名為列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);</b></span></span></pre>
			<p>新增一個新的<span>TIMESTAMP</span>列，名稱為<span>d</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD d TIMESTAMP;</b></span></span></pre>
			<p>在列<span>d</span>和列<span>a</span>中新增索引：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD INDEX (d), ADD INDEX (a);</b></span></span></pre>
			<p>刪除列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c;</b></span></span></pre>
			<p>新增一個新的<span>AUTO_INCREMENT</span>整數列，名稱為<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ADD PRIMARY KEY (c);</b></span></span></pre>
			<p>注意我們為<span>c</span>編製了索引（作為<span>PRIMARY KEY</span>），因為<span>AUTO_INCREMENT</span>列必須編製索引。同時我們定義<span>c</span>為<span>NOT 
			NULL</span>，因為主鍵列不能為<span>NULL</span>。</p>
			<p>當您新增一個<span>AUTO_INCREMENT</span>列時，列值被自動地按序號填入。對於<span>MyISAM</span>資料表，您可以在<span>ALTER 
			TABLE</span>之前執行<span>SET INSERT_ID<span>=<i>value</i></span></span><span>來設置第一個序號，也可以使用<span>AUTO_INCREMENT=<i>value</i></span></span>資料表選項來設置。請參見<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3節，「SET語法」</a>。</p>
			<p>如果值大於<span>AUTO_INCREMENT</span>列中的最大值，則您可以使用用於<span>InnoDB</span>資料表的<span>ALTER 
			TALBE...AUTO_INCREMENT<span>=<i>value</i></span></span>資料表選項，來為新行設置序號。如果值小於列中當前的最大值，不會出現錯誤訊息，當前的序列值也不改變。</p>
			<p>使用<span>MyISAM</span>資料表時，如果您不更改<span>AUTO_INCREMENT</span>列，則序列號不受影響。如果您取消一個<span>AUTO_INCREMENT</span>列，然後新增另一個<span>AUTO_INCREMENT</span>列，則序號重新排列，從<span>1</span>開始。</p>
			<p>見<a href="problems.html#alter-table-problems" title="A.7.1. Problems with ALTER TABLE">A.7.1節，「與ALTER TABLE有關的問題」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-database"></a>13.1.3. CREATE 
			DATABASE語法</h3></div></div></div><a class="indexterm" name="id2892556"></a><a class="indexterm" name="id2892565"></a><a class="indexterm" name="id2892574"></a><a class="indexterm" name="id2892584"></a><a class="indexterm" name="id2892594"></a><a class="indexterm" name="id2892604"></a>
			<pre><span>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <span><i>db_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>create_specification</i></span> [, <span><i>create_specification</i></span>] ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_specification</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [DEFAULT] CHARACTER SET <span><i>charset_name</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] COLLATE <span><i>collation_name</i></span></span></pre>
			<p><span>CREATE DATABASE</span>用於建立資料庫，並進行命名。如果要使用<span>CREATE 
			DATABASE</span>，您需要獲得資料庫<span>CREATE</span>權限。</p>
			<p>有關合法資料庫名稱的規定列於<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2節，「資料庫、資料表、索引、列和別名」</a>。如果存在資料庫，並且您沒有指定<span>IF NOT EXISTS</span>，則會出現錯誤。</p>
			<p><span><span>
			create_specification</span>選項用於指定資料庫的特性。資料庫特性儲存在資料庫目錄中的<span>db.opt</span>檔案中。<span>CHARACTER 
			SET</span>子句用於指定預設的資料庫字元編碼。<span>COLLATE</span>子句用於指定預設的資料庫整序。字元編碼和整序名稱在</span><a href="charset.html">第10章</a>：<a href="charset.html" title="Chapter 10. Character Set Support"><i>字元編碼支援</i></a><span>中討論。</span></p>
			<p>有些目錄包含檔案，這些檔案與資料庫中的資料表對應。<span>MySQL</span>中的資料庫的執行方法與這些目錄的執行方法相同。因為當資料庫剛剛被建立時，在資料庫中沒有資料表，所以<span>CREATE 
			DATABASE</span>只建立一個目錄。這個目錄位於<span>MySQL</span>數據目錄和<span>db.opt</span>檔案之下。</p>
			<p>如果您手動在數據目錄之下建立一個目錄（例如，使用<strong><span>mkdir</span></strong>），則伺服器會認為這是一個資料庫目錄，並在<span>SHOW 
			DATABASES</span>的輸出中顯示出來。</p>
			<p>也可以使用<span>CREATE SCHEMA</span>。</p>
			<p>您還可以使用<strong><span>mysqladmin</span></strong>程式建立資料庫。請參見<a href="client-side-scripts.html#mysqladmin" title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5節，「mysqladmin：用於管理MySQL伺服器的客戶端」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-index"></a>13.1.4. CREATE 
			INDEX語法</h3></div></div></div><a class="indexterm" name="id2892800"></a><a class="indexterm" name="id2892809"></a><a class="indexterm" name="id2892816"></a><a class="indexterm" name="id2892826"></a>
			<pre><span>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX <span><i>index_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [USING <span><i>index_type</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ON <span><i>tbl_name</i></span> (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<p><span>CREATE INDEX</span>被映射到一個<span>ALTER 
			TABLE</span>語句上，用於建立索引。請參見<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2節，「ALTER 
		TABLE語法」</a>。</p>
			<p>通常，當使用<span>CREATE TABLE</span>建立資料表時，也同時在資料表中建立了所有的索引。請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
		TABLE語法」</a>。<span>CREATE INDEX</span>允許您向已有的資料表中新增索引。</p>
			<p>格式為（<span>col1, col2,...</span>）的一個列清單建立出一個多列索引。通過串接給定列中的值，確定索引值的格式。</p>
			<p>對於<span>CHAR</span>和<span>VARCHAR</span>列，只用一列的一部分就可建立索引。建立索引時，使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>語法，對前綴編製索引。前綴包括每列值的前<span><i><span>length</span></i>個</span>字元。<span>BLOB</span>和<span>TEXT</span>列也可以編製索引，但是必須給出前綴長度。</p>
			<p>此處展示的語句用於建立一個索引，索引使用列名稱的前<span>10</span>個字元。</p>
			<pre><span>CREATE INDEX part_of_name ON customer (name(10));</span></pre>
			<p>因為多數名稱的前<span>10</span>個字元通常不同，所以此索引不會比使用列的全名建立的索引速度慢很多。另外，使用列的一部分建立索引可以使索引檔案大大減小，從而節省了大量的磁盤空間，有可能提高<span>INSERT</span>操作的速度。</p>
			<p>前綴最長為<span>255</span>字節。對於<span>MyISAM</span>和<span>InnoDB</span>資料表，前綴最長為<span>1000</span>字節。注意前綴的限長以字節計，而<span>CREATE 
			INDEX</span>語句中的前綴長度指的是字元的數目。對於使用多字節字元編碼的列，在指定列的前綴長度時，要考慮這一點。</p>
			<p>在<span>MySQL 5.1</span>中：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有當您正在使用<span>MyISAM, InnoDB</span>或<span>BDB</span>資料表類型時，您可以向有<span>NULL</span>值的列中新增索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有當您正在使用<span>MyISAM, BDB</span>或<span>InnoDB</span>資料表類型時，您可以向<span>BLOB</span>或<span>TEXT</span>列中新增索引。</p>
			<p>一個<span><i><span>index_col_name</span></i>規約可以以<span>ASC</span>或<span>DESC</span>為結尾。這些關鍵詞將來可以延伸，用於指定遞增或遞減索引值儲存。目前，這些關鍵詞被分析，但是被忽略；索引值均以遞增順序儲存。</span></p>
			<p>部分儲存引擎允許在建立索引時指定索引類型。<span><i><span>index_type</span></i></span>指定語句的語法是<span>USING
			<span><i>type_name</i></span></span>。不同的儲存引擎所支援的<span><i><span>type_name</span></i></span>值已顯示在下資料表中。如果列有多個索引類型，當沒有指定<span><i><span>index_type</span></i>時，第一個類型是預設值</span>。</p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><strong><span>
					儲存引擎</span></strong></td>
					<td>
					<p><strong><span>
					允許的索引類型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span><span>/<span>HEAP</span></span></td>
					<td>
					<p>
					<span>HASH</span><span>,
					<span>BTREE</span></span></td>
				</tr>
			</table>
			<p>示範：</p>
			<pre><span>CREATE TABLE lookup (id INT) ENGINE = MEMORY;</span></pre>
			<pre><span>CREATE INDEX id_index USING BTREE ON lookup (id);</span></pre>
			<p><span>TYPE <i>type_name</i></span>可以作為<span>USING
			<i>type_name</i></span>的同義詞，用於指定索引類型。但是，<span>USING</span>是首選的格式。另外，在索引規約語法中，位於索引類型前面的索引名稱不能使用<span>TYPE</span>。這是因為，與<span>USING</span>不同，<span>TYPE</span>不是保留詞，因此會被認為是一個索引名稱。</p>
			<p>如果您指定的索引類型在給定的儲存引擎中不合法，但是有其它的索引類型適合引擎使用，並且不會影響查詢功能，則引擎應使用此類型。</p>
			<p>要瞭解更多有關<span>MySQL</span>如何使用索引的訊息，請參見<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5節，「MySQL如何使用索引」</a>。</p>
			<p><span>FULLTEXT</span>索引只能對<span>CHAR, VARCHAR</span>和<span>TEXT</span>列編製索引，並且只能在<span>MyISAM</span>資料表中編製。請參見<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7節，「全文搜索功能」</a>。</p>
			<p><span>SPATIAL</span>索引只能對空間列編製索引，並且只能在<span>MyISAM</span>資料表中編製。空間列類型在<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空間延伸</i></a>中進行了描述。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-table"></a>13.1.5. CREATE 
			TABLE語法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#silent-column-changes">
				13.1.5.1. 沉寂的列規格變更</a></span></dt></dl></div><a class="indexterm" name="id2893328"></a>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>create_definition</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>table_options</i></span>] [<span><i>select_statement</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(] LIKE <span><i>old_tbl_name</i></span> [)];</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>column_definition</i></span></span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] PRIMARY KEY [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | KEY [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | INDEX [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] UNIQUE [INDEX]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [FULLTEXT|SPATIAL] [INDEX] [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] FOREIGN KEY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...) [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECK (<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>column_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> <span><i>type</i></span> [NOT NULL | NULL] [DEFAULT <span><i>default_value</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT &#39;<span><i>string</i></span>&#39;] [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>type</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; TINYINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | SMALLINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | MEDIUMINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INTEGER[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | BIGINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | REAL[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DOUBLE[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | FLOAT[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DECIMAL(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | NUMERIC(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DATE</span></pre>
			<pre><span>&nbsp; | TIME</span></pre>
			<pre><span>&nbsp; | TIMESTAMP</span></pre>
			<pre><span>&nbsp; | DATETIME</span></pre>
			<pre><span>&nbsp; | CHAR(<span><i>length</i></span>) [BINARY | ASCII | UNICODE]</span></pre>
			<pre><span>&nbsp; | VARCHAR(<span><i>length</i></span>) [BINARY]</span></pre>
			<pre><span>&nbsp; | TINYBLOB</span></pre>
			<pre><span>&nbsp; | BLOB</span></pre>
			<pre><span>&nbsp; | MEDIUMBLOB</span></pre>
			<pre><span>&nbsp; | LONGBLOB</span></pre>
			<pre><span>&nbsp; | TINYTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | TEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | MEDIUMTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | LONGTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | ENUM(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | SET(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | <span><i>spatial_type</i></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; REFERENCES <span><i>tbl_name</i></span> [(<span><i>index_col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON DELETE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON UPDATE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; RESTRICT | CASCADE | SET NULL | NO ACTION</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_options</span></i></span><span>: <span><i>table_option</i></span> [<span><i>table_option</i></span>] ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; {ENGINE|TYPE} = <span><i>engine_name</i></span></span></pre>
			<pre><span>&nbsp; | AUTO_INCREMENT = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | AVG_ROW_LENGTH = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] CHARACTER SET <span><i>charset_name</i></span> [COLLATE <span><i>collation_name</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECKSUM = {0 | 1}</span></pre>
			<pre><span>&nbsp; | COMMENT = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | CONNECTION = &#39;<span><i>connect_string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | MAX_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | MIN_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | PACK_KEYS = {0 | 1 | DEFAULT}</span></pre>
			<pre><span>&nbsp; | PASSWORD = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | DELAY_KEY_WRITE = {0 | 1}</span></pre>
			<pre><span>&nbsp; | ROW_FORMAT = {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}</span></pre>
			<pre><span>&nbsp; | UNION = (<span><i>tbl_name</i></span>[,<span><i>tbl_name</i></span>]...)</span></pre>
			<pre><span>&nbsp; | INSERT_METHOD = { NO | FIRST | LAST }</span></pre>
			<pre><span>&nbsp; | DATA DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | INDEX DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_options</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; RANGE(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; LIST(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PARTITIONS <span><i>num</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [&nbsp; SUBPARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SUBPARTITIONS(<span><i>num</i></span>)]&nbsp; </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>partition_definition</i></span>), [(<span><i>partition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION <span><i>partition_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [VALUES { </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LESS THAN (<span><i>expr</i></span>) | <span>MAXVALUE</span> </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IN (<span><i>value_list</i></span>) }]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(<span><i>subpartition_definition</i></span>), [(<span><i>subpartition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>subpartition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SUBPARTITION <span><i>logical_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>select_statement:</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE | REPLACE] [AS] SELECT ...&nbsp;&nbsp; (<span><i>Some legal select statement</i></span>)</span></pre>
			<p><span>CREATE TABLE</span>用於建立帶給定名稱的資料表。您必須擁有資料表<span>CREATE</span>權限。</p>
			<p>允許的資料表名稱的規則列於<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2節，「資料庫、資料表、索引、列和別名」</a>中。預設的情況是，資料表被建立到當前的資料庫中。如果資料表已存在，或者如果沒有當前資料庫，或者如果資料庫不存在，則會出現錯誤。</p>
			<p>資料表名稱被指定為<span><i><span>db_name.tbl_name</span></i></span>，以便在特定的資料庫中建立資料表。不論是否有當前資料庫，都可以通過這種方式建立資料表。如果您使用加引號的識別名，則應對資料庫和資料表名稱分別加引號。例如，<span><span>`mydb`.`mytbl`</span>是合法的，但是<span>`mydb.mytbl`</span>不合法。</span></p>
			<p>在建立資料表格時，您可以使用<span>TEMPORARY</span>關鍵詞。只有在當前連接情況下，<span>TEMPORARY</span>資料表才是可見的。當連接關閉時，<span>TEMPORARY</span>資料表被自動取消。這意味著兩個不同的連接可以使用相同的臨時資料表名稱，同時兩個臨時資料表不會互相衝突，也不與原有的同名的非臨時資料表衝突。（原有的資料表被隱藏，直到臨時資料表被取消時為止。）您必須擁有<span>CREATE 
			TEMPORARY TABLES</span>權限，才能建立臨時資料表。</p>
			<p>如果資料表已存在，則使用關鍵詞<span>IF NOT EXISTS</span>可以防止發生錯誤。注意，原有資料表的結構與<span>CREATE 
			TABLE</span>語句中資料表示的資料表的結構是否相同，這一點沒有驗證。註釋：如果您在<span>CREATE 
			TABLE...SELECT</span>語句中使用<span>IF NOT EXISTS</span>，則不論資料表是否已存在，由<span>SELECT</span>部分選擇的記錄都會被插入。</p>
			<p><span>MySQL</span>通過資料庫目錄中的<span>.frm</span>資料表格式（定義）檔案資料表示每個資料表。資料表的儲存引擎也可能會建立其它檔案。對於<span>MyISAM</span>資料表，儲存引擎可以建立數據和索引檔案。因此，對於每個<span>MyISAM</span>資料表<span><i><span>tbl_name</span></i></span>，有三個磁盤檔案：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>
					檔案</span></strong></td>
					<td>
					<p><strong><span>
					作用</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.frm</span></span></td>
					<td>
					<p>資料表格式（定義）檔案</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYD</span></span></td>
					<td>
					<p>數據檔案</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYI</span></span></td>
					<td>
					<p>索引檔案</td>
				</tr>
			</table>
			<p>用於資料表示資料表的由儲存引擎建立的檔案在<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>儲存引擎和資料表類型</i></a>中描述。</p>
			<p>要瞭解有關各種列類型的性質的一般說明，請參見<a href="column-types.html" title="Chapter 11. Column Types">第11章：列類型</a>。要瞭解有關空間列類型的說明，請參見<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空間延伸</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果沒有指定是<span>NULL</span>或是<span>NOT 
			NULL</span>，則列在建立時假定指定為<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一個整數列可以擁有一個附加屬性<span>AUTO_INCREMENT</span>。當您向一個已編入索引的<span>AUTO_INCREMENT</span>列中插入一個<span>NULL</span>值（建議）或<span>0</span>時，此列被設置為下一個序列的值。通常情況下為<span><i><span>value</span></i><span>+1</span></span>，此處<span><i><span>value</span></i></span>是當前在資料表中的列的最大值。<span>AUTO_INCREMENT</span>序列從<span>1</span>開始。這樣的列必須被定義為一種整數類型，請參見<a href="column-types.html#numeric-type-overview" title="11.1.1. Overview of Numeric Types">11.1.1節，「數值類型概述」</a>中的敘述。（值<span>1.0</span>不是整數）。請參見<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36節，「mysql_insert_id()」</a>。</p>
			<p>為<span>--sql-mode</span>伺服器選項或<span>sql_mode</span>系統變數指定<span>NO_AUTO_VALUE_ON_ZERO</span>特徵位，這樣可以把<span>0</span>儲存到<span>AUTO_INCREMENT</span>列中，同時不生成一個新的序列值。請參見<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1節，「<span><strong class="command">mysqld</strong></span>命令行選項」</a>。</p>
			<p>註釋：有時候，每個資料表只有一個<span>AUTO_INCREMENT</span>列，此列必須編製索引，不能有<span>DEFAULT</span>值。一個<span>AUTO_INCREMENT</span>列只有在只包含正數的情況下，才能運行正常。插入一個負數會被認為是插入了一個非常大的正數。這樣做是為了避免當數字由正數轉為負數時出現精度問題，同時也為了確保<span>AUTO_INCREMENT</span>列中不會包含<span>0</span>。</p>
			<p>對於<span>MyISAM</span>和<span>BDB</span>資料表，您可以在一個多列關鍵字中指定一個<span>AUTO_INCREMENT</span>次級列。請參見<a href="tutorial.html#example-auto-increment" title="3.6.9. Using AUTO_INCREMENT">3.6.9節，「使用AUTO_INCREMENT」</a>。</p>
			<p>為了讓<span>MySQL</span>與部分<span>ODBC</span>應用軟件相兼容，您可以使用以下查詢方法找到最後一個插入行的<span>AUTO_INCREMENT</span>值：</p>
			<pre><span>SELECT * FROM <span><i>tbl_name</i></span> WHERE <span><i>auto_col</i></span> IS NULL</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>字元列的定義可以包括一個<span>CHARACTER SET</span>屬性，用來指定字元編碼，也可以指定列的整序。要瞭解詳細情況，請參見<a href="charset.html" title="Chapter 10. Character Set Support">第10章：<i>字元編碼支援</i></a>。<span>CHARSET</span>是<span>CHARACTER 
			SET</span>的同義詞。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);</span></pre>
			<p><span>MySQL 5.1</span>理解，在字元列定義中的長度規約以字元為單位。（有些早期版本以字節為單位。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DEFAULT</span>子句用於為列指定一個預設值。預設值必須為一個常數，不能為一個函數或一個資料表達式，有一種情況例外。例如，一個日期列的預設值不能被設置為一個函數，如<span>NOW()</span>或<span>CURRENT_DATE</span>。不過，有一種例外，您可以對<span>TIMESTAMP</span>列指定<span>CURRENT_TIMESTAMP</span>為預設值。請參見<a href="column-types.html#timestamp-4-1" title="11.3.1.1. TIMESTAMP Properties as of MySQL 4.1">11.3.1.1節，「MySQL 4.1中的TIMESTAMP屬性」</a>。</p>
			<p><span>BLOB</span>和<span>TEXT</span>列不能被賦予預設值。</p>
			<p>如果在列定義中沒有明確的<span>DEFAULT</span>值，則<span>MySQL</span>按照如下規則確定預設值：</p>
			<p>如果列可以使用<span>NULL</span>作為值，則使用<span>DEFAULT 
			NULL</span>子句對列進行定義。（在<span>MySQL</span>的早期版本中也如此。）</p>
			<p>如果列不能使用<span>NULL</span>作為值，則<span>MySQL</span>對列進行定義時不使用<span>DEFAULT</span>子句。輸入數據時，如果<span>INSERT</span>或<span>REPLACE</span>語句不包括列的值，則<span>MySQL</span>依據當時的有效的<span>SQL</span>模式操作列：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>如果嚴格模式沒有被啟用，則<span>MySQL</span>會根據列數據類型，把列設置為明確的預設值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			如果嚴格模式已被啟用，則事務資料表會出現錯誤，語句被回滾。對於非事務資料表，會出現錯誤，不過，如果錯誤出現在一個多行語句中的第二行或後續行，則以前的各行將被插入。</p>
			<p>假設資料表<span>t</span>按下面的方法進行定義：</p>
			<pre><span>CREATE TABLE t (i INT NOT NULL);</span></pre>
			<p>在這種情況下，<span>i</span>沒有明確的預設值，所以在嚴格模式中，每個後續語句都會產生一個錯誤，並且沒有行被插入。當未使用嚴格模式時，只有第三個語句產生錯誤；明確的預設值被插入到前兩個語句中，但是第三個語句會出現錯誤，因為<span>DEFAULT(i)</span>不會產生一個值：</p>
			<pre><span>INSERT INTO t VALUES();</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT);</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT(i));</span></pre>
			<p>見<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2節，「SQL伺服器模式」</a>。</p>
			<p>對於一個給定的資料表，您可以使用<span>SHOW 
			CREATE TABLE</span>語句來查看那些列有明確的<span>DEFAULT</span>子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於列的評注可以使用<span>COMMENT</span>選項來進行指定。評注通過<span>SHOW 
			CREATE TABLE</span>和<span>SHOW FULL COLUMNS</span>語句顯示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>屬性<span>SERIAL</span>可以用作<span>BIGINT 
			UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</span>的別名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>KEY</span>通常是<span>INDEX</span>同義詞。如果關鍵字屬性<span>PRIMARY 
			KEY</span>在列定義中已給定，則<span>PRIMARY KEY</span>也可以只指定為<span>KEY</span>。這麼做的目的是與其它資料庫系統兼容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>UNIQUE</span>索引中，所有的值必須互不相同。如果您在新增新行時使用的關鍵字與原有行的關鍵字相同，則會出現錯誤。例外情況是，如果索引中的一個列允許包含<span>NULL</span>值，則此列可以包含多個<span>NULL</span>值。此例外情況不適用於<span>BDB</span>資料表。在<span>BDB</span>中，帶索引的列只允許一個單一<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>是一個唯一<span>KEY</span>，此時，所有的關鍵字列必須定義為<span>NOT 
			NULL</span>。如果這些列沒有被明確地定義為<span>NOT NULL</span>，<span>MySQL</span>應隱含地定義這些列。一個資料表只有一個<span>PRIMARY 
			KEY</span>。如果您沒有<span>PRIMARY KEY</span>並且一個應用程式要求在資料表中使用<span>PRIMARY 
			KEY</span>，則<span>MySQL</span>返回第一個<span>UNIQUE</span>索引，此索引沒有作為<span>PRIMARY 
			KEY</span>的<span>NULL</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在已建立的資料表中，<span>PRIMARY KEY</span>的位置最靠前，然後是所有的<span>UNIQUE</span>索引，然後是非唯一索引。這可以幫助<span>MySQL</span>最佳化程式選擇優先使用哪個索引，並且更快速的檢測出重複的<span>UNIQUE</span>關鍵字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>可以是一個多列索引。但是，在列規約中使用<span>PRIMARY 
			KEY</span>關鍵字屬性無法建立多列索引。這麼做只能把一個列標記為主列。您必須使用一個單獨的<span>PRIMARY 
			KEY</span>（<span>index_col_name, 
			...</span>）子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引只包括一個列，並且此列為整數類型，則您也可以在<span>SELECT</span>語句中把此列作為<span>_rowid</span>引用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL</span>中，<span>PRIMARY 
			KEY</span>的名稱為<span>PRIMARY</span>。對於其它索引，如果您沒有賦予名稱，則索引被賦予的名稱與第一個已編入索引的列的名稱相同，並自選新增後綴（<span>_2, 
			_3,...</span>），使名稱為唯一名稱。您可以使用<span>SHOW INDEX FROM
			<span><i>tbl_name</i></span></span>來查看資料表的索引名稱。請參見<a href="sql-syntax.html#show-index" title="13.5.4.11. SHOW INDEX Syntax">13.5.4.11節，「SHOW 
			INDEX語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>部分儲存引擎允許您在建立索引時指定索引類型。<span><i><span>index_type</span></i>指示語句的語法是<span>USING 
			type_name</span>。</span></p>
			<p>示範：</p>
			<pre><span>CREATE TABLE lookup</span></pre>
			<pre><span>&nbsp; (id INT, INDEX USING BTREE (id))</span></pre>
			<pre><span>&nbsp; ENGINE = MEMORY;</span></pre>
			<p>要瞭解有關<span>USING</span>的詳細說明，請參見<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4節，「CREATE 
			INDEX語法」</a>。</p>
			<p>要瞭解有關<span>MySQL</span>如何使用索引的更多訊息，請參見<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5節，「MySQL如何使用索引」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL 5.1</span>中，只有<span>MyISAM</span>，<span>InnoDB, 
			BDB</span>和<span>MEMORY</span>儲存引擎支援在含有<span>NULL</span>值的列中編索引。在其它情況下，您必須定義已編索引的列為<span>NOT 
			NULL</span>，否則會出現錯誤。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一個索引規約中使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>語法，您可以建立一個索引，此索引只使用一個<span>CHAR</span>或<span>VARCHAR</span>列的第一個<span><i><span>length</span></i></span>字元。只對列值的前綴編製索引可以使索引檔案大大減小。請參見<a href="optimization.html#indexes" title="7.4.3. Column Indexes">7.4.3節，「列索引」</a>。</p>
			<p><span>MyISAM</span>和<span>InnoDB</span>儲存引擎也支援對<span>BLOB</span>和<span>TEXT</span>列編索引。當對<span>BLOB</span>或<span>TEXT</span>列編索引時，您必須為索引指定一個前綴長度。例如：</p>
			<pre><span>CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));</span></pre>
			<p>對於<span>MyISAM</span>和<span>InnoDB</span>資料表，前綴最長可以為<span>1000</span>字節，對於其它資料表格類型，最長可以為<span>255</span>字節。注意前綴長度限值以字節為單位，而在<span>CREATE 
			TABLE</span>語句中的前綴長度用字元數目來資料表述。當為一個使用多字節字元編碼的列指定前綴長度時，一定要考慮到這一點。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一個<span><i><span>index_col_name</span></i></span>規約可以以<span>ASC</span>或<span>DESC</span>結尾。這些關鍵詞可以在將來進行延伸，用於指定升序或降序的索引值儲存。當前，這些關鍵詞被分析但是被忽略；索引值均以升序儲存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當您在<span>SELECT</span>中的<span>TEXT</span>列或<span>BLOB</span>列中使用<span>ORDER 
			BY</span>或<span>GROUP BY</span>時，伺服器只使用初始的字節數目對值進行分類。字節數目由<span><span>max_sort_length</span>系統變數進行指示。請參見</span><a href="column-types.html#blob" title="11.4.3. The BLOB and TEXT Types">11.4.3節，「BLOB和TEXT類型<code class="literal"></code>」</a><span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以建立特殊的<span>FULLTEXT</span>索引，用於全文搜索。只有<span>MyISAM</span>資料表類型支援<span>FULLTEXT</span>索引。<span>FULLTEXT</span>索引只可以從<span>CHAR, 
			VARCHAR</span>和<span>TEXT</span>列中建立。整個列都會被編入索引；不支援對部分列編索引。如果已指定，前綴長度會被忽略。要瞭解運行的詳細說明，請參見<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7節，「全文搜索功能」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以為空間列類型建立<span>SPATIAL</span>索引。只有<span>MyISAM</span>資料表支援空間類型，已編索引的列必須聲明為<span>NOT 
			NULL</span>。請參見<a href="spatial-extensions-in-mysql.html">第19章：</a><a href="spatial-extensions-in-mysql.html" title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空間延伸</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>InnoDB</span>資料表支援對外部鍵限制條件進行檢查。請參見<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2節，「InnoDB儲存引擎」</a>。注意，在<span>InnoDB</span>中，<span>FOREIGN 
			KEY</span>語法比本節開始時介紹的<span>CREATE TABLE</span>語句的語法更嚴格：被引用的資料表中的列必須有明確的命名。<span>InnoDB</span>支援外部鍵的<span>ON 
			DELETE</span>和<span>ON UPDATE</span>兩種操作。有關精確語法的說明，請參見<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4節，「FOREIGN 
			KEY約束」</a>。</p>
			<p>對於其它儲存引擎，<span>MySQL</span>伺服器對<span>CREATE 
			TABLE</span>語句中的<span>FOREIGN KEY</span>和<span>REFERENCES</span>語法進行分析，但不採取進一步的行動。所有的儲存引擎均對<span>CHECK</span>子句進行分析，但是忽略<span>CHECK</span>子句。請參見<a href="introduction.html#ansi-diff-foreign-keys" title="1.8.5.5. Foreign Keys">1.8.5.5節，「外部鍵」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於<span>MyISAM</span>資料表，每個<span>NULL</span>列要多佔用一位，進位到距離最近的字節。最大記錄長度（以字節為單位）按照如下方法計算：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>row length = 1</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>sum of column lengths</i></span>)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of NULL columns</i></span> + <span><i>delete_flag</i></span> + 7)/8</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of variable-length columns</i></span>)</span></pre>
			<p>對於採用靜態記錄格式的資料表，<span><i><span>delete_flag</span></i></span>為<span>1</span>。靜態資料表在行記錄中使用一位用作位標記。位標記指示該行是否已被刪除。對於動態資料表，<span><i><span>delete_flag</span></i></span>為<span>0</span>，因為在動態行標題中已儲存了位標記。</p>
			<p>這些計算方法不適用於<span>InnoDB</span>資料表。對於<span>InnoDB</span>資料表，<span>NULL</span>列的儲存量與<span>NOT 
			NULL</span>列的儲存量沒有區別。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>選項用於為資料表指定儲存引擎。<span>ENGINE</span>是首選的選項名稱。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>選項採用以下值：</p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p><strong><span>
					儲存引擎</span></strong></td>
					<td>
					<p><strong><span>
					說明</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ARCHIVE</span></td>
					<td>
					<p>檔案儲存引擎。請參見<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8節，「ARCHIVE儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BDB</span></td>
					<td>
					<p>帶頁面鎖定的事務安全資料表。也稱為<span>BerkeleyDB</span>。請參見<a href="storage-engines.html#bdb-storage-engine" title="15.5. The BDB (BerkeleyDB) Storage Engine">15.5節，「BDB (BerkeleyDB)儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>CSV</span></td>
					<td>
					<p>值之間用逗號隔開的資料表。請參見<a href="storage-engines.html#csv-storage-engine" title="15.9. The CSV Storage Engine">15.9節，「CSV儲存引擎</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>EXAMPLE</span></td>
					<td>
					<p>示範引擎。請參見<a href="storage-engines.html#example-storage-engine" title="15.6. The EXAMPLE Storage Engine">15.6節，「EXAMPLE儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>FEDERATED</span></td>
					<td>
					<p>可以訪問遠程資料表的儲存引擎。請參見<a href="storage-engines.html#federated-storage-engine" title="15.7. The FEDERATED Storage Engine">15.7節，「FEDERATED儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>HEAP</span></td>
					<td>
					<p>見<a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">15.4節，「MEMORY (HEAP)儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p><span>(<em><span>OBSOLETE</span></em>)
					<span>ISAM</span></span></td>
					<td>
					<p>在<span>MySQL 5.1</span>中沒有此引擎。如果您要從以前的版本升級到<span>MySQL 
					5.1</span>，您應該在進行升級前把原有的<span>ISAM</span>資料表轉換為<span>MyISAM</span>資料表。請參見<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>儲存引擎和資料表類型</i></a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>帶行鎖定和外部鍵的事務安全資料表。請參見<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2節，「InnoDB儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span></td>
					<td>
					<p>本資料表類型的數據只保存在儲存器裡。（在早期<span>MySQL</span>版本中被稱為<span>HEAP</span>。）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MERGE</span></td>
					<td>
					<p><span>MyISAM</span>資料表的集合，作為一個資料表使用。也稱為<span>MRG_MyISAM</span>。請參見<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3節，「MERGE儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>二進制輕便式儲存引擎，此引擎是<span>MySQL</span>所用的預設儲存引擎。請參見<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1節，「MyISAM儲存引擎」</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>NDBCLUSTER</span></td>
					<td>
					<p>成叢集資料表，容錯資料表，以儲存器為基礎的資料表。也稱為<span>NDB</span>。請參見<a href="ndbcluster.html">第17章：</a><a href="ndbcluster.html" title="Chapter 17. MySQL Cluster"><i>MySQL叢集</i></a>。</td>
				</tr>
			</table>
			<p>要瞭解有關<span>MySQL</span>儲存引擎的更多訊息，請參見<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>儲存引擎和資料表類型</i></a>。</p>
			<p>如果被指定的儲存引擎無法利用，則<span>MySQL</span>使用<span>MyISAM</span>代替。例如，一個資料表定義包括<span>ENGINE=BDB</span>選項，但是<span>MySQL</span>伺服器不支援<span>BDB</span>資料表，則資料表被建立為<span>MyISAM</span>資料表。這樣，如果您在主機上有事務資料表，但在從屬機上建立的是非交互式資料表（以加快速度）時，可以進行複製設置。在<span>MySQL 
			5.1</span>中，如果沒有遵守儲存引擎規約，則會出現警告。</p>
			<p>其它資料表選項用於最佳化資料表的性質。在多數情況下，您不必指定資料表選項。這些選項適用於所有儲存引擎，另有說明除外：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AUTO_INCREMENT</span><span> </span></p>
			<p>資料表的初始<span>AUTO_INCREMENT</span>值。在<span>MySQL 
			5.1</span>中，本選項只適用於<span>MyISAM</span>和<span>MEMORY</span>資料表。<span>InnoDB</span>也支援本選項。如果引擎不支援<span>AUTO_INCREMENT</span>資料表選項，則要設置引擎的第一個<span>auto-increment</span>值，需插入一個「假」行。該行的值比建立資料表後的值小一，然後刪除該假行。</p>
			<p>對於在<span>CREATE TABLE</span>語句中支援<span>AUTO_INCREMENT</span>資料表選項的引擎，您也可以使用<span>ALTER 
			TABLE <i>tbl_name</i> AUTO_INCREMENT = <i>n</i></span>來重新設置<span>AUTO_INCREMENT</span>值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AVG_ROW_LENGTH</span><span> </span></p>
			<p>資料表中平均行長度的近似值。只需要對含尺寸可變的記錄的大型資料表進行此項設置。</p>
			<p >
			當建立一個<span>MyISAM</span>資料表時，<span>MySQL</span>使用<span>MAX_ROWS</span>和<span>AVG_ROW_LENGTH</span>選項的乘積來確定得出的資料表有多大。如果有一個選項未指定，則資料表的最大尺寸為<span>65,536TB</span>數據。（如果作業系統不支援這麼大的檔案，則資料表的尺寸被限定在作業系統的限值處。）如果您想縮小指針尺寸使索引更小，速度更快，並且您不需要大檔案，則您可以通過設置<span>myisam_data_pointer_size</span>系統變數來減少預設指針的尺寸。（見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。）如果您希望所有的資料表可以擴大，超過預設限值，並且願意讓資料表稍微慢點，並稍微大點，則您可以通過設置此變數增加預設指針的尺寸。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			[DEFAULT] CHARACTER SET</span><span> </span></p>
			<p>用於為資料表指定一個預設字元編碼。<span>CHARSET</span>是<span><span>CHARACTER 
			SET</span>的同義詞。</span></p>
			<p>對於<span>CHARACTER 
			SET</span><span>. </span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLLATE</span><span>
			</span></p>
			<p>用於為資料表指定一個預設整序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHECKSUM</span><span>
			</span></p>
			<p>如果您希望<span>MySQL</span>隨時對所有行進行實時檢驗求和（也就是，資料表變更後，<span>MySQL</span>自動更新檢驗求和），則應把此項設置為<span>1</span>。這樣做，資料表的更新速度會略微慢些，但是更容易尋找到受損的資料表。<span>CHECKSUM 
			TABLE</span>語句用於報告檢驗求和（僅限於<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COMMENT</span><span>
			</span></p>
			<p>資料表的註釋，最長<span>60</span>個字元。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CONNECTION</span><span> </span></p>
			<p><span>FEDERATED</span>資料表的連接字串。（
			註釋：較早版本的<span>MySQL</span>使用<span>COMMENT</span>選項用於連接字串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MAX_ROWS</span><span>
			</span></p>
			<p>
			您打算儲存在資料表中的行數目的最大值。這不是一個硬性限值，而更像一個指示語句，指示出資料表必須能儲存至少這麼多行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MIN_ROWS</span><span>
			</span></p>
			<p>您打算儲存在資料表中的行數目的最小值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			PACK_KEYS</span><span> </span></p>
			<p>如果您希望索引更小，則把此選項設置為<span>1</span>。這樣做通常使更新速度變慢，同時閱讀速度加快。把選項設置為<span>0</span>可以取消所有的關鍵字壓縮。把此選項設置為<span>DEFAULT</span>時，儲存引擎只壓縮長的<span>CHAR</span>或<span>VARCHAR</span>列（僅限於<span>MyISAM</span>）。</p>
			<p>如果您不使用<span>PACK_KEYS</span>，則預設操作是只壓縮字串，但不壓縮數字。如果您使用<span>PACK_KEYS=1</span>，則對數字也進行壓縮。</p>
			<p>在對二進制數字關鍵字進行壓縮時，<span>MySQL</span>採用前綴壓縮：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>每個關鍵字需要一個額外的字節來指示前一個關鍵字中有多少字節與下一個關鍵字相同。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>指向行的指針以高位字節優先的順序儲存在關鍵字的後面，用於改進壓縮效果。</p>
			<p>
			這意味著，如果兩個連續行中有許多相同的關鍵字，則後續的「相同」的關鍵字通常只佔用兩個字節（包括指向行的指針）。與此相比，常規情況下，後續的關鍵字佔用<span><span>storage_size_for_key 
			+ pointer_size</span>（指針尺寸通常為<span>4</span>）。但是，只有在許多數字相同的情況下，前綴壓縮才有好處。如果所有的關鍵字完全不同，並且關鍵字不能含有<span>NULL</span>值，則每個關鍵字要多使用一個字節。（在這種情況中，儲存壓縮後的關鍵字的長度的字節與用於標記關鍵字是否為<span>NULL</span>的字節是同一字節。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PASSWORD</span><span>
			</span></p>
			<p>使用密碼對<span>.frm</span>檔案加密。在標準<span>MySQL</span>版本中，本選項不起任何作用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			DELAY_KEY_WRITE</span><span> </span></p>
			<p>如果您想要延遲對關鍵字的更新，等到資料表關閉後再更新，則把此項設置為<span>1</span>（僅限於<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			ROW_FORMAT</span><span> </span></p>
			<p>定義各行應如何儲存。當前，此選項只適用於<span>MyISAM</span>資料表。對於靜態行或長度可變行，此選項值可以為<span>FIXED</span>或<span>DYNAMIC</span>。<strong><span>myisampack</span></strong>用於把類型設置為<span>COMPRESSED</span>。請參見<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3節，「MyISAM資料表的儲存格式」</a>。</p>
			<p>在預設情況下，<span>InnoDB</span>記錄以壓縮格式儲存（<span>ROW_FORMAT=COMPACT</span>）。通過指定<span>ROW_FORMAT=REDUNDANT</span>，仍然可以申請用於較早版本的<span>MySQL</span>中的非壓縮格式。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			RAID_TYPE</span><span> </span></p>
			<p>在<span>MySQL 5.0</span>中<span>,RAID</span>支援被刪除了。要瞭解有關<span>RAID</span>的說明，請參見<span class="MsoHyperlink"><span>http://dev.mysql.com/doc/refman/4.1/en/create-table.html</span></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>UNION</span><span>
			</span></p>
			<p>當您想要把一組相同的資料表當作一個資料表使用時，採用<span>UNION</span>。<span>UNION</span>僅適用於<span>MERGE</span>資料表。請參見<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3節，「MERGE儲存引擎」</a>。</p>
			<p>對於您映射到一個<span>MERGE</span>資料表上的資料表，您必須擁有<span>SELECT, 
			UPDATE</span>和<span>DELETE</span>權限。（註釋：以前，所有被使用的資料表必須位於同一個資料庫中，並作為<span>MERGE</span>資料表。這些限制不再適用。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INSERT_METHOD</span><span> </span></p>
			<p>如果您希望在<span>MERGE</span>資料表中插入數據，您必須用<span>INSERT_METHOD</span>指定應插入行的資料表。<span>INSERT_METHOD</span>選項僅用於<span>MERGE</span>資料表。使用<span>FIRST</span>或<span>LAST</span>把行插入到第一個或最後一個資料表中；或者使用<span>NO</span>，阻止插入行。請參見<a href="storage-engines.html#merge-storage-engine" title="15.3. The MERGE Storage Engine">15.3節，「MERGE儲存引擎」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span> </span></p>
			<p>通過使用<span>DATA 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>或<span>INDEX 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>，您可以指定<span>MyISAM</span>儲存引擎放置資料表格數據檔案和索引檔案的位置。注意，目錄應是通向目錄的完整路徑（不是相對路徑）。</p>
			<p>僅當您沒有使用<span>--skip-symbolic-links</span>選項時，<span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span></span>才能使用。作業系統必須有一個正在工作的、線程安全的<span>realpath()</span>使用。要瞭解全面訊息，請參見<a href="optimization.html#symbolic-links-to-tables" title="7.6.1.2. Using Symbolic Links for Tables on Unix">7.6.1.2節，「在Unix平台上使用資料表的符號連結</a>」。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於用<span>CREATE TABLE</span>建立的資料表，可以使用<span><i><span>partition_options</span></i></span>控制分區。如果使用了<span><i><span>partition_options</span></i></span>，則其中必須包含至少一個<span>PARTITION 
			BY</span>子句。本子句包含用於確定分區的函數；該函數會返回一個整值，範圍從<span>1</span>到<span><i><span>num</span></i></span>。此處<span><i><span>num</span></i></span>為分區的數目。此函數中可以使用的選項顯示在下面的清單中。
			要點：在本節開始時介紹的用於<span><i><span>partition_options</span></i></span>的語法中顯示的選項，並不是都能用於所有分區類型。要瞭解各種類型具體的訊息
			，請參見以下各類型的清單。要瞭解有關在<span>MySQL</span>中的分區的操作和使用情況的全面說明，以及要瞭解資料表建立的示範和與<span>MySQL</span>分區有關的其它命令，請參見<a href="partitioning.html">第18章：</a><a href="partitioning.html" title="Chapter 18. Partitioning"><i>分區</i></a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>HASH</span>（<span><i><span>expr</span></i></span>）：用於混編一個或多個列，建立一個關鍵字，用於放置行，並確定行的位置。<span><i><span>expr</span></i></span>是一個資料表達式，使用一個或多個資料表中的列。該資料表達式可以是任何能夠生成單一整值的合法的<span>MySQL</span>資料表達式（包括<span>MySQL</span>函數）。例如，這些都是有效的<span>CREATE 
			TABLE</span>語句，語句中使用了<span>PARTITION BY HASH</span>：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5)) </span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH(col1);</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH( ORD(col2) );</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH ( YEAR(col3) );</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY HASH</span>一起使用。</p>
			<p><span>PARTITION BY HASH</span>使用<span><i><span>expr</span></i></span>被分區數目所除後的餘數（也就是模數）。要瞭解示範和其它訊息，請參見<a href="partitioning.html#partitioning-hash" title="18.2.3. HASH Partitioning">18.2.3節，「HASH分區」</a>。</p>
			<p><span>LENEAR</span>關鍵詞需要一種不同的算法。在這種情況下，通過一次或多次邏輯<span>AND</span>運算得出的結果，計算出儲存記錄的分區的數目。要瞭解線形混編的討論和示範，請參見<a href="partitioning.html#partitioning-linear-hash" title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1節，「LINEAR 
				HASH分區」</a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>KEY(<i>column_list</i>)</span>：與<span>HASH</span>近似，除了有一點不一樣，即<span>MySQL</span>提供了混編函數，以保證均勻的數據分佈。<i><span>column_list</span></i>自變數只是各列的一個清單。本示範顯示了由關鍵字進行分區的一個簡單的資料表，分為<span>4</span>個分區：</span></p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY KEY(col3)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITIONS 4;</span></pre>
			<p>採用<span>LINEAR</span>關鍵詞，您可以對由關鍵字分區的資料表進行線形分區。這與由<span>HASH</span>進行分區的資料表格有同樣的效果；也就是說，使用<span>&amp;</span>操作符搜尋分區數目，而不是使用模數（詳細說明見<a href="partitioning.html#partitioning-linear-hash" title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1節，「LINEAR 
				HASH分區」</a>和<a href="partitioning.html#partitioning-key" title="18.2.4. KEY Partitioning">18.2.4節，「KEY分區」</a>）。本示範採用了關鍵字線形分區，用來在<span>5</span>個分區之間分配數據：</p>
			<pre><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;PARTITION BY LINEAR KEY(col3)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITIONS 5;</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY KEY</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>RANGE</span>：在此情況下，<span><i><span>expr</span></i>使用一套<span>VALUES 
			LESS THAN</span>操作符</span>顯示了某一範圍內的值。當使用範圍分區時，您必須使用<span>VALUES 
			LESS THAN</span>定義至少一個分區。<span>VALUES IN</span>不能和範圍分區一起使用。</p>
			<p><span>VALUES LESS THAN</span>可以與一個文字值同時使用，或者與一個可以求算單一值的資料表達式同時使用。</p>
			<p>舉例說明，假設您有一個資料表，您希望採用以下方法對包含年份值的一列進行分區：</p>
			<table border="1" cellpadding="0" id="table4">
				<tr>
					<td>
					<p>分區編號：</td>
					<td>
					<p>年份範圍：</td>
				</tr>
				<tr>
					<td>
					<p><span>0</span></td>
					<td>
					<p><span>1990</span>以前</td>
				</tr>
				<tr>
					<td>
					<p><span>1</span></td>
					<td>
					<p><span>1991 - 1994</span></td>
				</tr>
				<tr>
					<td>
					<p><span>2</span></td>
					<td>
					<p><span>1995 - 1998</span></td>
				</tr>
				<tr>
					<td>
					<p><span>3</span></td>
					<td>
					<p><span>1999 - 2002</span></td>
				</tr>
				<tr>
					<td>
					<p><span>4</span></td>
					<td>
					<p><span>2003 - 2005</span></td>
				</tr>
				<tr>
					<td>
					<p><span>5</span></td>
					<td>
					<p><span>2006</span>年以後</td>
				</tr>
			</table>
			<p>採用這種分區方法的資料表可以通過如下<span>CREATE 
			TABLE</span>語句實現：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT, </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;some_data INT </span></pre>
			<pre><span>) </span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p3 VALUES LESS THAN (2002),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p4 VALUES LESS THAN (2006),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p5 VALUES LESS THAN MAXVALUE</span></pre>
			<pre><span>);</span></pre>
			<p><span>
			<span>PARTITION ... VALUES LESS THAN ...</span>語句按順序執行。<span>VALUES 
			LESS THAN MAXVALUE</span>的作用是指定大於最大值的「其餘」的值。</span></p>
			<p>注意，<span>VALUES LESS THAN</span>子句按順序執行，執行方式類似於<span><span>switch 
			... case</span>語段的一部分</span>（許多編程語言，如<span>C, Java</span>和<span>PHP</span>也如此）。也就是說，子句必須按照這樣一種方法排列，每一個後續的<span>VALUES 
			LESS THAN</span>中指定的上限值大於前一個<span>VALUES LESS THAN</span>中指定的上限值，並在清單的最後加一個參照性的<span>MAXVALUE</span>。</p>
			<p><span>VALUES IN</span>與一系列的值同時使用。舉例說明，您可以建立如下的分區方法：</p>
			<pre><span>CREATE TABLE client_firms (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR(35)</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (id) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)</span></pre>
			<pre><span>);</span></pre>
			<p>當前，與<span>VALUES IN...</span>同時使用的值必須只包含整數值。</p>
			<p>（因為此資料表只使用<span>VALUES IN</span>資料表達式進行分區，您也可以用<span>PARTITION 
			BY LIST</span>代替，而不是使用<span>PARTITION BY RANGE</span>。請參見下一條。）</p>
			<p>在使用<span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>情況下，每個分區使用<span>PARTITION
			<span><i>name</i></span></span>定義，此處<span><i><span>name</span></i></span>是分區的標識名，後面接<span>VALUES...</span>子句。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>LIST(<i>expr</i>)</span>：當根據含有一系列限定性值（例如州代碼或國家代碼）的列進行分區時使用。在這種情況下，所有與特定的州或國家有關的記錄都被分配到一個單一分區中，或者可以預留出一個分區，用於一系列特定的州或國家。<span>LIST(<i>expr</i>)</span>與<span>RANGE</span>類似，除了一點以外，即只有<span>VALUES 
			IN</span>可以被用於為每個分區指定值。</span></p>
			<p>當使用清單分區時，您必須使用<span>VALUES 
			IN</span>定義至少一個分區。<span>VALUES LESS THAN</span>不能與<span>PARTITION 
			BY LIST</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分區數目可以使用<span>PARTITION
			<span><i>num</i></span></span>子句，自選進行指定，此處，<span><i><span>num</span></i></span>是分區的數目。如果本子句和其它<span>PARTITION</span>子句同時使用，則<span><i><span>num</span></i></span>必須與使用<span>PARTITION</span>子句說明的分區的總數相等。</p>
			<p>註釋：不論您在建立一個由<span>RANGE</span>或<span>LIST</span>進行分區的資料表時是否使用了<span>PARTITIONS</span>子句，您必須在資料表定義中包括至少一個<span>PARTITION 
			VALUES</span>（見後）。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一個分區可以自選分隔成多個子分區。使用自選的<span>SUBPARTITION BY</span>子句可以指示。子分區可以由<span>HASH</span>或<span>KEY</span>進行分隔。兩種方法建立的子分區均為<span>LINEAR</span>。分隔子分區時的操作方式與以前描述的分區類型的操作方式一樣。（無法由<span>LIST</span>或<span>RANGE</span>進行子分區分隔。）</p>
			<p>使用<span>SUBPARTITIONS</span>關鍵詞，後面接一個整值，可以對子分區的數目進行指示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用一個<span><i><span>partition_definition</span></i></span>子句可以對每個分區分別進行定義。下面是組成這個子句的各個部分：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>PARTITION <i>
			partition_name</i></span>：用於為分區指定一個邏輯名稱。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>VALUE</span>子句：對於範圍分區，每個分區必須包括一個<span>VALUES 
			LESS THAN</span>子句；對於清單分區，您必須為每個分區指定一個<span>VALUES IN</span>子句。本子句用於確定哪些行將被儲存到此分區中。要瞭解語法示範，請參見<a href="partitioning.html">第18章：</a><a href="partitioning.html" title="Chapter 18. Partitioning"><i>分區</i></a>中對分區類型的討論。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自選的<span>COMMENT</span>子句可以用於描述分區。註釋必須加單引號。舉例說明：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COMMENT = &#39;Data for the years previous to 1999&#39;</span></pre>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>可以被用於指示本分區的數據和索引各自的儲存位置的目錄。<span><i><span>data_dir</span></i></span>和<span><i><span>index_dir</span></i></span>都必須是絕對系統路徑。例如：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>PARTITION BY LIST(YEAR(adate))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p1999 VALUES IN (1995, 1999, 2003) DATA DIRECTORY = &#39;<span>/var/appdata/95/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/95/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1996, 2000, 2004) DATA DIRECTORY = &#39;<span>/var/appdata/96/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/96/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2001 VALUES IN (1997, 2001, 2005) DATA DIRECTORY = &#39;<span>/var/appdata/97/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/97/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1998, 2002, 2006) DATA DIRECTORY = &#39;<span>/var/appdata/98/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/98/idx</span>&#39;</span></pre>
			<pre><span>);</span></pre>
			<p><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>的操作方法與<span>CREATE TABLE</span>語句中的<span><i><span>table_option</span></i></span>子句的操作方法一樣。此<span><i><span>table_option</span></i></span>子句用於位於<span>MyISAM</span>資料表管理程式下的各資料表。</p>
			<p>
			可以為每個分區指定一個數據目錄和一個索引目錄。如果不指定，則數據和索引被儲存在預設的<span>MySQL</span>數據目錄中。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>MAX_ROWS</span>和<span>MIN_ROWS</span>分別用於將被儲存在分區中的行數目最大值和行數目最小值。<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i>的值</span>必須為正整數。和具有同樣名稱的桌面選項一樣，<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i></span>只作為對伺服器的「建議」值，並不是硬性限值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自選的<span>TABLESPACE</span>子句可以用於為分區指定一個桌面空間。僅用於<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自選的<span>[STORAGE] ENGINE</span>子句可以把本分區中資料表的類型改為指定的類型。資料表的類型可以是本<span>MySQL</span>伺服器支援的所有類型。<span>STORAGE</span>關鍵字和等號<span>(=)</span>均為自選項。如果沒有使用此選項設置分區儲存引擎，則適用於整個資料表的引擎可以用於此分區。</p>
			<p>註釋：分區管理程式對於<span>PARTITION</span>和<span>SUBPARTITION</span>均接受<span>[STORAGE] 
			ENGINE</span>選項。目前，此子句的使用方式僅限於對所有的分區或子分區設置同一個儲存引擎，如果試圖在同一個資料表內對不同的分區或子分區設置不同的儲存引擎，則會出現錯誤<span>ERROR 
			1469 (HY000)</span>：在本版本的<span>MySQL</span>中，不允許在各分區中混用管理程式。我們打算在將來的<span>MySQL 
			5.1</span>版本中加入這種對分區的限定。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>NODEGROUP</span>選項可以用於使本分區可以作為節點組的一部分，節點組使用<span><i><span>node_group_id</span></i></span>識別。本選項僅適用於<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分區定義可以自選地包含一個或多個<span><i><span>subpartition_definition</span></i></span>子句。每個這種子句至少包括<span>SUBPARTITION
			<i>name</i></span>，此處，<span><i><span>name</span></i></span>是子分區的識別名稱。除了用<span>SUBPARTITION</span>代替<span>PARTITION</span>關鍵詞外，用於子分區定義的語法與用於分區定義的語法一樣。</p>
			<p>子分區必須由<span>HASH</span>或<span>KEY</span>完成，並且只能對<span>RANGE</span>或<span>LIST</span>分區進行子分區。請參見<a href="partitioning.html#partitioning-subpartitions" title="18.2.5. Subpartitioning">18.2.5節，「子分區」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>分區可以修改、合併、新增到資料表中，或從資料表中刪去。要瞭解有關完成這些任務的<span>MySQL</span>命令的基本說明，請參見<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2節，「ALTER 
			TABLE語法」</a>。要瞭解詳細的說明和示範，請參見<a href="partitioning.html#partitioning-management" title="18.3. Partition Management">18.3節，「分區管理」</a>。</p>
			<p>您可以在<span>CREATE TABLE</span>語句的末尾新增一個<span>SELECT</span>語句，在一個資料表的基礎上建立資料表。</p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> SELECT * FROM <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>MySQL</span>會對<span>SELECT</span>中的所有項建立新列。舉例說明：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>PRIMARY KEY (a), KEY(b))</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>TYPE=MyISAM SELECT b,c FROM test2;</b></span></span></pre>
			<p>本語句用於建立含三個列（<span>a, b, c</span>）的<span>MyISAM</span>資料表。注意，用<span>SELECT</span>語句建立的列附在資料表的右側，而不是覆蓋在資料表上。參考以下示範：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM foo;</b></span></span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| n |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| 1 |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (m INT) SELECT n FROM foo;</b></span></span></pre>
			<pre><span>Query OK, 1 row affected (0.02 sec)</span></pre>
			<pre><span>Records: 1&nbsp; Duplicates: 0&nbsp; Warnings: 0</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM bar;</b></span></span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| m&nbsp;&nbsp;&nbsp; | n |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| NULL | 1 |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>1 row in set (0.00 sec)</span></pre>
			<p>對應於資料表<span>foo</span>中的每一行，在資料表<span>bar</span>中插入一行，含有資料表<span>foo</span>中的值以及新列中的預設值。</p>
			<p>在由<span>CREATE TABLE...SELECT</span>生成的資料表中，只在<span>CREATE 
			TABLE</span>部分中命名的列首先出現。在兩個部分中都命名的列和只在<span>SELECT</span>部分中命名的列隨後出現。也可以通過指定<span>CREATE 
			TABLE</span>部分中的列覆蓋<span>SELECT</span>列中的數據類型。</p>
			<p>如果在把數據複製到資料表中時出現錯誤，則資料表會自動被取消，不會被建立。</p>
			<p><span>CREATE TABLE...SELECT</span>不會自動建立任何索引。索引需要專門建立，以便使語句的靈活性更強。如果您希望為已建立的資料表建立索引，您應在<span>SELECT</span>語句前指定索引。</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</b></span></span></pre>
			<p>列的類型會發生部分轉化。例如，<span>AUTO_INCREAMENT</span>屬性不會被保留，<span>VARCHAR</span>列會變成<span>CHAR</span>列。</p>
			<p>當使用<span>CREATE...SELECT</span>建立資料表時，在查詢時一定要對功能使用和資料表達式起別名。如果不起別名，則<span>CREATE</span>語句會出現錯誤或者生成不符合需要的列名稱。</p>
			<pre><span>CREATE TABLE artists_and_works</span></pre>
			<pre><span>SELECT artist.name, COUNT(work.artist_id) AS number_of_works</span></pre>
			<pre><span>FROM artist LEFT JOIN work ON artist.id = work.artist_id</span></pre>
			<pre><span>GROUP BY artist.id;</span></pre>
			<p>您也可以明確地為一個已生成的列指定類型：</p>
			<pre><span>CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;</span></pre>
			<p>根據其它資料表的定義（包括在原資料表中定義的所有的列屬性和索引），使用<span>LIKE</span>建立一個空資料表<span>:</span></p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> LIKE <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>CREATE TABLE...LIKE</span>不會複製對原資料表或外部鍵定義指定的<span>DATA 
			DIRECTORY</span>或<span>INDEX DIRECTORY</span>資料表選項。</p>
			<p>您可以在<span>SELECT</span>前增加<span>IGNORE</span>或<span>REPLACE</span>，指示如何對複製唯一關鍵字值的記錄進行操縱。使用<span>IGNORE</span>後，如果新記錄複製了原有的唯一關鍵字值的記錄，則新記錄被丟棄。使用<span>REPLACE</span>後，新記錄替換具有相同的唯一關鍵字值的記錄。如果沒有指定<span>IGNORE</span>或<span>REPLACE</span>，則出現多重唯一關鍵字值時會導致發生錯誤。</p>
			<p>為了確保更新日誌<span>/</span>二進位日誌可以被用於再次建立原資料表，<span>MySQL</span>不允許在<span>CREATE 
			TABLE...SELECT</span>過程中進行聯合插入。</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="silent-column-changes"></a>
				13.1.5.1.&nbsp;沉寂的列規格變更</h4></div></div></div><a class="indexterm" name="id2897793"></a>
				<p>在有些情況下，較早版本的<span>MySQL</span>會靜默地更改在<span>CREATE 
				TABLE</span>或<span>ALTER TABLE</span>語句中給定的列規約。在<span>MySQL 
				5.1</span>中不會進行這類變更。如果使用指定的數據類型無法建立列，則會出現錯誤。</p>
				<div>
					<div>
						<h3 class="title"><a name="drop-database"></a>13.1.6. DROP 
			DATABASE語法</h3></div></div></div>
			<a class="indexterm" name="id2897830"></a>
			<a class="indexterm" name="id2897840"></a>
			<a class="indexterm" name="id2897848"></a>
			<a class="indexterm" name="id2897859"></a>
			<a class="indexterm" name="id2897869"></a>
			<a class="indexterm" name="id2897879"></a>
			<pre><span>DROP {DATABASE | SCHEMA} [IF EXISTS] <span><i>db_name</i></span></span></pre>
			<p><span>DROP DATABASE</span>用於取消資料庫中的所用資料表格和取消資料庫。使用此語句時要非常小心！如果要使用<span>DROP 
			DATABASE</span>，您需要獲得資料庫<span>DROP</span>權限。</p>
			<p><span>IF EXISTS</span>用於防止當資料庫不存在時發生錯誤。</p>
			<p>也可以使用<span>DROP SCHEMA</span>。</p>
			<p>如果您對一個帶有符號連結的資料庫使用<span>DROP DATABASE</span>，則連結和原資料庫都被取消。</p>
			<p><span>DROP DATABASE</span>會返回已被取消的資料表的數目。此數目相當於被取消的<span>.frm</span>檔案的數目。</p>
			<p>在正常操作中<span>MySQL</span>自身會建立出一些檔案和目錄。<span>DROP 
			DATABASE</span>語句會從給定的資料庫目錄中取消這些檔案和目錄：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有帶這些延伸名的檔案：</p>
			<table border="1" cellpadding="0" id="table5">
				<tr>
					<td>
					<p>
					<span>.BAK</span></td>
					<td>
					<p>
					<span>.DAT</span></td>
					<td>
					<p>
					<span>.HSH</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MRG</span></td>
					<td>
					<p>
					<span>.MYD</span></td>
					<td>
					<p>
					<span>.ISD</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MYI</span></td>
					<td>
					<p>
					<span>.db</span></td>
					<td>
					<p>
					<span>.frm</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>名稱中包含兩位<span>16</span>進制數<span>00-ff</span>的所有子目錄。這些子目錄用於<span>RAID</span>資料表。（當對<span>RAID</span>資料表的支援被取消時，在<span>MySQL 
			5.0</span>中，這些目錄不會被取消。您應該在升級到<span>MySQL 5.0</span>或更新的版本前轉化原有的<span>RAID</span>資料表，並人工取消這些目錄。請參見<span>MySQL 
			5.0</span>參考手冊中有關從較早版本升級到<span>MySQL 5.0</span>的章節。<span>MySQL 
			5.0</span>參考手冊可以從<span>MySQL</span>網站中獲取。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>db.opt</span>檔案</p>
			<p>如果在<span>MySQL</span>取消了上述這些檔案之後，在資料庫目錄中仍保留有其它檔案和目錄，則資料庫目錄不能被取消。在這種情況下，您必須人工取消所有保留下的檔案或目錄，並再次發送<span>DROP 
			DATABASE</span>語句。</p>
			<p>您還可以使用<strong><span>mysqladmin</span></strong>來取消檔案。請參見<a href="client-side-scripts.html#mysqladmin" title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5節，「mysqladmin：用於管理MySQL伺服器的客戶端」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-index"></a>13.1.7. DROP 
			INDEX語法</h3></div></div></div><a class="indexterm" name="id2898172"></a><a class="indexterm" name="id2898181"></a><a class="indexterm" name="id2898191"></a>
			<pre><span>DROP INDEX <span><i>index_name</i></span> ON <span><i>tbl_name</i></span></span></pre>
			<p><span>DROP INDEX</span>用於從資料表<span><i><span>tbl_name</span></i></span>中取消名稱為<span><i><span>index_name</span></i></span>的索引。本語句被映射到一個<span>ALTER 
			TABLE</span>語句中，用於取消索引。請參見<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2節，「ALTER 
		TABLE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-table"></a>13.1.8. DROP 
			TABLE語法</h3></div></div></div><a class="indexterm" name="id2898277"></a><a class="indexterm" name="id2898286"></a><a class="indexterm" name="id2898296"></a>
			<pre><span>DROP [TEMPORARY] TABLE [IF EXISTS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [RESTRICT | CASCADE]</span></pre>
			<p><span>DROP TABLE</span>用於取消一個或多個資料表。您必須有每個資料表的<span>DROP</span>權限。所有的資料表數據和資料表定義會被取消，所以使用本語句要小心！</p>
			<p>注意，對於一個帶分區的資料表，<span>DROP TABLE</span>會永久性地取消資料表定義，取消各分區，並取消儲存在這些分區中的所有數據。<span>DROP 
			TABLE</span>還會取消與被取消的資料表有關聯的分區定義（<span>.par</span>）檔案。</p>
			<p>對與不存在的資料表，使用<span>IF EXISTS</span>用於防止錯誤發生。當使用<span>IF 
			EXISTS</span>時，對於每個不存在的資料表，會生成一個<span>NOTE</span>。請參見<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22節，「SHOW 
		WARNINGS語法」</a>。</p>
			<p><span>RESTRICT</span>和<span>CASCADE</span>可以使分區更容易。目前，<span>RESTRICT</span>和<span>CASCADE</span>不起作用。</p>
			<p>註釋：除非您使用<span>TEMPORARY</span>關鍵詞，<span>DROP 
			TABLE</span>會自動提交當前的有效的事務。</p>
			<p><span>TEMPORARY</span>關鍵詞具有以下作用：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>語句只取消<span>TEMPORARY</span>資料表。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>語句不會終止正在進行中的事務。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不會查驗存取權。（<span>TEMPORARY</span>資料表僅對於建立該資料表的客戶端是可見的，所以查驗是不必要的。）</p>
			<p>使用<span>TEMPORARY</span>是確保您不會意外取消一個非<span>TEMPORARY</span>資料表的良好方法。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rename-table"></a>13.1.9. RENAME 
			TABLE語法</h3></div></div></div><a class="indexterm" name="id2898503"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<pre><span>RENAME TABLE <span><i>tbl_name</i></span> TO <span><i>new_tbl_name</i></span></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>tbl_name2</i></span> TO <span><i>new_tbl_name2</i></span>] ...</span></pre>
		<p>本語句用於對一個或多個資料表進行重命名。</p>
		<p>重命名操作自動進行，這意味著當重命名正在運行時，其它線程不能讀取任何資料表。例如，如果您有一個原有的資料表<span>old_table</span>，您可以建立另一個具有相同結構的空資料表<span>new_table</span>，然後用此空資料表替換原有的資料表：</p>
		<pre><span>CREATE TABLE <span><i>new_table</i></span> (...);</span></pre>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>backup_table</i></span>, <span><i>new_table</i></span> TO <span><i>old_table</i></span>;</span></pre>
		<p>如果此語句用於對多個資料表進行重命名，則重命名操作從左至右進行。如果您想要交換兩個資料表的名稱，您可以這樣做（假設不存在名稱為<span>tmp_table</span>的資料表）：</p>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>tmp_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>new_table</i></span> TO <span><i>old_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>tmp_table</i></span> TO <span><i>new_table</i></span>;</span></pre>
		<p>只要兩個資料庫位於同一檔案系統中，您還可以對資料表進行重命名，把資料表從一個資料庫中移動到另一個資料庫中：</p>
		<pre><span>RENAME TABLE <span><i>current_db.tbl_name</i></span> TO <span><i>other_db.tbl_name;</i></span></span></pre>
		<p>當您執行<span>RENAME</span>時，您不能有被鎖定的資料表，也不能有處於活性狀態的事務。您還必須擁有原資料表的<span>ALTER</span>和<span>DROP</span>權限，以及新資料表的<span>CREATE</span>和<span>INSERT</span>權限。</p>
		<p>如果<span>MySQL</span>對多個資料表進行重命名時遇到了錯誤，<span>MySQL</span>會對所有已被重命名的資料表進行反向重命名，返回到原來的狀態。</p>
		<p>只要您不嘗試通過重命名把視圖加入另一個資料庫中，則<span>RENAME TABLE</span>也可以用於視圖。</p>
		<h2 class="title"><a name="data-manipulation"></a>
		13.2.&nbsp;數據操作語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#delete">13.2.1. 
			DELETE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.2. 
			DO語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.3. 
			HANDLER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.4. 
			INSERT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.5. 
			LOAD DATA INFILE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.6. 
			REPLACE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.7. 
			SELECT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">
			13.2.8. Subquery語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate">13.2.9. 
			TRUNCATE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.10. 
			UPDATE語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>13.2.1. DELETE語法</h3></div></div></div><a class="indexterm" name="id2898726"></a>
			<p>單資料表語法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p>多資料表語法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; USING <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span><i><span>tbl_name</span></i></span>中有些行滿足由<span><i><span>where_definition</span></i></span>給定的條件。<span>DELETE</span>用於刪除這些行，並返回被刪除的記錄的數目。</p>
			<p>如果您編寫的<span>DELETE</span>語句中沒有<span>WHERE</span>子句，則所有的行都被刪除。當您不想知道被刪除的行的數目時，有一個更快的方法，即使用<span>TRUNCATE 
			TABLE</span>。請參見<a href="sql-syntax.html#truncate" title="13.2.9. TRUNCATE Syntax">13.2.9節，「TRUNCATE語法」</a>。</p>
			<p>如果您刪除的行中包括用於<span>AUTO_INCREMENT</span>列的最大值，則該值被重新用於<span>BDB</span>資料表，但是不會被用於<span>MyISAM</span>資料表或<span>InnoDB</span>資料表。如果您在<span>AUTOCOMMIT</span>模式下使用<span>DELETE 
			FROM <span><i>tbl_name</i></span></span>（不含<span>WHERE</span>子句）刪除資料表中的所有行，則對於所有的資料表類型（除<span>InnoDB</span>和<span>MyISAM</span>外），序列重新編排。對於<span>InnoDB</span>資料表，此項操作有一些例外，在<a href="storage-engines.html#innodb-auto-increment-column" title="15.2.6.3. How an AUTO_INCREMENT Column Works in InnoDB">15.2.6.3節，「AUTO_INCREMENT列如何在InnoDB中運行」</a>中進行了討論。</p>
			<p>對於<span>MyISAM</span>和<span>BDB</span>資料表，您可以把<span>AUTO_INCREMENT</span>次級列指定到一個多列關鍵字中。在這種情況下，從序列的頂端被刪除的值被再次使用，甚至對於<span>MyISAM</span>資料表也如此。請參見<a href="tutorial.html#example-auto-increment" title="3.6.9. Using AUTO_INCREMENT">3.6.9節，「使用AUTO_INCREMENT」</a>。</p>
			<p><span>DELETE</span>語句支援以下修飾符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定<span>LOW_PRIORITY</span>，則<span>DELETE</span>的執行被延遲，直到沒有其它客戶端讀取本資料表時再執行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於<span>MyISAM</span>資料表，如果您使用<span>QUICK</span>關鍵詞，則在刪除過程中，儲存引擎不會合併索引端結點，這樣可以加快部分種類的刪除操作的速度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在刪除行的過程中，<span>IGNORE</span>關鍵詞會使<span>MySQL</span>忽略所有的錯誤。（在分析階段遇到的錯誤會以常規方式處理。）由於使用本選項而被忽略的錯誤會作為警告返回。</p>
			<p>刪除操作的速度會受到一些因素的影響，這些因素在<a href="optimization.html#delete-speed" title="7.2.18. Speed of DELETE Statements">7.2.18節，「DELETE語句的速度」</a>中進行了討論。 </p>
			<p>在<span>MyISAM</span>資料表中，被刪除的記錄被保留在一個帶連結的清單中，後續的<span>INSERT</span>操作會重新使用舊的記錄位置。要重新使用未使用的空間並減小檔案的尺寸，則使用<span>OPTIMIZE 
			TABLE</span>語句或<strong><span>myisamchk</span></strong>應用程式重新編排資料表。<span>OPTIMIZE 
			TABLE</span>更簡便，但是<strong><span>myisamchk</span></strong>速度更快。請參見<a href="sql-syntax.html#optimize-table" title="13.5.2.5. OPTIMIZE TABLE Syntax">13.5.2.5節，「OPTIMIZE 
		TABLE語法」</a>和<a href="optimization.html">第7章：</a><a href="optimization.html" title="Chapter 7. Optimization"><i>最佳化</i></a>。</p>
			<p><span>QUICK</span>修飾符會影響到在刪除操作中索引端結點是否合併。當用於被刪除的行的索引值被來自後插入的行的相近的索引值代替時，<span>DELETE 
			QUICK</span>最為適用。在此情況下，被刪除的值留下來的空穴被重新使用。</p>
			<p>未充滿的索引塊跨越某一個範圍的索引值，會再次發生新的插入。當被刪除的值導致出現未充滿的索引塊時，<span>DELETE 
			QUICK</span>沒有作用。在此情況下，使用<span>QUICK</span>會導致未利用的索引中出現廢棄空間。下面是此種情況的舉例說明：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>建立一個資料表，資料表中包含已編索引的<span>AUTO_INCREMENT</span>列。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在資料表中插入很多記錄。每次插入會產生一個索引值，此索引值被新增到索引的高端處。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>DELETE QUICK</span>從列的低端處刪除一組記錄。</p>
			<p>在此情況下，與被刪除的索引值相關的索引塊變成未充滿的狀態，但是，由於使用了<span>QUICK</span>，這些索引塊不會與其它索引塊合併。當插入新值時，這些索引塊仍為未充滿的狀態，原因是新記錄不含有在被刪除的範圍內的索引值。另外，即使您此後使用<span>DELETE</span>時不包含<span>QUICK</span>，這些索引塊也仍是未充滿的，除非被刪除的索引值中有一部分碰巧位於這些未充滿的塊的之中，或與這些塊相鄰。在這些情況下，如果要重新利用未使用的索引空間，需使用<span>OPTIMIZE 
			TABLE</span>。</p>
			<p>如果您打算從一個資料表中刪除許多行，使用<span>DELETE QUICK</span>再加上<span>OPTIMIZE 
			TABLE</span>可以加快速度。這樣做可以重新建立索引，而不是進行大量的索引塊合併操作。</p>
			<p>用於<span>DELETE</span>的<span>MySQL</span>唯一的<span>LIMIT<span>
			<i>row_count</i></span></span>選項用於告知伺服器在控制命令被返回到客戶端前被刪除的行的最大值。本選項用於確保一個<span>DELETE</span>語句不會佔用過多的時間。您可以只重複<span>DELETE</span>語句，直到相關行的數目少於<span>LIMIT</span>值為止。</p>
			<p>如果<span>DELETE</span>語句包括一個<span>ORDER BY</span>子句，則各行按照子句中指定的順序進行刪除。此子句只在與<span>LIMIT</span>聯用是才起作用。例如，以下子句用於搜尋與<span>WHERE</span>子句對應的行，使用<span>timestamp_column</span>進行分類，並刪除第一（最舊的）行：</p>
			<pre><span>DELETE FROM somelog</span></pre>
			<pre><span>WHERE user = &#39;jcole&#39;</span></pre>
			<pre><span>ORDER BY timestamp_column</span></pre>
			<pre><span>LIMIT 1;</span></pre>
			<p>您可以在一個<span>DELETE</span>語句中指定多個資料表，根據多個資料表中的特定條件，從一個資料表或多個資料表中刪除行。不過，您不能在一個多資料表<span>DELETE</span>語句中使用<span>ORDER 
			BY</span>或<span>LIMIT</span>。</p>
			<p><span><i><span>table_references</span></i></span>部分列出了包含在聯合中的資料表。此語法在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>中進行了說明。</p>
			<p>對於第一個語法，只刪除列於<span>FROM</span>子句之前的資料表中的對應的行。對於第二個語法，只刪除列於<span>FROM</span>子句之中（在<span>USING</span>子句之前）的資料表中的對應的行。作用是，您可以同時刪除許多個資料表中的行，並使用其它的資料表進行搜索：</p>
			<pre><span>DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>或：</p>
			<pre><span>DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>當搜索待刪除的行時，這些語句使用所有三個資料表，但是只從資料表<span>t1</span>和資料表<span>t2</span>中刪除對應的行。</p>
			<p>以上例子顯示了使用逗號操作符的內部聯合，但是多資料表<span>DELETE</span>語句可以使用<span>SELECT</span>語句中允許的所有類型的聯合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>本語法允許在名稱後面加<span>.*</span>，以便與<span>Access</span>相容。</p>
			<p>如果您使用的多資料表<span>DELETE</span>語句包括<span>InnoDB</span>資料表，並且這些資料表受外部鍵的限制，則<span>MySQL</span>最佳化程式會對資料表進行處理，改變原來的從屬關係。在這種情況下，該語句出現錯誤並返回到前面的步驟。要避免此錯誤，您應該從單一資料表中刪除，並依靠<span>InnoDB</span>提供的<span>ON 
			DELETE</span>功能，對其它資料表進行相應的修改。</p>
			<p>註釋：當引用資料表名稱時，您必須使用別名（如果已給定）：</p>
			<pre><span>DELETE t1 FROM test AS t1, test2 WHERE ...</span></pre>
			<p>進行多資料表刪除時支援跨資料庫刪除，但是在此情況下，您在引用資料表時不能使用別名。舉例說明：</p>
			<pre><span>DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...</span></pre>
			<p>目前，您不能從一個資料表中刪除，同時又在子查詢中從同一個資料表中選擇。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="do"></a>13.2.2. DO語法</h3></div></div></div><a class="indexterm" name="id2899415"></a><pre class="programlisting">DO <em class="replaceable">expr</em> [, <em class="replaceable">expr</em>] ...
</pre></div><div class="section"><div class="titlepage"><div><div>
			<span>DO</span>用於執行資料表達式，但是不返回任何結果。<span>DO</span>是<span>SELECT<span>
			<i>expr</i></span></span><span>的簡化資料表達方式</span>。<span>DO</span>有一個優勢，就是如果您不太關心結果的話，<span>DO</span>的速度稍快。<p>
			<span>DO</span>主要用於執行有副作用的函數，比如<span>RELEASE_LOCK()</span>。</p>
			<h3 class="title"><a name="handler"></a>13.2.3. HANDLER語法</h3></div></div></div><a class="indexterm" name="id2899497"></a><pre class="programlisting">HANDLER <em class="replaceable">tbl_name</em> OPEN [ AS <em class="replaceable">alias</em> ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { = | &gt;= | &lt;= | &lt; } (<em class="replaceable">value1</em>,<em class="replaceable">value2</em>,...)
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> CLOSE
</pre>
			<p><span>HANDLER</span>語句提供通往資料表儲存引擎接口的直接通道。<span>HANDLER</span>可以用於<span>MyISAM</span>和<span>InnoDB</span>資料表。</p>
			<p><span>HANDLER...OPEN</span>語句用於打開一個資料表，通過後續的<span>HANDLER...READ</span>語句建立讀取資料表的通道。本資料表目標不會被其它線程共享，也不會關閉，直到線程使用<span>HANDLER...CLOSE</span>或線程中止時為止。如果您使用一個別名打開資料表，則使用其它<span>HANDLER</span>語句進一步參閱資料表是必須使用此別名，而不能使用資料表名。</p>
			<p>如果被指定的索引滿足給定的值並且符合了<span>WHERE</span>條件，則第一個<span>HANDLER...READ</span>語法取出一行。如果您有一個多列索引，則指定索引列值為一個用逗號隔開的清單。既可以為索引中的所有列指定值，也可以為索引列的最左邊的前綴指定值。假設一個索引包括三個列，名稱為<span>col_a</span><span>,
			<span>col_b</span>,</span>和<span>col_c</span>，並按此順序排列。<span>HANDLER</span>語句可以為索引中的所有三個列指定值，或者為一個最左邊前綴中的各列指定值。舉例說明：</p>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val,col_c_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val) ...</span></pre>
			<p>第二個<span>HANDLER...READ</span>語法按索引的順序從資料表中取出一行。索引的順序符合<span>WHERE</span>條件。</p>
			<p>第三個<span>HANDLER...READ</span>語法按自然行的順序從資料表中取出一行。自然行的順序符合<span>WHERE</span>條件。當想要對整個資料表進行掃瞄時，此語句比<span>HANDLER
			<i>tbl_name</i> READ index_name</span>更快。自然行的順序指的是行儲存在<span>MyISAM</span>資料表數據檔案的順序。本語句也適用於<span>InnoDB</span>資料表，但是因為沒有獨立的數據檔案，所以沒有這類概念。</p>
			<p>不使用<span>LIMIT</span>子句時，所有形式的<span>HANDLER...READ</span>語句均只取出一行。 
			如果要返回多個行，應加入一個<span>LIMIT</span>子句。本語句於<span>SELECT</span>語句的語法一樣。請參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
			<p><span>HANDLER...CLOSE</span>用於關閉使用<span>HANDLER...OPEN</span>打開的資料表。</p>
			<p>註釋：要使用<span>HANDLER</span>接口來查閱一個資料表的<span>PRIMARY 
			KEY</span>，應使用帶引號的識別符<span>`PRIMARY`</span>：</p>
			<pre><span>HANDLER <span><i>tbl_name</i></span> READ `PRIMARY` &gt; (...);</span></pre>
			<p><span>HANDLER</span>是比較低級別的語句。例如，它不能提供一致性。也就是說，<span>HANDLER...OPEN</span>不能為資料表做快照，也不能鎖定資料表。這意味著，當一個<span>HANDLER...OPEN</span>語句被編寫後，資料表數據可以被更改（用此線程或用其它線程），並且這些更改只會部分地出現在<span>HANDLER...NEXT</span>或<span>HANDLER...PREV</span>掃瞄中。</p>
			<p>使用<span>HANDLER</span>接口代替常規的<span>SELECT</span>語句有多個原因：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>比<span>SELECT</span>更快：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一個指定的儲存引擎管理程式目標為了<span>HANDLER...OPEN</span>進行整序。該目標被重新用於該資料表的後續的<span>HANDLER</span>語句；不需要對每個語句進行重新初始化。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>涉及的分析較少。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>沒有最佳化程式或查詢校驗開銷。 </p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>在兩個管理程式請求之間，不需要鎖定資料表。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>管理程式接口不需要提供外觀一致的數據（例如，允許無條理的讀取），所以儲存引擎可以使用最佳化，而<span>SELECT</span>通常不允許使用最佳化。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些應用程式使用與<span>ISAM</span>近似的接口與<span>MySQL</span>連接。使用<span>HANDLER</span>可以更容易地與這些應用程式連接。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>允許您採用一種特殊的方式進出資料庫。而使用<span>SELECT</span>時難以採用（或不可能採用）這種方式。有些應用程式可以提供一個交互式的用戶接口與資料庫連接。當與這些應用程式同時使用時，用<span>HANDLER</span>接口觀看數據更加自然。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert"></a>13.2.4. INSERT語法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#insert-select">13.2.4.1. 
			INSERT ... SELECT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-delayed">13.2.4.2. 
			INSERT DELAYED語法</a></span></dt></dl></div><a class="indexterm" name="id2899968"></a><a class="indexterm" name="id2899975"></a>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p><span>INSERT</span>用於向一個已有的資料表中插入新行。<span>INSERT...VALUES</span>和<span>INSERT...SET</span>形式的語句根據明確指定的值插入行。<span>INSERT...SELECT</span>形式的語句插入從其它資料表中選出的行。在<a href="sql-syntax.html#insert-select" title="13.2.4.1. INSERT ... SELECT Syntax">13.2.4.1節，「INSERT 
		... SELECT語法」</a>中對<span>INSERT...SELECT</span>進行了進一步的討論。</p>
			<p>行應被插入到<span><i><span>tbl_name</span></i>資料表中。可以按以下方法指定列。本語句向這些列提供值。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>列名稱清單或<span>SET</span>子句明確的指示了列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您不為<span>INSERT...VALUES</span>或<span>INSERT...SELECT</span>指定列的清單，則資料表中每列的值必須在<span>VALUES</span>清單中提供，或由<span>SELECT</span>提供。如果您不知道資料表中各列的順序，則使用<span>DESCRIBE
			<i>tbl_name</i></span>查詢。</p>
			<p>列值可以採用多種方法給定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931016"></a>

            如果不是在嚴格模式下運行，則所有沒有明確給定值的列都被設置為預設值（明確的或隱含的）。例如，如果您指定了一個列清單，但此清單沒有對資料表中所有的列進行命名，則未命名的各列被設置為預設值。預設值的賦值在<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>中進行了說明。也可參見<a href="introduction.html#constraint-invalid-data" title="1.8.6.2. Constraints on Invalid Data">1.8.6.2節，「對無效數據的約束」</a>。</p>
			<p>
			有時候，您需要對所有沒有預設值的列明確地指定值。如果您希望，在沒有明確指定值時，<span>INSERT</span>語句可以生成錯誤訊息，則您應該使用<span>STRICT</span>模式。請參見<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2節，「SQL伺服器模式」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用關鍵詞<span>DEFAULT</span>，明確地把列設置為預設值。這樣，編寫向所有列賦值的<span>INSERT</span>語句時可以更容易，因為使用<span>DEFAULT</span>可以避免編寫出不完整的、未包含全部列值的<span>VALUES</span>清單。如果不使用<span>DEFUALT</span>，您必須編寫一個列名稱清單，與<span>VALUES</span>清單中的每個值對應。</p>
			<p>您還可以使用<span>DEFAULT(<i>col_name</i>)</span>作為一種更通用的形式，在資料表達式中使用，用於生成一個列的預設值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列清單和<span>VALUES</span>清單均為空清單，則<span>INSERT</span>會建立一個行，每個列都被設置為預設值：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> () VALUES();</b></span></span></pre>
			<p>在<span>STRICT</span>模式中，如果有一列沒有預設值，則會出現錯誤。或者，<span>MySQL</span>會對所有沒有明確定義預設值的列使用隱含的預設值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以指定一個資料表達式<span><i><span>expr</span></i></span>來提供一個列值。如果資料表達式的類型與列值不匹配，這樣做會造成類型轉化。並且，給定值的轉化會導致不同的插入值，插入何值由列類型而定。例如，向一個<span>INT, 
			FLOAT, DECIMAL(10,6)</span>或<span>YEAR</span>列插入字串<span><span>&#39;1999.0e-2&#39;</span>，插入值分別是<span>1999</span>，<span>19.9921</span>，<span>19.992100</span>和<span>1999</span>。儲存在<span>INT</span>和<span>YEAR</span>列中的值為<span>1999</span>的原因是，在從字串到整數的轉化中，只把字串的前面部分看作有效的整數或年份。對於浮點列和固定點列，在從字串到浮點的轉化中，把整個字串均看作有效的浮點值。</span></p>
			<p>資料表達式<span><i><span>expr</span></i></span>可以引用在值清單中已設置的所有列。例如，您可以這麼操作，因為用於<span>col2</span>的值引用了<span>col1</span>，而<span>col1</span>已經被賦值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(15,<i>col1</i>*2);</b></span></span></pre>
			<p>但是以下語句不合法，因為用於<span>col1</span>的值引用了<span>col2</span>，而<span>col2</span>在<span>col1</span>之後被賦值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(<i>col2</i>*2,15);</b></span></span></pre>
			<p>有一種例外情況，那就是含有<span>AUTO_INCREMENT</span>值的列。因為<span>AUTO_INCREMENT</span>值在其它值賦值之後被生成，所以任何在賦值時對<span>AUTO_INCREMENT</span>列的引用都會返回<span>0</span>。</p>
			<p><span>INSERT</span>語句支援下列修改符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>DELAYED</span>關鍵字，則伺服器會把待插入的行放到一個緩衝器中，而發送<span>INSERT 
			DELAYED</span>語句的客戶端會繼續運行。如果資料表正在被使用，則伺服器會保留這些行。當資料表空閒時，伺服器開始插入行，並定期檢查是否有新的讀取請求。如果有新的讀取請求，則被延遲的行被延緩執行，直到資料表再次空閒時為止。請參見<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2節，「INSERT 
			DELAYED語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>關鍵詞，則<span>INSERT</span>的執行被延遲，直到沒有其它客戶端從資料表中讀取為止。當原有客戶端正在讀取時，有些客戶端剛開始讀取。這些客戶端也被包括在內。此時，<span>INSERT 
			LOW_PRIORITY</span>語句等候。因此，在讀取量很大的情況下，發出<span>INSERT 
			LOW_PRIORITY</span>語句的客戶端有可能需要等待很長一段時間（甚至是永遠等待下去）。（這與<span>INSERT 
			DELAYED</span>形成對比，<span>INSERT DELAYED</span>立刻讓客戶端繼續執行。請參見<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2節，「INSERT 
			DELAYED語法」</a>。）注意<span>LOW_PRIORITY</span>通常不應用於<span>MyISAM</span>資料表，因為這麼做會取消同時進行的插入。請參見<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1節，「MyISAM儲存引擎」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了<span>HIGH_PRIORITY</span>，同時伺服器採用<span>--low-priority-updates</span>選項啟動，則<span>HIGH_PRIORITY</span>將覆蓋<span><span>--low-priority-updates</span>選項。這麼做還會導致同時進行的插入被取消。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_affected_rows()</span><span> 
			C API</span>函數，可以獲得用於<span>INSERT</span>的受影響行的值。請參見<a href="apis.html#mysql-affected-rows" title="25.2.3.1. mysql_affected_rows()">25.2.3.1節，「mysql_affected_rows()」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您在一個<span>INSERT</span>語句中使用<span>IGNORE</span>關鍵詞，在執行語句時出現的錯誤被當作警告處理。例如，沒有使用<span>IGNORE</span>時，如果一個行複製了原有的<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>值，會導致出現重複關鍵字錯誤，語句執行失敗。使用<span>IGNORE</span>時，該行仍然未被插入，但是不會出現錯誤。<span>IGNORE</span>未被指定時，如果數據轉化引發錯誤，則會使語句執行失敗。使用<span>IGNORE</span>後，無效數據被調整到最接近的值，並被插入；此時，生成警告，但是語句執行不會失敗。您可以使用<span>mysql_info()</span><span> 
			C API</span>函數測定有多少行被插入到資料表中。</p>
			<p>如果您指定了<span>ON DUPLICATE KEY UPDATE</span>，並且插入行後會導致在一個<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>中出現重複值，則執行舊行<span>UPDATE</span>。例如，如果列<span>a</span>被定義為<span>UNIQUE</span>，並且包含值<span>1</span>，則以下兩個語句具有相同的效果：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=c+1;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1;</b></span></span></pre>
			<p>如果行作為新記錄被插入，則受影響行的值為<span>1</span>；如果原有的記錄被更新，則受影響行的值為<span>2</span>。</p>
			<p>註釋：如果列<span>b</span>也是唯一列，則<span>INSERT</span>與此<span>UPDATE</span>語句相當：</p>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</b></span></span></pre>
			<p>如果<span><span>a=1 OR b=2</span>與多個行向匹配，則只有一個行被更新。通常，您應該盡量避免對帶有多個唯一關鍵字的資料表使用<span>ON 
			DUPLICATE KEY</span>子句。</span></p>
			<p>您可以在<span>UPDATE</span>子句中使用<span>VALUES(col_name)</span>函數從<span>INSERT...UPDATE</span>語句的<span>INSERT</span>部分引用列值。換句話說，如果沒有發生重複關鍵字衝突，則<span>UPDATE</span>子句中的<span><span>VALUES(<i>col_name</i>)</span>可以引用被插入的<i><span>col_name</span></i>的值。本函數特別適用於多行插入。<span>VALUES()</span>函數只在<span>INSERT...UPDATE</span>語句中有意義，其它時候會返回<span>NULL</span>。</span></p>
			<p>示範：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);</b></span></span></pre>
			<p>本語句與以下兩個語句作用相同：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=3;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=9;</b></span></span></pre>
			<p>當您使用<span>ON DUPLICATE KEY UPDATE</span>時，<span>DELAYED</span>選項被忽略。</p>
			<p>您可以使用<span>SQL LAST_INSERT_ID()</span>函數搜尋用於<span>AUTO_INCREMENT</span>列的值。從<span>C 
			API</span>的內部，使用<span>mysql_insert_id()</span>函數。不過，您應該注意，兩個函數的作用並不總是相同的。在<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3節，「訊息函數」</a>和<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36節，「mysql_insert_id()」</a>中進一步討論了與<span>AUTO_INCREMENT</span>列有關的<span>INSERT</span>語句的作用。</p>
			<p>如果您使用<span>INSERT...VALUES</span>語句時採用了多個值清單或<span>INSERT...SELECT</span>，則該語句按以下格式返回一個訊息字串：</p>
			<pre><span>Records: 100 Duplicates: 0 Warnings: 0</span></pre>
			<p>
			記錄指示了經過語句處理的行的數目。（因為重複數目可以不是零，所以該數目不一定是實際被插入的行的數目。）重複數目指的是不能被插入的行的數目，因為這些行會複製部分原有的唯一索引值。警告指的是插入有錯誤或有問題的列值的次數。在以下情況下會出現警告：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一個已定義為<span>NOT NULL</span>的列中插入<span>NULL</span>。對於一個多行<span>INSERT</span>語句或<span>INSERT 
			INTO...SELECT</span>語句，根據列數據的類型，列被設置為隱含的預設值。對於數字類型，預設值為<span>0</span>；對於字串類型，預設值為空字串<span>(<span>&#39;&#39;</span>)</span>；對於日期和時間類型，預設值為「<span>zero</span>」值。對<span>INSERT 
			INTO...SELECT</span>語句的處理方法與對多行插入的處理方法一樣，因為伺服器不能檢測來自<span>SELECT</span>的結果，不能判斷是否返回單一行。（對於單一行<span>INSERT</span>，當<span>NULL</span>被插入一個<span>NOT 
			NULL</span>列時，不會出現警告，而是出現錯誤，並且語句運行失敗。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>數字列的值被設置在列的值範圍之外。此值被修改為未最接近的值範圍端點。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一個數字列賦予一個例如<span>&#39;10.34 
			a&#39;</span>的值。尾部的非數字文本被刪節，其餘的數字部分被插入，如果字串值沒有前導的數字部分，則該列被設置為<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一個字串列（<span>CHAR, VARCHAR, TEXT</span>或<span>BLOB</span>）中插入的字串超過了列的最大長度。此值被刪節到列的最大長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向日期或時間列中插入的值對於該列的類型是不合法的。根據列的類型，該列被設置到相應的零值。</p>
			<p>如果您正在使用<span>C API</span>，則可以通過使用<span>mysql_info()</span>函數獲取訊息字串。請參見<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34節，「mysql_info()」</a>。</p>
			<a class="indexterm" name="id2900883"></a><a class="indexterm" name="id2900892"></a><a class="indexterm" name="id2901132"></a><a class="indexterm" name="id2901141"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-select"></a>13.2.4.1. INSERT 
				... SELECT語法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
				<p>使用<span>INSERT...SELECT</span>，您可以快速地從一個或多個資料表中向一個資料表中插入多個行。</p>
				<p>示範：</p>
				<pre><span>INSERT INTO tbl_temp2 (fld_id)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT tbl_temp1.fld_order_id</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;</span></pre>
				<p>使用<span>INSERT...SELECT</span>語句時會出現以下情況：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>明確地指定<span>IGNORE</span>，用於忽略會導致重複關鍵字錯誤的記錄。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>不要同時使用<span>DELAYED</span>和<span>INSERT...SELECT</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT</span>語句的目標資料表會顯示在查詢的<span>SELECT</span>部分的<span>FROM</span>子句中。（在有些舊版本的<span>MySQL</span>中不會出現這種情況。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>AUTO_INCREMENT</span>列照常運行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>為了確保二進制日誌可以被用於再次建立原資料表，<span>MySQL</span>不允許在<span>INSERT...SELECT</span>運行期間同時進行插入操作。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>目前，您不能在向一個資料表插入的同時，又在一個子查詢中從同一個資料表中選擇。</p>
				<p>在<span>ON DUPLICATE KEY UPDATE</span>的值部分中，只要您不使用<span>SELECT</span>部分中的<span>GROUP 
				BY</span>，您就可以引用在其它資料表中的列。有一個副作用是，您必須使值部分中的非唯一列的名稱符合要求。</p>
				<p>您可以使用<span>REPLACE</span>替代<span>INSERT</span>，來覆蓋舊行。對於包含唯一關鍵字值，並複製了舊行的新行，在進行處理時，<span>REPLACE</span>可以作為<span>INSERT 
				IGNORE</span>的同類子句：新行被用於替換舊行，而不是被丟棄。</p>
				<h4 class="title"><a name="insert-delayed"></a>13.2.4.2. INSERT 
				DELAYED語法</h4></div></div></div><a class="indexterm" name="id2901376"></a><a class="indexterm" name="id2901385"></a><a class="indexterm" name="id2901394"></a>
				<pre><span>INSERT DELAYED ...</span></pre>
				<p>用於<span>INSERT</span>語句的<span>DELAYED</span>選項是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。如果您的客戶端不能等待<span>INSERT</span>完成，則這個選項是非常有用的。當您使用<span>MySQL</span>進行日誌編寫時，這是非常常見的問題。您也可以定期運行<span>SELECT</span>和<span>UPDATE</span>語句，這些語句花費的時間較長。</p>
				<p>當一個客戶端使用<span>INSERT DELAYED</span>時，會立刻從伺服器處得到一個確定。並且行被排入隊列，當資料表沒有被其它線程使用時，此行被插入。</p>
				<p>使用<span>INSERT DELAYED</span>的另一個重要的好處是，來自許多客戶端的插入被集中在一起，並被編寫入一個塊。這比執行許多獨立的插入要快很多。</p>
				<p>使用<span>DELAYED</span>時有一些限制：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>僅適用於<span>MyISAM, 
				MEMORY</span>和<span>ARCHIVE</span>資料表。對於<span>MyISAM</span>資料表，如果在數據檔案的中間沒有空閒的塊，則支援同時採用<span>SELECT</span>和<span>INSERT</span>語句。在這些情況下，基本不需要對<span>MyISAM</span>使用<span>INSERT 
				DELAYED</span>。請參見<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1節，「MyISAM儲存引擎」</a><span>,
				</span>
              <a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">
				15.4節，「MEMORY (HEAP)儲存引擎」</a>和<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8節，「ARCHIVE儲存引擎」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>應該僅用於指定值清單的<span>INSERT</span>語句。伺服器忽略用於<span>INSERT 
				DELAYED...SELECT</span>語句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>伺服器忽略用於<span>INSERT DELAYED...ON 
				DUPLICATE UPDATE</span>語句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因為在行被插入前，語句立刻返回，所以您不能使用<span>LAST_INSERT_ID()</span>來獲取<span>AUTO_INCREMENT</span>值。<span>AUTO_INCREMENT</span>值可能由語句生成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>SELECT</span>語句，<span>DELAYED</span>行不可見，直到這些行確實被插入了為止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>DELAYED</span>在從屬複製伺服器中被忽略了，因為<span>DELAYED</span>不會在從屬伺服器中產生與主伺服器不一樣的數據。</p>
				<p>注意，目前在隊列中的各行只保存在儲存器中，直到它們被插入到資料表中為止。這意味著，如果您強行中止了<strong><span>mysqld</span></strong>（例如，使用<span>kill 
				-9</span>）或者如果<strong><span>mysqld</span></strong>意外停止，則所有沒有被寫入磁盤的行都會丟失。</p>
				<p>以下詳細描述了當您對<span>INSERT</span>或<span>REPLACE</span>使用<span>DELAYED</span>選項時會發生什麼情況。在這些描述中，「線程」指的是已接受了一個<span>INSERT 
				DELAYED</span>語句的線程，「管理程式」指的是為某個特定的資料表處理所有<span>INSERT 
				DELAYED</span>語句的線程。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>當一個線程對一個資料表執行<span>DELAYED</span>語句時，會建立出一個管理程式線程（如果原來不存在），對用於本資料表的所有<span>DELAYED</span>語句進行處理。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>線程會檢查是否管理程式以前已獲取了<span>DELAYED</span>鎖定；如果沒有獲取，則告知管理程式線程進行此項操作。即使其它線程對資料表有<span>READ</span>或<span>WRITE</span>鎖定，也可以獲得<span>DELAYED</span>鎖定。但是管理程式會等待所有的<span>ALTER 
				TABLE</span>鎖定或<span>FLUSH TABLE</span>鎖定，以確保資料表的結構是最新的。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>線程執行<span>INSERT</span>語句，但不是把行寫入資料表中，而是把最終行的拷貝放入一個由管理程式線程管理的隊列中。線程會提示出現語法錯誤，這些錯誤會被報告到客戶端中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因為在插入操作之前，<span>INSERT</span>返回已經完成，所以客戶端不能從伺服器處獲取重複記錄的數目，也不能獲取生成的行的<span>AUTO_INCREMENT</span>值。（如果您使用<span>C 
				API</span>，則出於同樣的原因，<span><span>mysql_info()</span>函數</span>不會返回任何有意義的東西。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				當行被插入資料表中時，二進制日誌被管理程式線程更新。在多行插入情況下，當第一行被插入時，二進制日誌被更新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>每次<span>delayed_insert_limit</span>行被編寫時，管理程式會檢查是否有<span>SELECT</span>語句仍然未執行。如果有，則會在繼續運行前，讓這些語句先執行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>當管理程式的隊列中沒有多餘的行時，資料表被解鎖。如果在<span>delayed_insert_timeout</span>時間內，沒有接收到新的<span>INSERT 
				DELAYED</span>語句，則管理程式中止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果在某個特定的管理程式隊列中，有超過<span><span>delayed_queue_size</span>的行未被執行，則申請<span>INSERT 
				DELAYED</span>的線程會等待，直到隊列中出現空間為止。這麼做可以確保</span><strong><span>mysqld</span></strong><span>不會把所有的儲存器都用於被延遲的儲存隊列。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>管理程式線程會顯示在<span>MySQL</span>程序清單中，其命令列中包含<span>delayed_insert</span>。如果您執行一個<span>FLUSH 
				TABLES</span>語句或使用<span>KILL thread_id</span>進行刪除，則會刪除此線程。不過，在退出前，線程會首先把所有排入隊列的行儲存到資料表中。在這期間，該線程不會從其它線程處接受任何新的<span>INSERT</span>語句。如果您在此之後執行一個<span>INSERT 
				DELAYED</span>語句，則會建立出一個新的管理程式線程。</p>
				<p>注意，如果有一個<span>INSERT 
				DELAYED</span>管理程式正在運行，則這意味著<span>INSERT DELAYED</span>語句比常規的<span>INSERT</span>語句具有更高的優先權。其它更新語句必須等待，直到<span>INSERT 
				DELAYED</span>語句隊列都運行完畢，或者管理程式線程被中止（使用<span>KILL 
				thread_id</span>），或者執行了一個<span>FLUSH TABLES</span>時為止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以下狀態變數提供了有關<span>INSERT DELAYED</span>語句的訊息：</p>
				<table border="1" cellpadding="0" id="table6">
					<tr>
						<td>
						<p><strong>
						<span>狀態變數</span></strong></td>
						<td>
						<p><strong>
						<span>意義</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_insert_threads</span></td>
						<td>
						<p>管理程式線程的數目</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_writes</span></td>
						<td>
						<p><span>使用<span>INSERT 
						DELAYED</span>寫入的行的數目</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Not_flushed_delayed_rows</span></td>
						<td>
						<p>等待被寫入的行的數目</td>
					</tr>
				</table>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>您可以通過發送一個<span>SHOW STATUS</span>語句，或者執行一個<strong><span>mysqladmin 
				extended-status</span></strong>命令，來閱覽這些變數。</p>
				<p>注意，當沒有使用資料表時，<span>INSERT DELAYED</span>比常規的<span>INSERT</span>要慢。對於伺服器來說，為每個含有延遲行的資料表操縱一個獨立的線程，也是一個額外的系統開銷。這意味著只有當您確認您需要時，才應使用<span>INSERT 
				DELAYED</span>。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-data"></a>13.2.5. LOAD 
			DATA INFILE語法</h3></div></div></div><a class="indexterm" name="id2902077"></a>
			<pre><span>LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#39;<span><i>file_name</i></span>.txt&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [REPLACE | IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; INTO TABLE <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FIELDS</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[OPTIONALLY] ENCLOSED BY &#39;<span><i>char</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ESCAPED BY &#39;<span><i>char</i></span>&#39; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LINES</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STARTING BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE <span><i>number</i></span> LINES]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>col_name_or_user_var</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [SET <span><i>col_name</i></span> = <span><i>expr</i></span>,...)]</span></pre>
			<p><span>LOAD DATA INFILE</span>語句用於高速地從一個文本檔案中讀取行，並裝入一個資料表中。檔案名稱必須為一個文字字串。</p>
			<p>要瞭解有關<span>INSERT</span>和<span>LOAD DATA 
			INFILE</span>的效率的對比和有關<span>LOAD DATA INFILE</span>加速的更多訊息，請參見<a href="optimization.html#insert-speed" title="7.2.16. Speed of INSERT Statements">7.2.16節，「INSERT語句的速度」</a>。</p>
			<p>由<span>character_set_database</span>系統變數指示的字元編碼被用於解釋檔案中的訊息。<span>SET 
			NAMES</span>和<span>character_set_client</span>的設置不會影響對輸入的解釋。</p>
			<p>注意，目前不能載入<span>UCS2</span>數據檔案。</p>
			<p>您也可以通過使用<strong><span>mysqlimport</span></strong>應用程式載入數據檔案；通過向伺服器發送一個<span>LOAD 
			DATA INFILE</span>語句實現此功能。<span>--local</span>選項用於使<strong><span>mysqlimport</span></strong>從客戶主機中讀取數據檔案。如果客戶端和伺服器支援壓縮協議，則您可以指定—<span>compress</span>選項提高在慢速網絡中的性能。請參見<a href="client-side-scripts.html#mysqlimport" title="8.10. mysqlimport — A Data Import Program">8.10節，「mysqlimport：數據導入程式</a>。</p>
			<p>如果您使用<span>LOW_PRIORITY</span>，則<span>LOAD 
			DATA</span>語句的執行被延遲，直到沒有其它的客戶端從資料表中讀取為止。</p>
			<p>如果一個<span>MyISAM</span>資料表滿足同時插入的條件（即該資料表在中間有空閒塊），並且您對這個<span>MyISAM</span>資料表指定了<span>CONCURRENT</span>，則當<span>LOAD 
			DATA</span>正在執行時，其它線程會從資料表中重新獲取數據。即使沒有其它線程在同時使用本資料表格，使用本選項也會略微影響<span>LOAD 
			DATA</span>的性能。</p>
			<p>如果指定了<span>LOCAL</span>，則被認為與連接的客戶端有關：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果指定了<span>LOCAL</span>，則檔案會被客戶主機上的客戶端讀取，並被發送到伺服器。檔案會被給予一個完整的路徑名稱，以指定確切的位置。如果給定的是一個相對的路徑名稱，則此名稱會被理解為相對於啟動客戶端時所在的目錄。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LOCAL</span>沒有被指定，則檔案必須位於伺服器主機上，並且被伺服器直接讀取。</p>
			<p>當在伺服器主機上為檔案定位時，伺服器使用以下規則：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果給定了一個絕對的路徑名稱，則伺服器使用此路徑名稱。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果給定了帶有一個或多個引導組件的相對路徑名稱，則伺服器會搜索相對於伺服器數據目錄的檔案。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果給定了一個不帶引導組件的檔案名稱，則伺服器會在預設資料庫的資料庫目錄中尋找檔案。</p>
			<p>注意，這些規則意味著名為<span>./myfile.txt</span>的檔案會從伺服器數據目錄中被讀取，而名為<span>myfile.txt</span>的同樣的檔案會從預設資料庫的資料庫目錄中讀取。例如，下面的<span>LOAD 
			DATA</span>語句會從<span>db1</span>資料庫目錄中讀取檔案<span>data.txt</span>，因為<span>db1</span>是當前資料庫。即使語句明確把檔案載入到<span>db2</span>資料庫中的資料表裡，也會從<span>db1</span>目錄中讀取。</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE db2.my_table;</b></span></span></pre>
			<p>注意，使用正斜槓指定<span>Windows</span>路徑名稱，而不是使用反斜槓。如果您使用反斜槓，您必須使用兩個。</p>
			<p>出於安全原因，當讀取位於伺服器中的文本檔案時，檔案必須位於資料庫目錄中，或者是全體可讀的。另外，要對伺服器檔案使用<span>LOAD 
			DATA INFILE</span>，您必須擁有<span>FILE</span>權限。</p>
			<p>見<a href="database-administration.html#privileges-provided" title="5.7.3. Privileges Provided by MySQL">5.7.3節，「MySQL提供的權限」</a>。</p>
			<p>與讓伺服器直接讀取檔案相比，使用<span>LOCAL</span>速度略慢，這是因為檔案的內容必須通過客戶端發送到伺服器上。不過，您不需要<span>FILE</span>權限來載入本地檔案。</p>
			<p>只有當您的伺服器和您的客戶端都授權時，<span>LOCAL</span>才可運行。例如，如果使用—<span>local-infile=0</span>啟動<strong><span>mysqld</span></strong>，則<span>LOCAL</span>不運行。請參見<a href="database-administration.html#load-data-local" title="5.6.4. Security Issues with LOAD DATA LOCAL">5.6.4節，「LOAD DATA LOCAL安全問題<code class="literal"></code>」</a>。</p>
			<p>如果您需要<span>LOAD DATA</span>來從一個管道中讀取，您可以使用以下方法（此處我們把<span>/</span>目錄清單載入一個資料表格）：</p>
			<pre><span>mkfifo /mysql/db/x/x</span></pre>
			<pre><span>chmod 666 /mysql/db/x/x</span></pre>
			<pre><span>find / -ls &gt; /mysql/db/x/x</span></pre>
			<pre><span>mysql -e &quot;LOAD DATA INFILE &#39;x&#39; INTO TABLE x&quot; x</span></pre>
			<p>有些輸入記錄把原有的記錄複製到唯一關鍵字值上。<span>REPLACE</span>和<span>IGNORE</span>關鍵字用於控制這些輸入記錄的操作。</p>
			<p>如果您指定了<span>REPLACE</span>，則輸入行會替換原有行（換句話說，與原有行一樣，對一個主索引或唯一索引具有相同值的行）。請參見<a href="sql-syntax.html#replace" title="13.2.6. REPLACE Syntax">13.2.6節，「REPLACE語法」</a>。</p>
			<p>如果您指定<span>IGNORE</span>，則把原有行複製到唯一關鍵字值的輸入行被跳過。如果您這兩個選項都不指定，則運行情況根據<span>LOCAL</span>關鍵詞是否被指定而定。不使用<span>LOCAL</span>時，當出現重複關鍵字值時，會發生錯誤，並且剩下的文本檔案被忽略。使用<span>LOCAL</span>時，預設的運行情況和<span>IGNORE</span>被指定時的情況相同；這是因為在運行中間，伺服器沒有辦法中止檔案的傳輸。</p>
			<p>如果您希望在載入運行過程中忽略外部鍵的限制，您可以在執行<span>LOAD DATA</span>前發送一個<span>SET 
			FOREIGN_KEY_CHECKS=0</span>語句。</p>
			<p>如果您對一個空的<span>MyISAM</span>資料表使用<span>LOAD DATA 
			INFILE</span>，則所有的非唯一索引會被建立在一個獨立批中（對於<span>REPAIR TABLE</span>）。當您有許多索引時，這通常會使<span>LOAD 
			DATA INFILE</span>大大加快。通常，<span>LOAD DATA INFILE</span>的速度會非常快，但是在某些極端情況下，您可以在把檔案載入到資料表中之前使用<span>ALTER 
			TABLE...DISABLE KEYS</span>關閉<span>LOAD DATA INFILE</span>，或者在載入檔案之後使用<span>ALTER 
			TABLE...ENABLE KEYS</span>再次建立索引，使建立索引的速度更快。請參見<a href="optimization.html#insert-speed" title="7.2.16. Speed of INSERT Statements">7.2.16節，「INSERT語句的速度」</a>。</p>
			<p><span>LOAD DATA INFILE</span>是<span>SELECT...INTO 
			OUTFILE</span>的補語。（見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。）要從一個資料表中把數據寫入一個檔案中，應使用<span>SELECT...INTO 
			OUTFILE</span>。要讀取檔案，放回到資料表中，應使用<span>LOAD DATA INFILE</span>。<span>FIELDS</span>和<span>LINES</span>子句的語法對於兩個語句是一樣的。兩個子句都是自選的，但是如果兩個都被指定了，<span>FIELDS</span>必須位於<span>LINES</span>的前面。</p>
			<p>如果您指定了一個<span>FIELDS</span>子句，則每個亞子句（<span>TERMINATED 
			BY, [OPTIONALLY] ENCLOSED BY</span>和<span>ESCAPED BY</span>）也是自選的。不過，您必須指定其中至少一個。</p>
			<p>如果您不指定<span>FIELDS</span>子句，則預設值為假設您寫下如下語句時的值：</p>
			<pre><span>FIELDS TERMINATED BY &#39;\t&#39; ENCLOSED BY &#39;&#39; ESCAPED BY &#39;\\&#39;</span></pre>
			<p>如果您不指定<span>LINES</span>子句，則預設值為假設您寫下如下語句時的值：</p>
			<pre><span>LINES TERMINATED BY &#39;\n&#39; STARTING BY &#39;&#39;</span></pre>
			<p>換句話說，當讀取輸入值時，預設值會使<span>LOAD DATA INFILE</span>按如下方式運行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在新行處尋找行的邊界。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不會跳過任何行前綴。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在製表符處把行分解為字段。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不希望字段被包含在任何引號字元之中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>出現製表符、新行、或在『<span>\</span>』前有『<span>\</span>』時，理解為作為字段值一部分的文字字元。</p>
			<p>相反的，當編寫輸出值時，預設值會使<span>SELECT...INTO OUTFILE</span>按如下方式運行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在字段之間寫入製表符。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不把字段包含在任何引號字元中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當字段值中出現製表符、新行或『<span>\</span>』時，使用『<span>\</span>』進行轉義。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在行的末端寫入新行。</p>
			<p>注意，要寫入<span>FIELDS ESCAPED BY </span>『<span>\\</span>』，您必須為待讀取的值指定兩個反斜槓，作為一個單反斜槓使用。</p>
			<p>註釋：如果您已經在<span>Windows</span>系統中生成了文本檔案，您可能必須使用<span>LINES 
			TERMINATED BY </span>『<span>\r\n</span>』來正確地讀取檔案，因為<span>Windows</span>程式通常使用兩個字元作為一個行終止符。部分程式，比如<strong><span>WordPad</span></strong>，當編寫檔案時，可能會使用<span>\r</span>作為行終止符。要讀取這樣的檔案，應使用<span>LINES 
			TERMINATED BY </span>『<span>\r</span>』。</p>
			<p>如果所有您希望讀入的行都含有一個您希望忽略的共用前綴，則您可以使用<span>&#39;<i>prefix_string</i>&#39;</span>來跳過前綴（和前綴前的字元）。如果某行不包括前綴，則整個行被跳過。註釋：<span><i><span>prefix_string</span></i></span>會出現在一行的中間。</p>
			<p>示範： </p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test LINES STARTING BY &quot;xxx&quot;;</b></span></span></pre>
			<p>使用此語句，您可以讀入包含有如下內容的檔案：</p>
			<pre><span>xxx&quot;row&quot;,1</span></pre>
			<pre><span>something xxx&quot;row&quot;,2</span></pre>
			<p>並只得到數據<span>(&quot;row&quot;,1)</span>和<span>(&quot;row&quot;,2)</span>。</p>
			<p><span>IGNORE <i>number</i> 
			LINES</span>選項可以被用於在檔案的開始處忽略行。例如，您可以使用<span>IGNORE 
			1 LINES</span>來跳過一個包含列名稱的起始標題行：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test IGNORE 1 LINES;</b></span></span></pre>
			<p>當您聯合使用<span>SELECT...INTO OUTFILE</span>和<span>LOAD 
			DATA INFILE</span>來從一個資料庫中把數據寫入一個檔案中，然後再讀取檔案，返回到資料庫中時，用於兩個語句的<span>field-</span>和<span>line-handling</span>選項必須匹配。否則，<span>LOAD 
			DATA INFILE</span>不會正確地理解檔案的內容。假設您使用<span>SELECT...INTO 
			OUTFILE</span>來編寫一個的檔案，字段由逗號分隔：</p>
			<pre><span>mysql&gt; <span><b>SELECT * INTO OUTFILE &#39;data.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FROM table2;</b></span></span></pre>
			<p>要讀取由逗號分隔的檔案並返回，則正確的語句應該是：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;;</b></span></span></pre>
			<p>如果您嘗試使用以下所示的語句讀入檔案，則不會運行，因為該語句命令<span>LOAD DATA INFILE</span>尋找位於字段之間的製表符：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;\t&#39;;</b></span></span></pre>
			<p>結果很可能是，每個輸入行被理解為一個單一字段。</p>
			<p><span>LOAD DATA INFILE</span>也可以被用於讀取從外源中獲取的檔案。例如，一個<span>dBASE</span>格式的檔案具有以逗號分隔並且包含在雙引號中的字段。如果檔案中的各行以新行為結尾，則此處所示的語句描述了您可以用於載入檔案的<span>field-</span>和<span>line-handling</span>選項：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE <i>tbl_name</i></b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;&quot;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n&#39;;</b></span></span></pre>
			<p>所有<span>field-</span>或<span>line-handling</span>選項都可以指定一個空字串<span>(<span>&#39;&#39;</span>)</span>。如果字串不是空的，則<span>FIELDS 
			[OPTIONALLY] ENCLOSED BY</span>和<span>FIELDS ESCAPED BY</span>值必須為單一字元。<span>FIELDS 
			TERMINATED BY, LINES STARTING BY</span>和<span>LINES 
			TERMINATED BY</span>值可以超過一個字元。例如，要編寫由回車<span>/</span>換行成對字元作為結尾的行，或讀取包含這類行的檔案，則應指定一個<span>LINES 
			TERMINATED BY </span>『<span>\r\n</span>』子句。</p>
			<p>如果<span>jokes</span>被由<span>%%</span>組成的行分隔，<span>要讀取包含<span>jokes</span>的檔案，您可以這麼操作：</span></p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>(a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>joke TEXT NOT NULL);</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/jokes.txt&#39; INTO TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n%%\n&#39; (joke);</b></span></span></pre>
			<p><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>用於控制字段的引號。對於（<span>SELECT...INTO 
			OUTFILE</span>），如果您忽略了詞語<span>OPTIONALLY</span>，則所有的字段都被包含在<span>ENCLOSED 
			BY</span>字串中。此處展示了此類輸出的一個示範（使用逗號作為字段分隔符）：</p>
			<pre><span>&quot;1&quot;,&quot;a string&quot;,&quot;100.20&quot;</span></pre>
			<pre><span>&quot;2&quot;,&quot;a string containing a , comma&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;3&quot;,&quot;a string containing a \&quot; quote&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;4&quot;,&quot;a string containing a \&quot;, quote and comma&quot;,&quot;102.20&quot;</span></pre>
			<p>如果您指定了<span>OPTINALLY</span>，則<span>ENCLOSED 
			BY</span>字元只被用於包含具有字串數據類型（比如<span>CHAR, BINARY, TEXT</span>或<span>ENUM</span>）的列中的值：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a \&quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a \&quot;, quote and comma&quot;,102.20</span></pre>
			<p>注意，如果在字段值內出現<span>ENCLOSED BY</span>字元，則通過使用<span>ESCAPED 
			BY</span>字元作為前綴，對<span>ENCLOSED BY</span>字元進行轉義。另外，要注意，如果您指定了一個空的<span>ESCAPED 
			BY</span>值，則可能會生成不能被<span>LOAD DATA INFILE</span>正確讀取的輸出值。例如，如果轉義符為空字元，則剛顯示的先前輸出值應顯示如下。請觀察，第四行中的第二個字段在引號後面包含一個逗號，該引號（錯誤地）顯示出來，作為字段的結尾：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a &quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a &quot;, quote and comma&quot;,102.20</span></pre>
			<p>對於輸入值，<span>ENCLOSED BY</span>字元被從字段字的末尾剝離。（不論<span>OPTIONALLY</span>是否被指定都會剝離；<span>OPTIONALLY</span>對輸入值的解釋沒有影響。）如果<span>ENCLOSED 
			BY</span>字元前面帶有<span>ESCAPED BY</span>字元，則被理解為當前字段值的一部分。</p>
			<p>如果字段以<span>ENCLOSED BY</span>字元為開始，當出現這類字元時，只有後面接著字段或行<span>TERMINATED 
			BY</span>序列時，這類字元被認為是一個字段值的結尾。為了避免意思不明確，當在一個字段值中出現<span>ENCLOSED 
			BY</span>字元時，此字元可以重複書寫，並被理解為單一的字元。例如，如果指定了<span>ENCLOSED 
			BY <span>&#39;&quot;&#39;</span></span>，則按照以下方法操作引號：</p>
			<pre><span>&quot;The &quot;&quot;BIG&quot;&quot; boss&quot;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;BIG&quot; boss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;&quot;BIG&quot;&quot; boss&nbsp;&nbsp;&nbsp; -&gt; The &quot;&quot;BIG&quot;&quot; boss</span></pre>
			<p><span>FIELDS ESCAPED BY</span>用於控制如何寫入或讀取特殊字元。如果<span>FIELDS 
			ESCAPED BY</span>字元不是空字元，則可以在輸出中用於對以下字元加前綴：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS ESCAPED BY</span>字元</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字元</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一個字元</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ASCII 0</span>（在轉義符之後編寫的字元實際上是<span>ASCII</span>『<span>0</span>』，而不是一個值為<span>0</span>的字節）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字元為空字元，則沒有字元被轉義，並且<span>NULL</span>被作為<span>NULL</span>輸出，而不是<span>\N</span>。去指定一個空的轉義符不是一個好辦法，特別是如果數據的字段值包含任何剛給定的清單中的字元時，更不能這麼做。</p>
			<p>對於輸入值，如果<span>FIELDS ESCAPED BY</span>字元不是空字元，則出現這種字元時會被剝離，然後以下字元被作為字段值的一部分。例外情況是，被轉義的『<span>0</span>』或『<span>N</span>』（例如，<span>\0</span>或<span>\N</span>，此時轉義符為『<span>\</span>』）。這些序列被理解為<span>ASCII 
			NUL</span>（一個零值字節）和<span>NULL</span>。用於<span>NULL</span>處理的規則在本節的後部進行說明。</p>
			<p>要瞭解有關『<span>\</span>』<span>-escape</span>語法的更多訊息，請參見<a href="language-structure.html#literals" title="9.1. Literal Values">9.1節，「文字值」</a>。</p>
			<p>在特定情況下，<span>field-</span>和<span>line-handling</span>選項相互影響：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LINES TERMINATED BY</span>是空字串，並且<span>FIELDS 
			TERMINATED BY</span>不是空字串，則各行以<span>FIELDS TERMINATED BY</span>作為結尾。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>值均為空值<span>(<span>&#39;&#39;</span>)</span>，則使用固定行（無分隔）格式。使用固定行格式時，在字段之間不使用分隔符（但是您仍然可以有行終止符）。列值使用列的顯示寬度進行寫入和讀取。例如，如果某列被定義為<span>INT(7)</span>，則使用<span>7</span>字元字段寫入列值。輸出時，通過讀取<span>7</span>個字元獲取列值。</p>
			<p><span>LINES TERMINATED BY</span>仍然用於分隔行。如果某行不包含所有字段，則其餘的各列被設置到預設值。如果您沒有行終止符，您應該把終止符設置為<span>&#39;&#39;</span>。在此情況下，文本檔案必須包含每行的所有字段。</p>
			<p>固定行格式也會影響<span>NULL</span>值的操作，這將在以後進行介紹。注意，如果您正在使用一個多字節字元編碼，則固定規格格式不會運行。</p>
			<p>根據正在使用中的<span>FIELDS</span>和<span>LINES</span>選項的不同，<span>NULL</span>值的操作有所變化：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於預設的<span>FIELDS</span>和<span>LINES</span>值，<span>NULL</span>被作為<span>\N</span>的字段值編寫，用於輸出；<span>\N</span>字段值被作為<span>NULL</span>讀取，用於輸入（假設<span>ESCAPED 
			BY</span>字元為『<span>\</span>』）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ENCLOSED BY</span>不是空值，則包含以文字詞語<span>NULL</span>為值的字段被作為<span>NULL</span>值讀取。這與被<span>FIELDS 
			ENCLOSED BY</span>字元包圍的詞語<span>NULL</span>不同。該詞語被作為字串<span>&#39;NULL&#39;</span>讀取。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>是空值，則<span>NULL</span>被作為詞語<span>NULL</span>寫入。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>採用固定行格式時（當<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均為空值時採用），<span>NULL</span>被作為一個空字串寫入。注意，這會導致在被寫入檔案時，資料表中的<span>NULL</span>值和空字串均無法辨別，這是因為兩者都被作為空字串寫入。如果您需要在讀取檔案並返回時能夠分辨兩者，則您不應使用固定行格式。</p>
			<p><span>LOAD DATA INFILE</span>不支援有些情況：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>固定規格行（<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均為空值）和<span>BLOB</span>或<span>TEXT</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了一個分隔符，並且該分隔符與其它的前綴一樣，則<span>LOAD DATA 
			INFILE</span>不能正確地理解輸入值。例如，下面的<span>FIELDS</span>子句會導致問題：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>FIELDS TERMINATED BY &#39;&quot;&#39; ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>為空值，則包含<span>FIELDS 
			ENCLOSED BY</span>或<span>LINES TERMINATED BY</span>的字段值後面再接<span>FIELDS 
			TERMINATED BY</span>值會導致<span>LOAD DATA INFILE</span>過早地停止讀取一個字段或行。出現這種情況的原因是<span>LOAD 
			DATA INFILE</span>不能正確地決定字段或行值在哪裡結束。</p>
			<p>以下的例子載入了<span>persondata</span>資料表中的所有列：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39; INTO TABLE persondata;</b></span></span></pre>
			<p>預設情況下，如果在<span>LOAD DATA INFILE</span>語句的末尾處沒有設列清單時，則輸入行預計會包含一個字段，用於資料表中的每個列。如果您只想載入一個資料表的部分列，則應指定一個列清單：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>INTO TABLE persondata (col1,col2,...);</b></span></span></pre>
			<p>如果輸入檔案中各字段的順序與資料表中各列的順序不同，您也必須指定一個列清單。否則，<span>MySQL</span>不能把輸入字段和資料表中的列匹配起來。</p>
			<p>列清單可以包含列名稱或用戶變數。支援<span>SET</span>子句。這使您可以把輸入值賦予用戶變數，然後在把結果賦予列之前，對這些值進行變換。</p>
			<p><span>SET</span>子句中的用戶變數可以採用多種方式使用。以下例子使用數據檔案中的第一列，直接用於<span>t1.column1</span>的值。在用戶變數被用於<span>t2.column2</span>值之前，把第二列賦予用戶變數。該變數從屬於一個分割運行。</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @var1)</span></pre>
			<pre><span>&nbsp; SET column2 = @var1/100;</span></pre>
			<p><span>SET</span>子句可以被用於提供不是來源於輸入檔案的值。以下語句把<span>column3</span>設置為當前的日期和時間：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, column2)</span></pre>
			<pre><span>&nbsp; SET column3 = CURRENT_TIMESTAMP;</span></pre>
			<p>您也可以通過把輸入值賦予一個用戶變數，同時不把變數賦予資料表中的列，來丟棄此輸入值：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @dummy, column2, @dummy, column3);</span></pre>
			<p>列<span>/</span>變數清單和<span>SET</span>子句的使用受到以下限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>SET</span>子句中的賦值應只含有位於賦值操作符的左側的列名稱。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在<span>SET</span>賦值的右側使用子查詢。如果子查詢可以返回一個值，並且此值將被賦予到一個列中，則此子查詢只能是標量子查詢。另外，您不能使用子查詢從一個正在被載入的資料表中選擇。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對于于列<span>/</span>變數清單或<span>SET</span>子句，被<span>IGNORE</span>子句忽略的行不被處理。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當載入採用固定行格式的數據時，不能使用用戶變數，因為用戶變數沒有顯示寬度。</p>
			<p>當處理一個輸入行時，<span>LOAD DATA</span>會依據列<span>/</span>變數清單和<span>SET</span>子句，把行拆分成字段，並使用值。然後，得到的行被插入資料表中。如果有用於資料表的<span>BEFORE 
			INSERT</span>或<span>AFTER INSERT</span>觸發器，則在插入行之前和插入行之後分別啟動觸發器。</p>
			<p>如果一個輸入行含有過多的字段，則多餘的字段被忽略，並且警告的數量增加。</p>
			<p>如果一個輸入行含有的字段過少，則輸入字段缺失的資料表中的列被設置為預設值。預設值賦值在<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
		TABLE語法」</a>中進行了說明。</p>
			<p>如果字段值缺失，則對一個空字段值會被按不同方式理解：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於字串類型，列被設置為空字串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於數字類型，列被設置為<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於日期和時間類型，列被設置為該類型相應的「<span>zero</span>」。請參見<a href="column-types.html#date-and-time-types" title="11.3. Date and Time Types">11.3節，「日期和時間類型」</a>。</p>
			<p>如果您明確地把一個空字串賦予一個<span>INSERT</span>或<span>UPDATE</span>語句中的字串類型、數字類型或日期或時間類型，則產生的這些值相同。</p>
			<p>只有在兩種情況下<span>TIMESTAMP</span>列被設置為當前日期和時間。一種情況時當列有一個<span>NULL</span>值（也就是<span>\N</span>）時；另一種情況是（僅對於第一個<span>TIMESTAMP</span>列），當一個字段清單被指定時，<span>TIMESTAMP</span>列會從字段清單中被略去。</p>
			<p><span>LOAD DATA INFILE</span>把所有的輸入值當作字串，所以您不能按照使用<span>INSERT</span>語句的方式使用<span>ENUM</span>或<span>SET</span>列的數字值。所有的<span>ENUM</span>和<span>SET</span>值必須被指定為字串。</p>
			<p>當<span>LOAD DATA INFILE</span>語句結束時，會按以下格式返回一個訊息字串： 
			</p>
			<pre><span>Records: 1&nbsp; Deleted: 0&nbsp; Skipped: 0&nbsp; Warnings: 0</span></pre>
			<p>如果您正在使用<span>C API</span>，您可以通過使用<span>mysql_info()</span>函數獲取有關語句的訊息。請參見<a href="apis.html#mysql-info" title="25.2.3.34. mysql_info()">25.2.3.34節，「mysql_info()」</a>。</p>
			<p>當值通過<span>INSERT</span>語句被插入時或出現相同情況時，會發生警告（見<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4節，「INSERT語法」</a>）。例外情況是，當輸入行中字段過多或過少時，<span>LOAD 
			DATA INFILE</span>也生成警告。這些警告並不儲存；警告的數量只用於指示運行是否良好。</p>
			<p>您可以使用<span>SHOW WARNINGS</span>來得到第一批<span>max_error_count</span>警告的清單，作為有關運行錯誤的訊息。請參見<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22節，「SHOW 
		WARNINGS語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replace"></a>13.2.6. REPLACE語法</h3></div></div></div><a class="indexterm" name="id2904199"></a>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<p><span>REPLACE</span>的運行與<span>INSERT</span>很相像。只有一點除外，如果資料表中的一個舊記錄與一個用於<span>PRIMARY 
			KEY</span>或一個<span>UNIQUE</span>索引的新記錄具有相同的值，則在新記錄被插入之前，舊記錄被刪除。請參見<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4節，「INSERT語法」</a>。</p>
			<p>注意，除非資料表有一個<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引，否則，使用一個<span>REPLACE</span>語句沒有意義。該語句會與<span>INSERT</span>相同，因為沒有索引被用於確定是否新行複製了其它的行。</p>
			<p>所有列的值均取自在<span>REPLACE</span>語句中被指定的值。所有缺失的列被設置為各自的預設值，這和<span>INSERT</span>一樣。您不能從當前行中引用值，也不能在新行中使用值。如果您使用一個例如「<span>SET
			<i>col_name</i> = <i>col_name</i> + 1<span>」的賦值，則對位於右側的列名稱的引用會被作為</span>DEFAULT(<i>col_name</i>)</span>處理。因此，該賦值相當於<span>SET
			<i>col_name</i> = DEFAULT(<i>col_name</i>) + 1</span>。</p>
			<p>為了能夠使用<span>REPLACE</span>，您必須同時擁有資料表的<span>INSERT</span>和<span>DELETE</span>權限。</p>
			<p><span>REPLACE</span>語句會返回一個數，來指示受影響的行的數目。該數是被刪除和被插入的行數的和。如果對於一個單行<span>REPLACE</span>該數為<span>1</span>，則一行被插入，同時沒有行被刪除。如果該數大於<span>1</span>，則在新行被插入前，有一個或多個舊行被刪除。如果資料表包含多個唯一索引，並且新行複製了在不同的唯一索引中的不同舊行的值，則有可能是一個單一行替換了多個舊行。</p>
			<p>受影響的行數可以容易地確定是否<span>REPLACE</span>只新增了一行，或者是否<span>REPLACE</span>也替換了其它行：檢查該數是否為<span>1</span>（新增）或更大（替換）。</p>
			<p>如果您正在使用<span>C API</span>，則可以使用<span>mysql_affected_rows()</span>函數獲得受影響的行數。</p>
			<p>目前，您不能在一個子查詢中，向一個資料表中更換，同時從同一個資料表中選擇。</p>
			<p>以下是所用算法的更詳細的說明（該算法也用於<span>LOAD DATA...REPLACE</span>）：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>嘗試把新行插入到資料表中</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>當因為對於主鍵或唯一關鍵字出現重複關鍵字錯誤而造成插入失敗時：</p>
			<p>
			<span>a.<span>&nbsp;&nbsp;&nbsp;
			</span></span>從資料表中刪除含有重複關鍵字值的衝突行</p>
			<p>
			<span>b.<span>&nbsp;&nbsp;&nbsp;
			</span></span>再次嘗試把新行插入到資料表中</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select"></a>13.2.7. SELECT語法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#join">13.2.7.1. 
			JOIN語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#union">13.2.7.2. 
			UNION語法<br>
&nbsp;</a></span></dt></dl></div><a class="indexterm" name="id2904508"></a>
			<pre><span>SELECT</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ALL | DISTINCT | DISTINCTROW ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HIGH_PRIORITY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STRAIGHT_JOIN]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>select_expr</i></span>, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO OUTFILE &#39;<span><i>file_name</i></span>&#39; <span><i>export_options</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | INTO DUMPFILE &#39;<span><i>file_name</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [GROUP BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC], ... [WITH ROLLUP]]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [HAVING <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC] , ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT {[<span><i>offset</i></span>,] <span><i>row_count</i></span> | <span><i>row_count</i></span> OFFSET <span><i>offset</i></span>}]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PROCEDURE <span><i>procedure_name</i></span>(<span><i>argument_list</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FOR UPDATE | LOCK IN SHARE MODE]]</span></pre>
			<p><span>SELECT</span>用於恢復從一個或多個資料表中選擇的行，並可以加入<span>UNION</span>語句和子查詢。請參見<a href="sql-syntax.html#union" title="13.2.7.2. UNION Syntax">13.2.7.2節，「UNION語法<br>
		」</a>和<a href="sql-syntax.html#subqueries" title="13.2.8. Subquery Syntax">13.2.8節，「Subquery語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>每個<span><i><span>select_expr</span></i></span>都指示一個您想要恢復的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			table_references</span></i></span>指示行從哪個資料表或哪些資料表中被恢復。在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>中對該語法進行了說明。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			where_definition</span></i></span>包括關鍵詞<span>WHERE</span>，後面接一個資料表達式。該資料表達式指示被選擇的行必須滿足的條件。</p>
			<p>有的行在計算時未引用任何資料表。<span>SELECT</span>也可以用於恢復這類行。</p>
			<p>舉例說明：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>所有被使用的子句必須按語法說明中顯示的順序嚴格地排序。例如，一個<span>HAVING</span>子句必須位於<span>GROUP 
			BY</span>子句之後，並位於<span>ORDER BY</span>子句之前。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931017"></a>

            <a class="indexterm" name="id2931018"></a>

            使用<span>AS <i>alias_name</i></span>可以為<span><i><span>select_expr</span></i></span>給定一個別名。此別名用作資料表達式的列名，可以用於<span>GROUP 
			BY</span>、<span>ORDER BY</span>或<span>HAVING</span>子句。例如：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) AS full_name</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>在為<span><i><span>select_expr</span></i></span>給定別名時，<span>AS</span>關鍵詞是自選的。前面的例子可以這樣編寫：</p>
			<pre><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) full_name</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>因為<span>AS</span>是自選的，如果您忘記在兩個<span><i><span>select_expr</span></i></span>資料表達式之間加逗號，則會出現一個小問題：<span>MySQL</span>會把第二個資料表達式理解為一個別名。例如，在以下語句中，<span>columnb</span>被作為別名對待：</p>
			<pre><span>mysql&gt; <span><b>SELECT columna columnb FROM mytable;</b></span></span></pre>
			<p>因此，使用<span>AS</span>明確地指定列的別名，把它作為習慣，是一個良好的操作規範。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一個<span>WHERE</span>子句中使用列別名是不允許的，因為當執行<span>WHERE</span>子句時，列值可能還沒有被確定。請參見<a href="problems.html#problems-with-alias" title="A.5.4. Problems with Column Aliases">A.5.4節，「與列別名有關的問題」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FROM <i>
			table_references</i></span>子句指示行從哪些資料表中被恢復。如果您命名的資料表多於一個，則您在進行一個聯合操作。要瞭解有關聯合語法的說明，請參見<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>。對於每一個被指定的資料表，您可以自選地指定一個別名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>tbl_name</span></i></span><span> [[AS] <span><i>alias</i></span>]</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;[{USE|IGNORE|FORCE} INDEX (<span><i>key_list</i></span>)]</span></pre>
			<p>使用<span>USE INDEX</span>、<span>IGNORE 
			INDEX</span>、<span>FORCE INDEX</span>可以向最佳化符提示如何選擇索引。這部分內容在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>中進行了討論。</p>
			<p>您可以使用<span>SET 
			max_seeks_for_key=<i>value</i></span>作為一種替代方法，來促使<span>MySQL</span>優先採用關鍵字掃瞄，替代資料表掃瞄。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以把當前資料庫中的一個資料表作為<span><i><span>tbl_name</span></i></span>（在當前資料庫中）引用，或作為<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span><span>引用</span>，來明確地指定一個資料庫。您可以把一列作為<span><i><span>col_name</span></i></span><span>,
			<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span><span>引用</span>或作為<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span>引用。您不需要對一個列引用指定一個<span><i><span>tbl_name</span></i></span>或<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span>前綴，除非此引用意義不明確。意義不明確時，要求指定明確的列引用格式。有關示範見<a href="language-structure.html#legal-names" title="9.2. Database, Table, Index, Column, and Alias Names">9.2節，「資料庫、資料表、索引、列和別名」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931019"></a>

            <a class="indexterm" name="id2931020"></a>

            <a class="indexterm" name="id2931021"></a>

            在沒有資料表被引用的情況下，允許您指定<span>DUAL</span>作為一個假的資料表名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT 1 + 1 FROM DUAL;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 2</span></pre>
			<p>有些伺服器要求一個<span>FROM</span>子句。<span>DUAL</span>僅用於與這些伺服器兼容。如果沒有資料表被引用，則<span>MySQL</span>不要求該子句，前面的語句可以按以下方法編寫：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><i><span>tbl_name</span></i><span> 
			AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
			alias_name</span></i></span>可以為一個資料表引用起別名：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>WHERE</span>子句中，您可以使用<span>MySQL</span>支援的所有函數，不過總計（總結）函數除外。請參見<a href="functions.html">第12章：</a><a href="functions.html" title="Chapter 12. Functions and Operators"><i>函數和操作符</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被選擇的用於輸出的列可以使用列名稱、列別名或列位置被引用到<span>ORDER BY</span>和<span>GROUP 
			BY</span>子句中。列位置為整數，從<span>1</span>開始：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY region, seed;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region AS r, seed AS s FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY r, s;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY 2, 3;</b></span></span></pre>
			<p>要以相反的順序進行分類，應把<span>DESC</span>（降序）關鍵字新增到<span>ORDER 
			BY</span>子句中的列名稱中。預設值為升序；該值可以使用<span>ASC</span>關鍵詞明確地指定。</p>
			<p>不建議使用列位置，因為該語法已經從<span>SQL</span>標準中刪除。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>GROUP BY</span>，則輸出行根據<span>GROUP 
			BY</span>列進行分類，如同您對相同的列進行了<span>ORDER BY</span>。<span>MySQL</span>對<span>GROUP 
			BY</span>進行了延伸，因此您可以在各列（在子句中進行命名）的後面指定<span>ASC</span>和<span>DESC</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT a, COUNT(b) FROM test_table GROUP BY a DESC</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MySQL</span>對<span>GROUP BY</span>的使用進行了延伸，允許選擇在<span>GROUP 
			BY</span>子句中沒有被提到的字段。如果您沒有得到預期的結果，請閱讀<span>GROUP BY</span>的說明，請參見<a href="functions.html#group-by-functions-and-modifiers" title="12.10. Functions and Modifiers for Use with GROUP BY Clauses">12.10節，「與GROUP BY子句同時使用的函數和修改程式<code class="literal"></code>」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>GROUP BY</span>允許一個<span>WITH 
			ROLLUP</span>修飾符。請參見<a href="functions.html#group-by-modifiers" title="12.10.2. GROUP BY Modifiers">12.10.2節，「GROUP 
			BY修改程式」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句基本上是最後使用，只位於被發送給客戶端的條目之前，沒有進行最佳化。（<span>LIMIT</span>用於<span>HAVING</span>之後。）</p>
			<p><span>SQL</span>標準要求<span>HAVING</span>必須引用<span>GROUP 
			BY</span>子句中的列或用於總計函數中的列。不過，<span>MySQL</span>支援對此工作性質的延伸，並允許<span>HAVING</span>因為<span>SELECT</span>清單中的列和外部子查詢中的列。</p>
			<p>如果<span>HAVING</span>子句引用了一個意義不明確的列，則會出現警告。在下面的語句中，<span>col2</span>意義不明確，因為它既作為別名使用，又作為列名使用：</p>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;</b></span></span></pre>
			<p>標準<span>SQL</span>工作性質具有優先權，因此如果一個<span>HAVING</span>列名既被用於<span>GROUP 
			BY</span>，又被用作輸出列清單中的起了別名的列，則優先權被給予<span>GROUP BY</span>列中的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>不能用於應被用於<span>WHERE</span>子句的條目。例如，不能編寫如下語句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> HAVING <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>而應這麼編寫：</p>
			<pre><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> WHERE <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句可以引用總計函數，而<span>WHERE</span>子句不能引用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT user, MAX(salary) FROM users</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>GROUP BY user HAVING MAX(salary)&gt;10;</b></span></span></pre>
			<p>（在有些較早版本的<span>MySQL</span>中，本語句不運行。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LIMIT</span>子句可以被用於限制被<span>SELECT</span>語句返回的行數。<span>LIMIT</span>取一個或兩個數字自變數，自變數必須是非負的整數常數（當使用已預備的語句時除外）。</p>
			<p>
			使用兩個自變數時，第一個自變數指定返回的第一行的偏移量，第二個自變數指定返回的行數的最大值。初始行的偏移量為<span>0</span>（不是<span>1</span>）：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5,10;&nbsp; # Retrieve rows 6-15</b></span></span></pre>
			<p>為了與<span>PostgreSQL</span>兼容，<span>MySQL</span>也支援<span>LIMIT
			<span><i>row_count</i> OFFSET <i>offset</i></span></span>語法。</p>
			<p>
			如果要恢復從某個偏移量到結果集合的末端之間的所有的行，您可以對第二個參數是使用比較大的數。本語句可以恢復從第<span>96</span>行到最後的所有行：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 95,18446744073709551615;</b></span></span></pre>
			<p>使用<span>1</span>個自變數時，該值指定從結果集合的開頭返回的行數：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5;&nbsp;&nbsp;&nbsp;&nbsp; # Retrieve first 5 rows</b></span></span></pre>
			<p>換句話說，<span>LIMIT n</span>與<span>LIMIT 
			0,n</span>等價。</p>
			<p>對於已預備的語句，您可以使用位置保持符。以下語句將從<span>tb1</span>資料表中返回一行：</p>
			<pre><span>mysql&gt; <span><b>SET @a=1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @a;</b></span></span></pre>
			<p>以下語句將從<span>tb1</span>資料表中返回第二到第六行：</p>
			<pre><span>mysql&gt; <span><b>SET @skip=1; SET @numrows=5;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?, ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @skip, @numrows;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SELECT...INTO OUTFILE<span> 
			&#39;<i>file_name</i>&#39;</span></span>形式的<span>SELECT</span>可以把被選擇的行寫入一個檔案中。該檔案被建立到伺服器主機上，因此您必須擁有<span>FILE</span>權限，才能使用此語法。<span><i><span>file_name</span></i></span>不能是一個原有的檔案。原有檔案會阻止例如「<span>/etc/passwd</span>」的檔案和資料庫資料表被銷毀。</p>
			<p><span>SELECT...INTO OUTFILE</span>語句的主要作用是讓您可以非常快速地把一個資料表轉儲到伺服器機器上。如果您想要在伺服器主機之外的部分客戶主機上建立結果檔案，您不能使用<span>SELECT...INTO 
			OUTFILE</span>。在這種情況下，您應該在客戶主機上使用比如「<span>mysql </span>–<span>e
			<span>&quot;SELECT ...&quot; &gt; file_name</span></span><span>」的命令，來生成檔案。</span></p>
			<p><span>SELECT...INTO OUTFILE</span>是<span>LOAD 
			DATA INFILE</span>的補語；用於語句的<span>exort_options</span>部分的語法包括部分<span>FIELDS</span>和<span>LINES</span>子句，這些子句與<span>LOAD 
			DATA INFILE</span>語句同時使用。請參見<a href="sql-syntax.html#load-data" title="13.2.5. LOAD DATA INFILE Syntax">13.2.5節，「LOAD DATA INFILE語法」</a>。</p>
			<p><span>FIELDS ESCAPED BY</span>用於控制如何寫入特殊字元。如果<span>FIELDS 
			ESCAPED BY</span>字元不是空字元，則被用於在輸出中對以下字元設前綴：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS ESCAPED BY</span>字元</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字元</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一個字元</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>ASCII 0</span>（在編寫時接在轉義符後面的是<span>ASCII
			</span>『<span>0</span>』，而不是一個零值字節）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字元是空字元，則沒有字元被轉義，並且<span>NULL</span>被作為<span>NULL</span>輸出，而不是作為<span>\N</span>輸出。指定一個空的轉義符不是一個好的主意。特別是當您的數據中的字段值包含剛被給予的清單中的字元時，更是如此。</p>
			<p>其原因是您必須對所有<span>FIELDS 
			TERMINATED BY, ENCLOSED BY, ESCAPED BY</span>或<span>LINES 
			TERMINATED BY</span>字元進行轉義，才能可靠地讀取檔案並返回。<span>ASCII NUL</span>被轉義，以便更容易地使用調頁程式觀看。</p>
			<p>生成的檔案不必符合<span>SQL</span>語法，所以沒有其它的字元需要被轉義。</p>
			<p>在下面的例子中，生成一個檔案，各值用逗號隔開。這種格式可以被許多程式使用。</p>
			<pre><span>SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;</span></pre>
			<pre><span>FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<pre><span>LINES TERMINATED BY &#39;\n&#39;</span></pre>
			<pre><span>FROM test_table;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>INTO DUMPFILE</span>代替<span>INTO 
			OUTFILE</span>，則<span>MySQL</span>只把一行寫入到檔案中，不對任何列或行進行終止，也不執行任何轉義處理。如果您想要把一個<span>BLOB</span>值儲存到檔案中，則這個語句是有用的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>註釋：任何由<span>INTO OUTFILE</span>或<span>INTO 
			DUMPFILE</span>建立的檔案都可以被伺服器主機上的所有用戶編寫。原因是，<span>MySQL</span>伺服器不能建立這樣的檔案，即檔案的所有者不是該檔案運行時所屬的用戶（任何時候，您都不能出於此原因或出於其它原因把<strong><span>mysqld</span></strong>作為根段運行）。該檔案必須是全局可寫的，這樣您就可以操作其中的內容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有的過程應在結果集合內處理數據。<span>PROCEDURE</span>子句用於對這些過程進行命名。要瞭解示範，請參見<a href="extending-mysql.html#procedure-analyse" title="27.3.1. Procedure Analyse">27.3.1節，「步驟分析」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>儲存引擎使用頁面或行鎖。如果您對儲存引擎使用<span>FOR UPDATE</span>，則受到查詢檢驗的行會被進行寫鎖定，直到當前事務結束為止。使用<span>LOCK 
			IN SHARE MODE</span>可以設置一個共享鎖。共享鎖可以防止其它事務更新或刪除被檢驗的行。請參見<a href="storage-engines.html#innodb-locking-reads" title="15.2.10.5. Locking Reads SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE">15.2.10.5節，「鎖定讀取SELECT ... FOR UPDATE和SELECT ... LOCK IN SHARE MODE」</a>。</p>
			<p>在<span>SELECT</span>關鍵詞的後面，您可以使用許多選項。這些選項可以影響語句的運行。</p>
			<p><span>ALL, DISTINCT</span>和<span>DISTINCTROW</span>選項指定是否重複行應被返回。如果這些選項沒有被給定，則預設值為<span>ALL</span>（所有的匹配行被返回）。<span>DISTINCT</span>和<span>DISTINCTROW</span>是同義詞，用於指定結果集合中的重複行應被刪除。</p>
			<p><span>HIGH_PRIORITY, STRAIGHT_JOIN</span>和以<span>SQL_</span>為開頭的選項是<span>MySQL</span>相對於標準<span>SQL</span>的延伸。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>給予<span>SELECT</span>更高的優先權，高於用於更新資料表的語句。您應該只對查詢使用<span>HIGH_PRIORITY</span>。查詢速度非常快，而且立刻被執行。<span>SELECT 
			HIGH_PRIORITY</span>查詢在資料表被鎖定用於讀取時被發出。即使有一個新的語句正在等待資料表變為空閒，查詢也會運行。</p>
			<p><span>HIGH_PRIORITY</span>不能和<span>SELECT</span>語句同時使用。<span>SELECT</span>語句是<span>UNION</span>的一部分。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>STRAIGHT_JOIN</span>用於促使最佳化符把資料表聯合在一起，順序按照這些資料表在<span>FROM</span>子句中排列的順序。如果最佳化符聯合資料表時順序不佳，您可以使用<span>STRAIGHT_JOIN</span>來加快查詢的速度。請參見<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1節，「EXPLAIN語法（獲取關於SELECT的訊息）<code class="literal"></code>」</a>。<span>STRAIGHT_JOIN</span>也可以被用於<span><i><span>table_references</span></i></span>清單中。請參見<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BIG_RESULT</span>可以與<span>GROUP 
			BY</span>或<span>DISTINCT</span>同時使用，來告知最佳化符結果集合有很多行。在這種情況下，<span>MySQL</span>直接使用以磁盤為基礎的臨時資料表（如果需要的話）。在這種情況下，<span>MySQL</span>還會優先進行分類，不優先使用臨時資料表。臨時資料表對於<span>GROUP 
			BY</span>組分帶有關鍵字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BUFFER_RESULT</span>促使結果被放入一個臨時資料表中。這可以幫助<span>MySQL</span>提前解開資料表鎖定，在需要花費較長時間的情況下，也可以幫助把結果集合發送到客戶端中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_SMALL_RESULT</span>可以與<span>GROUP 
			BY</span>或<span>DISTINCT</span>同時使用，來告知最佳化符結果集合是較小的。在此情況下，<span>MySAL</span>使用快速臨時資料表來儲存生成的資料表，而不是使用分類。在<span>MySQL 
			5.1</span>中，通常不需要這樣。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_CALC_FOUND_ROWS</span>告知<span>MySQL</span>計算有多少行應位於結果集合中，不考慮任何<span>LIMIT</span>子句。行的數目可以使用<span>SELECT 
			FOUND_ROWS()</span>恢復。請參見<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3節，「訊息函數」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在使用一個<span>query_cache_type</span>值，值為<span>2</span>或<span>DEMAND</span>，則<span>SQL_CACHE</span>告知<span>MySQL</span>把查詢結果儲存在查詢緩存中。對於使用<span>UNION</span>的查詢或子查詢，本選項會影響查詢中的所有<span>SELECT</span>。請參見<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13節，「MySQL查詢高速緩衝」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_NO_CACHE</span>告知<span>MySQL</span>不要把查詢結果儲存在查詢緩存中。請參見<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13節，「MySQL查詢高速緩衝」</a>。對於一個使用<span>UNION</span>或子查詢的查詢，本選項會影響查詢中的<span>SELECT</span>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="join"></a>13.2.7.1. JOIN語法</h4></div></div></div><a class="indexterm" name="id2906549"></a><a class="indexterm" name="id2906558"></a><a class="indexterm" name="id2906567"></a><a class="indexterm" name="id2906576"></a><a class="indexterm" name="id2906585"></a><a class="indexterm" name="id2906594"></a><a class="indexterm" name="id2906603"></a><a class="indexterm" name="id2906612"></a><a class="indexterm" name="id2906621"></a><a class="indexterm" name="id2906630"></a><a class="indexterm" name="id2906639"></a><a class="indexterm" name="id2906648"></a><a class="indexterm" name="id2906658"></a>
				<p><span>MySQL</span>支援以下<span>JOIN</span>語法。這些語法用於<span>SELECT</span>語句的<span><i><span>table_references</span></i></span>部分和多資料表<span>DELETE</span>和<span>UPDATE</span>語句：</p>
				<pre class="programlisting"><em class="replaceable">table_references:</em>
    <em class="replaceable">table_reference</em> [, <em class="replaceable">table_reference</em>] …

<em class="replaceable">table_reference</em>:
    <em class="replaceable">table_factor</em>
  | <em class="replaceable">join_table</em>

<em class="replaceable">table_factor</em>:
    <em class="replaceable">tbl_name</em> [[AS] <em class="replaceable">alias</em>]
        [{USE|IGNORE|FORCE} INDEX (<em class="replaceable">key_list</em>)]
  | ( <em class="replaceable">table_references</em> )
  | { OJ <em class="replaceable">table_reference</em> LEFT OUTER JOIN <em class="replaceable">table_reference</em>
        ON <em class="replaceable">conditional_expr</em> }

<em class="replaceable">join_table</em>:
    <em class="replaceable">table_reference</em> [INNER | CROSS] JOIN <em class="replaceable">table_factor</em> [<em class="replaceable">join_condition</em>]
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em> ON <em class="replaceable">condition</em>
  | <em class="replaceable">table_reference</em> LEFT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [LEFT [OUTER]] JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> RIGHT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [RIGHT [OUTER]] JOIN <em class="replaceable">table_factor</em>

<em class="replaceable">join_condition</em>:
    ON <em class="replaceable">conditional_expr</em>
  | USING (<em class="replaceable">column_list</em>)
</pre>
				<p>一個資料表引用還被稱為一個聯合資料表達式。</p>
				<p>與<span>SQL</span>標準相比，<span><i><span>table_factor</span></i></span>的語法被延伸了。<span>SQL</span>標準只接受<span><i><span>table_reference</span></i></span>，而不是圓括號內的一系列條目。</p>
				<p>如果我們把一系列<span><i><span>table_reference</span></i></span>條目中的每個逗號都看作相當於一個內部聯合，則這是一個穩妥的延伸。例如：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3, t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>相當於：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>在<span>MySQL</span>中，<span>CROSS JOIN</span>從語法上說與<span>INNER 
				JOIN</span>等同（兩者可以互相替換。在標準<span>SQL</span>中，兩者是不等同的。<span>INNER 
				JOIN</span>與<span>ON</span>子句同時使用，<span>CROSS 
				JOIN</span>以其它方式使用。</p>
				<p>通常，在只含有內部聯合運行的聯合資料表達式中，圓括號可以被忽略。<span>MySQL</span>也支援嵌套的聯合（見<a href="optimization.html#nested-joins" title="7.2.10. How MySQL Optimizes Nested Joins">7.2.10節，「MySQL如何最佳化嵌套Join」</a>）。</p>
				<p>通常，您不應對<span>ON</span>部分有任何條件。<span>ON</span>部分用於限定在結果集合中您想要哪些行。但是，您應在<span>WHERE</span>子句中指定這些條件。這條規則有一些例外。</p>
				<p>在前面的清單中顯示的<span><span>{ OJ 
				... LEFT OUTER JOIN ...}</span>語法的目的只是為了保持與<span>ODBC</span>的相容性。語法中的花括號應按字面書寫；該括號不是中間語法。中間語法用於語法描述的其它地方。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>資料表引用可以使用<span><i><span>tbl_name</span></i><span> 
				AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
				alias_name</span></i></span>指定別名：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ON</span>條件句是可以被用於<span>WHERE</span>子句的格式的任何條件資料表達式。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果對於在<span>LEFT JOIN</span>中的<span>ON</span>或<span>USING</span>部分中的右資料表沒有匹配的記錄，則所有列被設置為<span>NULL</span>的一個行被用於右資料表。如果一個資料表在其它資料表中沒有對應部分，您可以使用這種方法在這種資料表中搜尋記錄：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT table1.* FROM table1</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE table2.id IS NULL;</b></span></span></pre>
				<p>本例搜尋在<span>table1</span>中含有一個<span>id</span>值的所有行。同時，在<span>table2</span>中沒有此<span>id</span>值（即，<span>table1</span>中的所有行在<span>table2</span>中沒有對應的行）。本例假設<span>table2.id</span>被定義為<span>NOT 
				NULL</span>。請參見<a href="optimization.html#left-join-optimization" title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9節，「MySQL如何最佳化LEFT JOIN和RIGHT 
				JOIN」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				USING(<i>column_list</i>)</span>子句用於為一系列的列進行命名。這些列必須同時在兩個資料表中存在。如果資料表<span>a</span>和資料表<span>b</span>都包含列<span>c1, 
				c2</span>和<span>c3</span>，則以下聯合會對比來自兩個資料表的對應的列：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>兩個資料表的<span>NATURAL [LEFT] JOIN</span>被定義為與<span>INNER 
				JOIN</span>語義相同，或與使用<span>USING</span>子句的<span>LEFT 
				JOIN</span>語義相同。<span>USING</span>子句用於為同時存在於兩個資料表中的所有列進行命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INNER JOIN</span>和，（逗號）在無聯合條件下是語義相同的：兩者都可以對指定的資料表計算出笛卡兒乘積（也就是說，第一個資料表中的每一行被聯合到第二個資料表中的每一行）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>RIGHT JOIN</span>的作用與<span>LEFT 
				JOIN</span>的作用類似。要使代碼可以在資料庫內移植，建議您使用<span>LEFT JOIN</span>代替<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>STRAIGHT_JOIN</span>與<span>JOIN</span>相同。除了有一點不一樣，左資料表會在右資料表之前被讀取。<span>STRAIGH_JOIN</span>可以被用於這樣的情況，即聯合最佳化符以錯誤的順序排列資料表。</p>
				<p>您可以提供提示，當從一個資料表中恢復訊息時，<span>MySQL</span>應使用哪個索引。通過指定<span>USE 
				INDEX</span>（<span>key_list</span>），您可以告知<span>MySQL</span>只使用一個索引來搜尋資料表中的行。另一種語法<span>IGNORE 
				INDEX</span>（<span>key_list</span>）可以被用於告知<span>MySQL</span>不要使用某些特定的索引。如果<span>EXPLAIN</span>顯示<span>MySQL</span>正在使用來自索引清單中的錯誤索引時，這些提示會有用處。</p>
				<p>您也可以使用<span>FORCE INDEX</span>，其作用接近<span>USE 
				INDEX</span>（<span>key_list</span>），不過增加了一項作用，一次資料表掃瞄被假設為代價很高。換句話說，只有當無法使用一個給定的索引來搜尋資料表中的行時，才使用資料表掃瞄。</p>
				<p><span>USE KEY</span>、<span>IGNORE KEY</span>和<span>FORCE 
				KEY</span>是<span>USE INDEX</span>、<span>IGNORE 
				INDEX</span>和<span>FORCE INDEX</span>的同義詞。</p>
				<p>註釋：當<span>MySQL</span>決定如何在資料表中搜尋行並決定如何進行聯合時，使用<span>USE 
				INDEX</span>、<span>IGNORE INDEX</span>和<span>FORCE 
				INDEX</span>只會影響使用哪些索引。當分解一個<span>ORDER BY</span>或<span>GROUP 
				BY</span>時，這些語句不會影響某個索引是否被使用。</p>
				<p>部分的聯合示範：</p>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1,table2 WHERE table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 USING (id);</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table3 ON table2.id=table3.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 USE INDEX (key1,key2)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 IGNORE INDEX (key3)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<p>見<a href="optimization.html#left-join-optimization" title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9節，「MySQL如何最佳化LEFT JOIN和RIGHT 
				JOIN」</a>。</p>
				<p>註釋：自然聯合和使用<span>USING</span>的聯合，包括外部聯合變數，依據<span>SQL:2003</span>標準被處理。這些變更時<span>MySQL</span>與標準<span>SQL</span>更加相符。不過，對於有些聯合，這些變更會導致不同的輸出列。另外，有些查詢在舊版本（<span>5.0.12</span>以前）工作正常，但也必須重新編寫，以符合此標準。對於有關當前聯合處理和舊版本中的聯合處理的效果的對比，以下列資料表提供了更詳細的訊息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>NATURAL</span>聯合或<span>USING</span>聯合的列會與舊版本不同。特別是，不再出現冗余的輸出列，用於<span>SELECT 
				*</span>延伸的列的順序會與以前不同。</p>
				<p>示範：</p>
				<pre><span>CREATE TABLE t1 (i INT, j INT);</span></pre>
				<pre><span>CREATE TABLE t2 (k INT, j INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1 NATURAL JOIN t2;</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 USING (j);</span></pre>
				<p>對於舊版本，語句會產生以下輸出：</p>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<p>在第一個<span>SELECT</span>語句中，列<span>i</span>同時出現在兩個資料表中，為一個聯合列，所以，依據標準<span>SQL</span>，該列在輸出中只出現一次。與此類似，在第二個<span>SELECT</span>語句中，列<span>j</span>在<span>USING</span>子句中被命名，應在輸出中只出現一次。但是，在兩種情況下，冗余的列均沒被消除。另外，依據標準<span>SQL</span>，列的順序不正確。</p>
				<p>現在，語句產生如下輸出：</p>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<p>冗余的列被消除，並且依據標準<span>SQL</span>，列的順序是正確的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第一，兩資料表共有的列，按在第一個資料表中的順序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第二，第一個資料表中特有的列，按該資料表中的順序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第三，第二個資料表中特有的列，按該資料表中的順序排列</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對多方式自然聯合的估算會不同。方式要求重新編寫查詢。假設您有三個資料表<span>t1(a,b)</span><span>,
				<span>t2(c,b)</span></span>和<span>t3(a,c)</span>，每個資料表有一行：<span>t1(1,2)</span><span>,
				<span>t2(10,2)</span></span>和<span>t3(7,10)</span>。同時，假設這三個資料表具有<span>NATURAL 
				JOIN</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT </span>…<span> FROM t1 NATURAL JOIN t2 NATURAL JOIN t3;</span></pre>
				<p>在舊版本中，第二個聯合的左操作數被認為是<span>t2</span>，然而它應該為嵌套聯合（<span>t1 
				NATURAL JOIN t2</span>）。結果，對<span>t3</span>的列進行檢查時，只檢查其在<span>t2</span>中的共有列。如果<span>t3</span>與<span>t1</span>有共有列，這些列不被用作<span>equi-join</span>列。因此，在舊版本的<span>MySQL</span>中，前面的查詢被轉換為下面的<span>equi-join</span>：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c;</span></pre>
				<p>此聯合又省略了一個<span>equi-join</span>謂語（<span>t1.a 
				= t3.a</span>）。結果是，該聯合產生一個行，而不是空結果。正確的等價查詢如下：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c AND t1.a = t3.a;</span></pre>
				<p>如果您要求在當前版本的<span>MySQL</span>中獲得和舊版本中相同的查詢結果，應把自然聯合改寫為第一個<span>equi-join</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在舊版本中，逗號操作符（，）和<span>JOIN</span>均有相同的優先權，所以聯合資料表達式<span>t1, 
				t2 JOIN t3</span>被理解為<span>((t1, 
				t2) JOIN t3)</span>。現在，<span>JOIN</span>有更高的優先權，所以資料表達式被理解為<span>(t1, 
				(t2 JOIN t3))</span>。這個變更會影響使用<span>ON</span>子句的語句，因為該子句只參閱聯合操作數中的列。優先權的變更改變了對什麼是操作數的理解。</p>
				<p>示範：</p>
				<pre><span>CREATE TABLE t1 (i1 INT, j1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT, j2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT, j3 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t3 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>在舊版本中，<span>SELECT</span>是合法的，因為<span>t1, 
				t2</span>被隱含地歸為<span>(t1,t2)</span>。現在，<span>JOIN</span>取得了優先權，因此用於<span>ON</span>子句的操作數是<span>t2</span>和<span>t3</span>。因為<span>t1.i1</span>不是任何一個操作數中的列，所以結果是出現在<span><span>&#39;on 
				clause&#39;</span>中有未知列<span>&#39;t1.i1&#39;</span>的錯誤。要使聯合可以被處理，用使用圓括號把前兩個表明確地歸為一組，這樣用於<span>ON</span>子句的操作數為<span>(t1,t2)</span>和<span>t3</span>：</span></p>
				<pre><span>SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>本變更也適用於<span>INNER JOIN</span>，<span>CROSS 
				JOIN</span>，<span>LEFT JOIN</span>和<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在舊版本中，<span>ON</span>子句可以參閱在其右邊命名的資料表中的列。現在，<span>ON</span>子句只能參閱操作數。</p>
				<p>示範：</p>
				<pre><span>CREATE TABLE t1 (i1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT);</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;</span></pre>
				<p>在舊版本中，<span>SELECT</span>語句是合法的。現在該語句會運行失敗，出現在<span>&#39;on 
				clause&#39;</span>中未知列<span>&#39;i3&#39;</span>的錯誤。這是因為<span>i3</span>是<span>t3</span>中的一個資料表，而<span>t3</span>不是<span>ON</span>子句中的操作數。本語句應進行如下改寫：</p>
				<pre><span>SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在舊版本中，一個<span>USING</span>子句可以被改寫為一個<span>ON</span>子句。<span>ON</span>子句對比了相應的列。例如，以下兩個子句具有相同的語義：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3</span></pre>
				<p>現在，這兩個子句不再是一樣的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在決定哪些行滿足聯合條件時，兩個聯合保持語義相同。</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在決定哪些列顯示<span>SELECT *</span>延伸時，兩個聯合的語義不相同。<span>USING</span>聯合選擇對應列中的合併值，而<span>ON</span>聯合選擇所有資料表中的所有列。對於前面的<span>USING</span>聯合，<span>SELECT 
				*</span>選擇這些值：</p>
				<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)</span></pre>
				<p>對於<span>ON</span>聯合，<span>SELECT 
				*</span>選擇這些值：</p>
				<pre><span>a.c1, a.c2, a.c3, b.c1, b.c2, b.c3</span></pre>
				<p>使用內部聯合時，<span>COALESCE<span>(a.c1,b.c1)</span></span><span>與<span>a.c1</span>或<span>b.c1</span>相同，因為兩列將具有相同的值。使用外部聯合時（比如<span>LEFT 
				JOIN</span>），兩列中有一列可以為<span>NULL</span>。該列將會從結果中被忽略。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="union"></a>13.2.7.2. UNION語法<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2908061"></a></div></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>SELECT ...</span></pre>
			<pre><span>UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...</span></pre>
			<pre><span>[UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...]</span></pre>
			<p><span>UNION</span>用於把來自許多<span>SELECT</span>語句的結果組合到一個結果集合中。</p>
			<p>列於每個<span>SELECT</span>語句的對應位置的被選擇的列應具有相同的類型。（例如，被第一個語句選擇的第一列應和被其它語句選擇的第一列具有相同的類型。）在第一個<span>SELECT</span>語句中被使用的列名稱也被用於結果的列名稱。</p>
			<p><span>SELECT</span>語句為常規的選擇語句，但是受到如下的限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有最後一個<span>SELECT</span>語句可以使用<span>INTO 
			OUTFILE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>不能與作為<span>UNION</span>一部分的<span>SELECT</span>語句同時使用。如果您對第一個<span>SELECT</span>指定了<span>HIGH_PRIORITY</span>，則不會起作用。如果您對其它後續的<span>SELECT</span>語句指定了<span>HIGH_PRIORITY</span>，則會產生語法錯誤。</p>
			<p>如果您對<span>UNION</span>不使用關鍵詞<span>ALL</span>，則所有返回的行都是唯一的，如同您已經對整個結果集合使用了<span>DISTINCT</span>。如果您指定了<span>ALL</span>，您會從所有用過的<span>SELECT</span>語句中得到所有匹配的行。</p>
			<p><span>DISTINCT</span>關鍵詞是一個自選詞，不起任何作用，但是根據<span>SQL</span>標準的要求，在語法中允許採用。（在<span>MySQL</span>中，<span>DISTINCT</span>代資料表一個共用體的預設工作性質。）</p>
			<p>您可以在同一查詢中混合<span>UNION ALL</span>和<span>UNION 
			DISTINCT</span>。被混合的<span>UNION</span>類型按照這樣的方式對待，即<span>DISTICT</span>共用體覆蓋位於其左邊的所有<span>ALL</span>共用體。<span>DISTINCT</span>共用體可以使用<span>UNION 
			DISTINCT</span>明確地生成，或使用<span>UNION</span>（後面不加<span>DISTINCT</span>或<span>ALL</span>關鍵詞）隱含地生成。</p>
			<p>如果您想使用<span>ORDER BY</span>或<span>LIMIT</span>子句來對全部<span>UNION</span>結果進行分類或限制，則應對單個地<span>SELECT</span>語句加圓括號，並把<span>ORDER 
			BY</span>或<span>LIMIT</span>放到最後一個的後面。以下例子同時使用了這兩個子句：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2)</span></pre>
			<pre><span>ORDER BY a LIMIT 10;</span></pre>
			<p>這種<span>ORDER BY</span>不能使用包括資料表名稱（也就是，採用<span><i><span>tbl_name</span></i></span><span>.<span><i>col_name</i></span></span>格式的名稱）列引用。可以在第一個<span>SELECT</span>語句中提供一個列別名，並在<span>ORDER 
			BY</span>中參閱別名，或使用列位置在<span>ORDER BY</span>中參閱列。（首選採用別名，因為不建議使用列位置。）</p>
			<p>另外，如果帶分類的一列有別名，則<span>ORDER BY</span>子句必須引用別名，而不能引用列名稱。以下語句中的第一個語句必須運行，但是第二個會運行失敗，出現在<span>&#39;order 
			clause&#39;</span>中有未知列<span>&#39;a&#39;</span>的錯誤：</p>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;</span></pre>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;</span></pre>
			<p><span>To apply <span>ORDER BY</span> 
			or <span>LIMIT</span> to an individual
			<span>SELECT</span>, place the clause inside 
			the parentheses that enclose the <span>
			SELECT</span>:&nbsp;&nbsp; </span>為了對單個<span>SELECT</span>使用<span>ORDER 
			BY</span>或<span>LIMIT</span>，應把子句放入圓括號中。圓括號包含了<span>SELECT</span>：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1 ORDER BY a LIMIT 10)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2 ORDER BY a LIMIT 10);</span></pre>
			<p>圓括號中用於單個<span>SELECT</span>語句的<span>ORDER BY</span>只有當與<span>LIMIT</span>結合後，才起作用。否則，<span>ORDER 
			BY</span>被最佳化去除。</p>
			<p><span>UNION</span>結果集合中的列的類型和長度考慮了被所有<span>SELECT</span>語句恢復的數值。例如，考慮如下語句：</p>
			<pre><span>mysql&gt; <span><b>SELECT REPEAT(&#39;a&#39;,1) UNION SELECT REPEAT(&#39;b&#39;,10);</b></span></span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| REPEAT(&#39;a&#39;,1) |</span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| bbbbbbbbbb&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+---------------+</span></pre>
			<p>（在部分早期版本的<span>MySQL</span>中，第二行已被刪節到長度為<span>1</span>。）</p>
			<h3 class="title"><a name="subqueries"></a>
			13.2.8.&nbsp;Subquery語法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#scalar-subqueries">
				13.2.8.1. 子查詢作為標量操作數</a></span></dt><dt><span class="section"><a href="sql-syntax.html#comparisons-using-subqueries">13.2.8.2. 
				使用子查詢進行比較</a></span></dt><dt><span class="section"><a href="sql-syntax.html#any-in-some-subqueries">13.2.8.3. 
				使用ANY, IN和SOME進行子查詢</a></span></dt><dt><span class="section"><a href="sql-syntax.html#all-subqueries">13.2.8.4. 
				使用ALL進行子查詢<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#row-subqueries">
				13.2.8.5. 行子查詢</a></span></dt><dt><span class="section"><a href="sql-syntax.html#exists-and-not-exists-subqueries">13.2.8.6. 
				EXISTS和NOT EXISTS</a></span></dt><dt><span class="section"><a href="sql-syntax.html#correlated-subqueries">
				13.2.8.7. 關聯子查詢</a></span></dt><dt><span class="section"><a href="sql-syntax.html#unnamed-views">
				13.2.8.8. FROM子句中的子查詢<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-errors">13.2.8.9. 
				子查詢錯誤</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimizing-subqueries">
				13.2.8.10. 最佳化子查詢</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rewriting-subqueries">
				13.2.8.11. 把子查詢作為用於早期MySQL版本的聯合進行改寫</a></span></dt></dl></div><a class="indexterm" name="id2908464"></a><a class="indexterm" name="id2908470"></a><a class="indexterm" name="id2908477"></a><a class="indexterm" name="id2908484"></a>
			<p>子查詢是另一個語句中的一個<span>SELECT</span>語句。</p>
			<p><span>MySQL</span>支援<span>SQL</span>標準要求的所有子查詢格式和操作，也支援<span>MySQL</span>特有的幾種特性。</p>
			<p>以下是一個子查詢的例子：</p>
			<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
			<p>在本例中，<span>SELECT * FROM t1...</span>是外部查詢（或外部語句）<span>,</span>（<span>SELECT 
			column1 FROM t2</span>）是子查詢。我們可以說子查詢嵌套在外部查詢中。實際上，子查詢也可以嵌套在其它子查詢中，嵌套程度可以很深。子查詢必須要位於圓括號中。</p>
			<p>子查詢的主要優勢為：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>子查詢允許結構化的查詢，這樣就可以把一個語句的每個部分隔離開。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些操作需要複雜的聯合和關聯。子查詢提供了其它的方法來執行這些操作。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在許多人看來，子查詢是可讀的。實際上，子查詢給予人們使用早期<span>SQL</span>「結構化查詢語言」的原本的想法，這是子查詢的創新。</p>
			<p>以下是一個示範語句。該語句顯示了有關子查詢語法的要點。子查詢語法由<span>SQL</span>標準指定並被<span>MySQL</span>支援。</p>
			<pre><span>DELETE FROM t1</span></pre>
			<pre><span>WHERE s11 &gt; ANY</span></pre>
			<pre><span>(SELECT COUNT(*) /* no hint */ FROM t2</span></pre>
			<pre><span>WHERE NOT EXISTS</span></pre>
			<pre><span>(SELECT * FROM t3</span></pre>
			<pre><span>WHERE ROW(5*t2.s1,77)=</span></pre>
			<pre><span>(SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM</span></pre>
			<pre><span>(SELECT * FROM t5) AS t5)));</span></pre>
			<p>
			一個子查詢會返回一個標量（單一值）、一個行、一個列或一個資料表（一行或多行及一列或多列）。這些子查詢被稱為標量、列、行和資料表子查詢。可返回一個特定種類結果的子查詢經常只被用於特定的語境中，在後面各節中有說明。</p>
			<p>有些語句可以使用子查詢。對這些語句的類型基本沒有限定。子查詢可以包括普通<span>SELECT</span>可以包括的任何關鍵詞或子句：<span>DISTINCT</span><span>,
			<span>GROUP BY</span>,
			<span>ORDER BY</span>,
			<span>LIMIT</span>, </span>聯合<span>,
			</span>索引提示<span>, <span>UNION</span></span><span>結構化</span><span>,
			</span>評注和函數等。</p>
			<p>有一個限定是，一個子查詢的外部語句必須是以下語句之一：<span>SELECT, INSERT, 
			UPDATE, DELETE, SET</span>或<span>DO</span>。還有一個限定是，目前，您不能在一個子查詢中修改一個資料表，又在同一個資料表中選擇。這適用於<span>DELETE, 
			INSERT, REPLACE</span>和<span>UPDATE</span>語句。在<a href="restrictions.html">附錄</a><a href="restrictions.html" title="Appendix I. Feature Restrictions">I：<i>特性限制</i></a>中給出了對子查詢使用的更綜合的討論。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scalar-subqueries"></a>
				13.2.8.1.&nbsp;子查詢作為標量操作數</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				子查詢最簡單的形式是返回單一值的標量子查詢。標量子查詢是一個單一操作數。只要單一列值或文字是合法的，並且您希望子查詢具有所有操作數都具有的特性，則您就可以使用子查詢。操作數具有的特性包括：一個數據類型、一個長度、一個指示是否可以為<span>NULL</span>的標誌等。舉例說明：<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(100, &#39;abcde&#39;);</span></pre>
				<pre><span>SELECT (SELECT s2 FROM t1);</span></pre>
				<p>在本<span>SELECT</span>中的子查詢返回一個單一值<span>(<span>&#39;abcde&#39;</span>)</span>。該單一值的數據類型為<span>CHAR</span>，長度為<span>5</span>，字元編碼和整序與在<span>CREATE 
				TABLE</span>時有效的預設值相同，並有一個指示符號，指示列中的值可以為<span>NULL</span>。實際上，基本上所有的子查詢都為<span>NULL</span>。如果在本例中使用的資料表為空資料表，則子查詢的值應為<span>NULL</span>。</p>
				<p>在有些情況下，標量子查詢不能使用。如果一個語句只允許一個文字值，您不能使用子查詢。例如，<span>LIMIT</span>要求文字整數自變數，<span>LOAD 
				DATA</span>要求一個文字字串檔案名。您不能使用子查詢來提供這些值。</p>
				<p>後面各節包括更簡練的結構（<span>SELECT column1 FROM t1</span>）。當您在這些章節中觀看例子時，請設想一下您自己的代碼包含更多樣、更複雜的結構。</p>
				<p>舉例說明，假設我們製作兩個資料表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (1);</span></pre>
				<pre><span>CREATE TABLE t2 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t2 VALUES (2);</span></pre>
				<p>然後執行一個<span>SELECT</span>：</p>
				<pre><span>SELECT (SELECT s1 FROM t2) FROM t1;</span></pre>
				<p>結果為<span>2</span>，因為<span>t2</span>中有一行包含<span>s1</span>，<span>s1</span>有一個值為<span>2</span>。</p>
				<p>
				一個標量子查詢可以為一個資料表達式的一部分。不要忘記圓括號。即使是子查詢是一個為函數提供自變數的操作數時，也不要忘記圓括號。舉例說明：</p>
				<pre><span>SELECT UPPER((SELECT s1 FROM t1)) FROM t2;</span></pre>
				<h4 class="title"><a name="comparisons-using-subqueries"></a>
				13.2.8.2.&nbsp;使用子查詢進行比較</h4></div></div></div>
				<p>子查詢最常見的一種使用方式如下：</p>
				<pre><span><i><span>non_subquery_operand</span></i></span><span> <span><i>comparison_operator</i></span> (<span><i>subquery</i></span>)</span></pre>
				<p>當<span><i><span>comparison_operator</span></i></span>是以下
				操作符之一時：</p>
				<pre><span>=&nbsp; &gt;&nbsp; &lt;&nbsp; &gt;=&nbsp; &lt;=&nbsp; &lt;&gt;</span></pre>
				<p>例如：</p>
				<pre><span>&nbsp; ... &#39;a&#39; = (SELECT column1 FROM t1)</span></pre>
				<p>有時，子查詢的合法位置只能在比較式的右側，您可以發現，在有些舊的<span>DBMSs</span>中仍保持這一點。</p>
				<p>以下是一個常見格式的子查詢比較的例子。您不能使用聯合進行此類比較。資料表<span>t1</span>中有些值與資料表<span>t2</span>中的最大值相同。該比較可以搜尋出所有這類值：</p>
				<pre><span>SELECT column1 FROM t1</span></pre>
				<pre><span>WHERE column1 = (SELECT MAX(column2) FROM t2);</span></pre>
				<p>下面還有另一個例子，該例子也不可能使用聯合，因為該例子涉及對其中一個資料表進行總計。資料表<span>t1</span>中的有些行含有的值會在給定的列中出現兩次。該例子可以搜尋出所有這些行：</p>
				<pre><span>SELECT * FROM t1 AS t</span></pre>
				<pre><span>WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);</span></pre>
				<p>對於採用這些操作符之一進行的比較，子查詢必須返回一個標量。有一個例外，那就是＝可以和行子查詢同時使用。請參見<a href="sql-syntax.html#row-subqueries" title="13.2.8.5. Row Subqueries">13.2.8.5節，「行子查詢」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="any-in-some-subqueries"></a>
				13.2.8.3.&nbsp;使用ANY, IN和SOME進行子查詢</h4></div></div></div>
				<p>語法：</p>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ANY (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> IN (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> SOME (<span><i>subquery</i></span>)</span></pre>
				<p><span>ANY</span>關鍵詞必須後面接一個比較操作符。<span>ANY</span>關鍵詞的意思是「對於在子查詢返回的列中的任一數值，如果比較結果為<span>TRUE</span>的話，則返回<span>TRUE</span>」。例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);</span></pre>
				<p>假設資料表<span>t1</span>中有一行包含（<span>10</span>）。如果資料表<span>t2</span>包含（<span>21</span>，<span>14</span>，<span>7</span>），則資料表達式為<span>TRUE</span>，因為<span>t2</span>中有一個值為<span>7</span>，該值小於<span>10</span>。如果資料表<span>t2</span>包含（<span>20</span>，<span>10</span>），或者如果資料表<span>t2</span>為空資料表，則資料表達式為<span>FALSE</span>。如果資料表<span>t2</span>包含（<span>NULL, 
				NULL, NULL</span>），則資料表達式為<span>UNKNOWN</span>。</p>
				<p>詞語<span>IN</span>是＝<span>ANY</span>的別名。因此，這兩個語句是一樣的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 IN&nbsp;&nbsp;&nbsp; (SELECT s1 FROM t2);</span></pre>
				<p>不過，<span>NOT IN</span>不是<span>&lt;&gt; ANY</span>的別名，但是是<span>&lt;&gt; 
				ALL</span>的別名。請參見<a href="sql-syntax.html#all-subqueries" title="13.2.8.4. Subqueries with ALL">13.2.8.4節，「使用ALL進行子查詢<code class="literal"></code>」</a>。</p>
				<p>詞語<span>SOME</span>是<span>ANY</span>的別名。因此，這兩個語句是一樣的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY&nbsp; (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);</span></pre>
				<p>使用詞語<span>SOME</span>的機會很少，但是本例顯示了為什麼<span>SOME</span>是有用的。對於多數人來說，英語短語「<span>a 
				is not equal to any b</span>」的意思是「沒有一個<span>b</span>與<span>a</span>相等」，但是在<span>SQL</span>語法中不是這個意思。該語法的意思是「有部分<span>b</span>與<span>a</span>不相等」。使用<span>&lt;&gt; 
				SOME</span>有助於確認每個人都理解該查詢的真正含義。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="all-subqueries"></a>
				13.2.8.4.&nbsp;使用ALL進行子查詢<code class="literal"></code></h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				語法：<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ALL (<span><i>subquery</i></span>)</span></pre>
				<p>詞語<span>ALL</span>必須接在一個比較操作符的後面。<span>ALL</span>的意思是「對於子查詢返回的列中的所有值，如果比較結果為<span>TRUE</span>，則返回<span>TRUE</span>。」例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>假設資料表<span>1</span>中有一行包含（<span>10</span>）。如果資料表<span>t2</span>包含（<span>-5</span>，<span>0</span>，＋<span>5</span>），則資料表達式為<span>TRUE</span>，因為<span>10</span>比<span>t2</span>中的所有三個值都大。如果資料表<span>t2</span>包含（<span>12</span>，<span>6</span>，<span>NULL</span>，－<span>100</span>），則資料表達式為<span>FALSE</span>，因為資料表<span>t2</span>中有一個值<span>12</span>大於<span>10</span>。如果資料表<span>t2</span>包含（<span>0</span>，<span>NULL</span>，<span>1</span>），則資料表達式為<span>unknown</span>。</p>
				<p>最後，如果資料表<span>t2</span>為空資料表，則結果為<span>TRUE</span>。因此，當資料表<span>t2</span>為空資料表時，以下語句為<span>TRUE</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>但是，當資料表<span>t2</span>為空資料表時，本語句為<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);</span></pre>
				<p>另外，當資料表<span>t2</span>為空資料表時，以下語句為<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);</span></pre>
				<p>通常，包含<span>NULL</span>值的資料表和空資料表為「邊緣情況」。當編寫子查詢代碼時，都要考慮您是否把這兩種可能性計算在內。</p>
				<p><span>NOT IN</span>是<span>&lt;&gt; ALL</span>的別名。因此，以下兩個語句是相同的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);</span></pre>
				<h4 class="title"><a name="row-subqueries"></a>13.2.8.5.&nbsp;行子查詢</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				對於本點的討論屬於標量或列子查詢，即返回一個單一值或一列值的子查詢。行子查詢是一個能返回一個單一行的子查詢變數，因此可以返回一個以上的列值。以下是兩個例子：<pre><span>SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<pre><span>SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<p>如果在資料表<span>t2</span>的一個行中，<span>column1=1</span>並且<span>column2=2</span>，則查詢結果均為<span>TRUE</span>。</p>
				<p>資料表達式（<span>1</span>，<span>2</span>）和<span>ROW</span>（<span>1</span>，<span>2</span>）有時被稱為行構造符。兩者是等同的，在其它的語境中，也是合法的。例如，以下兩個語句在語義上是等同的（但是目前只有第二個語句可以被最佳化）：</p>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE (column1,column2) = (1,1);</span></pre>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;</span></pre>
				<p>行構造符通常用於與對能返回兩個或兩個以上列的子查詢進行比較。例如，以下查詢可以答覆請求，「在資料表<span>t1</span>中搜尋同時也存在於資料表<span>t2</span>中的所有的行」：</p>
				<pre><span>SELECT column1,column2,column3</span></pre>
				<pre><span>FROM t1</span></pre>
				<pre><span>WHERE (column1,column2,column3) IN</span></pre>
				<pre><span>(SELECT column1,column2,column3 FROM t2);</span></pre>
				<h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.8.6. EXISTS和NOT 
				EXISTS</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				如果一個子查詢返回任何的行，則<span>EXISTS
				<span><i>subquery</i></span></span>為<span>FALSE</span>。例如：<pre><span>SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);</span></pre>
				<p>過去，<span>EXISTS</span>子查詢以<span>SELECT *</span>為開始，但是可以以<span>SELECT 
				5</span>或<span>SELECT column1</span>或其它的為開始。<span>MySQL</span>在這類子查詢中忽略了<span>SELECT</span>清單，因此沒有區別。</p>
				<p>對於前面的例子，如果<span>t2</span>包含任何行，即使是只含有<span>NULL</span>值的行，<span>EXISTS</span>條件也為<span>TRUE</span>。這實際上是一個不可能的例子，因為基本上所有的<span>[NOT] 
				EXISTS</span>子查詢均包含關聯。以下是一些更現實的例子：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些種類的商店出現在一個或多個城市裡？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些種類的商店沒有出現在任何城市裡？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些種類的商店出現在所有城市裡？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores s1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.city = cities.city</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND cities_stores.store_type = stores.store_type));</span></pre>
				<p>最後一個例子是一個雙嵌套<span>NOT EXISTS</span>查詢。也就是，該查詢包含一個<span>NOT 
				EXISTS</span>子句，該子句又包含在一個<span>NOT EXISTS</span>子句中。該查詢正式地回答了這個問題，「是否有某個城市擁有沒有列在<span>Stores</span>中的商店？」。可以比較容易的說，一個帶嵌套的<span>NOT 
				EXISTS</span>可以回答這樣的問題，「是否對於所有的<span>y</span>，<span>x</span>都為<span>TRUE</span>？」</p>
				<h4 class="title"><a name="correlated-subqueries"></a>
				13.2.8.7.&nbsp;關聯子查詢</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				相關聯的子查詢是一個包含對資料表的引用的子查詢。該資料表也顯示在外部查詢中。例如：<pre><span>SELECT * FROM t1 WHERE column1 = ANY</span></pre>
				<pre><span>(SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);</span></pre>
				<p>注意，即使子查詢的<span>FROM</span>子句不提及資料表<span>t1</span>，該子查詢也會包含一個對<span>t1</span>中一列的引用。所以，<span>MySQL</span>看上去位於子查詢的外部，並在外部查詢中搜尋<span>t1</span>。</p>
				<p>假設資料表<span>t1</span>包含一行，在此行中<span>column1=5</span>並且<span>column2=6</span>；同時，資料表<span>t2</span>包含一行，在此行中<span>column1=5</span>並且<span>column2=7</span>。簡單的資料表達式<span><span>... 
				WHERE column1 = ANY (SELECT column1 FROM t2)</span>會為<span>TRUE</span>。但是在本例中，在子查詢中的<span>WHERE</span>子句為<span>FALSE</span>（因為（<span>5</span>，<span>6</span>）不等於（<span>5</span>，<span>7</span>）），所以子查詢總體上為<span>FALSE</span>。</span></p>
				<p>範圍劃分規則：<span>MySQL</span>從內到外進行評估。例如：</p>
				<pre><span>SELECT column1 FROM t1 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t2 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t3</span></pre>
				<pre><span>WHERE x.column2 = t3.column1));</span></pre>
				<p>在本語句中，<span>x.column2</span>必須是資料表<span>t2</span>中的列，因為<span><span>SELECT 
				column1 FROM t2 AS x ...</span>對<span>t2</span>進行了重命名。它不是資料表<span>t1</span>中的列，因為<span>SELECT 
				column1 FROM t1 ...</span>是一個更靠外的外部查詢。</span></p>
				<p>對於<span>HAVING</span>或<span>ORDER BY</span>子句中的子查詢，<span>MySQL</span>也會在外部選擇清單中尋找列名稱。</p>
				<p>對於特定的情況，相關聯的子查詢被最佳化。例如：</p>
				<pre><span><i><span>val</span></i></span><span> IN (SELECT <span><i>key_val</i></span> FROM <span><i>tbl_name</i></span> WHERE <span><i>correlated_condition</i></span>)</span></pre>
				<p>否則，這些子查詢效率不高，可能速度會慢。把查詢作為聯合進行改寫可能會改進效率。</p>
				<p>相關聯的子查詢不能從外部查詢中引用總計函數的結果。</p>
				<h4 class="title"><a name="unnamed-views"></a>
				13.2.8.8.&nbsp;FROM子句中的子查詢<code class="literal"></code></h4></div></div></div><a class="indexterm" name="id2909893"></a><a class="indexterm" name="id2909900"></a>
				<p>在<span>SELECT</span>語句的<span>FROM</span>子句中，子查詢是合法的。實際的語法是：</p>
				<pre><span>SELECT ... FROM (<span><i>subquery</i></span>) [AS] <span><i>name</i></span> ...</span></pre>
				<p><span>[AS]<span><i> name</i></span></span>子句是強制性的，因為<span>FROM</span>子句中的每個資料表必須有一個名稱。在子查詢選擇列資料表中的任何列都必須有唯一的名稱。您可以在本手冊中的其它地方找到對本語法的說明。在該處，所用的詞語是「導出資料表」。</p>
				<p>為了進行詳細說明，假設您有如下一個資料表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);</span></pre>
				<p>下面使用了示範資料表，解釋了在<span>FROM</span>子句中如何使用子查詢：</p>
				<pre><span>INSERT INTO t1 VALUES (1,&#39;1&#39;,1.0);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (2,&#39;2&#39;,2.0);</span></pre>
				<pre><span>SELECT sb1,sb2,sb3</span></pre>
				<pre><span>FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb</span></pre>
				<pre><span>WHERE sb1 &gt; 1;</span></pre>
				<p>結果：<span>2, &#39;2&#39;, 4.0</span>。</p>
				<p>下面是另一個例子：假設您想瞭解一個分類後的資料表的一組和的平均值。採用如下操作：</p>
				<pre><span>SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;</span></pre>
				<p>不過，本查詢提供所需的訊息：</p>
				<pre><span>SELECT AVG(sum_column1)</span></pre>
				<pre><span>FROM (SELECT SUM(column1) AS sum_column1</span></pre>
				<pre><span>FROM t1 GROUP BY column1) AS t1;</span></pre>
				<p>注意，在子查詢中使用的列名稱（<span>sum_column1</span>）被整理到外部查詢中。</p>
				<p><span>FROM</span>子句中的子查詢可以返回標量、列、行或資料表。<span>FROM</span>子句中的子查詢不能為有關聯的子查詢。</p>
				<p>即使對<span>EXPLAIN</span>語句（即建立臨時導出資料表），<span>FROM</span>子句中的子查詢也會被執行。這是因為在最佳化過程中，上一級的查詢需要有關所有資料表的訊息。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="subquery-errors"></a>
							13.2.8.9.&nbsp;子查詢錯誤</h4></div></div></div>
				<p>以下錯誤只適用於子查詢。本節把這些錯誤歸在一起。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>來自子查詢的列的數目不正確</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1241 (ER_OPERAND_COL)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Operand should contain 1 column(s)&quot;</span></pre>
				<p>在出現以下情況時，發生此錯誤：</p>
				<pre><span>SELECT (SELECT column1, column2 FROM t2) FROM t1;</span></pre>
				<p>如果您的目的是進行比較，您可以使用能返回多個列的子查詢。請參見<a href="sql-syntax.html#row-subqueries" title="13.2.8.5. Row Subqueries">13.2.8.5節，「行子查詢」</a>。不過，在其它的語境下，子查詢必須為標量操作數。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>來自子查詢的行的數目不正確：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1242 (ER_SUBSELECT_NO_1_ROW)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Subquery returns more than 1 row&quot;</span></pre>
				<p>
				如果在語句中，子查詢返回的行多於一個，則發生此錯誤。請考慮以下例子：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
				<p>如果<span>SELECT column1 
				FROM t2</span>只返回一行，則將執行以前的查詢。如果子查詢返回的行多於一個，則將出現錯誤<span>1242</span>。在這種情況下，該查詢將被改寫為：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在子查詢中資料表格使用不正確：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Error 1093 (ER_UPDATE_TABLE_USED)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = HY000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;You can&#39;t specify target table &#39;x&#39;</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>for update in FROM clause&quot;</span></pre>
				<p>在如下情況下，發生該錯誤：</p>
				<pre><span>UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);</span></pre>
				<p>和<span>SELECT</span>語句一樣，在<span>UPDATE</span>和<span>DELETE</span>語句中，子查詢是合法的。所以您可以在<span>UPDATE</span>語句中使用子查詢進行賦值。不過，您不能把同一個資料表（在本例中為資料表<span>t1</span>）既用於子查詢的<span>FROM</span>子句，又用於更新目標。</p>
				<p>對於事務儲存引擎，子查詢的錯誤會導致整個語句失效。對於非事務儲存引擎，在遇到錯誤之前進行的數據修訂會被保留。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-subqueries"></a>
				13.2.8.10.&nbsp;最佳化子查詢</h4></div></div></div>
				<p>開發過程不斷進展，所以從長遠來看，沒有一個可靠的最佳化技巧。有些技巧您可能會感興趣，並原意採用：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>有些子句會影響在子查詢中的行的數量和順序。使用這類子句。例如：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT column1 FROM t2 ORDER BY column1);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT DISTINCT column1 FROM t2);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE EXISTS</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT * FROM t2 LIMIT 1);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>用子查詢替換聯合。例如，試進行如下操作：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT column1 FROM t2);</span></pre>
				<p>代替如下操作：</p>
				<pre><span>SELECT DISTINCT t1.column1 FROM t1, t2</span></pre>
				<pre><span>WHERE t1.column1 = t2.column1;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>部分子查詢可以被轉換為聯合，以便與不支援子查詢的舊版本的<span>MySQL</span>相兼容。不過，在有些情況下，把子查詢轉化為聯合可以提高效果。請參見<a href="sql-syntax.html#rewriting-subqueries" title="13.2.8.11. Rewriting Subqueries as Joins for Earlier MySQL Versions">13.2.8.11節，「把子查詢作為用於早期MySQL版本的聯合進行改寫」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>把子句從子查詢的外部轉移到內部。例如，使用此查詢：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);</span></pre>
				<p>代替此查詢：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);</span></pre>
				<p>另一個例子是，使用此查詢：</p>
				<pre><span>SELECT (SELECT column1 + 5 FROM t1) FROM t2;</span></pre>
				<p>代替此查詢：</p>
				<pre><span>SELECT (SELECT column1 FROM t1) + 5 FROM t2;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>使用行子查詢，代替關聯子查詢。舉例說明，使用此查詢：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);</span></pre>
				<p>代替此查詢：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1</span></pre>
				<pre><span>AND t2.column2=t1.column2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				NOT (a = ANY (...))</span> rather than
				<span>a &lt;&gt; ALL (...)</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				x = ANY (table containing (1,2))</span> rather than
				<span>x=1 OR x=2</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				= ANY</span> rather than <span>EXISTS</span>.
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於只返回一行的無關聯子查詢，<span>IN</span>的速度慢於＝。舉例說明，使用此查詢：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>= (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>代替此查詢：</p>
				<pre><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>IN (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>使用這些技巧可以使程式更快或更慢。使用<span>BENCHMARK()</span>函數等<span>MySQL</span>工具，您可以瞭解到在您所處的情況下，哪些技巧會有幫助。</p>
				<p><span>MySQL</span>本身進行的部分最佳化包括：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>只執行一次無關聯子查詢。使用<span>EXPLAIN</span>確認給定的子查詢確實是無關聯的。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>改寫<span>IN, 
				ALL, ANY</span>和<span>SOME</span>子查詢，目的是如果子查詢中的<span>select-list</span>列已編製索引，則能發揮出此優勢。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>使用<span>index-lookup</span>函數代替以下格式的子查詢。<span>EXPLAIN</span>把此函數描述為特殊的聯合類型（<span>unique_subquery</span>或<span>index_subquery</span>）：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>... IN (SELECT <span><i>indexed_column</i></span> FROM <span><i>single_table</i></span> ...)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>當資料表達式中不包含<span>NULL</span>值或空集時，<span>MySQL</span>使用一個包含<span>MIN()</span>或<span>MAX()</span>的資料表達式，對以下格式的資料表達式進行延伸：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>value</span></i></span><span> {ALL|ANY|SOME} {&gt; | &lt; | &gt;= | &lt;=} (<span><i>non-correlated subquery</i></span>)</span></pre>
				<p>例如，本<span>WHERE</span>子句：</p>
				<pre><span>WHERE 5 &gt; ALL (SELECT x FROM t)</span></pre>
				<p>可以用最佳化符進行如下處理：</p>
				<pre><span>WHERE 5 &gt; (SELECT MAX(x) FROM t)</span></pre>
				<p>在<span>MySQL</span>內部手冊中有一章名為「<span>MySQL</span>如何轉換子查詢」，可以從<span><a target="_top"  href="http://dev.mysql.com/doc/">http://dev.mysql.com/doc/</a></span>獲取。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rewriting-subqueries"></a>
				13.2.8.11.&nbsp;把子查詢作為用於早期MySQL版本的聯合進行改寫</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			在較早版本的<span>MySQL</span>中（早於<span>MySQL 4.1</span>），只支援<span>INSERT...SELECT</span>和<span>REPLACE...SELECT...</span>格式的帶嵌套的查詢。雖然在<span>MySQL 
			5.1</span>中沒有這種情況，但有時，仍然有其它的方法測試一組值的從屬關係。並且，在有些情況下，不僅可以在沒有子查詢時對查詢進行改寫，而且有時使用這些方法比使用子查詢效率更高。這些方法之一是<span>IN()</span>結構：<p>
			舉例說明，本查詢：</p>
			<pre><span>SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);</span></pre>
			<p>可以被改寫為：</p>
			<pre><span>SELECT DISTINCT t1.* FROM t1, t2 WHERE t1.id=t2.id;</span></pre>
			<p>以下查詢：</p>
			<pre><span>SELECT * FROM t1 WHERE id NOT IN (SELECT id FROM t2);</span></pre>
			<pre><span>SELECT * FROM t1 WHERE NOT EXISTS (SELECT id FROM t2 WHERE t1.id=t2.id);</span></pre>
			<p>也可以使用<span>IN()</span>進行改寫：</p>
			<pre><span>SELECT table1.* FROM table1 LEFT JOIN table2 ON table1.id=table2.id</span></pre>
			<pre><span>WHERE table2.id IS NULL;</span></pre>
			<p><span>LEFT [OUTER] JOIN</span>可以比對應的子查詢更快，因為伺服器可能對其進行更好的最佳化——這一點對於單獨的<span>MySQL</span>伺服器並不明確。在<span>SQL-92</span>之前，不存在外部聯合，因此在做某些事情時，子查詢是唯一的方法。現在，<span>MySQL</span>伺服器和其它許多先進的資料庫系統都能提供多種的外部聯合類型。</p>
			<p><span>MySQL</span>支援<span>multiple-table 
			DELETE</span>語句，該語句可以被用於高效地刪除行。刪除時依據來自一個資料表或同時來自多個資料表的訊息。同時也支援<span>Multiple-table 
			UPDATE</span>語句。</p>
			<h3 class="title"><a name="truncate"></a>13.2.9. TRUNCATE語法</h3></div></div></div><a class="indexterm" name="id2910732"></a></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>TRUNCATE [TABLE] <span><i>tbl_name</i></span></span></pre>
			<p><span>TRUNCATE TABLE</span>用於完全清空一個資料表。從邏輯上說，該語句與用於刪除所有行的<span>DELETE</span>語句等同，但是在有些情況下，兩者在使用上有所不同。</p>
			<p>對於<span>InnoDB</span>資料表，如果有需要引用資料表的外部鍵限制，則<span>TRUNCATE 
			TABLE</span>被映射到<span>DELETE</span>上；否則使用快速刪減（取消和重新建立資料表）。使用<span>TRUNCATE 
			TABLE</span>重新設置<span>AUTO_INCREMENT</span>計數器，設置時不考慮是否有外部鍵限制。</p>
			<p>對於其它儲存引擎，在<span>MySQL 5.1</span>中，<span>TRUNCATE 
			TABLE</span>與<span>DELETE FROM</span>有以下幾處不同：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>刪減操作會取消並重新建立資料表，這比一行一行的刪除行要快很多。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>刪減操作不能保證對事務是安全的；在進行事務處理和資料表鎖定的過程中嘗試進行刪減，會發生錯誤。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被刪除的行的數目沒有被返回。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只要資料表定義檔案<span><i><span>tbl_name</span></i><span>.frm</span></span>是合法的，則可以使用<span>TRUNCATE 
			TABLE</span>把資料表重新建立為一個空資料表，即使數據或索引檔案已經被破壞。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表管理程式不記得最後被使用的<span>AUTO_INCREMENT</span>值，但是會從頭開始計數。即使對於<span>MyISAM</span>和<span>InnoDB</span>也是如此。<span>MyISAM</span>和<span>InnoDB</span>通常不再次使用序列值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當被用於帶分區的資料表時，<span>TRUNCATE TABLE</span>會保留分區；即，數據和索引檔案被取消並重新建立，同時分區定義（<span>.par</span>）檔案不受影響。</p>
			<p><span>TRUNCATE TABLE</span>是在<span>MySQL</span>中採用的一個<span>Oracle 
			SQL</span>延伸。</p>
			<h3 class="title"><a name="update"></a>13.2.10. UPDATE語法</h3></div></div></div><a class="indexterm" name="id2910933"></a>
			<p><span>Single-table</span>語法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp; &nbsp;[WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p><span>Multiple-table</span>語法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span>UPDATE</span>語法可以用新值更新原有資料表行中的各列。<span>SET</span>子句指示要修改哪些列和要給予哪些值。<span>WHERE</span>子句指定應更新哪些行。如果沒有<span>WHERE</span>子句，則更新所有的行。如果指定了<span>ORDER 
			BY</span>子句，則按照被指定的順序對行進行更新。<span>LIMIT</span>子句用於給定一個限值，限制可以被更新的行的數目。</p>
			<p><span>UPDATE</span>語句支援以下修飾符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>關鍵詞，則<span>UPDATE</span>的執行被延遲了，直到沒有其它的客戶端從資料表中讀取為止。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>IGNORE</span>關鍵詞，則即使在更新過程中出現錯誤，更新語句也不會中斷。如果出現了重複關鍵字衝突，則這些行不會被更新。如果列被更新後，新值會導致數據轉化錯誤，則這些行被更新為最接近的合法的值。</p>
			<p>如果您在一個資料表達式中通過<span><i><span>tbl_name</span></i></span>訪問一列，則<span>UPDATE</span>使用列中的當前值。例如，以下語句把年齡列設置為比當前值多一：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age+1;</b></span></span></pre>
			<p><span>UPDATE</span>賦值被從左到右評估。例如，以下語句對年齡列加倍，然後再進行增加：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age*2, age=age+1;</b></span></span></pre>
			<p>如果您把一列設置為其當前含有的值，則<span>MySQL</span>會注意到這一點，但不會更新。</p>
			<p>如果您把被已定義為<span>NOT NULL</span>的列更新為<span>NULL</span>，則該列被設置到與列類型對應的預設值，並且累加警告數。對於數字類型，預設值為<span>0</span>；對於字串類型，預設值為空字串<span>(<span>&#39;&#39;</span>)</span>；對於日期和時間類型，預設值為「<span>zero</span>」值。</p>
			<p><span>UPDATE</span>會返回實際被改變的行的數目。<span>Mysql_info() 
			C API</span>函數可以返回被匹配和被更新的行的數目，以及在<span>UPDATE</span>過程中產生的警告的數量。</p>
			<p>您可以使用<span>LIMIT <i>
			row_count</i></span>來限定<span>UPDATE</span>的範圍。<span>LIMIT</span>子句是一個與行匹配的限定。只要發現可以滿足<span>WHERE</span>子句的<span><i><span>row_count</span></i></span>行，則該語句中止，不論這些行是否被改變。</p>
			<p>如果一個<span>UPDATE</span>語句包括一個<span>ORDER BY</span>子句，則按照由子句指定的順序更新行。</p>
			<p>您也可以執行包括多個資料表的<span>UPDATE</span>操作。<span><i><span>table_references</span></i></span>子句列出了在聯合中包含的資料表。該語法在<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>中進行了說明。以下是一個例子：</p>
			<pre><span>UPDATE items,month SET items.price=month.price</span></pre>
			<pre><span>WHERE items.id=month.id;</span></pre>
			<p>以上的例子顯示出了使用逗號操作符的內部聯合，但是<span>multiple-table UPDATE</span>語句可以使用在<span>SELECT</span>語句中允許的任何類型的聯合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>註釋：您不能把<span>ORDER BY</span>或<span>LIMIT</span>與<span>multiple-table 
			UPDATE</span>同時使用。</p>
			<p>在一個被更改的<span>multiple-table UPDATE</span>中，有些列被引用。您只需要這些列的<span>UPDATE</span>權限。有些列被讀取了，但是沒被修改。您只需要這些列的<span>SELECT</span>權限。</p>
			<p>如果您使用的<span>multiple-table UPDATE</span>語句中包含帶有外部鍵限制的<span>InnoDB</span>資料表，則<span>MySQL</span>最佳化符處理資料表的順序可能與上下層級關係的順序不同。在此情況下，語句無效並被
			回滾。同時，更新一個單一資料表，並且依靠<span>ON 
			UPDATE</span>功能。該功能由<span>InnoDB</span>提供，用於對其它資料表進行相應的修改。請參見<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4節，「FOREIGN 
		KEY約束」</a>。</p>
			<p>目前，您不能在一個子查詢中更新一個資料表，同時從同一個資料表中選擇。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="basic-user-commands"></a>
		13.3.&nbsp;MySQL實用工具語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.3.1. 
			DESCRIBE語法（獲取有關列的訊息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.3.2. 
			USE語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="describe"></a>13.3.1. DESCRIBE語法（獲取有關列的訊息）</h3></div></div></div><a class="indexterm" name="id2911402"></a><a class="indexterm" name="id2911411"></a>
			<pre><span>{DESCRIBE | DESC} <span><i>tbl_name</i></span> [<span><i>col_name</i></span> | <span><i>wild</i></span>]</span></pre>
			<p><span>DESCRIBE</span>可以提供有關資料表中各列的訊息。它是<span>SHOW 
			COLUMNS FROM</span>的快捷方式。這些語句也可以顯示語句，用於閱覽。</p>
			<p>見<a href="sql-syntax.html#show-columns" title="13.5.4.3. SHOW COLUMNS Syntax">13.5.4.3節，「SHOW 
		COLUMNS語法」</a>。</p>
			<p><span><i><span>col_name</span></i></span>可以是一個列名稱，或一個包含『％』和『<span>_</span>』的通配符的字串，用於獲得對於帶有與字串相匹配的名稱的各列的輸出。沒有必要在引號中包含字串，除非其中包含空格或其它特殊字元。</p>
			<pre><span>mysql&gt; <span><b>DESCRIBE city;</b></span></span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Field&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;| Type&nbsp;&nbsp;&nbsp;&nbsp; | Null | Key | Default | Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | int(11)&nbsp; | NO&nbsp;&nbsp; | PRI | NULL&nbsp;&nbsp;&nbsp; | auto_increment |</span></pre>
			<pre><span>| Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | char(35) | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Country&nbsp;&nbsp;&nbsp; | char(3)&nbsp; | NO&nbsp;&nbsp; | UNI |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| District&nbsp;&nbsp; | char(20) | YES&nbsp; | MUL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Population | int(11)&nbsp; | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>5 rows in set (0.00 sec)</span></pre>
			<p><span>NULL</span>字段指示是否<span>NULL</span>可以被儲存在列中。</p>
			<p><span>Key</span>字段指示是否該列已編製索引。<span>PRI</span>的值指示該列是資料表的主鍵的一部分。<span>UNI</span>指示，該列是<span>UNIQUE</span>索引的一部分。<span>MUL</span>值指示，在列中某個給定值多次出現是允許的。</p>
			<p><span>MUL</span>將被顯示在<span>UNIQUE</span>索引中，原因之一是多個列會組合成一個復合<span>UNIQUE</span>索引；儘管列的組合是唯一的，但每個列仍可以多次出現同一個給定值。注意，在復合索引中，只有索引最左邊的列可以進入<span>Key</span>字段中。</p>
			<p>預設字段指示，預設值被賦予該列。</p>
			<p><span>Extra</span>字段包含可以獲取的與給定列有關的附加訊息。在我們的例子中，<span>Extra</span>字段指示，<span>Id</span>列使用<span>AUTO_INCREMENT</span>關鍵詞建立。</p>
			<p>如果列類型與您預計的依據<span>CREATE TABLE</span>語句得出的列類型不同，則請注意，<span>MySQL</span>有時會改變列類型。請參見<a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1節，「沉寂的列規格變更」</a>。</p>
			<p><span>DESCRIBE</span>語句被設立出來，用於與<span>Oracle</span>相兼容。</p>
			<p><span>SHOW CREATE TABLE</span>和<span>SHOW 
			TABLE STATUS</span>語句也可以提供有關資料表的訊息。請參見<a href="sql-syntax.html#show" title="13.5.4. SHOW Syntax">13.5.4節，「SHOW語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="use"></a>13.3.2. USE語法</h3></div></div></div><a class="indexterm" name="id2911699"></a>
			<pre><span>USE <span><i>db_name</i></span></span></pre>
			<p><span>USE <i>db_name</i></span>語句可以通告<span>MySQL</span>把<span><i><span>db_name</span></i></span>資料庫作為預設（當前）資料庫使用，用於後續語句。該資料庫保持為預設資料庫，直到語段的結尾，或者直到發佈一個不同的<span>USE</span>語句：</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(*) FROM mytable;&nbsp;&nbsp; # selects from db1.mytable</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>USE db2;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(*) FROM mytable;&nbsp;&nbsp; # selects from db2.mytable</b></span></span></pre>
			<p>使用<span>USE</span>語句為一個特定的當前的資料庫做標記，不會阻礙您訪問其它資料庫中的資料表。下面的例子可以從<span>db1</span>資料庫訪問作者資料表，並從<span>db2</span>資料庫訪問編輯資料表：</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT author_name,editor_name FROM author,db2.editor</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE author.editor_id = db2.editor.editor_id;</b></span></span></pre>
			<p><span>USE</span>語句被設立出來，用於與<span>Sybase</span>相兼容。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="transactional-commands"></a>
		13.4.&nbsp;MySQL事務處理和鎖定語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.4.1. 
			START TRANSACTION, COMMIT和ROLLBACK語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">
			13.4.2. 不能回滾的語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">
			13.4.3. 會造成隱式提交的語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoints">13.4.4. 
			SAVEPOINT和ROLLBACK TO SAVEPOINT語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.4.5. 
			LOCK TABLES和UNLOCK TABLES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.4.6. 
			SET TRANSACTION語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">
			13.4.7. XA事務</a></span></dt></dl></div>
		<p><span>MySQL</span>通過<span>SET AUTOCOMMIT, START 
		TRANSACTION, COMMIT</span>和<span>ROLLBACK</span>等語句支援本地事務（在給定的客戶端連接中）。請參見<a href="sql-syntax.html#commit" title="13.4.1. START TRANSACTION, COMMIT, and ROLLBACK Syntax">13.4.1節，「START 
		TRANSACTION, COMMIT和ROLLBACK語法」</a>。<span>XA</span>事務支援還可以允許<span>MySQL</span>參與分佈式事務。請參見<a href="sql-syntax.html#xa" title="13.4.7. XA Transactions">13.4.7節，「XA事務」</a>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="commit"></a>13.4.1. START 
			TRANSACTION, COMMIT和ROLLBACK語法</h3></div></div></div><a class="indexterm" name="id2911894"></a><a class="indexterm" name="id2911903"></a><a class="indexterm" name="id2911912"></a><a class="indexterm" name="id2911921"></a>
			<pre><span>START TRANSACTION | BEGIN [WORK]</span></pre>
			<pre><span>COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]</span></pre>
			<pre><span>ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]</span></pre>
			<pre><span>SET AUTOCOMMIT = {0 | 1}</span></pre>
			<p><span>START TRANSACTION</span>或<span>BEGIN</span>語句可以開始一項新的事務。<span>COMMIT</span>可以提交當前事務，是變更成為永久變更。<span>ROLLBACK</span>可以
			回滾當前事務，取消其變更。<span>SET 
			AUTOCOMMIT</span>語句可以禁用或啟用預設的<span>autocommit</span>模式，用於當前連接。</p>
			<p>自選的<span>WORK</span>關鍵詞被支援，用於<span>COMMIT</span>和<span>RELEASE</span>，與<span>CHAIN</span>和<span>RELEASE</span>子句。<span>CHAIN</span>和<span>RELEASE</span>可以被用於對事務完成進行附加控制。<span>Completion_type</span>系統變數的值決定了預設完成的性質。請參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。</p>
			<p><span>AND CHAIN</span>子句會在當前事務結束時，立刻啟動一個新事務，並且新事務與剛結束的事務有相同的隔離等級。<span>RELEASE</span>子句在終止了當前事務後，會讓伺服器中斷與當前客戶端的連接。包含<span>NO</span>關鍵詞可以抑制<span>CHAIN</span>或<span>RELEASE</span>完成。如果<span>completion_type</span>系統變數被設置為一定的值，使連鎖或釋放完成可以預設進行，此時<span>NO</span>關鍵詞有用。</p>
			<p>預設情況下，<span>MySQL</span>採用<span>autocommit</span>模式運行。這意味著，當您執行一個用於更新（修改）資料表的語句之後，<span>MySQL</span>立刻把更新儲存到磁盤中。</p>
			<p>如果您正在使用一個事務安全型的儲存引擎（如<span>InnoDB, BDB</span>或<span>NDB</span>叢集），則您可以使用以下語句禁用<span>autocommit</span>模式：</p>
			<pre><span>SET AUTOCOMMIT=0;</span></pre>
			<p>通過把<span>AUTOCOMMIT</span>變數設置為零，禁用<span>autocommit</span>模式之後，您必須使用<span>COMMIT</span>把變更儲存到磁盤中，或著如果您想要忽略從事務開始進行以來做出的變更，使用<span>ROLLBACK</span>。</p>
			<p>如果您想要對於一個單一系列的語句禁用<span>autocommit</span>模式，則您可以使用<span>START 
			TRANSACTION</span>語句：</p>
			<pre><span>START TRANSACTION;</span></pre>
			<pre><span>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;</span></pre>
			<pre><span>UPDATE table2 SET summary=@A WHERE type=1;</span></pre>
			<pre><span>COMMIT;</span></pre>
			<p>使用<span>START TRANSACTION</span>，<span>autocommit</span>仍然被禁用，直到您使用<span>COMMIT</span>或<span>ROLLBACK</span>結束事務為止。然後<span>autocommit</span>模式恢復到原來的狀態。</p>
			<p><span>BEGIN</span>和<span>BEGIN WORK</span>被作為<span>START 
			TRANSACTION</span>的別名受到支援，用於對事務進行初始化。<span>START 
			TRANSACTION</span>是標準的<span>SQL</span>語法，並且是啟動一個<span>ad-hoc</span>事務的推薦方法。<span>BEGIN</span>語句與<span>BEGIN</span>關鍵詞的使用不同。<span>BEGIN</span>關鍵詞可以啟動一個<span>BEGIN...END</span>復合語句。後者不會開始一項事務。請參見<a href="stored-procedures.html#begin-end" title="20.2.7. BEGIN ... END Compound Statement">20.2.7節，「BEGIN 
		... END復合語句」</a>。</p>
			<p>您也可以按照如下方法開始一項事務：</p>
			<pre><span>START TRANSACTION WITH CONSISTENT SNAPSHOT;</span></pre>
			<p><span>WITH CONSISTENT SNAPSHOT</span>子句用於啟動一個一致的讀取，用於具有此類功能的儲存引擎。目前，該子句只適用於<span>InnoDB</span>。該子句的效果與發佈一個<span>START 
			TRANSACTION</span>，後面跟一個來自任何<span>InnoDB</span>資料表的<span>SELECT</span>的效果一樣。請參見<a href="storage-engines.html#innodb-consistent-read" title="15.2.10.4. Consistent Non-Locking Read">15.2.10.4節，「一致的非鎖定讀」</a>。</p>
			<p>開始一項事務會造成一個隱含的<span>UNLOCK TABLES</span>被執行。</p>
			<p>為了獲得最好的結果，事務應只使用由單一事務儲存引擎管理的資料表執行。否則，會出現以下問題：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用的資料表來自多個事務安全型儲存引擎（例如<span>InnoDB</span>和<span>BDB</span>），並且事務隔離等級不是<span>SERIALIZABLE</span>，則有可能當一個事務提交時，其它正在進行中的、使用同樣的資料表的事務將只會發生由第一個事務產生的變更。也就是，用混合引擎不能保證事務的原子性，並會造成不一致。（如果混合引擎事務不經常有，則您可以根據需要使用<span>SET 
			TRANSACTION ISOLATION LEVEL</span>把隔離等級設置到<span>SERIALIZABLE</span>。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您在事務中使用非事務安全型資料表，則對這些資料表的任何變更被立刻儲存，不論<span>autocommit</span>模式的狀態如何。</p>
			<p>如果您在更新了事務中一個事務資料表之後，發佈一個<span>ROLLBACK</span>語句，則會出現一個<span>ER_WARNING_NOT_COMPLETE_ROLLBACK</span>警告。對事務安全型資料表的變更被
			回滾，但是對非事務安全型資料表沒有變更。</p>
			<p>每個事務被儲存在一個組塊中的二進制日誌中，在<span>COMMIT</span>之上。被回滾的事務不被計入日誌。（例外情況：對非事務資料表的更改不會被
			回滾。如果一個被回滾的事務包括對非事務資料表的更改，則整個事務使用一個在末端的<span>ROLLBACK</span>語句計入日誌，以確保對這些資料表的更改進行複製。）見<a href="database-administration.html#binary-log" title="5.11.3. The Binary Log">5.11.3節，「二進制日誌」</a>。</p>
			<p>您可以使用<span>SET TRANSACTION ISOLATION LEVEL</span>更改事務的隔離等級。請參見<a href="sql-syntax.html#set-transaction" title="13.4.6. SET TRANSACTION Syntax">13.4.6節，「SET 
		TRANSACTION語法」</a>。</p>
			<p>回滾可以慢速運行。在用戶沒有明確要求時，也可以進行回滾（例如，當錯誤發生時）。因此，在明確地和隱含的（<span>ROLLBACK 
			SQL</span>命令）回滾時，<span>SHOW PROCESSLIST</span>會在<span>Stage</span>列中顯示<span>Rolling 
			back</span>，用於連接。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cannot-roll-back"></a>
			13.4.2.&nbsp;不能回滾的語句</h3></div></div></div>
			<p>有些語句不能被回滾。通常，這些語句包括數據定義語言（<span>DDL</span>）語句，比如建立或取消資料庫的語句，和建立、取消或更改資料表或儲存的子程式的語句。</p>
			<p>
			您在設計事務時，不應包含這類語句。如果您在事務的前部中發佈了一個不能被回滾的語句，則後部的其它語句會發生錯誤，在這些情況下，通過發佈<span>ROLLBACK</span>語句不能
			回滾事務的全部效果。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="implicit-commit"></a>
			13.4.3.&nbsp;會造成隱式提交的語句</h3></div></div></div>
			<p>以下語句（以及同義詞）均隱含地結束一個事務，似乎是在執行本語句前，您已經進行了一個<span>COMMIT</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER 
			FUNCTION</span><span>,
			<span>ALTER PROCEDURE</span>,
			<span>ALTER TABLE</span>,
			<span>BEGIN</span>,
			<span>CREATE DATABASE</span>,
			<span>CREATE FUNCTION</span>,
			<span>CREATE INDEX</span>,
			<span>CREATE PROCEDURE</span>,
			<span>CREATE TABLE</span>,
			<span>DROP DATABASE</span>,
			<span>DROP FUNCTION</span>,
			<span>DROP INDEX</span>,
			<span>DROP PROCEDURE</span>,
			<span>DROP TABLE</span>,
			<span>LOAD MASTER DATA</span>,
			<span>LOCK TABLES</span>,
			<span>RENAME TABLE</span>,
			<span>SET AUTOCOMMIT=1</span>,
			<span>START TRANSACTION</span>,
			<span>TRUNCATE TABLE</span>,
			<span>UNLOCK TABLES</span>. </span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當當前所有的資料表均被鎖定時，<span>UNLOCK TABLES</span>可以提交事務。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CREATE 
			TABLE</span><span>, <span>
			CREATE DATABASE</span> <span>DROP DATABASE</span>,
			<span>TRUNCATE TABLE</span>,
			<span>ALTER FUNCTION</span>,
			<span>ALTER PROCEDURE</span>,
			<span>CREATE FUNCTION</span>,
			<span>CREATE PROCEDURE</span>,
			<span>DROP FUNCTION</span></span>和<span><span>DROP 
			PROCEDURE</span>等語句會導致一個隱含提交。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>InnoDB</span>中的<span>CREATE 
			TABLE</span>語句被作為一個單一事務進行處理。這意味著，來自用戶的<span>ROLLBACK</span>不會撤銷用戶在事務處理過程中建立的<span>CREATE 
			TABLE</span>語句。</p>
			<p>事務不能被嵌套。這是隱含<span>COMMIT</span>的結果。當您發佈一個<span>START 
			TRANSACTION</span>語句或其同義詞時，該<span>COMMIT</span>被執行，用於任何當前事務。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="savepoints"></a>13.4.4. SAVEPOINT和ROLLBACK 
			TO SAVEPOINT語法</h3></div></div></div><a class="indexterm" name="id2912645"></a><a class="indexterm" name="id2912654"></a><a class="indexterm" name="id2912663"></a>
			<pre><span>SAVEPOINT <span><i>identifier</i></span></span></pre>
			<pre><span>ROLLBACK [WORK] TO SAVEPOINT <span><i>identifier</i></span></span></pre>
			<pre><span>RELEASE SAVEPOINT <span><i>identifier</i></span></span></pre>
			<p><span>InnoDB</span>支援<span>SQL</span>語句<span>SAVEPOINT</span><span>,
			<span>ROLLBACK TO SAVEPOINT</span>,
			<span>RELEASE SAVEPOINT</span></span><span>和自選的用於<span>ROLLBACK</span>的<span>WORK</span>關鍵詞。</span></p>
			<p><span>SAVEPOINT</span>語句用於設置一個事務保存點，帶一個標識符名稱。如果當前事務有一個同樣名稱的保存點，則舊的保存點被刪除，新的保存點被設置。</p>
			<p><span>ROLLBACK TO SAVEPOINT</span>語句會向以命名的保存點回滾一個事務。如果在保存點被設置後，當前事務對行進行了更改，則這些更改會在
			回滾中被撤銷。但是，<span>InnoDB</span>不會釋放被儲存在保存點之後的儲存器中的行鎖定。（注意，對於新插入的行，鎖定訊息被儲存在行中的事務<span>ID</span>承載；鎖定沒有被分開儲存在儲存器中。在這種情況下，行鎖定在撤銷中被釋放。）在被命名的保存點之後設置的保存點被刪除。</p>
			<p>如果語句返回以下錯誤，則意味著不存在帶有指定名稱的保存點：</p>
			<pre><span>ERROR 1181: Got error 153 during ROLLBACK</span></pre>
			<p><span>RELEASE SAVEPOINT</span>語句會從當前事務的一組保存點中刪除已命名的保存點。不出現提交或
			回滾。如果保存點不存在，會出現錯誤。</p>
			<p>如果您執行<span>COMMIT</span>或執行不能命名保存點的<span>ROLLBACK</span>，則當前事務的所有保存點被刪除。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lock-tables"></a>13.4.5. LOCK 
			TABLES和UNLOCK TABLES語法</h3></div></div></div><a class="indexterm" name="id2912838"></a><a class="indexterm" name="id2912846"></a>
			<pre><span>LOCK TABLES</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [AS <span><i>alias</i></span>] {READ [LOCAL] | [LOW_PRIORITY] WRITE}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>tbl_name</i></span> [AS <span><i>alias</i></span>] {READ [LOCAL] | [LOW_PRIORITY] WRITE}] ...</span></pre>
			<pre><span>UNLOCK TABLES</span></pre>
			<p><span>LOCK TABLES</span>可以鎖定用於當前線程的資料表。如果資料表被其它線程鎖定，則造成堵塞，直到可以獲取所有鎖定為止。<span>UNLOCK 
			TABLES</span>可以釋放被當前線程保持的任何鎖定。當線程發佈另一個<span>LOCK TABLES</span>時，或當與伺服器的連接被關閉時，所有由當前線程鎖定的資料表被隱含地解鎖。</p>
			<p><span>&nbsp; </span>
			資料表鎖定只用於防止其它客戶端進行不正當地讀取和寫入。保持鎖定（即使是讀取鎖定）的客戶端可以進行資料表層級的操作，比如<span>DROP 
			TABLE</span>。</p>
			<p>注意，下面是對事務資料表使用<span>LOCK TABLES</span>的說明：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在嘗試鎖定資料表之前，<span>LOCK TABLES</span>不是事務安全型的，會隱含地提交所有活性事務。同時，開始一項事務（例如，使用<span>START 
			TRANSACTION</span>），會隱含地執行<span>UNLOCK TABLES</span>。（見<a href="sql-syntax.html#implicit-commit" title="13.4.3. Statements That Cause an Implicit Commit">13.4.3節，「會造成隱式提交的語句」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對事務資料表（如<span>InnoDB</span>）使用<span>LOCK 
			TABLES</span>的正確方法是，設置<span>AUTOCOMMIT=0</span>並且不能使用<span>UNLOCK 
			TABLES</span>，直到您明確地提交事務為止。當您使用<span>LOCK TABLES</span>時，<span>InnoDB</span>會內部地取其自己的資料表鎖定，<span>MySQL</span>取其自己的資料表鎖定。<span>InnoDB</span>在下一個提交時釋放其資料表鎖定，但是，對於<span>MySQL</span>，要釋放資料表鎖定，您必須使用<span>UNLOCK 
			TABLES</span>。您不應該讓<span>AUTOCOMMIT=1</span>，因為那樣的話，<span>InnoDB</span>會在使用<span>LOCK 
			TABLES</span>之後立刻釋放資料表鎖定，並且很容易形成死鎖定。注意，如果<span>AUTOCOMMIT=1</span>，我們根本不能獲取<span>InnoDB</span>資料表鎖定，這樣就可以幫助舊的應用軟件避免不必要的死鎖定。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ROLLBACK</span>不會釋放<span>MySQL</span>的非事務資料表鎖定。</p>
			<p>要使用<span>LOCK TABLES</span>，您必須擁有相關資料表的<span>LOCK 
			TABLES</span>權限和<span>SELECT</span>權限。</p>
			<p>使用<span>LOCK TABLES</span>的主要原因是倣傚事務，或在更新資料表時加快速度。這將在後面進行更詳細的解釋。</p>
			<p>如果一個線程獲得對一個資料表地<span>READ</span>鎖定，該線程（和所有其它線程）只能從該資料表中讀取。如果一個線程獲得對一個資料表的<span>WRITE</span>鎖定，只有保持鎖定的線程可以對資料表進行寫入。其它的線程被阻止，直到鎖定被釋放時為止。</p>
			<p><span>READ LOCAL</span>和<span>READ</span>之間的區別是，<span>READ 
			LOCAL</span>允許在鎖定被保持時，執行非衝突性<span>INSERT</span>語句（同時插入）。但是，如果您正打算在<span>MySQL</span>外面操作資料庫檔案，同時您保持鎖定，則不能使用<span>READ 
			LOCAL</span>。對於<span>InnoDB</span>資料表，<span>READ 
			LOCAL</span>與<span>READ</span>相同。</p>
			<p>當您使用<span>LOCK TABLES</span>時，您必須鎖定您打算在查詢中使用的所有的資料表。雖然使用<span>LOCK 
			TABLES</span>語句獲得的鎖定仍然有效，但是您不能訪問沒有被此語句鎖定的任何的資料表。同時，您不能在一次查詢中多次使用一個已鎖定的資料表——使用別名代替，在此情況下，您必須分別獲得對每個別名的鎖定。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t WRITE, t AS t1 WRITE;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO t SELECT * FROM t;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;t&#39; was not locked with LOCK TABLES</span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO t SELECT * FROM t AS t1;</b></span></span></pre>
			<p>如果您的查詢使用一個別名引用一個資料表，那麼您必須使用同樣的別名鎖定該資料表。如果沒有指定別名，則不會鎖定該資料表。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t READ;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t AS myalias;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;myalias&#39; was not locked with LOCK TABLES</span></pre>
			<p>相反的，如果您使用一個別名鎖定一個資料表，您必須使用該別名在您的查詢中引用該資料表。</p>
			<pre><span>mysql&gt; <span><b>LOCK TABLE t AS myalias READ;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t;</b></span></span></pre>
			<pre><span>ERROR 1100: Table &#39;t&#39; was not locked with LOCK TABLES</span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM t AS myalias;</b></span></span></pre>
			<p><span>WRITE</span>鎖定通常比<span>READ</span>鎖定擁有更高的優先權，以確保更新被盡快地處理。這意味著，如果一個線程獲得了一個<span>READ</span>鎖定，則另一個線程會申請一個<span>WRITE</span>鎖定，後續的<span>READ</span>鎖定申請會等待，直到<span>WRITE</span>線程獲得鎖定並釋放鎖定。您可以使用<span>LOW_PRIORITY 
			WRITE</span>鎖定來允許其它線程在該線程正在等待<span>WRITE</span>鎖定時獲得<span>READ</span>鎖定。只有當您確定最終將有一個時機，此時沒有線程擁有<span>READ</span>鎖定時，您才應該使用<span>LOW_PRIORITY 
			WRITE</span>鎖定。</p>
			<p><span>LOCK TABLES</span>按照如下方式執行：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>按照內部定義的順序，對所有要被鎖定的資料表進行分類。從用戶的角度，此順序是未經定義的。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果使用一個讀取和一個寫入鎖定對一個資料表進行鎖定，則把寫入鎖定放在讀取鎖定之前。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>一次鎖定一個資料表，直到線程得到所有鎖定為止。</p>
			<p>該規則確保資料表鎖定不會出現死鎖定。但是，對於該規則，您需要注意其它的事情：</p>
			<p>如果您正在對一個資料表使用一個<span>LOW_PRIORITY WRITE</span>鎖定，這只意味著，<span>MySQL</span>等待特定的鎖定，直到沒有申請<span>READ</span>鎖定的線程時為止。當線程已經獲得<span>WRITE</span>鎖定，並正在等待得到鎖定資料表清單中的用於下一個資料表的鎖定時，所有其它線程會等待<span>WRITE</span>鎖定被釋放。如果這成為對於應用程式的嚴重的問題，則您應該考慮把部分資料表轉化為事務安全型資料表。</p>
			<p>您可以安全地使用<span>KILL</span>來結束一個正在等待資料表鎖定的線程。請參見<a href="sql-syntax.html#kill" title="13.5.5.3. KILL Syntax">13.5.5.3節，「KILL語法」</a>。</p>
			<p>注意，您不能使用<span>INSERT DELAYED</span>鎖定任何您正在使用的資料表，因為，在這種情況下，<span>INSERT</span>由另一個線程執行。</p>
			<p>通常，您不需要鎖定資料表，因為所有的單個<span>UPDATE</span>語句都是原子性的；沒有其它的線程可以干擾任何其它當前正在執行的<span>SQL</span>語句。但是，在幾種情況下，鎖定資料表會有好處：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在對一組<span>MyISAM</span>資料表運行許多操作，鎖定您正在使用的資料表，可以快很多。鎖定<span>MyISAM</span>資料表可以加快插入、更新或刪除的速度。不利方面是，沒有線程可以更新一個用<span>READ</span>鎖定的資料表（包括保持鎖定的資料表），也沒有線程可以訪問用<span>WRITE</span>鎖定的資料表（除了保持鎖定的資料表以外）。</p>
			<p>有些<span>MyISAM</span>操作在<span>LOCK 
			TABLES</span>之下更快的原因是，<span>MySQL</span>不會清空用於已鎖定資料表的關鍵緩存，直到<span>UNLOCK 
			TABLE</span>被使用為止。通常，關鍵緩存在每個<span>SQL</span>語句之後被清空。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在使用<span>MySQL</span>中的一個不支援事務的儲存引擎，則如果您想要確定在<span>SELECT</span>和<span>UPDATE</span>之間沒有其它線程，您必須使用<span>LOCK 
			TABLES</span>。本處所示的例子要求<span>LOCK TABLES</span>，以便安全地執行：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>LOCK TABLES trans READ, customer WRITE;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT SUM(value) FROM trans WHERE customer_id=<i>some_id</i>;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>UPDATE customer</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>SET total_value=<i>sum_from_previous_statement</i></b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE customer_id=<i>some_id</i>;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>UNLOCK TABLES;</b></span></span></pre>
			<p>如果沒有<span>LOCK TABLES</span>，有可能另一個線程會在執行<span>SELECT</span>和<span>UPDATE</span>語句之間在<span>trans</span>資料表中插入一個新行。</p>
			<p>通過使用相對更新（<span>UPDATE 
			customer SET <i>value</i>=<i>value</i>+<i>new_value</i></span>）或<span>LAST_INSERT_ID()</span>函數，您可以在許多情況下避免使用<span>LOCK 
			TABLES</span>。請參見<a href="introduction.html#ansi-diff-transactions" title="1.8.5.3. Transactions and Atomic Operations">1.8.5.3節，「事務和原子操作」</a>。</p>
			<p>通過使用用戶層級的顧問式鎖定函數<span>GET_LOCK()</span>和<span>RELEASE_LOCK()</span>，您也可以在有些情況下避免鎖定資料表。這些鎖定被保存在伺服器中的一個混編資料表中，使用<span>pthread_mutex_lock()</span><span>
			</span>和<span><span>pthread_mutex_unlock()</span>，以加快速度。請參見</span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4節，「其他函數」</a><span>。</span></p>
			<p>要瞭解更多有關鎖定規則的說明，請參見<a href="optimization.html#internal-locking" title="7.3.1. Locking Methods">7.3.1節，「鎖定方法」</a>。</p>
			<p>您可以使用<span>FLUSH TABLES WITH READ LOCK</span>語句鎖定位於所有帶有讀取鎖定的資料庫中的所有資料表。請參見<a href="sql-syntax.html#flush" title="13.5.5.2. FLUSH Syntax">13.5.5.2節，「FLUSH語法」</a>。如果您有一個可以及時拍攝快照的檔案系統，比如<span>Veritas</span>，這是獲得備份的一個非常方便的方式。</p>
			<p>註釋：如果您對一個已鎖定的資料表使用<span>ALTER TABLE</span>，該資料表可能會解鎖。請參見<a href="problems.html#alter-table-problems" title="A.7.1. Problems with ALTER TABLE">A.7.1節，「與ALTER TABLE有關的問題」</a>。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-transaction"></a>13.4.6. SET 
			TRANSACTION語法</h3></div></div></div><a class="indexterm" name="id2913625"></a><a class="indexterm" name="id2913634"></a>
			<pre><span>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</span></pre>
			<pre><span>{ READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</span></pre>
			<p>本語句用於設置事務隔離等級，用於下一個事務，或者用於當前會話。</p>
			<p>在預設情況下，<span>SET TRANSACTION</span>會為下一個事務（還未開始）設置隔離等級。如果您使用<span>GLOBAL</span>關鍵詞，則語句會設置全局性的預設事務等級，用於從該點以後建立的所有新連接。原有的連接不受影響。要進行此操作，您需要<span>SUPER</span>權限。使用<span>SESSION</span>關鍵測可以設置預設事務等級，用於對當前連接執行的所有將來事務。</p>
			<p>要瞭解對每個<span>InnoDB</span>事務隔離等級的描述，請參見<a href="storage-engines.html#innodb-transaction-isolation" title="15.2.10.3. InnoDB and TRANSACTION ISOLATION LEVEL">15.2.10.3節，「InnoDB和TRANSACTION ISOLATION LEVEL」</a>。<span>InnoDB</span>支援<span>MySQL 
			5.1</span>中的各個等級。預設的等級是<span>REPEATABLE READ</span>。</p>
			<p>您可以使用<span>--transaction-isolation</span>選項，對<strong><span>mysqld</span></strong>設置初始的預設全局隔離等級。請參見<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1節，「<span><strong class="command">mysqld</strong></span>命令行選項」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xa"></a>
			13.4.7.&nbsp;XA事務</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#xa-statements">
				13.4.7.1. XA事務SQL語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa-states">13.4.7.2. 
				XA事務狀態</a></span></dt></dl></div><a class="indexterm" name="id2913760"></a>
			<p>對於<span>InnoDB</span>儲存引擎，可以獲得對<span>XA</span>事務的支援。<span>MySQL 
			XA</span>的執行依據<span>X/Open CAE</span>檔案<em><span>Distributed 
			Transaction Processing: The XA Specification</span></em>。本檔案由<span>Open 
			Group</span>出版，可以從<span><a target="_top"  href="http://www.opengroup.org/public/pubs/catalog/c193.htm">http://www.opengroup.org/public/pubs/catalog/c193.htm</a></span>獲取。在<a href="restrictions.html#xa-restrictions" title="I.5. Restrictions on XA Transactions">I.5節，「對XA事務的限制」</a>對當前<span>XA</span>執行的限制進行了描述。</p>
			<p>在客戶端方面，沒有特殊要求。連接<span>MySQL</span>伺服器的<span>XA</span>接口由以<span>XA</span>關鍵詞開頭的<span>SQL</span>語句組成。<span>MySQL</span>客戶端必須能發送<span>SQL</span>語句，並能理解<span>XA</span>語句接口的語義，但是它們不需要被連結到特定的<span>MySQL</span>客戶庫上。</p>
			<p>當前，在<span>MySQL</span>連接器當中，<span>MySQL</span>連接器<span>/J 
			5.0.0</span>直接支援<span>XA</span>（也就是，通過一個可以控制<span>XA 
			SQL</span>語句接口的等級接口）。</p>
			<p><span>XA</span>支援分佈式的事務，具備能力，讓多個獨立的事務資源參加全局的事務。事務資源通常是<span>RDBMSs</span>，不過也可以是其它種類的資源。</p>
			<p>
			一個全局事務會涉及到多個行動，這些行動本身是事務性的。不過，所有行動都必須作為一個群組成功完成，或者作為一個群組被回滾。實際上，這會延伸<span>ACID</span>性質，「提高等級」，這樣，多個<span>ACID</span>事務就可以一起執行，相當於也擁有<span>ACID</span>性質的全局操作的組件。（但是，對於一個分佈式事務，您必須使用<span>SERAILIZABLE</span>隔離等級，以實現<span>ACID</span>性質。對於一個非分佈式事務，使用<span>REPEATABLE 
			READ</span>就足夠了。但是對於分佈式事務，使用<span>REPEATABLE READ</span>是不夠的。）</p>
			<p>分佈式事務的部分示範：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>應用程式相當於一個把消息傳遞服務和<span>RDBMS</span>組合在一起的整合工具。應用程式可以確保，所有進行消息發送、回收和處理的事務（同時包含一個事務資料庫）均在一個全局事務中發生。您可以把這看作是「事務電子郵件。」</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>應用程式執行的行動會涉及到不同資料庫伺服器，比如<span>MySQL</span>伺服器和<span>Oracle</span>伺服器（或多個<span>MySQL</span>伺服器）。涉及到多個伺服器的行動必須作為一個全局事務的一部分發生，而不是作為針對每個伺服器的獨立的本地事務發生。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>銀行把帳戶訊息保存在<span>RDBMS</span>中，並通過自動取款機（<span>ATMs</span>）分發和收取欠款。必須要確保<span>ATM</span>行動被正確地反映到帳戶中，但是這不能只由<span>RDBMS</span>單獨完成。全局事務管理器會整合<span>ATM</span>和資料庫資源，以確保財務事務的整體一致性。</p>
			<p>使用全局事務的應用程式涉及一個或多個資源管理器和一個事務管理器：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資源管理器（<span>RM</span>）用於提供通向事務資源的途徑。資料庫伺服器是一種資源管理器。該管理器必須可以提交或
			回滾由<span>RM</span>管理的事務。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>事務管理器（<span>TM</span>）用於協調作為一個全局事務一部分的事務。<span>TM</span>與管理每個事務的<span>RMs</span>進行通訊。一個全局事務中各個單個事務均是全局事務的「分支」。全局事務和各分支通過一種命名方法進行標識。這種命名方法在後面進行講述。</p>
			<p><span>MySQL</span>執行<span>XA MySQL</span>時，<span>MySQL</span>伺服器相當於一個用於管理全局事務中的<span>XA</span>事務的資源管理器。與<span>MySQL</span>伺服器連接的客戶端相當於事務管理器。</p>
			<p>
			要執行一個全局事務，必須知道涉及到了哪些組件，並且把每個組件引到一點，在此時，組件可以被提交或回滾時。根據每個組件報告的有關組件效能的內容，這些組件必須作為一個原子性群組全部提交或
			回滾。即，要麼所有的組件必須提交，要麼所有的組件必須回滾。要管理一個全局事務，必須要考慮任何組件或連接網絡可能會故障。</p>
			<p>用於執行全局事務的過程使用兩階段提交（<span>2PC</span>），發生時間在由全局事務的分支進行的行動已經被執行之後。</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在第一階段，所有的分支被預備好。即，它們被<span>TM</span>告知要準備提交。通常，這意味著用於管理分支的每個<span>RM</span>會記錄對於被穩定保存的分支的行動。分支指示是否它們可以這麼做。這些結果被用於第二階段。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在第二階段，<span>TM</span>告知<span>RMs</span>是否要提交或
			回滾。如果在預備分支時，所有的分支指示它們將能夠提交，則所有的分支被告知要提交。如果在預備時，有任何分支指示它將不能提交，則所有分支被告知
			回滾。</p>
			<p>在有些情況下，一個全局事務可能會使用一階段提交（<span>1PC</span>）。例如，當一個事務管理器發現，一個全局事務只由一個事務資源組成（即，單一分支），則該資源可以被告知同時進行預備和提交。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-statements"></a>
				13.4.7.1.&nbsp;XA事務SQL語法</h4></div></div></div><a class="indexterm" name="id2914022"></a><a class="indexterm" name="id2914031"></a><a class="indexterm" name="id2914043"></a><a class="indexterm" name="id2914052"></a><a class="indexterm" name="id2914065"></a><a class="indexterm" name="id2914074"></a><a class="indexterm" name="id2914086"></a><a class="indexterm" name="id2914095"></a><a class="indexterm" name="id2914108"></a><a class="indexterm" name="id2914117"></a><a class="indexterm" name="id2914129"></a><a class="indexterm" name="id2914138"></a><a class="indexterm" name="id2914151"></a><a class="indexterm" name="id2914161"></a>
				<p>要在<span>MySQL</span>中執行<span>XA</span>事務，應使用以下語句：</p>
				<pre><span>XA {START|BEGIN} <span><i>xid</i></span> [JOIN|RESUME]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA END <span><i>xid</i></span> [SUSPEND [FOR MIGRATE]]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA PREPARE <span><i>xid</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA COMMIT <span><i>xid</i></span> [ONE PHASE]</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA ROLLBACK <span><i>xid</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>XA RECOVER</span></pre>
				<p>對於<span>XA START</span>，<span>JOIN</span>和<span>RESUME</span>子句不被支援。</p>
				<p>對於<span>XA END</span>，<span>SUSPEND [FOR 
				MIGRATE]</span>子句不被支援。</p>
				<p>每個<span>XA</span>語句以<span>XA</span>關鍵詞為開頭，多數語句要求一個<span>xid</span>值。<span> 
				xid</span>是一個<span>XA</span>事務標識符。它指示該語句適用於哪個事務。<span>xid</span>值由客戶端提供，或由<span>MySQL</span>伺服器生成。<span>xid</span>值包含一到三個部分：</p>
				<pre><span><i><span>xid</span></i></span><span>: <span><i>gtrid</i></span> [, <span><i>bqual</i></span> [, <span><i>formatID</i></span> ]]</span></pre>
				<p><span>gtrid</span>是一個全局事務標識符，<span>bqual</span>是一個分支限定符，<span>formatID</span>是一個數字，用於標識由<span>gtrid</span>和<span>bqual</span>值使用的格式。根據語法的資料表示，<span>bqual</span>和<span>formatID</span>是自選的。如果沒有給定，預設的<span>bqual</span>值是<span>&#39;&#39;</span>。如果沒有給定，預設的<span>fromatID</span>值是<span>1</span>。</p>
				<p><span>gtrid</span>和<span>bqual</span>必須為字串文字，每個的長度最多為<span>64</span>字節（不是字元）。<span>gtrid</span>和<span>bqual</span>可以用多種方法指定。您可以使用帶引號的字串<span>(<span>&#39;ab&#39;</span>)</span>，十六進制字串<span>(<span>0x6162</span>,
				<span>X&#39;ab&#39;</span>)</span>，或位值<span>(<span>b&#39;<i>nnnn</i>&#39;</span>)</span>。</p>
				<p><span>formatID</span>是一個無符號的整數。</p>
				<p>通過<span>MySQL</span>伺服器的帶下劃線的<span>XA</span>支援子程式，<span>gtrid</span>和<span>bqual</span>值被理解為以字節為單位。但是，在包含<span>XA</span>語句的<span>SQL</span>語句正在被分析的同時，伺服器會去操作一些特定的字元編碼。為了安全，把<span>gtrid</span>和<span>bqual</span>作為十六進制字串寫入。</p>
				<p>通常，<span>xid</span>值由事務管理器生成。由一個<span>TM</span>生成的值必須與由其它<span>TMs</span>生成的值不同。一個給定的<span>TM</span>必須能識別自己的<span>xid</span>值。這些值位於由<span>XA 
				RECOVER</span>語句返回的值清單中。</p>
				<p><span>XA START xid</span>用於啟動一個帶給定<span>xid</span>值的<span>XA</span>事務。每個<span>XA</span>事務必須有一個唯一的<span>xid</span>值，因此該值當前不能被其它的<span>XA</span>事務使用。使用<span>gtrid</span>和<span>bqual</span>值評估唯一性。所有下列的用於<span>XA</span>事務的<span>XA</span>語句必須使用與<span>XA 
				START</span>語句中給定的相同的<span>xid</span>值進行指定。如果您使用這些語句，但是指定的<span>xid</span>值與部分原有的<span>XA</span>事務不對應的話，會發生錯誤。</p>
				<p>一項或多項<span>XA</span>事務可以是同一個全局事務的一部分。在一個給定的全局事務中的所有<span>XA</span>事務必須在<span>xid</span>值中使用同樣的<span>gtrid</span>值。出於這個原因，<span>gtrid</span>值必須為全局唯一的，這樣，有關一個給定的<span>XA</span>事務是哪個全局事務的一部分的問題就不會含糊不清。對於一個全局事務中的每個<span>XA</span>事務，<span>xid</span>值中的<span>bqual</span>部分必須不一樣。（<span>bqual</span>值應不一樣，這個要求是當前執行<span>MySQL 
				XA</span>的一個限制條件。這不是<span>XA</span>規約的一部分。）</p>
				<p>對於在<span>MySQL</span>伺服器上的處於<span>PREPARED</span>狀態的<span>XA</span>事務，<span>XA 
				RECOVER</span>語句會返回訊息。（見<a href="sql-syntax.html#xa-states" title="13.4.7.2. XA Transaction States">13.4.7.2節，「XA事務狀態」</a>.。）輸出包括一個行，該行用於伺服器上的每個這類<span>XA</span>事務，不論是哪個客戶端啟動了它。</p>
				<p><span>XA RECOVER</span>輸出行看上去像這樣（例如，<span>xid</span>值包括<span>&#39;abc&#39;</span><span>,
				<span>&#39;def&#39;</span></span>和 
				<span><span>7</span>等部分）：</span></p>
				<pre><span>mysql&gt; <span><b>XA RECOVER;</b></span></span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<pre><span>| formatID | gtrid_length | bqual_length | data&nbsp;&nbsp; |</span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 | abcdef |</span></pre>
				<pre><span>+----------+--------------+--------------+--------+</span></pre>
				<p>輸出列有以下意義：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>formatID</span>是事務<span>xid</span>的<span>formatID</span>部分</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>gtrid_length</span>是<span>xid</span>的<span>gtrid</span>部分的長度，以字節為單位</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>bqual_length</span>是<span>xid</span>的<span>bqual</span>部分的長度，以字節為單位</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>data</span>是<span>xid</span>的<span>gtrid</span>部分和<span>bqual</span>部分的串聯</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-states"></a>
				13.4.7.2.&nbsp;XA事務狀態</h4></div></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
		<span>XA</span>事務在以下狀態下進展：<p>
		<span>1.<span>&nbsp;&nbsp;&nbsp;
		</span></span>使用<span>XA START</span>來啟動一個<span>XA</span>事務，並把它放入<span>ACTIVE</span>狀態。</p>
		<p><span>2.<span>&nbsp;&nbsp;&nbsp;
		</span></span>對於一個<span>ACTIVE XA</span>事務，發佈構成事務的<span>SQL</span>語句，然後發佈一個<span>XA 
		END</span>語句。<span>XA END</span>把事務放入<span>IDLE</span>狀態。</p>
		<p><span>3.<span>&nbsp;&nbsp;&nbsp;
		</span></span>對於一個<span>IDLE XA</span>事務，您可以發佈一個<span>XA 
		PREPARE</span>語句或一個<span>XA COMMIT</span>…<span>ONE 
		PHASE</span>語句：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>XA PREPARE</span>把事務放入<span>PREPARED</span>狀態。在此點上的<span>XA 
		RECOVER</span>語句將在其輸出中包括事務的<span>xid</span>值，因為<span>XA 
		RECOVER</span>會列出處於<span>PREPARED</span>狀態的所有<span>XA</span>事務。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>XA COMMIT</span>…<span>ONE PHASE</span>用於預備和提交事務。<span>xid</span>值將不會被<span>XA 
		RECOVER</span>列出，因為事務終止。</p>
		<p><span>4.<span>&nbsp;&nbsp;&nbsp;
		</span></span>對於一個<span>PREPARED XA</span>事務，您可以發佈一個<span>XA 
		COMMIT</span>語句來提交和終止事務，或者發佈<span>XA ROLLBACK</span>來回滾並終止事務。</p>
		<p>下面是一個簡單的<span>XA</span>事務，該事務把一行作為一個全局事務的一部分插入一個資料表中。</p>
		<pre><span>mysql&gt; <span><b>XA START &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>INSERT INTO mytable (i) VALUES(10);</b></span></span></pre>
		<pre><span>Query OK, 1 row affected (0.04 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA END &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA PREPARE &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>mysql&gt; <span><b>XA COMMIT &#39;xatest&#39;;</b></span></span></pre>
		<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
		<p>根據一個給定的客戶端連接的語境，<span>XA</span>事務和本地（非<span>XA</span>）事務互相排斥。舉例說明，如果已經發佈了<span>XA 
		START</span>來開始一項<span>XA</span>事務，則本地事務不會被啟動，直到<span>XA</span>事務已經被提交或被
		回滾為止。相反的，如果已經使用<span>START 
		TRANSACTION</span>啟動一個本地事務，則<span>XA</span>語句不能被使用，直到該事務被提交或被
		回滾為止。</p>
		<h2 class="title"><a name="database-administration-statements"></a>
		13.5.&nbsp;資料庫管理語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">
			13.5.1. 帳號管理語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">
			13.5.2. 資料表維護語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-option">13.5.3. 
			SET語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.5.4. 
			SHOW語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">
			13.5.5. 其它管理語句</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="account-management-sql"></a>
			13.5.1.&nbsp;帳號管理語句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#create-user">13.5.1.1. 
				CREATE USER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-user">13.5.1.2. 
				DROP USER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#grant">13.5.1.3. 
				GRANT和REVOKE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-user">13.5.1.4. 
				RENAME USER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-password">13.5.1.5. 
				SET PASSWORD語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-user"></a>13.5.1.1. CREATE 
				USER語法</h4></div></div></div><a class="indexterm" name="id2914882"></a><a class="indexterm" name="id2914890"></a><a class="indexterm" name="id2914901"></a>
				<pre><span>CREATE USER <span><i>user</i></span> [IDENTIFIED BY [PASSWORD] &#39;<span><i>password</i></span>&#39;]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>user</i></span> [IDENTIFIED BY [PASSWORD] &#39;<span><i>password</i></span>&#39;]] ...</span></pre>
				<p><span>CREATE USER</span>用於建立新的<span>MySQL</span>帳號。要使用<span>CREATE 
				USER</span>，您必須擁有<span>mysql</span>資料庫的全局<span>CREATE 
				USER</span>權限，或擁有<span>INSERT</span>權限。對於每個帳號，<span>CREATE 
				USER</span>會在沒有權限的<span>mysql.user</span>資料表中建立一個新記錄。如果
				帳號已經存在，則出現錯誤。</p>
				<p>使用自選的<span>IDENTIFIED BY</span>子句，可以為帳號給定一個密碼。<span>user</span>值和
				密碼的給定方法和<span>GRANT</span>語句一樣。特別是，要在純文本中指定密碼，需忽略<span>PASSWORD</span>關鍵詞。要把
				密碼指定為由<span>PASSWORD()</span>函數返回的混編值，需包含關鍵字<span>PASSWORD</span>。請參見<a href="sql-syntax.html#grant" title="13.5.1.3. GRANT and REVOKE Syntax">13.5.1.3節，「GRANT和REVOKE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-user"></a>13.5.1.2. DROP 
				USER語法</h4></div></div></div><a class="indexterm" name="id2915028"></a><a class="indexterm" name="id2915037"></a><a class="indexterm" name="id2915047"></a><a class="indexterm" name="id2915057"></a><a class="indexterm" name="id2915067"></a><a class="indexterm" name="id2915078"></a><a class="indexterm" name="id2915088"></a><a class="indexterm" name="id2915098"></a><a class="indexterm" name="id2915108"></a>
				<pre><span>DROP USER <span><i>user</i></span> [, <span><i>user</i></span>] ...</span></pre>
				<p><span>DROP USER</span>語句用於刪除一個或多個<span>MySQL</span>帳號。要使用<span>DROP 
				USER</span>，您必須擁有<span>mysql</span>資料庫的全局<span>CREATE 
				USER</span>權限或<span>DELETE</span>權限。使用與<span>GRANT</span>或<span>REVOKE</span>相同的格式為每個
				帳號命名；例如，<span>&#39;jeffrey&#39;@&#39;localhost&#39;</span>。
				帳號名稱的用戶和主機部分與用戶資料表記錄的<span>User</span>和<span>Host</span>列值相對應。</p>
				<p>使用<span>DROP USER</span>，您可以取消一個帳號和其權限，操作如下：</p>
				<pre><span>DROP USER <span><i>user</i></span>;</span></pre>
				<p>該語句可以刪除來自所有授權資料表的帳戶權限記錄。</p>
				<p>要點：<span>DROP USER</span>不能自動關閉任何打開的用戶對話。而且，如果用戶有打開的對話，此時取消用戶，則命令不會生效，直到用戶對話被關閉後才生效。一旦對話被關閉，用戶也被取消，此用戶再次試圖登錄時將會失敗。這是有意設計的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="grant"></a>13.5.1.3. GRANT和REVOKE語法</h4></div></div></div><a class="indexterm" name="id2915267"></a><a class="indexterm" name="id2915276"></a><a class="indexterm" name="id2915285"></a><a class="indexterm" name="id2915295"></a><a class="indexterm" name="id2915305"></a><a class="indexterm" name="id2915312"></a><a class="indexterm" name="id2915322"></a><pre class="programlisting">GRANT <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)] [, <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)]] ...
    ON [<em class="replaceable">object_type</em>] {<em class="replaceable">tbl_name</em> | * | *.* | <em class="replaceable">db_name</em>.*}
    TO <em class="replaceable">user</em> [IDENTIFIED BY [PASSWORD] '<em class="replaceable">password</em>']
        [, <em class="replaceable">user</em> [IDENTIFIED BY [PASSWORD] '<em class="replaceable">password</em>']] ...
    [REQUIRE
        NONE |
        [{SSL| X509}]
        [CIPHER '<em class="replaceable">cipher</em>' [AND]]
        [ISSUER '<em class="replaceable">issuer</em>' [AND]]
        [SUBJECT '<em class="replaceable">subject</em>']]
    [WITH <em class="replaceable">with_option</em> [<em class="replaceable">with_option</em>] ...]

<em class="replaceable">object_type</em> =
    TABLE
  | FUNCTION
  | PROCEDURE

<em class="replaceable">with_option</em> =
    GRANT OPTION
  | MAX_QUERIES_PER_HOUR <em class="replaceable">count</em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable">count</em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable">count</em>
  | MAX_USER_CONNECTIONS <em class="replaceable">count</em>
</pre><pre class="programlisting">REVOKE <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)] [, <em class="replaceable">priv_type</em> [(<em class="replaceable">column_list</em>)]] ...
    ON [<em class="replaceable">object_type</em>] {<em class="replaceable">tbl_name</em> | * | *.* | <em class="replaceable">db_name</em>.*}
    FROM <em class="replaceable">user</em> [, <em class="replaceable">user</em>] ...

REVOKE ALL PRIVILEGES, GRANT OPTION FROM <em class="replaceable">user</em> [, <em class="replaceable">user</em>] ...
</pre>
				<p><span>GRANT</span>和<span>REVOKE</span>語句允許系統管理員建立<span>MySQL</span>用戶
				帳號，授予權限和撤銷權限。</p>
				<p><span>MySQL</span>帳號訊息儲存在<span>mysql</span>資料庫的資料表中。在<a href="database-administration.html">第5章：</a><a href="database-administration.html" title="Chapter 5. Database Administration"><i>資料庫管理</i></a>中對本資料庫和訪問控制系統進行了詳盡的討論。要瞭解更多詳細訊息，您應該查詢此章。</p>
				<p>如果授權資料表擁有含有<span>mixed-case</span>資料庫或資料表名稱的權限記錄，並且<span>lower_case_table_names</span>系統變數已設置，則不能使用<span>REVOKE</span>撤銷權限，必須直接操縱授權資料表。（當<span><span>lower_case_table_names</span>已設置時，<span>GRANT</span>將不會建立此類記錄，但是此類記錄可能已經在設置變數之前被建立了。）</span></p>
				<p>授予的權限可以分為多個層級：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>全局層級</span></strong></p>
				<p>全局權限適用於一個給定伺服器中的所有資料庫。這些權限儲存在<span>mysql.user</span>資料表中。<span>GRANT 
				ALL ON *.*</span>和<span><span>REVOKE 
				ALL ON *.*</span>只授予和撤銷全局權限。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>資料庫層級</span></strong>
				</p>
				<p>資料庫權限適用於一個給定資料庫中的所有目標。這些權限儲存在<span>mysql.db</span>和<span>mysql.host</span>資料表中。<span>GRANT 
				ALL ON <i>db_name</i>.*</span>和<span><span>REVOKE 
				ALL ON <i>db_name</i>.*</span>只授予和撤銷資料庫權限。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>資料表層級</span></strong></p>
				<p>資料表權限適用於一個給定資料表中的所有列。這些權限儲存在<span>mysql.talbes_priv</span>資料表中。<span>GRANT 
				ALL ON <i>db_name.tbl_name</i></span>和<span>REVOKE 
				ALL ON <i>db_name.tbl_name</i></span>只授予和撤銷資料表權限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>列層級</span></strong></p>
				<p>列權限適用於一個給定資料表中的單一列。這些權限儲存在<span>mysql.columns_priv</span>資料表中。當使用<span>REVOKE</span>時，您必須指定與被授權列相同的列。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>子程式層級</span></strong></p>
				<p><span>CREATE ROUTINE, 
				ALTER ROUTINE, EXECUTE</span>和<span>GRANT</span>權限適用於已儲存的子程式。這些權限可以被授予為全局層級和資料庫層級。而且，除了<span>CREATE 
				ROUTINE</span>外，這些權限可以被授予為子程式層級，並儲存在<span>mysql.procs_priv</span>資料表中。</p>
				<p>當後續目標是一個資料表、一個已儲存的函數或一個已儲存的過程時，<span><i><span>object_type</span></i></span>子句應被指定為<span>TABLE</span>、<span>FUNCTION</span>或<span>PROCEDURE</span>。當從舊版本的<span>MySQL</span>升級時，要使用本子句，您必須升級您的授權資料表。請參見<a href="installing.html#upgrading-grant-tables" title="2.10.2. Upgrading the Grant Tables">2.10.2節，「升級授權資料表」</a>。</p>
				<p>要使用<span>GRANT</span>或<span>REVOKE</span>，您必須擁有<span>GRANT 
				OPTION</span>權限，並且您必須用於您正在授予或撤銷的權限。</p>
				<p>要撤銷所有權限，需使用以下語法。此語法用於取消對於已命名的用戶的所有全局層級、資料庫層級、資料表層級和列層級的權限。</p>
				<pre><span>REVOKE ALL PRIVILEGES, GRANT OPTION FROM <span><i>user</i></span> [, <span><i>user</i></span>] ...</span></pre>
				<p>要使用本<span>REVOKE</span>語法，您必須擁有<span>mysql</span>資料庫的全局<span>CREATE 
				USER</span>權限或<span>UPDATE</span>權限。</p>
				<p>對於<span>GRANT</span>和<span>REVOKE</span>語句，<span>priv_type</span>可以被指定為以下任何一種：</p>
				<table border="1" cellpadding="0" id="table7">
					<tr>
						<td>
						<p><strong>
						<span>權限</span></strong></td>
						<td>
						<p><strong>
						<span>意義</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALL [PRIVILEGES]</span></td>
						<td>
						<p><span>設置除<span>GRANT 
						OPTION</span>之外的所有簡單權限</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALTER</span></td>
						<td>
						<p><span>允許使用<span>ALTER 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>ALTER ROUTINE</span></td>
						<td>
						<p>更改或取消已儲存的子程式</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE</span></td>
						<td>
						<p><span>允許使用<span>CREATE 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE ROUTINE</span></td>
						<td>
						<p>建立已儲存的子程式</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE TEMPORARY TABLES</span></td>
						<td>
						<p><span>允許使用<span>CREATE 
						TEMPORARY TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE USER</span></td>
						<td>
						<p>允許使用<span>CREATE USER, 
						DROP USER, RENAME USER</span>和<span>REVOKE 
						ALL PRIVILEGES</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CREATE VIEW</span></td>
						<td>
						<p><span>允許使用<span>CREATE 
						VIEW</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>DELETE</span></td>
						<td>
						<p><span>允許使用<span>DELETE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>DROP</span></td>
						<td>
						<p><span>允許使用<span>DROP 
						TABLE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>EXECUTE</span></td>
						<td>
						<p>允許用戶運行已儲存的子程式</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>FILE</span></td>
						<td>
						<p><span>允許使用<span>SELECT...INTO 
						OUTFILE</span>和<span>LOAD DATA INFILE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>INDEX</span></td>
						<td>
						<p><span>允許使用<span>CREATE 
						INDEX</span>和<span>DROP INDEX</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>INSERT</span></td>
						<td>
						<p><span>允許使用<span>INSERT</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>LOCK TABLES</span></td>
						<td>
						<p>允許對您擁有<span>SELECT</span>權限的資料表使用<span>LOCK 
						TABLES</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>PROCESS</span></td>
						<td>
						<p><span>允許使用<span>SHOW 
						FULL PROCESSLIST</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REFERENCES</span></td>
						<td>
						<p>未被實施</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>RELOAD</span></td>
						<td>
						<p><span>允許使用<span>FLUSH</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REPLICATION CLIENT</span></td>
						<td>
						<p>允許用戶詢問從屬伺服器或主伺服器的地址</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>REPLICATION SLAVE</span></td>
						<td>
						<p>用於複製型從屬伺服器（從主伺服器中讀取二進制日誌事件）</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SELECT</span></td>
						<td>
						<p><span>允許使用<span>SELECT</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHOW DATABASES</span></td>
						<td>
						<p><span>SHOW DATABASES</span>顯示所有資料庫</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHOW VIEW</span></td>
						<td>
						<p><span>允許使用<span>SHOW 
						CREATE VIEW</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SHUTDOWN</span></td>
						<td>
						<p>允許使用<strong><span>mysqladmin 
						shutdown</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>SUPER</span></td>
						<td>
						<p>允許使用<span>CHANGE 
						MASTER, KILL, PURGE MASTER LOGS</span>和<span>SET 
						GLOBAL</span>語句，<strong><span>mysqladmin 
						debug</span></strong>命令；允許您連接（一次），即使已達到<span>max_connections</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>UPDATE</span></td>
						<td>
						<p><span>允許使用<span>UPDATE</span></span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>USAGE</span></td>
						<td>
						<p>「無權限」的同義詞</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>GRANT OPTION</span></td>
						<td>
						<p>允許授予權限</td>
					</tr>
				</table>
				<p>當從舊版本的<span>MySQL</span>升級時，要使用<span>EXECUTE, 
				CREATE VIEW, SHOW VIEW, CREATE USER, CREATE ROUTINE</span>和<span>ALTER 
				ROUTINE</span>權限，您必須首先升級您的授權資料表。請參見<a href="installing.html#upgrading-grant-tables" title="2.10.2. Upgrading the Grant Tables">2.10.2節，「升級授權資料表」</a>。</p>
				<p><span>REFERENCES</span>權限目前未被使用。</p>
				<p>當您想要建立一個沒有權限的用戶時，可以指定<span>USAGE</span>。</p>
				<p>使用<span>SHOW GRANTS</span>來確定帳戶擁有什麼權限。請參見<a href="sql-syntax.html#show-grants" title="13.5.4.10. SHOW GRANTS Syntax">13.5.4.10節，「SHOW 
			GRANTS語法」</a>。</p>
				<p>您可以通過使用<span>ON *.*</span>語法賦予全局權限，或通過使用<span>ON
				<i>db_name</i>.*</span>語法賦予資料庫層級權限。如果您指定了<span>ON 
				*</span>並且您已經選擇了一個預設資料庫，則權限被賦予到這個資料庫中。（警告：如果您指定了<span>ON 
				*</span>同時您沒有選擇一個預設資料庫，則權限是全局的。）</p>
				<p><span>FILE, PROCESS, RELOAD, REPLICATION CLIENT, 
				REPLICATION SLAVE, SHOW DATABASES, SHUTDOWN</span>和<span>SUPER</span>權限是管理性權限，只能進行全局授權（使用<span>ON 
				*.*</span>語法）。</p>
				<p>其它權限可以被全局授權，或被賦予為其它層級。</p>
				<p>對於一個資料表，您可以指定的<span>priv_type</span>值只能是<span>SELECT, 
				INSERT, UPDATE, DELETE, CREATE, DROP, GRANT OPTION, INDEX</span>和<span>ALTER</span>。</p>
				<p>對於一個列（也就是，當您使用一個<span>column_list</span>子句時），您可以指定的<span>priv_type</span>值只能是<span>SELECT, 
				INSERT</span>和<span>UPDATE</span>。</p>
				<p>在子程式層級，您可以指定的<span>priv_type</span>值只能是<span>ALTER 
				ROUTINE, EXECUTE</span>和<span>GRANT OPTION</span>。<span>CREATE 
				ROUTINE</span>不是一個子程式層級的權限，因為您必須擁有此權限，才能建立一個子程式。</p>
				<p>對於全局、資料庫、資料表和子程式層級，<span>GRANT ALL</span>只能賦予在您正在授權的層級中存在的權限。例如，如果您使用<span>GRANT 
				ALL ON <i>db_name</i>.*</span>，這是一個資料庫層級語句，因此不會授予全局權限，如<span>FILE</span>等。</p>
				<p><span>MySQL</span>允許您對不存在的資料庫目標授予權限。在此情況下，將被授予的權限必須包括<span>CREATE</span>權限。這個性質是有意設計的，目的是允許資料庫管理員為將在此後被建立的資料庫目標預備用戶
				帳號和權限。</p>
				<p>要點：當您取消一個資料表或資料庫時，<span>MySQL</span>不會自動撤銷任何權限。但是，如果您取消一個子程式，則被賦予該子程式的所有子程式層級的權限都被撤銷。</p>
				<p>注意：<span>GRANT</span>語句用於在全局層級或資料庫層級賦予權限。當在<span>GRANT</span>語句中指定資料庫名稱時，允許使用『<span>_</span>』和『<span>%</span>』通配符。這意味著，如果您想要使用『<span>_</span>』字元作為一個資料庫名稱的一部分，您應該在<span>GRANT</span>語句中指定它為『<span>\_</span>』，以防止用戶可以訪問其它符合此通配符格式的資料庫；例如，<span>GRANT 
				... ON `foo\_bar`.* TO ...</span>。</p>
				<p>為了接納對來自任意主機的用戶授權的權利，<span>MySQL</span>支援以<span><i><span>user_name</span></i><span>@<i>host_name</i></span></span>的形式指定<span>user</span>值。如果一個<span>user_name</span>或<span>host_name</span>與一個不加引號的標識符一樣是合法的，那麼您不需要對它加引號。不過，要指定一個包含特殊字元（如『<span>-</span>』）的<span>user_name</span>字串，或一個包含特殊字元或通配字元（如『<span>%</span>』），則引號是必要的；例如，<span>&#39;test-user&#39;@&#39;test-hostname&#39;</span>。分別對<span>username</span>和<span>hostname</span>加引號。</p>
				<p>您可以在<span>hostname</span>中指定通配符。例如<span><i><span>user_name</span></i><span>@&#39;%.loc.gov&#39;</span></span>適用於在<span>loc.gov</span>域中的任何主機的<span>user_name</span>。同時<span><i><span>user_name</span></i><span>@&#39;144.155.166.%&#39;</span></span>適用於<span>144.155.166 
				C</span>級子網中的任何主機的<span>user_name</span>。</p>
				<p>簡單形式<span>user_name</span>是<span><i><span>user_name</span></i><span>@&#39;%&#39;</span></span>的同義詞。</p>
				<p><span>MySQL</span>不支援<span>usernames</span>中的通配符。通過把帶有<span>User=&#39;&#39;</span>的登錄項插入到<span>mysql.user</span>資料表中，或通過使用<span>GRANT</span>語句建立一個帶有空名稱的用戶，可以定義匿名用戶：</p>
				<pre><span>mysql&gt; <span><b>GRANT ALL ON test.* TO &#39;&#39;@&#39;localhost&#39; ...</b></span></span></pre>
				<p>當把帶引號的值是，需使用反勾號<span>(</span>『<span>`</span>』<span>)</span>為資料庫、資料表、列和子程式名稱加引號。使用單引號<span>(</span>『<span>&#39;</span>』<span>)</span>為<span>hostnames</span>、<span>usernames</span>和
				密碼加引號。</p>
				<p>警告：如果您允許匿名用戶連接到<span>MySQL</span>伺服器，則您應該同時向所有本地用戶授予<span><i><span>user_name</span></i><span>@localhost</span></span>權限。否則，當有名稱的用戶試圖從本地機器登錄<span>MySQL</span>伺服器時，<span>mysql.user</span>資料表中的用於<span>localhost</span>的匿名用戶帳戶會被使用。</p>
				<p>您可以通過執行以下查詢來確定是否這適合於您。以下查詢列舉了所有匿名用戶：</p>
				<pre><span>mysql&gt; <span><b>SELECT Host, User FROM mysql.user WHERE User=&#39;&#39;;</b></span></span></pre>
				<p>如果您想要刪除本地匿名用戶帳號，以避免出現剛才談到的問題，則需使用以下語句：</p>
				<pre><span>mysql&gt; <span><b>DELETE FROM mysql.user WHERE Host=&#39;localhost&#39; AND User=&#39;&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>FLUSH PRIVILEGES;</b></span></span></pre>
				<p><span>GRANT</span>支援最長為<span>60</span>個字元的<span>hostnames</span>。資料庫、資料表、列和子程式名稱最長可為<span>64</span>個字元。<span>Usernames</span>最長可為<span>16</span>個字元。
				註釋：不能通過更改<span>mysql.user</span>資料表來改變<span>usernames</span>的允許長度。如果試圖這麼做，會導致出現不可預見的問題，可能會造成用戶無法登錄<span>MySQL</span>伺服器。除了採用由<span>MySQL</span>公司提供的用於升級<span>MySQL</span>伺服器的<span><span>mysql_fix_privilege_tables</span>原稿之外，</span>請您不要以任何方式變更授權資料表。</p>
				<p>對於資料表或列的權限是作為各個權限層級的邏輯<span>OR</span>權限被附加形成的。例如，如果<span>mysql.user</span>資料表指定一個用戶擁有全局<span>SELECT</span>權限，則該權限不能被資料庫、資料表或列層級的登錄項定義。</p>
				<p>可以按下列方法計算列權限：</p>
				<pre><span>global privileges</span></pre>
				<pre><span>OR (database privileges AND host privileges)</span></pre>
				<pre><span>OR table privileges</span></pre>
				<pre><span>OR column privileges</span></pre>
				<p>在多數情況下，您只在一個權限層級下向用戶授予權利，所以壽命通常不是那麼複雜。有關權限檢查規程的細節，請參見<a href="database-administration.html#privilege-system" title="5.7. The MySQL Access Privilege System">5.7節，「MySQL訪問權限系統」</a>。</p>
				<p>如果您對一個在<span>mysql.user</span>資料表中不存在的<span>username/hostname</span>組合授予權限，則增加一個登錄項並保持在此處，直到使用<span>DELETE</span>語句刪除為止。換句話說，<span>GRANT</span>可以建立用戶資料表登錄項，但是<span>REVOKE</span>不會取消它們；您必須使用<span>DROP 
				USER</span>或<span>DELETE</span>明確地操作。</p>
				<p>如果建立了一個新的用戶，或者如果您擁有全局授權權限，則用戶密碼被設置為由<span>IDENTIFIED 
				BY</span>子句指定的密碼（如果給定了一個）。如果用戶已擁有了一個密碼，則此密碼被新密碼替代。</p>
				<p>警告：如果您建立了一個新用戶，但是不指定<span>IDENTIFIED BY</span>子句，則用戶沒有
				密碼。這是很不安全的。不過，您可以啟用<span>NO_AUTO_CREATE_USER 
				SQL</span>模式，來防止<span>GRANT</span>建立一個新用戶（否則<span>GRANT</span>會這麼做），除非給定了<span>IDENTIFIED 
				BY</span>來為新用戶提供一個密碼。</p>
				<p>使用<span>SET PASSWORD</span>語句也可以設置密碼。請參見<a href="sql-syntax.html#set-password" title="13.5.1.5. SET PASSWORD Syntax">13.5.1.5節，「SET 
			PASSWORD語法」</a>。</p>
				<p>在<span>IDENTIFIED BY</span>子句中，密碼應被作為文字密碼只被給定。沒有必要使用<span>PASSWORD()</span>函數，因為該函數用於<span>SET 
				PASSWORD</span>語句。例如：</p>
				<pre><span>GRANT ... IDENTIFIED BY &#39;mypass&#39;;</span></pre>
				<p>如果您不想以明白的文字發送密碼，並且您知道<span>PASSWORD()</span>返回給密碼的混編值，則您可以指定混編值，前面加入關鍵詞<span>PASSWORD</span>：</p>
				<pre><span>GRANT ...</span></pre>
				<pre><span>IDENTIFIED BY PASSWORD &#39;*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4&#39;;</span></pre>
				<p>在一個<span>C</span>程式中，您可以通過使用<span>make_scrambled_password()</span><span> 
				C API</span>函數得到混編值。</p>
				<p>如果您為一個資料庫授予權限，則在<span>mysql.db</span>資料表中，會根據需要建立登錄項。如果使用<span>REVOKE</span>刪除了所有的資料庫權限，則本登錄項被刪除。</p>
				<p>如果一個用戶不擁有資料表權限，則當用戶申請資料表清單時（例如，使用<span>SHOW TABLES</span>語句），資料表名稱不顯示。</p>
				<p><span>SHOW DATABASES</span>權限允許帳號通過發佈<span>SHOW 
				DATABASE</span>語句來觀看數據名稱。不擁有此權限的帳號只能看到他們擁有部分權限的資料庫，並且如果使用<span>--skip-show-database</span>選項啟動伺服器，則根本不能使用本語句。</p>
				<p><span>WITH GRANT OPTION</span>子句給予用戶能力，可以在指定的權限層級，向其它用戶給定其擁有的任何權限。您應該留心您給予了誰<span>GRANT 
				OPTION</span>權限，因為擁有不同權限的兩個用戶可以聯合使用權限！</p>
				<p>您不能向其它用戶授予您自己沒有的權限；<span>GRANT OPTION</span>權限只允許您賦予您自己擁有的權限。</p>
				<p>要注意，當您在某個特定權限層級向一個用戶授予<span>GRANT OPTION</span>權限時，用戶擁有的該層級的任何權限（或未來將被給定的權限）也可以由該用戶授予。假設您向一個用戶賦予了資料庫<span>INSERT</span>權限。如果您然後賦予資料庫<span>SELECT</span>權限，並指定了<span>WITH 
				GRANT OPTION</span>，則該用戶不僅可以向其它用戶給予<span>SELECT</span>權限，還可以給予<span>INSERT</span>。如果您然後向用戶授予資料庫<span>UPDATE</span>權限，則用戶可以授予<span>INSERT, 
				SELECT</span>和<span>UPDATE</span>。</p>
				<p>您不應該向一個常規用戶授予<span>ALTER</span>權限。如果您這麼做，則該用戶可以嘗試通過對資料表重新命名來破壞授權系統！</p>
				<p><span>The <span>
				MAX_QUERIES_PER_HOUR <i>count</i></span>,
				<span>MAX_UPDATES_PER_HOUR <i>count</i></span>, 
				and <span>MAX_CONNECTIONS_PER_HOUR <i>
				count</i></span> options limit the number of queries, updates, 
				and logins a user can perform during any given one-hour period. 
				If <span><i>count</i></span> is
				<span>0</span> (the default), this means 
				that there is no limitation for that user.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<span>MAX_QUERIES_PER_HOUR <i>count</i></span>,
				<span>MAX_UPDATES_PER_HOUR <i>count</i></span></span>和<span>MAX_CONNECTIONS_PER_HOUR
				<i>count</i></span>選項限制了在任何給定的一小時期間，用戶可以執行的查詢、更新和登錄的數目。如果<span>count</span>是<span>0</span>（預設值），這意味著，對該用戶沒有限制。</p>
				<p><span>
				MAX_USER_CONNECTIONS <i>count</i></span>選項限制了帳號可以同時進行的連接的最大數目。如果<span>count</span>是<span>0</span>（預設值），則<span>max_user_connections</span>系統可以決定該
				帳號同時連接的數目。</p>
				<p>註釋：要對一個原有的用戶指定任何這類資源限制型選項，同時又不影響原有的權限，需使用<span>GRANT 
				USAGE ON *.* ... WITH MAX_...</span>。</p>
				<p>見<a href="database-administration.html#user-resources" title="5.8.4. Limiting Account Resources">5.8.4節，「限制帳號資源」</a>。</p>
				<p>除了根據<span>username</span>和密碼進行常規鑒定外，<span>MySQL</span>還可以檢查<span>X509</span>證明屬性。要為<span>MySQL</span>帳號指定與<span>SSL</span>有關的選項，需使用<span>GRANT</span>語句的<span>REQUIRE</span>子句。（要瞭解有關在<span>MySQL</span>中使用<span>SSL</span>的背景訊息，請參見<a href="database-administration.html#secure-connections" title="5.8.7. Using Secure Connections">5.8.7節，「使用安全連接」</a>。）</p>
				<p>對於一個給定的帳號，有多種可能性可以限制連接類型：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果帳號沒有<span>SSL</span>或<span>X509</span>要求，並且如果<span>username</span>和
				密碼是有效的，則允許不加密連接。但是，如果客戶端有正確的證明和關鍵檔案，則根據客戶端的選擇，也可以使用加密連接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>REQUIRE SSL</span>選項用於告知伺服器，對於該帳號只允許<span>SSL</span>加密連接。注意，如果有允許任何非<span>SSL</span>連接的訪問控制記錄，則本選項可以被忽略。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39; REQUIRE SSL;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>REQUIRE X509</span>意味著客戶端必須擁有一個有效證明，除非不需要確切的證明、發佈者和主題。唯一的要求是，應可以使用<span>CA</span>證明其中之一來驗證簽名。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39; REQUIRE X509;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REQUIRE ISSUER &#39;<i>issuer</i>&#39;</span>用於對連接嘗試進行限定，客戶端必須出示一個由<span>CA</span>』<span>issuer</span>』發佈的有效的<span>X509</span>證明。如果客戶端出示的證明是有效的，但是有一個不同的發佈者，則伺服器會拒絕連接。使用<span>X509</span>證明就意味著要加密，所以在這種情況下，<span>SSL</span>選項是不必要的。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE ISSUER &#39;/C=FI/ST=Some-State/L=Helsinki/</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com&#39;;</span></pre>
				<p>注意，<span>ISSUER</span>值應被作為一個單一字串輸入。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REQUIRE SUBJECT &#39;<i>subject</i>&#39;</span>用於對連接嘗試進行限定，客戶端必須出示一個包含主題<span>subject</span>的有效的<span>X509</span>證明。如果客戶端出示的證明是有效的，但是有一個不同的主題，則伺服器會拒絕連接。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE SUBJECT &#39;/C=EE/ST=Some-State/L=Tallinn/</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O=MySQL demo client certificate/</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CN=Tonu Samuel/Email=tonu@example.com&#39;;</span></pre>
				<p>注意，<span>SUBJECT</span>值應被作為一個單一字串輸入。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>需要<span>REQUIRE 
				CIPHER &#39;<i>cipher</i>&#39;</span>來確認使用了密碼和足夠長度的關鍵字。如果使用了採用短型加密關鍵字的舊算法，<span>SSL</span>本身會比較脆弱。使用本選項，您可以要求使用特定的密碼方法來授權一個連接。</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>REQUIRE CIPHER &#39;EDH-RSA-DES-CBC3-SHA&#39;;</b></span></span></pre>
				<p><span>SUBJECT, ISSUER</span>和<span>CIPHER</span>選項可以在<span>REQUIRE</span>子句中結合，如下：</p>
				<pre><span>mysql&gt; <span><b>GRANT ALL PRIVILEGES ON test.* TO &#39;root&#39;@&#39;localhost&#39;</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>IDENTIFIED BY &#39;goodsecret&#39;</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>REQUIRE SUBJECT &#39;/C=EE/ST=Some-State/L=Tallinn/</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O=MySQL demo client certificate/</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN=Tonu Samuel/Email=tonu@example.com&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>AND ISSUER &#39;/C=FI/ST=Some-State/L=Helsinki/</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>AND CIPHER &#39;EDH-RSA-DES-CBC3-SHA&#39;;</b></span></span></pre>
				<p>注意，<span>SUBJECT</span>和<span>ISSUER</span>值各自應被作為一個單一字串輸入。</p>
				<p>在<span>REQUIRE</span>各選項之間，<span>AND</span>關鍵詞是自選的。</p>
				<p>選項的順序無所謂，但是選項不能被指定兩次。</p>
				<p>當<span>mysqld</span>啟動後，所有的權限被讀入儲存器中。要瞭解詳細說明，請參見<a href="database-administration.html#privilege-changes" title="5.7.7. When Privilege Changes Take Effect">5.7.7節，「權限更改何時生效」</a>。</p>
				<p>注意，如果您正在使用資料表權限或列權限，即使只對一個用戶使用，伺服器也會對所有用戶檢查資料表權限和列權限，這會略微降低<span>MySQL</span>的速度。與此類似，如果您對某些用戶限制查詢、更新或連接的數目，則伺服器必須監測這些值。</p>
				<p>標準<span>SQL</span>版本和<span>MySQL</span>版本的<span>GRANT</span>之間的最大區別是：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>MySQL</span>中，權限與<span>hostname</span>和<span>username</span>的組合有關，與 
				單一的<span>username</span>無關。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>標準<span>SQL</span>不擁有全局層級或資料庫層級權限，也不支援<span>MySQL</span>支援的所有權限類型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>不支援標準<span>SQL 
				TRIGGER</span>或<span>UNDER</span>權限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>標準<span>SQL</span>權限以一種分等級的方式進行組織。如果您取消一個用戶，則用戶被授予的所有權限都被撤銷。在<span>MySQL</span>中，如果您使用<span>DROP 
				USER</span>，也會如此。請參見<a href="sql-syntax.html#drop-user" title="13.5.1.2. DROP USER Syntax">13.5.1.2節，「DROP 
				USER語法」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在標準<span>SQL</span>中，當您取消一個資料表時，對一個資料表的所有權限會被撤銷。在標準<span>SQL</span>中，當您撤銷一個權限時，根據該權限被授予的所有權限也會被撤銷。在<span>MySQL</span>中，只有使用明確的<span>REVOKE</span>語句，或通過操作儲存在<span>MySQL</span>授權資料表中的值，才能取消權限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>MySQL</span>中，可以只對一個資料表中的部分列擁有<span>INSERT</span>權限。在此情況下，如果您忽略您不擁有<span>INSERT</span>權限的那些列，，您仍然可以對資料表執行<span>INSERT</span>語句。如果沒有啟用嚴格的<span>SQL</span>模式，則被忽略的列被設置為各自隱含的預設值。在嚴格模式下，如果某個被忽略的列沒有預設值，則該語句被拒絕。<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2節，「SQL伺服器模式」</a>對嚴格模式進行了討論。<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
				TABLE語法」</a>對隱含預設值進行了討論。</p>
				<p>您不擁有<span>INSERT</span>權限的列被設置為各自的預設值。標準<span>SQL</span>要求您擁有所有列的<span>INSERT</span>權限。</p>
				<p>在<span>MySQL</span>中，如果您只擁有一個資料表中的部分列的<span>INSERT</span>權限，同時，如果您從<span>INSERT</span>語句中忽略您不擁有權限的列，則您仍然可以對資料表執行<span>INSERT</span>語句；那些列將被設置為各自的預設值。在嚴格模式下（即當<span>sql_mode=&#39;traditional&#39;</span>時，如果某些被忽略的列沒有預設值，則<span>INSERT</span>語句將被拒絕。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rename-user"></a>13.5.1.4. RENAME 
				USER語法</h4></div></div></div><a class="indexterm" name="id2917845"></a><a class="indexterm" name="id2917854"></a><a class="indexterm" name="id2917865"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RENAME USER <span><i>old_user</i></span> TO <span><i>new_user</i></span></span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;[, <span><i>old_user</i></span> TO <span><i>new_user</i></span>] ...</span></pre>
				<p><span>RENAME USER</span>語句用於對原有<span>MySQL</span>帳號進行重命名。要使用<span>RENAME 
				USER</span>，您必須擁有全局<span>CREATE USER</span>權限或<span>mysql</span>資料庫<span>UPDATE</span>權限。如果舊
				帳號不存在或者新帳號已存在，則會出現錯誤。<span><i><span>old_user</span></i></span>和<span><i><span>new_user</span></i></span>值的給定方法與<span>GRANT</span>語句一樣。</p>
				<h4 class="title"><a name="set-password"></a>13.5.1.5. SET 
				PASSWORD語法</h4></div></div></div><a class="indexterm" name="id2917966"></a><a class="indexterm" name="id2917976"></a><a class="indexterm" name="id2917986"></a>
				<pre><span>SET PASSWORD = PASSWORD(&#39;<span><i>some password</i></span>&#39;)</span></pre>
				<pre><span>SET PASSWORD FOR <span><i>user</i></span> = PASSWORD(&#39;<span><i>some password</i></span>&#39;)</span></pre>
				<p><span>SET PASSWORD</span>語句用於向一個原有<span>MySQL</span>用戶
				帳號賦予一個密碼。</p>
				<p>第一個語法為當前用戶設置密碼。已使用一個非匿名帳號連接到伺服器上的任何客戶即都可以更改該帳號的密碼。</p>
				<p>第二個語法為當前伺服器主機上的一個特定帳號設置密碼。只有擁有<span>mysql</span>資料庫<span>UPDATE</span>權限的客戶端可以這麼做。<span>user</span>值應以<span><i><span>user_name</span></i><span>@<i>host_name</i></span></span>的格式被給定，此處<span><i><span>user_name</span></i></span>和<span><i><span>host_name</span></i></span>與<span>mysql.user</span>資料表登錄項的<span>User</span>和<span>Host</span>列中列出的完全一樣。舉例說明，如果您有一個登錄項，<span>User</span>和<span>Host</span>列值為<span>&#39;bob&#39;</span>和<span>&#39;%.loc.gov&#39;</span>，您應該按如下方法寫語句：</p>
				<pre><span>mysql&gt; <span><b>SET PASSWORD FOR &#39;bob&#39;@&#39;%.loc.gov&#39; = PASSWORD(&#39;<i>newpass</i>&#39;);</b></span></span></pre>
				<p>這相當於以下語句：</p>
				<pre><span>mysql&gt; <span><b>UPDATE mysql.user SET Password=PASSWORD(&#39;<i>newpass</i>&#39;)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>WHERE User=&#39;bob&#39; AND Host=&#39;%.loc.gov&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>FLUSH PRIVILEGES;</b></span></span></pre>
				<p>註釋：如果您正在使用一個<span>4.1</span>以前的客戶端連接到一個<span>MySQL 
				4.1</span>或<span>MySQL 4.1</span>以後的伺服器，則在閱讀<a href="database-administration.html#password-hashing" title="5.7.9. Password Hashing in MySQL 4.1">5.7.9節，「MySQL 4.1中的密碼哈希處理」</a>之前，不能使用前面的<span>SET PASSWORD</span>或<span>UPDATE</span>語句。
				密碼格式在<span>MySQL 
				4.1</span>中變更了，並且在特定情況下，如果您更改密碼，您可能無法在連接到伺服器上。</p>
				<p>您可以通過執行<span>SELECT CURRENT_USER()</span>觀看您當前的鑒定<span>user@host</span>登錄項。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-maintenance-sql"></a>
			13.5.2.&nbsp;資料表維護語句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#analyze-table">13.5.2.1. 
				ANALYZE TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#backup-table">13.5.2.2. 
				BACKUP TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#check-table">13.5.2.3. 
				CHECK TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#checksum-table">13.5.2.4. 
				CHECKSUM TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimize-table">13.5.2.5. 
				OPTIMIZE TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repair-table">13.5.2.6. 
				REPAIR TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#restore-table">13.5.2.7. 
				RESTORE TABLE語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="analyze-table"></a>13.5.2.1. ANALYZE 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2918217"></a>
				<pre><span>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
				<p>本語句用於分析和儲存資料表的關鍵字分佈。在分析期間，使用一個讀取鎖定對資料表進行鎖定。這對於<span>MyISAM, 
				BDB</span>和<span>InnoDB</span>資料表有作用。對於<span>MyISAM</span>資料表，本語句與使用<strong><span>myisamchk 
				-a</span></strong>相當。</p>
				<p><span>MySQL</span>使用已儲存的關鍵字分佈來決定，當您對除常數以外的對象執行聯合時，資料表按什麼順序進行聯合。</p>
				<p>本語句會返回一個含有以下列的資料表：</p>
				<table border="1" cellpadding="0" id="table8">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>資料表名稱</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>進行分析</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						狀態、錯誤、訊息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>您可以使用<span>SHOW INDEX</span>語句檢查已儲存的關鍵字分佈。請參見<a href="sql-syntax.html#show-index" title="13.5.4.11. SHOW INDEX Syntax">13.5.4.11節，「SHOW 
			INDEX語法」</a>。</p>
				<p>如果從上一個<span>ANALYZE TABLE</span>語句開始，資料表沒有變化，則不再分析該資料表。</p>
				<p><span>ANALYZE TABLE</span>語句被寫入二進制日誌中，除非使用了自選的<span>NO_WRITE_TO_BINLOG</span>關鍵詞（或其別名<span>LOCAL</span>）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="backup-table"></a>13.5.2.2. BACKUP 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2918452"></a><a class="indexterm" name="id2918461"></a>
				<pre><span>BACKUP TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... TO &#39;<span><i>/path/to/backup/directory</i></span>&#39;</span></pre>
				<p>註釋：本語句不理想。我們正在努力尋找一種更好的替代方式，該方式將提供線上備份能力。同時，也可以使用<strong><span>mysqlhotcopy</span></strong>原本替代。</p>
				<p><span>BACKUP TABLE</span>用於在刷新了所有對磁盤的緩衝變更後，把恢復資料表所需的最少數目的資料表檔案拷貝到備份目錄中。本語句只對<span>MyISAM</span>資料表起作用。它可以拷貝<span>.frm</span>定義檔案和<span>.MYD</span>數據檔案。<span>.MYI</span>索引檔案可以從這兩個檔案中重建。本目錄應被指定為一個完整的路徑名。</p>
				<p>在使用本語句前，請參見<a href="database-administration.html#backup" title="5.9.1. Database Backups">5.9.1節，「資料庫備份」</a>。</p>
				<p>
				在備份期間，為每個資料表保持一個讀取鎖定，每次一個，在正在備份時鎖定。如果您想要把多個資料表作為一個快照來備份（防止它們在備份操作過程中被更改），您必須實現發佈一個<span>LOCK 
				TABLES</span>語句，以獲得對一個組群中的每個資料表的讀取鎖定。</p>
				<p>該語句會返回一個含有以下列的資料表：</p>
				<table border="1" cellpadding="0" id="table9">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>資料表名稱</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>進行備份</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						狀態、錯誤、訊息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="check-table"></a>13.5.2.3. CHECK 
			TABLE語法</h4></div></div></div><a class="indexterm" name="id2918695"></a>
				<pre><span>CHECK TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [<span><i>option</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>option</span></i></span><span> = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</span></pre>
				<p>檢查一個或多個資料表是否有錯誤。<span>CHECK TABLE</span>對<span>MyISAM</span>和<span>InnoDB</span>資料表有作用。對於<span>MyISAM</span>資料表，關鍵字統計數據被更新。</p>
				<p><span>CHECK TABLE</span>也可以檢查視圖是否有錯誤，比如在視圖定義中被引用的資料表已不存在。</p>
				<p><span>CHECK TABLE</span>語句會返回一個含有以下列的資料表：</p>
				<table border="1" cellpadding="0" id="table10">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>資料表名稱</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>進行檢查</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						狀態、錯誤、訊息或錯誤之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>注意，該語句可能會為每個被檢查的資料表產生多行訊息。最後一行有一個<span>Msg_type</span>狀態值。<span>Msg_text</span>通常應為<span>OK</span>。如果您沒有得到<span>OK</span>，或資料表已經更新了，則您通常應該運行修復後的資料表。請參見<a href="database-administration.html#table-maintenance" title="5.9.4. Table Maintenance and Crash Recovery">5.9.4節，「資料表維護和崩潰恢復」</a>。資料表已經更新了，這意味著資料表的儲存引擎指示沒有必要檢查資料表。</p>
				<p>可以給予的不同的檢查選項列於下資料表中。這些選項只適用於檢查<span>MyISAM</span>資料表。對於<span>InnoDB</span>資料表和視圖，這些選項被忽略。</p>
				<table border="1" cellpadding="0" id="table11">
					<tr>
						<td>
						<p><strong>
						<span>類型</span></strong></td>
						<td>
						<p><strong>
						<span>意義</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>QUICK</span></td>
						<td>
						<p>不掃瞄行，不檢查錯誤的連結。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>FAST</span></td>
						<td>
						<p>只檢查沒有被正確關閉的資料表。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CHANGED</span></td>
						<td>
						<p>只檢查上次檢查後被更改的資料表，和沒有被正確關閉的資料表。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MEDIUM</span></td>
						<td>
						<p>
						掃瞄行，以驗證被刪除的連結是有效的。也可以計算各行的關鍵字校驗和，並使用計算出的校驗和驗證這一點。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>EXTENDED</span></td>
						<td>
						<p>對每行的所有關鍵字進行一個全面的關鍵字搜尋。這可以確保資料表是<span>100</span>％一致的，但是花的時間較長。</td>
					</tr>
				</table>
				<p>如果沒有指定<span>QUICK, MEDIUM</span>或<span>EXTENDED</span>選項，則對於動態格式<span>MyISAM</span>資料表，預設檢查類型是<span>MEDIUM</span>。這與對資料表運行<strong><span>myisamchk 
				--medium-check </span></strong><span><b>
				<i><span>tbl_name</span></i></b></span>的結果相同。對於靜態格式<span>MyISAM</span>資料表，預設檢查類型也是<span>MEDIUM</span>，除非<span>CHANGED</span>或<span>FAST</span>已被指定。在此情況下，預設值為<span>QUICK</span>。對於<span>CHANGED</span>和<span>FAST</span>，行掃瞄被跳過，因為行極少被破壞。</p>
				<p>您可以組合檢查選項，如下面的例子所示。該例子對資料表進行了一個快速檢查，來查看該資料表是否被正確關閉：</p>
				<pre><span>CHECK TABLE test_table FAST QUICK;</span></pre>
				<p>註釋：在有些情況下，<span>CHECK TABLE</span>會更改資料表。如果資料表被標記為「<span>corrupted</span>」或「<span>not 
				closed properly</span>」，則出現這種情況。但是<span>CHECK TABLE</span>不會找出資料表中的問題。在這種情況下，<span>CHECK 
				TABLE</span>會把資料表標記為良好。</p>
				<p>
				如果一個資料表被破壞，很有可能問題在索引中，而不在數據部分中。所有前述的檢查類型都可以徹底地檢查索引，因此，可以找出多數的錯誤。</p>
				<p>如果您只想要檢查您假定的資料表是良好的，您應該不使用檢查選項或<span>QUICK</span>選項。當您時間匆忙時，應使用<span>QUICK</span>。<span>QUICK</span>無法找出數據檔案中的錯誤的風險非常小。（在多數情況下，在正常使用中，<span>MySQL</span>應能在數據檔案中找出錯誤。如果找出了錯誤，資料表被標記為「<span>corrupted</span>」，並不能被使用，直到修復為止。）</p>
				<p>如果您想要時常檢查資料表，<span>FAST</span>和<span>CHANGED</span>多數情況下從原本中被使用（例如，從<span>cron</span>中被執行）。在多數情況下，<span>FAST</span>優先於<span>CHANGED</span>。（只有一種情況<span>FAST</span>不優先於<span>CHANGED</span>，那就是當您懷疑您在<span>MyISAM</span>代碼中發現了錯誤。）</p>
				<p>當<span>MySQL</span>試圖通過關鍵字更新一行或搜尋一行時，如果您已經運行了一個常規檢查後但仍得到來自資料表的奇怪的錯誤，此時使用<span>EXTENDED</span>。（如果常規的檢查運行成功，則基本用不著<span>EXTENDED</span>。）</p>
				<p>被<span>CHECK TABLE</span>報告的部分問題不會被自動修正：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>發現行。此行中，<span>auto_increment</span>列有<span>0</span>值。</p>
				<p>這意味著，您在資料表中有一行，該行的<span>AUTO_INCREMENT</span>索引列包含<span>0</span>值。（可以通過使用<span>UPDATE</span>語句，明確地把列設置為<span>0</span>，以建立一個<span>AUTO_INCREMENT</span>列為<span>0</span>的行。）</p>
				<p>這本身不是一個錯誤，但是如果您決定轉儲資料表並恢復資料表，或對資料表進行<span>ALTER 
				TABLE</span>，那麼會導致出現麻煩。在此情況下，<span>AUTO_INCREMENT</span>列會根據<span>AUTO_INCREMENT</span>列的結果更改值，這會導致出現問題，如重複關鍵字錯誤等。</p>
				<p>要消除警告，只需執行一個<span>UPDATE</span>語句，把列設置為除<span>0</span>以外的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="checksum-table"></a>13.5.2.4. CHECKSUM 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2919302"></a>
				<pre><span>CHECKSUM TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [ QUICK | EXTENDED ]</span></pre>
				<p>報告一個資料表校驗和。</p>
				<p>如果指定了<span>QUICK</span>，則報告活性資料表校驗和，否則報告<span>NULL</span>。這是非常快的。活性資料表通過指定<span>CHECKSUM</span>＝<span>1</span>資料表選項啟用，目前只支援用於<span>MyISAM</span>資料表。請參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
			TABLE語法」</a>。</p>
				<p>在<span>EXTENDED</span>模式下，整個資料表被一行一行地讀取，並計算校驗和。對於大型資料表，這是非常慢的。</p>
				<p>預設情況下，如果既沒有指定<span>QUICK</span>，也沒有指定<span>EXTENDED</span>，並且如果資料表儲存引擎支援，則<span>MySQL</span>返回一個活性校驗和，否則會對資料表進行掃瞄。</p>
				<p><span>CHECKSUM TABLE</span>對於不存在的資料表會返回<span>NULL</span>。對於這種情況，會生成一個警告。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-table"></a>13.5.2.5. OPTIMIZE 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2919431"></a><a class="indexterm" name="id2919440"></a><a class="indexterm" name="id2919450"></a>
				<pre><span>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
				<p>如果您已經刪除了資料表的一大部分，或者如果您已經對含有可變長度行的資料表（含有<span>VARCHAR, 
				BLOB</span>或<span>TEXT</span>列的資料表）進行了很多更改，則應使用<span>OPTIMIZE 
				TABLE</span>。被刪除的記錄被保持在連結清單中，後續的<span>INSERT</span>操作會重新使用舊的記錄位置。您可以使用<span>OPTIMIZE 
				TABLE</span>來重新利用未使用的空間，並整理數據檔案的碎片。</p>
				<p>在多數的設置中，您根本不需要運行<span>OPTIMIZE TABLE</span>。即使您對可變長度的行進行了大量的更新，您也不需要經常運行，每週一次或每月一次即可，只對特定的資料表運行。</p>
				<p><span>OPTIMIZE TABLE</span>只對<span>MyISAM, 
				BDB</span>和<span>InnoDB</span>資料表起作用。</p>
				<p>對於<span>MyISAM</span>資料表，<span>OPTIMIZE 
				TABLE</span>按如下方式操作：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>如果資料表已經刪除或分解了行，則修復資料表。</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>如果未對索引頁進行分類，則進行分類。</p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span>&nbsp;&nbsp;&nbsp;</span>如果資料表的統計數據沒有更新（並且通過對索引進行分類不能實現修復），則進行更新。</p>
				<p>對於<span>BDB</span>資料表，<span>OPTIMIZE TABLE</span>目前被映射到<span>ANALYZE 
				TABLE</span>上。對於<span>InnoDB</span>資料表，<span>OPTIMIZE 
				TABLE</span>被映射到<span>ALTER TABLE</span>上，這會重建資料表。重建操作能更新索引統計數據並釋放成叢集索引中的未使用的空間。請參見<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1節，「ANALYZE 
			TABLE語法」</a>。</p>
				<p>使用—<span>skip-new</span>或—<span>safe-mode</span>選項可以啟動<span>mysqld</span>。通過啟動<span>mysqld</span>，您可以使<span>OPTIMIZE 
				TABLE</span>對其它資料表類型起作用。</p>
				<p>注意，在<span>OPTIMIZE TABLE</span>運行過程中，<span>MySQL</span>會鎖定資料表。</p>
				<p><span>OPTIMIZE TABLE</span>語句被寫入到二進制日誌中，除非使用了自選的<span>NO_WRITE_TO_BINLOG</span>關鍵詞（或其別名<span>LOCAL</span>）。已經這麼做了，因此，用於<span>MySQL</span>伺服器的<span>OPTIMIZE 
				TABLE</span>命令的作用相當於一個複製主伺服器，在預設情況下，這些命令將被複製到複製從屬伺服器中。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repair-table"></a>13.5.2.6. REPAIR 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2919705"></a>
				<pre><span>REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... [QUICK] [EXTENDED] [USE_FRM]</span></pre>
				<p><span>REPAIR TABLE</span>用於修復被破壞的資料表。預設情況下，<span>REPAIR 
				TABLE</span>與<strong><span>myisamchk 
				--recover </span></strong><span><b><i>
				<span>tbl_name</span></i></b></span>具有相同的效果。<span>REPAIR 
				TABLE</span>對<span>MyISAM</span>和<span>ARCHIVE</span>資料表起作用。請參見<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1節，「MyISAM儲存引擎」</a><span>,
				</span>
          <a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">
				15.8節，「ARCHIVE儲存引擎」</a>。</p>
				<p>通常，您基本上不必運行此語句。但是，如果災難發生，<span>REPAIR TABLE</span>很有可能從<span>MyISAM</span>資料表中找回所有數據。如果您的資料表經常被破壞，您應該盡力找到原因，以避免使用<span>REPAIR 
				TALBE</span>。請參見<a href="problems.html#crashing" title="A.4.2. What to Do If MySQL Keeps Crashing">A.4.2節，「如果MySQL依然崩潰，應作些什麼」</a>。同時也見<a href="storage-engines.html#myisam-table-problems" title="15.1.4. MyISAM Table Problems">15.1.4節，「MyISAM資料表方面的問題」</a>。</p>
				<p>本語句會返回一個含有以下列的資料表：</p>
				<table border="1" cellpadding="0" id="table12">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>資料表名稱</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>進行修復</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						狀態、錯誤、訊息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
				<p>對於每個被修復的資料表，<span>REPAIR TABLE</span>語句會產生多行的訊息。上一行含有一個<span>Msg_type</span>狀態值。<span>Msg_test</span>通常應為<span>OK</span>。如果您沒有得到<span>OK</span>，您應該嘗試使用<strong><span>myisamchk 
				--safe-recover</span></strong>修復資料表，因為<span>REPAIR TABLE</span>尚不會執行所有的<strong><span>myisamchk</span></strong>選項。我們計劃在將來使它的靈活性更強。</p>
				<p>如果給定了<span>QUICK</span>，則<span>REPAIR 
				TABLE</span>會嘗試只修復索引樹。這種類型的修復與使用<strong><span>myisamchk 
				--recover --quick</span></strong>相似。</p>
				<p>如果您使用<span>EXTENDED</span>，則<span>MySQL</span>會一行一行地建立索引行，代替使用分類一次建立一個索引。這種類型的修復與使用<strong><span>myisamchk 
				--safe-recover</span></strong>相似。</p>
				<p>對於<span>REPAIR TABLE</span>，還有一種<span>USE_FRM</span>模式可以利用。如果<span>.MYI</span>索引檔案缺失或標題被破壞，則使用此模式。在這種模式下，<span>MySQL</span>可以使用來自<span>.frm</span>檔案重新建立<span>.MYI</span>檔案。這種修復不能使用<strong><span>myisamchk</span></strong>來完成。
				註釋：只能在您不能使用常規<span>REPAIR</span>模式是，才能使用此模式。<span>.MYI</span>標題包含重要的資料表元數據（特別是，當前的<span>AUTO_INCREMENT</span>值和<span>Delete</span>連結）。這些元數據在<span>REPAIR...USE_FRM</span>中丟失。如果資料表被壓縮，則不能使用<span>USE_FRM</span>。因為本訊息也儲存在<span>.MYI</span>檔案中。</p>
				<p><span>REPAIR TABLE</span>語句被寫入二進制日誌中，除非使用了自選的<span>NO_WRITE_TO_BINLOG</span>關鍵詞（或其別名<span>LOCAL</span>）。</p>
				<p>警告：如果在<span>REPAIR TABLE</span>運行過程中，伺服器停機，則在重新啟動之後，在執行其它操作之前，您必須立刻對資料表再執行一個<span>REPAIR 
				TABLE</span>語句。（通過製作一個備份來啟動是一個好辦法。）再最不利情況下，您可以有一個新的乾淨的索引檔案，不含有關數據檔案的訊息。然後，您執行的下一個操作會覆蓋數據檔案。這很少發生，但是是有可能的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="restore-table"></a>13.5.2.7. RESTORE 
				TABLE語法</h4></div></div></div><a class="indexterm" name="id2920125"></a>
				<pre><span>RESTORE TABLE <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ... FROM &#39;<span><i>/path/to/backup/directory</i></span>&#39;</span></pre>
				<p>用於恢復來自用<span>BACKUP TABLE</span>製作的備份的資料表。原有的資料表不會被覆蓋；如果您試圖覆蓋一個原有的資料表，會發生錯誤。和<span>BACKUP 
				TABLE</span>一樣，<span>RESTORE TABLE</span>目前只對<span>MyISAM</span>資料表起作用。目錄應被指定為一個完整路徑名。</p>
				<p>每個資料表的備份包括其<span>.frm</span>格式檔案和<span>.MYD</span>數據檔案。恢復操作會恢復這些檔案，然後使用這些檔案來重建<span>.MYI</span>索引檔案。恢復操作比備份操作花的時間更長，這是因為需要重建索引。資料表含有的索引越多，花的時間就越長。</p>
				<p>該語句會返回一個含有以下列的資料表：</p>
				<table border="1" cellpadding="0" id="table13">
					<tr>
						<td>
						<p><strong>
						<span>列</span></strong></td>
						<td>
						<p><strong>
						<span>值</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Table</span></td>
						<td>
						<p>資料表名稱</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Op</span></td>
						<td>
						<p><span>進行恢復</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_type</span></td>
						<td>
						<p><span>
						狀態、錯誤、訊息或警告之一</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Msg_text</span></td>
						<td>
						<p>消息</td>
					</tr>
				</table>
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-option"></a>13.5.3. SET語法</h3></div></div></div><a class="indexterm" name="id2920330"></a><a class="indexterm" name="id2920339"></a>
			<pre><span>SET <span><i>variable_assignment</i></span> [, <span><i>variable_assignment</i></span>] ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>variable_assignment</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>user_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; | [GLOBAL | SESSION] <span><i>system_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; | @@[global. | session.]<span><i>system_var_name</i></span> = <span><i>expr</i></span></span></pre>
			<p><span>SET</span>用於設置不同類型的變數。這些變數會影響伺服器或客戶端的操作。<span>SET</span>可以用於向用戶變數或系統變數賦值。</p>
			<p>用於分配帳號密碼的<span>SET PASSWORD</span>語句在<a href="sql-syntax.html#set-password" title="13.5.1.5. SET PASSWORD Syntax">13.5.1.5節，「SET 
		PASSWORD語法」</a>中進行了討論。</p>
			<p>多數系統變數可以在運行時間被更改。可以被動態設置的系統變數在<a href="database-administration.html#dynamic-system-variables" title="5.3.3.1. Dynamic System Variables">5.3.3.1節，「動態系統變數」</a>中進行了討論。</p>
			<p>註釋：舊版本的<span>MySQL</span>採用<span>SET OPTION</span>作為這個命令，但是由於有了<span>SET</span>，現在不贊成使用<span>SET 
			OPTION</span>。</p>
			<p>以下例子顯示了您可以用於設置變數的不同語法。</p>
			<p>用戶變數可以被寫作<span>@<i>var_name</i></span>，並可以進行如下設置：</p>
			<pre><span>SET @<span><i>var_name</i></span> = <span><i>expr</i></span>;</span></pre>
			<p>在<a href="language-structure.html#variables" title="9.3. User Variables">9.3節，「用戶變數」</a>中給出了有關用戶變數的更多訊息。</p>
			<p>系統變數可以被作為<span><i><span>var_name</span></i></span>引用到<span>SET</span>語句中。在名稱的前面可以自選地新增<span>GLOBAL</span>或<span>@@global</span>，以明確地指示該變數是全局變數。或者在名稱前面新增<span>SESSION, 
			@@session</span>，或<span>@@</span>，以指示它是一個會話變數。<span>LOCAL</span>和<span>@@local</span>是<span>SESSION</span>和<span>@@session</span>地同義詞。如果沒有修改符，則<span>SET</span>設置會話變數。</p>
			<p>支援系統變數的<span>@@<i>var_name</i></span>語法，以便使<span>MySQL</span>語法與其它資料庫系統相兼容。</p>
			<p>如果您在同一個語句中設置多個系統變數，則最後一個<span>GLOBAL</span>或<span>SESSION</span>選項被用於沒有指定模式的變數。</p>
			<pre><span>SET sort_buffer_size=10000;</span></pre>
			<pre><span>SET @@local.sort_buffer_size=10000;</span></pre>
			<pre><span>SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;</span></pre>
			<pre><span>SET @@sort_buffer_size=1000000;</span></pre>
			<pre><span>SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;</span></pre>
			<p>如果您使用<span>SESSION</span>（預設情況）設置一個系統變數，則該值仍然有效，直到當前會話結束為止，或者直到您吧變數設置為一個不同的值為止。如果您使用<span>GLOBAL</span>（要求<span>SUPER</span>權限）來設置一個系統變數，則該值被記住，並被用於新的連接，直到伺服器重新啟動為止。如果您想要進行永久式變數設置，您應該把它放入一個選項檔案。請參見<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2節，「使用選項檔案」</a>。</p>
			<p>為了防止不正確的使用，如果您使用<span>SET GLOBAL</span>時同時使用了一個只能與<span>SET 
			SESSION</span>同時使用的變數，或者如果您在設置一個全局變數時未指定<span>GLOBAL</span>（或<span>@@</span>），則<span>MySQL</span>會產生一個錯誤。</p>
			<p>如果您想要把一個<span>SESSION</span>變數設置為<span>GLOBAL</span>值或把一個<span>GLOBAL</span>值設置為內部<span>MySQL</span>預設值，需使用<span>DEFAULT</span>關鍵詞。例如，在把<span>max_join_size</span>會話值設置為全局值時，以下兩個語句是一樣的：</p>
			<pre><span>SET max_join_size=DEFAULT;</span></pre>
			<pre><span>SET @@session.max_join_size=@@global.max_join_size;</span></pre>
			<p>您可以使用<span>SHOW VARIABLES</span>來得到系統變數清單。（見<a href="sql-syntax.html#show-variables" title="13.5.4.21. SHOW VARIABLES Syntax">13.5.4.21節，「SHOW VARIABLES語法」</a>。）要獲得與樣式匹配的一個具體的變數名稱或者名稱清單，需使用<span>LIKE</span>子句，使用方法如下：</p>
			<pre><span>SHOW VARIABLES LIKE &#39;max_join_size&#39;;</span></pre>
			<pre><span>SHOW GLOBAL VARIABLES LIKE &#39;max_join_size&#39;;</span></pre>
			<p>要得到名稱與樣式匹配的變數的清單，需使用通配符『<span>%</span>』：</p>
			<pre><span>SHOW VARIABLES LIKE &#39;have%&#39;;</span></pre>
			<pre><span>SHOW GLOBAL VARIABLES LIKE &#39;have%&#39;;</span></pre>
			<p>通配符可以被用於相匹配的樣式中的任何位置。</p>
			<p>您也可以通過使用<span>@@[global.|local.]var_name</span>語法和<span>SELECT</span>來得到值：</p>
			<pre><span>SELECT @@max_join_size, @@global.max_join_size;</span></pre>
			<p>當您使用<span>SELECT @@var_name</span>（即您不指定全局、會話或本地）來恢復一個變數時，則<span>MySQL</span>會返回<span>SESSION</span>值（如果存在）或者<span>GLOBAL</span>值。</p>
			<p>以下清單用於描述帶有非標準語法的變數，或描述在系統變數清單中（見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。）中沒有描述的變數。儘管這些變數沒有被<span>SHOW VARIABLES</span>顯示，但是您可以使用<span>SELECT</span>來獲得它們的值（例外情況是，使用<span>CHARACTER 
			SET</span>和<span>SET NAMES</span>）。例如：</p>
			<pre><span>mysql&gt; <span><b>SELECT @@AUTOCOMMIT;</b></span></span></pre>
			<pre><span>+--------------+</span></pre>
			<pre><span>| @@AUTOCOMMIT |</span></pre>
			<pre><span>+--------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
			<pre><span>+--------------+</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AUTOCOMMIT = {0 | 1}</span><span> </span></p>
			<p>設置<span>autocommit</span>模式。如果設置為<span>1</span>，則所有對資料表的更改會立刻生效。如果設置為<span>0</span>，則您必須使用<span>COMMIT</span>來接受一個事務，或使用<span>ROLLBACK</span>來取消它。如果您把<span>AUTOCOMMIT</span>模式從<span>0</span>改為<span>1</span>，則<span>MySQL</span>會對開放事務執行一個自動<span>COMMIT</span>。開始一個事務的另一種方法是使用一個<span>START 
			TRANSACTION</span>或<span>BEGIN</span>語句。請參見<a href="sql-syntax.html#commit" title="13.4.1. START TRANSACTION, COMMIT, and ROLLBACK Syntax">13.4.1節，「START 
			TRANSACTION, COMMIT和ROLLBACK語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			BIG_TABLES = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>1</span>，所有的臨時資料表被儲存在磁盤中，而不是儲存在儲存期中。這樣會稍微慢些，但是對於需要一個大型臨時資料表的<span>SELECT</span>操作，不會發生<span>The 
			table <i>tbl_name</i> is full</span>錯誤。對於一個新連接，預設值為<span>0</span>（使用儲存器內部臨時資料表）。通常，您不必設置此變數，因為根據需要，儲存器內部資料表會被自動轉換為以磁盤為基礎的資料表。（
			註釋：本變數以前被命名為<span>SQL_BIG_TABLES</span>。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CHARACTER SET {<i>charset_name</i> | DEFAULT}</span><span>
			</span></p>
			<p>
			本語句使用給定的映射為所有來自客戶端和指向客戶端的字串建立映射。您可以通過在<span>MySQL</span>源分佈中編輯<span>sql/convert.cc</span>來新增新的映射。<span>SET 
			CHARACTER SET</span>用於設定三個會話系統變數：<span>character_set_client</span>和<span>character_set_results</span>被設置為給定的字元編碼，<span>character_set_connection</span>被設置為<span>character_set_database</span>值。</p>
			<p>可以通過使用<span>DEFAULT</span>值恢復預設的映射。</p>
			<p>注意，<span>SET CHARACTER SET</span>的語法與設置其它選項的語法不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			FOREIGN_KEY_CHECKS = {0 | 1}</span><span> </span>
			</p>
			<p>如果設置為<span>1</span>（預設情況），則檢查<span>InnoDB</span>資料表的外部鍵限制條件。如果設置為<span>0</span>，則限制條件被忽略。如果重新載入<span>InnoDB</span>資料表時按照的順序與上級<span>/</span>下級目錄所要求的順序不同，此時禁用外部鍵檢查是有用的。請參見<a href="storage-engines.html#innodb-foreign-key-constraints" title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4節，「FOREIGN 
			KEY約束」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>IDENTITY 
			= <i>value</i></span><span> </span></p>
			<p>該變數是<span>LAST_INSERT_ID</span>變數的同義詞。該變數的作用是保持與其它資料庫兼容。您可以使用<span>SELECT 
			@@IDENTITY</span>讀取其值，並可以使用<span>SET IDENTITY</span>設置它。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INSERT_ID = <i>value</i></span><span> </span></p>
			<p>用於設置將被以下<span>INSERT</span>或<span>ALTER 
			TABLE</span>語句使用的值。此值在插入一個<span>AUTO_INCREMENT</span>值時使用。本語句主要和二進制日誌同時使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			LAST_INSERT_ID = <i>value</i></span><span> </span>
			</p>
			<p>用於設定將從<span>LAST_INSERT_ID()</span>被返回的值。當您在用於更新資料表的語句中使用<span>LAST_INSERT_ID()</span>時，它被儲存在二進制日誌中。設置此變數不會更新由<span>mysql_insert_id() 
			C API</span>函數返回的值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>NAMES {&#39;<i>charset_name</i>&#39; 
			| DEFAULT}</span><span> </span></p>
			<p><span>SET NAMES</span>用於把三個會話系統變數<span>character_set_client, 
			character_set_connection</span>和<span>character_set_results</span>設置為給定的字元編碼。把<span>character_set_connection</span>設置為<span>charset_name</span>時，同時把<span>collation_connection</span>設置為<span>charset_name</span>的預設整序。</p>
			<p>使用一個<span>DEFAULT</span>值可以恢復預設的映射。</p>
			<p>注意，<span>SET NAMES</span>的語法與用於設置其它選項的語法不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ONE_SHOT</span><span>
			</span></p>
			<p>
			這不是一個伺服器系統變數，但是它可以被用來影響用於設置字元編碼、整序和時區的變數的效果。<span>ONE_SHOT</span>主要被用於複製：<span>mysqlbinlog</span>使用<span>SET 
			ONE_SHOT</span>來暫時地修改字元編碼、整序和時區變數的值，以反映出它們原先的值。</p>
			<p>您不能在使用<span>ONE_SHOT</span>時使用除允許的變數以外的變數；如果您這麼做，您會得到如下錯誤：</p>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT max_allowed_packet = 1;</b></span></span></pre>
			<pre><span>ERROR 1382 (HY000): The &#39;SET ONE_SHOT&#39; syntax is reserved for purposes internal to the MySQL server </span></pre>
			<p>如果同時使用<span>ONE_SHOT</span>和被允許的變數，則會根據要求更改變數，但是會在下一個語句後，重新設置所有的字元編碼、整序和與時區有關的伺服器系統變數。唯一的例外是，當下一個語句是<span>SET</span>語句時，不會進行重新設置。換句話說，在下一個非<span>SET</span>語句之後，才會進行重新設置。例如：</p>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT character_set_connection = latin5;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SET ONE_SHOT collation_connection = latin5_turkish_ci;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;%_connection&#39;;</b></span></span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| character_set_connection | latin5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
			<pre><span>| collation_connection&nbsp;&nbsp;&nbsp;&nbsp; | latin5_turkish_ci |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;%_connection&#39;;</b></span></span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<pre><span>| character_set_connection | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| collation_connection&nbsp;&nbsp;&nbsp;&nbsp; | latin1_swedish_ci |</span></pre>
			<pre><span>+--------------------------+-------------------+</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_NOTES = {0 | 1}</span><span> </span></p>
			<p>當設置為<span>1</span>時（預設情況），「注意」一級的警報被記錄下來。當設置為<span>0</span>時，「注意」警告被壓制。<span>Mysqldump</span>包含輸出，用於把此變數設置為<span>0</span>，這樣，對於不會影響重新載入操作整體性的事件，重新載入轉儲檔案時不會產生警告。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_AUTO_IS_NULL = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>1</span>（預設情況），您可以通過使用以下結構搜尋包含一個<span>AUTO_INCREMENT</span>列的資料表的最後插入的行：</p>
			<pre><span>WHERE <span><i>auto_increment_column</i></span> IS NULL</span></pre>
			<p>此性質被有些<span>ODBC</span>程式，比如<span>Access</span>使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_BIG_SELECTS = {0 | 1}</span><span> </span></p>
			<p>如果設定為<span>0</span>，則<span>MySQL</span>會放棄有可能會花很長時間來執行的<span>SELECT</span>語句（也就是，對於這些語句，最佳化程式估算被檢查的行的數目超過了<span>max_join_size</span>的值）。當一個不妥當的<span>WHERE</span>語句被發佈後，本語句有用。一個新連接的預設值為<span>1</span>，這可以允許所有的<span>SELECT</span>語句。</p>
			<p>如果您把<span>max_join_size</span>系統變數設置為除<span>DEFAULT</span>以外的值，則<span>SQL_BIG_SELECTS</span>被設置為<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_BUFFER_RESULT = {0 | 1}</span><span> </span>
			</p>
			<p><span>SQL_BUFFER_RESULT</span>會迫使來自<span>SELECT</span>語句的結果被放入臨時資料表中。這可以幫助<span>MySQL</span>早點解除資料表鎖定。當需要花較長時間把結果發送給客戶端時，這是有好處的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_BIN = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>0</span>，則客戶端的二進制日誌中不會記錄日誌。客戶端必須擁有<span>SUPER</span>權限來設置此選項。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_OFF = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>1</span>，則此客戶端的總查詢日誌中不會記錄日誌。客戶端必須擁有<span>SUPER</span>權限來設置此選項。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_LOG_UPDATE = {0 | 1}</span><span> </span></p>
			<p>不贊成使用本變數。本變數被映射到<span>SQL_LOG_BIN</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_QUOTE_SHOW_CREATE = {0 | 1}</span><span> </span>
			</p>
			<p>如果設置為<span>1</span>，則<span>SHOW 
			CREATE TABLE</span>會對資料表和列的名稱加引號。如果設置為<span>0</span>，則加引號操作被禁用。預設情況下，本選項被啟用，因此對於含有需要加引號的名稱的資料表，複製操作起作用。請參見<a href="sql-syntax.html#show-create-table" title="13.5.4.5. SHOW CREATE TABLE Syntax">13.5.4.5節，「SHOW 
			CREATE TABLE語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_SAFE_UPDATES = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>1</span>，則<span>MySQL</span>會放棄在<span>WHERE</span>子句或<span>LIMIT</span>子句中不使用關鍵字的<span>UPDATE</span>或<span>DELETE</span>語句。這樣，當關鍵字使用不正確時，也有可能理解<span>UPDATE</span>或<span>DELETE</span>語句。這樣就可以更改或刪除大量的行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_SELECT_LIMIT = {<i>value</i> | DEFAULT}</span><span>
			</span></p>
			<p>從<span>SELECT</span>語句返回的記錄的最大數目。對於一個新連接，預設值是「<span>unlimited</span>」。如果您更改了限值，可以使用<span>SQL_SELECT_LIMIT 
			DEFAULT</span>值恢復預設值。</p>
			<p>如果<span>SELECT</span>有一個<span>LIMIT</span>子句，則<span>LIMIT</span>優先於<span>SQL_SELECT_LIMIT</span>值。</p>
			<p><span>SQL_SELECT_LIMT</span>不適用於在被儲存的子程式中執行的<span>SELECT</span>語句。它也不適用於不會產生將被返回到客戶端的結果集合的<span>SELECT</span>語句。這些包括子查詢中的<span>SELECT</span>語句，<span>CREATE 
			TABLE...SELECT</span>和<span>INSERT INTO...SELECT</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			SQL_WARNINGS = {0 | 1}</span><span> </span></p>
			<p>本變數用於控制當出現警告時，單行<span>INSERT</span>語句是否產生一個訊息字串。預設值為<span>0</span>。把值設置為<span>1</span>，來產生一個訊息字串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			TIMESTAMP = {<i>timestamp_value</i> | DEFAULT}</span><span>
			</span></p>
			<p>
			用於為此客戶端設置時間。當您使用二進制日誌來恢復行時，本語句用於得到原始的時間標記。<span>timestamp_value</span>應為一個<span>Unix</span>時間標記，而不是<span>MySQL</span>時間標記。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			UNIQUE_CHECKS = {0 | 1}</span><span> </span></p>
			<p>如果設置為<span>1</span>（預設情況），則會對<span>InnoDB</span>資料表中的二級索引執行唯一性檢查。如果設置為<span>0</span>，則對於被插入到<span>InnoDB</span>的插入緩衝器中的索引登錄項，不執行唯一性檢查。如果您可以肯定您的數據不違反唯一性要求，則您可以把此值設定為<span>0</span>，以加快向<span>InnoDB</span>導入大型資料表的速度。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="show"></a>13.5.4. SHOW語法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#show-character-set">13.5.4.1. 
			SHOW CHARACTER SET語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-collation">13.5.4.2. 
			SHOW COLLATION語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-columns">13.5.4.3. 
			SHOW COLUMNS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-database">13.5.4.4. 
			SHOW CREATE DATABASE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-table">13.5.4.5. 
			SHOW CREATE TABLE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-databases">13.5.4.6. 
			SHOW DATABASES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engine">13.5.4.7. 
			SHOW ENGINE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engines">13.5.4.8. 
			SHOW ENGINES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-errors">13.5.4.9. 
			SHOW ERRORS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-grants">13.5.4.10. 
			SHOW GRANTS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-index">13.5.4.11. 
			SHOW INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-innodb-status">13.5.4.12. 
			SHOW INNODB STATUS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-logs">13.5.4.13. 
			SHOW LOGS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-open-tables">13.5.4.14. 
			SHOW OPEN TABLES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-privileges">13.5.4.15. 
			SHOW PRIVILEGES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-processlist">13.5.4.16. 
			SHOW PROCESSLIST語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-status">13.5.4.17. 
			SHOW STATUS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-table-status">13.5.4.18. 
			SHOW TABLE STATUS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-tables">13.5.4.19. 
			SHOW TABLES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-triggers">13.5.4.20. 
			SHOW TRIGGERS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-variables">13.5.4.21. 
			SHOW VARIABLES語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-warnings">13.5.4.22. 
			SHOW WARNINGS語法</a></span></dt></dl></div><a class="indexterm" name="id2921795"></a><a class="indexterm" name="id2921810"></a><a class="indexterm" name="id2921823"></a><a class="indexterm" name="id2921832"></a><a class="indexterm" name="id2921841"></a><a class="indexterm" name="id2921850"></a><a class="indexterm" name="id2921859"></a><a class="indexterm" name="id2921868"></a><a class="indexterm" name="id2921877"></a><a class="indexterm" name="id2921886"></a><a class="indexterm" name="id2921895"></a><a class="indexterm" name="id2921904"></a><a class="indexterm" name="id2921913"></a><a class="indexterm" name="id2921922"></a><a class="indexterm" name="id2921931"></a><a class="indexterm" name="id2921940"></a><a class="indexterm" name="id2921949"></a><a class="indexterm" name="id2921958"></a><a class="indexterm" name="id2921967"></a><a class="indexterm" name="id2921976"></a><a class="indexterm" name="id2921985"></a><a class="indexterm" name="id2921994"></a><a class="indexterm" name="id2922003"></a><a class="indexterm" name="id2922012"></a><a class="indexterm" name="id2922021"></a><a class="indexterm" name="id2922030"></a>
			<p><span>SHOW</span>有多種形式，可以提供有關資料庫、資料表、列或伺服器狀態的訊息。本節敘述以下內容：</p>
			<pre><span>SHOW [FULL] COLUMNS FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW CREATE DATABASE <span><i>db_name</i></span></span></pre>
			<pre><span>SHOW CREATE TABLE <span><i>tbl_name</i></span></span></pre>
			<pre><span>SHOW DATABASES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW ENGINE <span><i>engine_name</i></span> {LOGS | STATUS }</span></pre>
			<pre><span>SHOW [STORAGE] ENGINES</span></pre>
			<pre><span>SHOW ERRORS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
			<pre><span>SHOW GRANTS FOR <span><i>user</i></span></span></pre>
			<pre><span>SHOW INDEX FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>]</span></pre>
			<pre><span>SHOW INNODB STATUS</span></pre>
			<pre><span>SHOW [BDB] LOGS</span></pre>
			<pre><span>SHOW PRIVILEGES</span></pre>
			<pre><span>SHOW [FULL] PROCESSLIST</span></pre>
			<pre><span>SHOW [GLOBAL | SESSION] STATUS [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW TABLE STATUS [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW [OPEN] TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW TRIGGERS</span></pre>
			<pre><span>SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
			<pre><span>SHOW WARNINGS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
			<p><span>SHOW</span>語句還有一些形式，可以提供有關複製型主伺服器和從屬伺服器的訊息。這些形式在<a href="sql-syntax.html#replication-sql" title="13.6. Replication Statements">13.6節，「複製語句」</a>中進行了敘述。</p>
			<pre><span>SHOW BINLOG EVENTS</span></pre>
			<pre><span>SHOW MASTER LOGS</span></pre>
			<pre><span>SHOW MASTER STATUS</span></pre>
			<pre><span>SHOW SLAVE HOSTS</span></pre>
			<pre><span>SHOW SLAVE STATUS</span></pre>
			<p>如果一個給定的<span>SHOW</span>語句的語法包括一個<span>LIKE<span> 
			&#39;<i>pattern</i>&#39;</span></span>部分，則<span>&#39;<i>pattern</i>&#39;</span>是一個可以包含<span>SQL
			</span>『<span>%</span>』和『<span>_</span>』通配符的字串。對於把語句輸出值限定為匹配值，本樣式是有用的。</p>
			<a class="indexterm" name="id2922160"></a><a class="indexterm" name="id2922169"></a><a class="indexterm" name="id2922178"></a><a class="indexterm" name="id2922187"></a><a class="indexterm" name="id2922196"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-character-set"></a>13.5.4.1. SHOW 
				CHARACTER SET語法</h4></div></div></div><a class="indexterm" name="id2922275"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW CHARACTER SET [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW CHARACTER SET</span>語句用於顯示所有可用的字元編碼。該語句取一個自選的<span>LIKE</span>子句。該子句指示哪些字元編碼名稱可以匹配。舉例說明：</p>
				<pre><span>mysql&gt; <span><b>SHOW CHARACTER SET LIKE &#39;latin%&#39;;</b></span></span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<pre><span>| Charset | Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Default collation | Maxlen |</span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<pre><span>| latin1&nbsp; | cp1252 West European&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1_swedish_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin2&nbsp; | ISO 8859-2 Central European | latin2_general_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin5&nbsp; | ISO 8859-9 Turkish&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin5_turkish_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>| latin7&nbsp; | ISO 8859-13 Baltic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin7_general_ci |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+---------+-----------------------------+-------------------+--------+</span></pre>
				<p><span>Maxlen</span>列顯示用於儲存一個字元的最大的字節數目。</p>
				<h4 class="title"><a name="show-collation"></a>13.5.4.2. SHOW 
				COLLATION語法</h4></div></div></div><a class="indexterm" name="id2922345"></a>
				<pre><span>SHOW COLLATION [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p>來自<span>SHOW COLLATION</span>的輸出包括所有可用的字元編碼。該語句取一個自選的<span>LIKE</span>子句。該子句的<span>pattern</span>指示哪些整序名稱可以匹配。舉例說明：</p>
				<pre><span>mysql&gt; <span><b>SHOW COLLATION LIKE &#39;latin1%&#39;;</b></span></span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<pre><span>| Collation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Charset | Id | Default | Compiled | Sortlen |</span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<pre><span>| latin1_german1_ci | latin1&nbsp; |&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_swedish_ci | latin1&nbsp; |&nbsp; 8 | Yes&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_danish_ci&nbsp; | latin1&nbsp; | 15 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_german2_ci | latin1&nbsp; | 31 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 |</span></pre>
				<pre><span>| latin1_bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp; | 47 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_general_ci | latin1&nbsp; | 48 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_general_cs | latin1&nbsp; | 49 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>| latin1_spanish_ci | latin1&nbsp; | 94 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
				<pre><span>+-------------------+---------+----+---------+----------+---------+</span></pre>
				<p><span>Default</span>列指示對於其字元編碼，整序值是否是預設值。<span>Compiled</span>指示字元編碼是否被編輯到伺服器中。<span>Sortlen</span>與對字串（在字元編碼中資料表達）分類所需的儲存器的數量有關。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-columns"></a>13.5.4.3. SHOW 
				COLUMNS語法</h4></div></div></div><a class="indexterm" name="id2922440"></a><a class="indexterm" name="id2922455"></a>
				<pre><span>SHOW [FULL] COLUMNS FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW COLUMNS</span>顯示在一個給定資料表中的各列的訊息。對於試圖，本語句也起作用。</p>
				<p>如果列類型與根據您的<span>CREATE TABLE</span>語句所預期的列類型不同，則需注意，當您建立或更改資料表時，<span>MySQL</span>有時會更改列類型。出現這種情況的條件在<a href="sql-syntax.html#silent-column-changes" title="13.1.5.1. Silent Column Specification Changes">13.1.5.1節，「沉寂的列規格變更」</a>中進行了描述。</p>
				<p><span>FULL</span>關鍵詞會使得輸出中包含您擁有的權限，並包含對每一列各自的評注。</p>
				<p>您可以使用<span>db_name.tbl_name</span>作為<span>tbl_name 
				FROM db_name</span>語法的另一種形式。換句話說，這兩個語句是等價的：</p>
				<pre><span>mysql&gt; <span><b>SHOW COLUMNS FROM mytable FROM mydb;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW COLUMNS FROM mydb.mytable;</b></span></span></pre>
				<p><span>SHOW FIELDS</span>是<span>SHOW 
				COLUMNS</span>的同義詞。您也可以使用<span>mysqlshow db_name 
				tbl_name</span>命令列舉資料表的各列。</p>
				<p><span>DESCRIBE</span>語句提供與<span>SHOW 
				COLUMNS</span>相近的訊息。請參見<a href="sql-syntax.html#describe" title="13.3.1. DESCRIBE Syntax (Get Information About Columns)">13.3.1節，「DESCRIBE語法（獲取關於列的訊息）」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-database"></a>13.5.4.4. SHOW 
				CREATE DATABASE語法</h4></div></div></div><a class="indexterm" name="id2922596"></a><a class="indexterm" name="id2922605"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW CREATE {DATABASE | SCHEMA} <span><i>db_name</i></span></span></pre>
				<p>顯示用於建立給定資料庫<span>CREATE DATABASE</span>語句。也可以使用<span>SHOW 
				CREATE SCHEMA</span>。</p>
				<pre><span>mysql&gt; <span><b>SHOW CREATE DATABASE test\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database: test</span></pre>
				<pre><span>Create Database: CREATE DATABASE `test`</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*!40100 DEFAULT CHARACTER SET latin1 */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW CREATE SCHEMA test\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database: test</span></pre>
				<pre><span>Create Database: CREATE DATABASE `test` </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*!40100 DEFAULT CHARACTER SET latin1 */</span></pre>
				<h4 class="title"><a name="show-create-table"></a>13.5.4.5. SHOW 
				CREATE TABLE語法</h4></div></div></div><a class="indexterm" name="id2922669"></a>
				<pre><span>SHOW CREATE TABLE <span><i>tbl_name</i></span></span></pre>
				<p>顯示用於建立給定資料表的<span>CREATE TABLE</span>語句。本語句對視圖也起作用。</p>
				<pre><span>mysql&gt; <span><b>SHOW CREATE TABLE t\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table: t</span></pre>
				<pre><span>Create Table: CREATE TABLE t (</span></pre>
				<pre><span>&nbsp; id INT(11) default NULL auto_increment,</span></pre>
				<pre><span>&nbsp; s char(60) default NULL,</span></pre>
				<pre><span>&nbsp; PRIMARY KEY (id)</span></pre>
				<pre><span>) ENGINE=MyISAM</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>根據<span>SQL_QUOTE_SHOW_CREATE</span>選項，<span>SHOW 
				CREATE TABLE</span>會對資料表名稱和列名稱加引號。請參見<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3節，「SET語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-databases"></a>13.5.4.6. SHOW 
				DATABASES語法</h4></div></div></div><a class="indexterm" name="id2922737"></a><a class="indexterm" name="id2922746"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW {DATABASES | SCHEMAS} [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW DATABASES</span>可以在<span>MySQL</span>伺服器主機上列舉資料庫。您也可以使用<span>mysqlshow</span>命令得到此清單。您只能看到您擁有某些權限的資料庫，除非您擁有全局<span>SHOW 
				DATABASES</span>權限。</p>
				<p>如果伺服器以<span>--skip-show-database</span>選項為起始，則您根本不能使用本語句，除非您擁有<span>SHOW 
				DATABASES</span>權限。</p>
				<p>也可以使用<span>SHOW SCHEMAS</span>。</p>
				<h4 class="title"><a name="show-engine"></a>13.5.4.7. SHOW 
				ENGINE語法</h4></div></div></div><a class="indexterm" name="id2922816"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW ENGINE <span><i>engine_name</i></span> {LOGS | STATUS }</span></pre>
				<p><span>SHOW ENGINE</span>顯示儲存引擎的日誌或狀態訊息。目前支援以下語句：</p>
				<pre><span>SHOW ENGINE BDB LOGS</span></pre>
				<pre><span>SHOW ENGINE INNODB STATUS</span></pre>
				<p><span>SHOW ENGINE BDB LOGS</span>顯示原有<span>BDB</span>日誌檔案的狀態訊息。它會返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>File</span><span>
				</span></p>
				<p>通向日誌檔案的完整路徑。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Type</span><span>
				</span></p>
				<p>日誌檔案類型（用於<span>Berkeley 
				DB</span>日誌檔案的<span>BDB</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Status</span><span> </span></p>
				<p>日誌檔案的狀態（如果檔案可以被取消，則為<span>FREE</span>。如果檔案被事務子系統需要，則為<span>IN 
				USE</span>）</p>
				<p><span>SHOW ENGINE INNODB STATUS</span>顯示<span>InnoDB</span>儲存引擎狀態的全面訊息。</p>
				<p>這些語句的舊的同義詞（現在不贊成使用）是<span>SHOW [BDB] LOGS</span>和<span>SHOW 
				INNODB STATUS</span>。</p>
				<p><span>SHOW ENGINE</span>可以從<span>MySQL 
				4.1.2</span>起使用。</p>
				<h4 class="title"><a name="show-engines"></a>13.5.4.8. SHOW 
				ENGINES語法</h4></div></div></div><a class="indexterm" name="id2922989"></a><a class="indexterm" name="id2922998"></a><a class="indexterm" name="id2923008"></a>
				<pre><span>SHOW [STORAGE] ENGINES</span></pre>
				<p><span>SHOW ENGINES</span>顯示儲存引擎的狀態訊息。對於檢查一個儲存引擎是否被支援，或者對於查看預設引擎是什麼，本語句十分有用。<span>SHOW 
				TABLE TYPES</span>是同義詞，但不贊成使用。</p>
				<pre class="programlisting">mysql&gt; <strong class="userinput">SHOW ENGINES\G</strong>
*************************** 1. row ***************************
 Engine: MyISAM
Support: DEFAULT
Comment: Default engine as of MySQL 3.23 with great performance
*************************** 2. row ***************************
 Engine: MEMORY
Support: YES
Comment: Hash based, stored in memory, useful for temporary tables
*************************** 3. row ***************************
 Engine: HEAP
Support: YES
Comment: Alias for MEMORY
*************************** 4. row ***************************
 Engine: MERGE
Support: YES
Comment: Collection of identical MyISAM tables
*************************** 5. row ***************************
 Engine: MRG_MYISAM
Support: YES
Comment: Alias for MERGE
*************************** 6. row ***************************
 Engine: ISAM
Support: NO
Comment: Obsolete storage engine, now replaced by MyISAM
*************************** 7. row ***************************
 Engine: MRG_ISAM
Support: NO
Comment: Obsolete storage engine, now replaced by MERGE
*************************** 8. row ***************************
 Engine: InnoDB
Support: YES
Comment: Supports transactions, row-level locking, and foreign keys
*************************** 9. row ***************************
 Engine: INNOBASE
Support: YES
Comment: Alias for INNODB
*************************** 10. row ***************************
 Engine: BDB
Support: NO
Comment: Supports transactions and page-level locking
*************************** 11. row ***************************
 Engine: BERKELEYDB
Support: NO
Comment: Alias for BDB
*************************** 12. row ***************************
 Engine: NDBCLUSTER
Support: DISABLED
Comment: Clustered, fault-tolerant, memory-based tables
*************************** 13. row ***************************
 Engine: NDB
Support: DISABLED
Comment: Alias for NDBCLUSTER
*************************** 14. row ***************************
 Engine: EXAMPLE
Support: NO
Comment: Example storage engine
*************************** 15. row ***************************
 Engine: ARCHIVE
Support: YES
Comment: Archive storage engine
*************************** 16. row ***************************
 Engine: CSV
Support: YES
Comment: CSV storage engine
*************************** 17. row ***************************
 Engine: FEDERATED
Support: NO
Comment: Federated MySQL storage engine
*************************** 18. row ***************************
 Engine: BLACKHOLE
Support: YES
Comment: /dev/null storage engine (anything you write to it disappears)
</pre>
				<p><span>Support</span>值指示某個儲存引擎是否被支援，並指示哪個是預設引擎。例如，如果伺服器以<span>--default-table-type=InnoDB</span>選項為起始，則<span>InnoDB</span>行的<span>Support</span>值為<span>DEFAULT</span>值。請參見<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>儲存引擎和資料表類型</i></a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-errors"></a>13.5.4.9. SHOW 
				ERRORS語法</h4></div></div></div><a class="indexterm" name="id2923134"></a>
				<pre><span>SHOW ERRORS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<pre><span>SHOW COUNT(*) ERRORS</span></pre>
				<p>本語句與<span>SHOW WARNINGS</span>接近，不過該語句只顯示錯誤，不同時顯示錯誤、警告和注意。</p>
				<p><span>LIMIT</span>子句與<span>SELECT</span>語句具有相同的語法，請參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
				<p><span>SHOW COUNT(*) ERRORS</span>語句顯示錯誤的數目。您也可以從<span>error_count</span>變數中找回此數目：</p>
				<pre><span>SHOW COUNT(*) ERRORS;</span></pre>
				<pre><span>SELECT @@error_count;</span></pre>
				<p>要瞭解更多訊息，請參見<a href="sql-syntax.html#show-warnings" title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22節，「SHOW 
			WARNINGS語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-grants"></a>13.5.4.10. SHOW 
				GRANTS語法</h4></div></div></div><a class="indexterm" name="id2923220"></a><a class="indexterm" name="id2923230"></a><a class="indexterm" name="id2923239"></a>
				<pre><span>SHOW GRANTS FOR <span><i>user</i></span></span></pre>
				<p>本語句列出了在為<span>MySQL</span>用戶帳號複製權限時必須發布的<span>GRANT</span>語句。</p>
				<pre><span>mysql&gt; <span><b>SHOW GRANTS FOR &#39;root&#39;@&#39;localhost&#39;;</b></span></span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<pre><span>| Grants for root@localhost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<pre><span>| GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |</span></pre>
				<pre><span>+---------------------------------------------------------------------+</span></pre>
				<p>要對當前的會話列出權限，您可以使用以下語句之一：</p>
				<pre><span>SHOW GRANTS;</span></pre>
				<pre><span>SHOW GRANTS FOR CURRENT_USER;</span></pre>
				<pre><span>SHOW GRANTS FOR CURRENT_USER();</span></pre>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="show-index"></a>13.5.4.11. SHOW 
				INDEX語法</h4></div></div></div>
				<a class="indexterm" name="id2923302"></a>
				<a class="indexterm" name="id2923316"></a>
				<a class="indexterm" name="id2923325"></a>
				<pre><span>SHOW INDEX FROM <span><i>tbl_name</i></span> [FROM <span><i>db_name</i></span>]</span></pre>
				<p><span>SHOW INDEX</span>會返回資料表索引訊息。其格式與<span>ODBC</span>中的<span>SQLStatistics</span>使用相似。</p>
				<p><span>SHOW INDEX</span>會返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span> </span></p>
				<p>資料表的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Non_unique</span><span> </span></p>
				<p>如果索引不能包括重複詞，則為<span>0</span>。如果可以，則為<span>1</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Key_name</span><span> </span></p>
				<p>索引的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Seq_in_index</span><span> </span></p>
				<p>索引中的列序列號，從<span>1</span>開始。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Column_name</span><span> </span></p>
				<p>列名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Collation</span><span> </span></p>
				<p>列以什麼方式儲存在索引中。在<span>MySQL</span>中，有值『<span>A</span>』（升序）或<span>NULL</span>（無分類）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Cardinality</span><span> </span></p>
				<p>索引中唯一值的數目的估計值。通過運行<span>ANALYZE 
				TABLE</span>或<strong><span>myisamchk 
				-a</span></strong>可以更新。基數根據被儲存為整數的統計數據來計數，所以即使對於小型資料表，該值也沒有必要是精確的。基數越大，當進行聯合時，<span>MySQL</span>使用該索引的機會就越大。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sub_part</span><span> </span></p>
				<p>
				如果列只是被部分地編入索引，則為被編入索引的字元的數目。如果整列被編入索引，則為<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Packed</span><span> </span></p>
				<p>指示關鍵字如何被壓縮。如果沒有被壓縮，則為<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Null</span><span>
				</span></p>
				<p>如果列含有<span>NULL</span>，則含有<span>YES</span>。如果沒有，則該列含有<span>NO</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Index_type</span><span> </span></p>
				<p>用過的索引方法（<span>BTREE, 
				FULLTEXT, HASH, RTREE</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Comment</span><span> </span></p>
				<p>多種評注。</p>
				<p>您可以使用<span>db_name.tbl_name</span>作為<span>tbl_name 
				FROM db_name</span>語法的另一種形式。這兩個語句是等價的：</p>
				<pre><span>mysql&gt; <span><b>SHOW INDEX FROM mytable FROM mydb;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW INDEX FROM mydb.mytable;</b></span></span></pre>
				<p><span>SHOW KEYS</span>是<span>SHOW INDEX</span>的同義詞。您也可以使用<strong><span>mysqlshow 
				-k </span></strong><span><b><i>
				<span>db_name</span></i></b></span><strong><span>
				</span></strong><span><b><i>
				<span>tbl_name</span></i></b></span>命令列舉一個資料表的索引。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-innodb-status"></a>13.5.4.12. SHOW 
				INNODB STATUS語法</h4></div></div></div>
				<pre><span>SHOW INNODB STATUS</span></pre>
				<p>在<span>MySQL 5.1</span>中，這是<span>SHOW 
				ENGINE INNODB STATUS</span>的同義詞，但不贊成使用。請參見<a href="sql-syntax.html#show-engine" title="13.5.4.7. SHOW ENGINE Syntax">13.5.4.7節，「SHOW 
			ENGINE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-logs"></a>13.5.4.13. SHOW 
				LOGS語法</h4></div></div></div>
				<pre><span>SHOW [BDB] LOGS</span></pre>
				<p>在<span>MySQL 5.1</span>中，這是<span>SHOW 
				ENGINE BDB LOGS</span>的同義詞，但是不贊成使用。請參見<a href="sql-syntax.html#show-engine" title="13.5.4.7. SHOW ENGINE Syntax">13.5.4.7節，「SHOW 
			ENGINE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-open-tables"></a>13.5.4.14. SHOW 
				OPEN TABLES語法</h4></div></div></div><a class="indexterm" name="id2923760"></a><a class="indexterm" name="id2923774"></a>
				<pre><span>SHOW OPEN TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW OPEN TABLES</span>列舉在資料表緩存中當前被打開的非<span>TEMPORARY</span>資料表。請參見<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9節，「MySQL如何打開和關閉資料表」</a>。</p>
				<p><span>SHOW OPEN TABLES</span>會返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Database</span><span> </span></p>
				<p>含有該資料表的資料庫。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span> </span></p>
				<p>資料表名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				In_use</span><span> </span></p>
				<p>
				資料表當前被查詢使用的次數。如果該數為零，則資料表是打開的，但是當前沒有被使用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Name_locked</span><span> </span></p>
				<p>資料表名稱是否被鎖定。名稱鎖定用於取消資料表或對資料表進行重命名等操作。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-privileges"></a>13.5.4.15. SHOW 
				PRIVILEGES語法</h4></div></div></div><a class="indexterm" name="id2923896"></a>
				<pre><span>SHOW PRIVILEGES</span></pre>
				<p><span>SHOW PRIVILEGES</span>顯示<span>MySQL</span>伺服器支援的系統權限清單。確切的輸出根據您的伺服器的版本而定。</p>
				<pre><span>mysql&gt; <span><b>SHOW PRIVILEGES\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>Privilege: Alter</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To alter the table</span></pre>
				<pre><span>*************************** 2. row ***************************</span></pre>
				<pre><span>Privilege: Alter routine</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To alter or drop stored functions/procedures</span></pre>
				<pre><span>*************************** 3. row ***************************</span></pre>
				<pre><span>Privilege: Create</span></pre>
				<pre><span>Context: Databases,Tables,Indexes</span></pre>
				<pre><span>Comment: To create new databases and tables</span></pre>
				<pre><span>*************************** 4. row ***************************</span></pre>
				<pre><span>Privilege: Create routine</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To use CREATE FUNCTION/PROCEDURE</span></pre>
				<pre><span>*************************** 5. row ***************************</span></pre>
				<pre><span>Privilege: Create temporary tables</span></pre>
				<pre><span>Context: Databases</span></pre>
				<pre><span>Comment: To use CREATE TEMPORARY TABLE</span></pre>
				<pre><span>*************************** 6. row ***************************</span></pre>
				<pre><span>Privilege: Create view</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To create new views</span></pre>
				<pre><span>*************************** 7. row ***************************</span></pre>
				<pre><span>Privilege: Create user</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To create new users</span></pre>
				<pre><span>*************************** 8. row ***************************</span></pre>
				<pre><span>Privilege: Delete</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To delete existing rows</span></pre>
				<pre><span>*************************** 9. row ***************************</span></pre>
				<pre><span>Privilege: Drop</span></pre>
				<pre><span>Context: Databases,Tables</span></pre>
				<pre><span>Comment: To drop databases, tables, and views</span></pre>
				<pre><span>*************************** 10. row ***************************</span></pre>
				<pre><span>Privilege: Execute</span></pre>
				<pre><span>Context: Functions,Procedures</span></pre>
				<pre><span>Comment: To execute stored routines</span></pre>
				<pre><span>*************************** 11. row ***************************</span></pre>
				<pre><span>Privilege: File</span></pre>
				<pre><span>Context: File access on server</span></pre>
				<pre><span>Comment: To read and write files on the server</span></pre>
				<pre><span>*************************** 12. row ***************************</span></pre>
				<pre><span>Privilege: Grant option</span></pre>
				<pre><span>Context: Databases,Tables,Functions,Procedures</span></pre>
				<pre><span>Comment: To give to other users those privileges you possess</span></pre>
				<pre><span>*************************** 13. row ***************************</span></pre>
				<pre><span>Privilege: Index</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To create or drop indexes</span></pre>
				<pre><span>*************************** 14. row ***************************</span></pre>
				<pre><span>Privilege: Insert</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To insert data into tables</span></pre>
				<pre><span>*************************** 15. row ***************************</span></pre>
				<pre><span>Privilege: Lock tables</span></pre>
				<pre><span>Context: Databases</span></pre>
				<pre><span>Comment: To use LOCK TABLES (together with SELECT privilege)</span></pre>
				<pre><span>*************************** 16. row ***************************</span></pre>
				<pre><span>Privilege: Process</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To view the plain text of currently executing queries</span></pre>
				<pre><span>*************************** 17. row ***************************</span></pre>
				<pre><span>Privilege: References</span></pre>
				<pre><span>Context: Databases,Tables</span></pre>
				<pre><span>Comment: To have references on tables</span></pre>
				<pre><span>*************************** 18. row ***************************</span></pre>
				<pre><span>Privilege: Reload</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To reload or refresh tables, logs and privileges</span></pre>
				<pre><span>*************************** 19. row ***************************</span></pre>
				<pre><span>Privilege: Replication client</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To ask where the slave or master servers are</span></pre>
				<pre><span>*************************** 20. row ***************************</span></pre>
				<pre><span>Privilege: Replication slave</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To read binary log events from the master</span></pre>
				<pre><span>*************************** 21. row ***************************</span></pre>
				<pre><span>Privilege: Select</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To retrieve rows from table</span></pre>
				<pre><span>*************************** 22. row ***************************</span></pre>
				<pre><span>Privilege: Show databases</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To see all databases with SHOW DATABASES</span></pre>
				<pre><span>*************************** 23. row ***************************</span></pre>
				<pre><span>Privilege: Show view</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To see views with SHOW CREATE VIEW</span></pre>
				<pre><span>*************************** 24. row ***************************</span></pre>
				<pre><span>Privilege: Shutdown</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To shut down the server</span></pre>
				<pre><span>*************************** 25. row ***************************</span></pre>
				<pre><span>Privilege: Super</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.</span></pre>
				<pre><span>*************************** 26. row ***************************</span></pre>
				<pre><span>Privilege: Update</span></pre>
				<pre><span>Context: Tables</span></pre>
				<pre><span>Comment: To update existing rows</span></pre>
				<pre><span>*************************** 27. row ***************************</span></pre>
				<pre><span>Privilege: Usage</span></pre>
				<pre><span>Context: Server Admin</span></pre>
				<pre><span>Comment: No privileges - allow connect only</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-processlist"></a>13.5.4.16. SHOW 
				PROCESSLIST語法</h4></div></div></div><a class="indexterm" name="id2924087"></a><a class="indexterm" name="id2924096"></a><a class="indexterm" name="id2924105"></a><a class="indexterm" name="id2924114"></a><a class="indexterm" name="id2924124"></a>
				<pre><span>SHOW [FULL] PROCESSLIST</span></pre>
				<p><span>SHOW PROCESSLIST</span>顯示哪些線程正在運行。您也可以使用<strong><span>mysqladmin 
				processlist</span></strong>語句得到此訊息。如果您有<span>SUPER</span>權限，您可以看到所有線程。否則，您只能看到您自己的線程（也就是，與您正在使用的<span>MySQL</span>帳號相關的線程）。請參見<a href="sql-syntax.html#kill" title="13.5.5.3. KILL Syntax">13.5.5.3節，「KILL語法」</a>。如果您不使用<span>FULL</span>關鍵詞，則只顯示每個查詢的前<span>100</span>個字元。</p>
				<p>本語句報告<span>TCP/IP</span>連接的主機名稱（採用<span><i><span>host_name</span></i><span>:<i>client_port</i></span></span>格式），以方便地判定哪個客戶端正在做什麼。</p>
				<p>如果您得到「<span>too many connections</span>」錯誤訊息，並且想要瞭解正在發生的情況，本語句是非常有用的。<span>MySQL</span>保留一個額外的連接，讓擁有<span>SUPER</span>權限的
				帳號使用，以確保管理員能夠隨時連接和檢查系統（假設您沒有把此權限給予所有的用戶）。</p>
				<p>在來自<span>SHOW PROCESSLIST</span>的輸出中常見的一些狀態：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Checking table</span><span> </span></p>
				<p>線程正在執行（自動）資料表格檢查。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Closing tables</span><span> </span></p>
				<p>
				意味著線程正在刷新更改後的資料表數據，並正在關閉使用過的資料表。這應該是一個快速的操作。如果不快，則您應該驗證您的磁盤沒有充滿，並且磁盤沒有被超負荷使用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Connect Out</span><span> </span></p>
				<p>連接到主伺服器上的從屬伺服器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Copying to tmp table on disk</span><span>
				</span></p>
				<p>臨時結果集合大於<span>tmp_table_size</span>。線程把臨時資料表從儲存器內部格式改變為磁盤模式，以節約儲存器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Creating tmp table</span><span> </span></p>
				<p>線程正在建立一個臨時資料表，以保持部分結果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				deleting from main table</span><span> </span>
				</p>
				<p>伺服器正在執行多資料表刪除的第一部分，只從第一個資料表中刪除。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				deleting from reference tables</span><span>
				</span></p>
				<p>伺服器正在執行多資料表刪除的第二部分，從其它資料表中刪除匹配的行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Flushing tables</span><span> </span></p>
				<p>線程正在執行<span>FLUSH 
				TABLES</span>，並正在等待所有線程，以關閉資料表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				FULLTEXT initialization</span><span> </span>
				</p>
				<p>伺服器正在準備執行一個自然語言全文本搜索。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Killed</span><span> </span></p>
				<p>有人已經向線程發送了一個<span>KILL</span>命令。在下一次檢查終止標記時，應放棄。該標記在<span>MySQL</span>的每個大循環中都檢查，但是在有些情況下，線程終止只需要較短的時間。如果該線程被其它線程鎖定，則只要其它線程接觸鎖定，終止操作就會生效。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Locked</span><span> </span></p>
				<p>該查詢被其它查詢鎖定。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sending data</span><span> </span></p>
				<p>線程正在為<span>SELECT</span>語句處理行，同時正在向客戶端發送數據。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sorting for group</span><span> </span></p>
				<p>線程正在進行分類，以滿足<span>GROUP 
				BY</span>要求。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sorting for order</span><span> </span></p>
				<p>線程正在進行分類，以滿足<span>ORDER 
				BY</span>要求。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Opening tables</span><span> </span></p>
				<p>
				線程正在試圖打開一個資料表。這應該是非常快的過程，除非打開操作受到阻止。例如，一個<span>ALTER 
				TABLE</span>或一個<span>LOCK TABLE</span>語句可以阻止打開一個資料表，直到語句完成為止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Removing duplicates</span><span> </span></p>
				<p>查詢正在使用<span>SELECT 
				DISTINCT</span>。使用時，在早期階段，<span>MySQL</span>不能最佳化不同的操作。因此，<span>MySQL</span>要求一個額外的階段，以便在把結果發送給客戶端之前取消所有的複製行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Reopen table</span><span> </span></p>
				<p>
				線程得到一個資料表鎖定，但是在得到鎖定後被通知帶下方的資料表結構已更改了。它已經釋放了鎖定，關閉了資料表，並試圖重新打開它。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Repair by sorting</span><span> </span></p>
				<p>修復代碼正在使用一個分類來建立索引。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Repair with keycache</span><span> </span></p>
				<p>
				修復代碼正在通過關鍵緩存一個接一個地使用建立關鍵字。這比通過分類修復要慢很多。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Searching rows for update</span><span> </span>
				</p>
				<p>線程正在進行第一階段，以在更新之前，搜尋所有匹配的行。如果<span>UPDATE</span>正在更改用於搜尋相關行的索引，則必須這麼做。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Sleeping</span><span> </span></p>
				<p>線程正在等待客戶端，以向它發送一個新語句。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				System lock</span><span> </span></p>
				<p>
				線程正在等待得到一個用於資料表的外部系統鎖定。如果您沒有正在使用多個正在訪問同一個資料表的<span>mysqld</span>伺服器，則您可以使用<span>--skip-external-locking</span>選項禁用系統鎖定。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Upgrading lock</span><span> </span></p>
				<p><span>INSERT DELAYED</span>管理程式正在試圖得到一個資料表鎖定，以插入行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Updating</span><span> </span></p>
				<p>線程正在搜索行，並正在更新這些行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>User 
				Lock</span><span> </span></p>
				<p>線程正在等待<span>GET_LOCK()</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Waiting for tables</span><span> </span></p>
				<p>
				線程得到一個通知，資料表的底層結構已經改變，需要重新打開資料表以得到新的結構。但是，為了能重新打開資料表，必須等待，直到所有其它的線程已經關閉了正在被質詢的資料表。</p>
				<p>如果其它線程已經對正在被質詢的資料表使用了<span>FLUSH 
				TABLES</span>或以下語句之一：<span>FLUSH TABLES<span>
				<i>tbl_name</i></span>, <span>ALTER 
				TABLE</span>, <span>RENAME TABLE</span>,
				<span>REPAIR TABLE</span>,
				<span>ANALYZE TABLE</span></span>或<span><span>OPTIMIZE 
				TABLE</span>；則會出現通知。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				waiting for handler insert</span><span> </span>
				</p>
				<p><span>INSERT DELAYED</span>管理程式已經處理了所有處於等待狀態的插入，並正在等待新插入。</p>
				<p>多數狀態對應於非常快的操作。如果一個線程在這些狀態下停留了數秒，則可能是有問題，需要進行調查。</p>
				<p>有一些其它的狀態，在前面的清單中沒有提及，但是其中有很多狀態對於搜尋伺服器中的程式錯誤是有用的。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-status"></a>13.5.4.17. SHOW 
				STATUS語法</h4></div></div></div><a class="indexterm" name="id2924776"></a><a class="indexterm" name="id2924783"></a>
				<pre><span>SHOW [GLOBAL | SESSION] STATUS [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW STATUS</span>提供伺服器狀態訊息。此訊息也可以使用<strong><span>mysqladmin 
				extended-status</span></strong>命令獲得。</p>
				<p>此處顯示了局部的輸出。對於您的伺服器，變數和值的清單可以是不同的。在<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4節，「伺服器狀態變數」</a>中給出了每個變數的意義。</p>
				<pre><span>mysql&gt; <span><b>SHOW STATUS;</b></span></span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<pre><span>| Aborted_clients&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Aborted_connects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Bytes_received&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 155372598&nbsp; |</span></pre>
				<pre><span>| Bytes_sent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1176560426 |</span></pre>
				<pre><span>| Connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 30023&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_disk_tables&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Created_tmp_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></pre>
				<pre><span>| Open_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Open_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Open_streams&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Opened_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 44600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Questions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2026873&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></pre>
				<pre><span>| Table_locks_immediate&nbsp;&nbsp;&nbsp; | 1920382&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Table_locks_waited&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_cached&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_created&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 30022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_connected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Threads_running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Uptime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 80380&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------------+------------+</span></pre>
				<p>使用<span>LIKE</span>子句，該語句只顯示匹配該樣式的那些變數：</p>
				<pre><span>mysql&gt; <span><b>SHOW STATUS LIKE &#39;Key%&#39;;</b></span></span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<pre><span>| Key_blocks_used&nbsp;&nbsp;&nbsp; | 14955&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| Key_read_requests&nbsp; | 96854827 |</span></pre>
				<pre><span>| Key_reads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 162040&nbsp;&nbsp; |</span></pre>
				<pre><span>| Key_write_requests | 7589728&nbsp; |</span></pre>
				<pre><span>| Key_writes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 3813196&nbsp; |</span></pre>
				<pre><span>+--------------------+----------+</span></pre>
				<p>使用<span>GLOBAL</span>選項，您可以得到所有<span>MySQL</span>連接的狀態值。使用<span>SESSION</span>，您可以得到所有當前連接的狀態值。如果您兩個選項都不使用，則預設值為<span>SESSION</span>。<span>LOCAL</span>是<span>SESSION</span>的同義詞。</p>
				<p>注意，有些狀態變數只有一個全局值。對於這些變數，使用<span>GLOBAL</span>和<span>SESSION</span>會得到同樣的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-table-status"></a>13.5.4.18. SHOW 
				TABLE STATUS語法</h4></div></div></div><a class="indexterm" name="id2924932"></a><a class="indexterm" name="id2924942"></a><a class="indexterm" name="id2924953"></a>
				<pre><span>SHOW TABLE STATUS [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW TABLE STATUS</span>的性質與<span>SHOW 
				TABLE</span>類似，不過，可以提供每個資料表的大量訊息。您也可以使用<strong><span>mysqlshow 
				--status </span></strong><span><b><i>
				<span>db_name</span></i></b></span>命令得到此清單。</p>
				<p>本語句也顯示視圖訊息。</p>
				<p>對於<span>NDB Cluster</span>資料表，本語句的輸出顯示<span>Avg_row_length</span>和<span>Data_length</span>列的適當值，不過<span>BLOB</span>列沒有被考慮進來。另外，複製數量在<span>Comment</span>列中顯示（作為<span>number_of_replicas</span>）。</p>
				<p><span>SHOW TABLE STATUS</span>會返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Name</span><span>
				</span></p>
				<p>資料表的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Engine</span><span> </span></p>
				<p>資料表的儲存引擎。在<span>MySQL 
				4.1.2</span>之前，本值被標記為<span>Type</span>。請參見<a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types">第15章：<i>儲存引擎和資料表類型</i></a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Version</span><span> </span></p>
				<p>資料表的<span>.frm</span>檔案的版本號。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Row_format</span><span> </span></p>
				<p>行儲存格式（<span>Fixed</span><span>,
				<span>Dynamic</span>,
				<span>Compressed</span>,
				<span>Redundant</span>,
				<span>Compact</span></span><span>）。<span>InnoDB</span>資料表的格式被報告為<span>Redundant</span>或<span>Compact</span>。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Rows</span><span>
				</span></p>
				<p>行的數目。部分儲存引擎，如<span>MyISAM</span>，儲存精確的數目。</p>
				<p>對於其它儲存引擎，比如<span>InnoDB</span>，本值是一個大約的數，與實際值相差可達<span>40</span>到<span>50</span>％。在這些情況下，使用<span>SELECT 
				COUNT(*)</span>來獲得準確的數目。</p>
				<p>對於在<span>INFORMATION_SCHEMA</span>資料庫中的資料表，<span>Rows</span>值為<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Avg_row_length</span><span> </span></p>
				<p>平均的行長度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Data_length</span><span> </span></p>
				<p>數據檔案的長度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Max_data_length</span><span> </span></p>
				<p>
				數據檔案的最大長度。如果給定了數據指針的大小，這是可以被儲存在資料表中的數據的字節總數。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Index_length</span><span> </span></p>
				<p>索引檔案的長度。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Data_free</span><span> </span></p>
				<p>被整序，但是未使用的字節的數目。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Auto_increment</span><span> </span></p>
				<p>下一個<span>AUTO_INCREMENT</span>值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Create_time</span><span> </span></p>
				<p>什麼時候資料表被建立。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Update_time</span><span> </span></p>
				<p>什麼時候數據檔案被最後一次更新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Check_time</span><span> </span></p>
				<p>
				什麼時候資料表被最後一次檢查。不是所有的儲存引擎此時都更新，在此情況下，值為<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Collation</span><span> </span></p>
				<p>資料表的字元編碼和整序。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Checksum</span><span> </span></p>
				<p>活性校驗和值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Create_options</span><span> </span></p>
				<p>和<span>CREATE TABLE</span>同時使用的額外選項。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Comment</span><span> </span></p>
				<p>建立資料表時使用的評注（或者有關為什麼<span>MySQL</span>可以訪問資料表訊息的說明）。</p>
				<p>在資料表評注中，<span>InnoDB</span>資料表報告資料表所屬的資料表空間的空閒空間。對於一個位於共享資料表空間中的資料表，這是共享資料表空間中的空閒空間。如果您正在使用多個資料表空間，並且該資料表有自己的資料表空間，則空閒空間只用於此資料表。</p>
				<p>對於<span>MEMORY (HEAP)</span>資料表，<span>Data_length, 
				Max_data_length</span>和<span>Index_length</span>值近似於被整序的儲存器的實際值。整序算法預留了大量的儲存器，以減少整序操作的數量。</p>
				<p>對於視圖，由<span>SHOW TABLE STATUS</span>顯示的所有字段均為<span>NULL</span>。例外情況是<span>Name</span>指示為視圖名稱同時<span>Comment</span>稱為視圖。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-tables"></a>13.5.4.19. SHOW 
				TABLES語法</h4></div></div></div><a class="indexterm" name="id2925476"></a><a class="indexterm" name="id2925490"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW [FULL] TABLES [FROM <span><i>db_name</i></span>] [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW TABLES</span>列舉了給定資料庫中的非<span>TEMPORARY</span>資料表。您也可以使用<strong><span>mysqlshow
				</span></strong><span><b><i>
				<span>db_name</span></i></b></span>命令得到此清單。</p>
				<p>本命令也列舉資料庫中的其它視圖。支援<span>FULL</span>修改符，這樣<span>SHOW 
				FULL TABLES</span>就可以顯示第二個輸出列。對於一個資料表，第二列的值為<span>BASE 
				TABLE</span>；對於一個視圖，第二列的值為<span>VIEW</span>。</p>
				<p>註釋：如果您對於一個資料表沒有權限，則該資料表不會在來自<span>SHOW TABLES</span>或的<strong><span>mysqlshow 
				db_name</span></strong>輸出中顯示。</p>
				<h4 class="title"><a name="show-triggers"></a>13.5.4.20. SHOW 
				TRIGGERS語法</h4></div></div></div><a class="indexterm" name="id2925584"></a><a class="indexterm" name="id2925590"></a><a class="indexterm" name="id2925597"></a>
				<pre><span>SHOW TRIGGERS [FROM <span><i>db_name</i></span>] [LIKE <span><i>expr</i></span>]</span></pre>
				<p><span>SHOW TRIGGERS</span>列出了目前被<span>MySQL</span>伺服器定義的觸發程式。</p>
				<p>對於在<a href="triggers.html#using-triggers" title="21.3. Using Triggers">21.3節，「使用觸發程式」</a>中定義的觸發程式<span>ins_sum</span>，本語句的輸出顯示如下：</p>
				<pre><span>mysql&gt; <span><b>SHOW TRIGGERS LIKE &#39;acc%&#39;;</b></span></span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<pre><span>| Trigger | Event&nbsp; | Table&nbsp;&nbsp; | Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Timing | Created |</span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<pre><span>| ins_sum | INSERT | account |&nbsp; SET @sum = @sum + NEW.amount | BEFORE | NULL&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------+---------+-------------------------------+--------+---------+</span></pre>
				<p>註釋：當使用一個含有<span>SHOW TRIGGERS</span>的<span>LIKE</span>子句時，待匹配的資料表達式（<span>expr</span>）會與觸發程式定義時所在的資料表的名稱相比較，而不與觸發程式的名稱相比較：</p>
				<pre><span>mysql&gt; <span><b>SHOW TRIGGERS LIKE &#39;ins%&#39;;</b></span></span></pre>
				<pre><span>Empty set (0.01 sec)</span></pre>
				<p>對本語句輸出中的各列的簡要解釋如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Trigger</span><span>: </span>觸發程式的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Event</span><span>: </span>使用觸發程式的時間。必須為<span>&#39;INSERT&#39;</span><span>,
				<span>&#39;UPDATE&#39;</span></span>或 
				 
				<span>&#39;DELETE&#39;</span><span>.</span>之一。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Table</span><span>: </span>觸發程式定義時對應的資料表。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Statement</span><span>: </span>
				當觸發程式被使用時執行的語句。這與在<span>INFORMATION_SCHEMA.TRIGGERS</span>的<span>ACTION_STATEMENT</span>列中顯示的文本一樣。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Timing</span><span>:
				<span>&#39;BEFORE&#39;</span></span>或<span>&#39;AFTER&#39;</span>兩個值之一。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Created</span><span>: </span>目前，本列的值為<span>NULL</span>。 
				</p>
				<p>為了執行<span>SHOW TRIGGERS</span>，您必須擁有<span>SUPER</span>權限。</p>
				<p>同時也見<a href="information-schema.html#triggers-table" title="23.1.16. The INFORMATION_SCHEMA TRIGGERS Table">23.1.16節，「INFORMATION_SCHEMA TRIGGERS資料表」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-variables"></a>13.5.4.21. SHOW 
				VARIABLES語法</h4></div></div></div><a class="indexterm" name="id2925833"></a><a class="indexterm" name="id2925840"></a><a class="indexterm" name="id2925847"></a><a class="indexterm" name="id2925857"></a>
				<pre><span>SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#39;<span><i>pattern</i></span>&#39;]</span></pre>
				<p><span>SHOW VARIABLES</span>顯示了部門<span>MySQL</span>系統變數的值。本訊息也可以使用<strong><span>mysqladmin 
				variables</span></strong>命令獲得。</p>
				<p>使用<span>GLOBAL</span>選項，您可以獲得被用於<span>MySQL</span>新連接的值。使用<span>SESSION</span>，您可以得到對於當前連接起效的值。如果您兩個選項都不使用，預設值為<span>SESSION</span>。</p>
				<p><span>LOCAL</span>是<span>SESSION</span>的同義詞。</p>
				<p>如果預設值不合適，當<span>mysqld</span>啟動時或在<span>SET</span>語句運行過程中，您可以使用命令行選項設置多數的這類變數。請參見<a href="database-administration.html#server-options" title="5.3.1. mysqld Command-Line Options">5.3.1節，「<span><strong class="command">mysqld</strong></span>命令行選項」</a>和<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3節，「SET語法</a>。</p>
				<p>此處顯示了部分的輸出。對於您的伺服器，變數和值的清單會有所不同。在<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>中給出了每個變數的意義。在<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>中提供了有關調整變數的訊息。</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES;</b></span></span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<pre><span>| auto_increment_increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| auto_increment_offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| automatic_sp_privileges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| back_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| basedir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | /home/jon/bin/mysql-5.1/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| bulk_insert_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8388608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| character_set_client&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| character_set_connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | latin1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></pre>
				<pre><span>| max_user_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| max_write_lock_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4294967295&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| multi_range_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_data_pointer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_max_sort_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2147483647&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| myisam_recover_options&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_repair_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| myisam_sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8388608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| ndb_autoincrement_prefetch_sz&nbsp;&nbsp; | 32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| ndb_cache_check_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| ndb_force_send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp; </span></pre>
				<pre><span>| time_zone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| timed_mutexes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| tmp_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 33554432&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| transaction_alloc_block_size&nbsp;&nbsp;&nbsp; | 8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| transaction_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| tx_isolation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | REPEATABLE-READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| updatable_views_with_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 5.1.2-alpha-log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Source distribution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_compile_machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | i686&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| version_compile_os&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | suse-linux&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 28800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------------------------+-----------------------------------------------+</span></pre>
				<p>使用<span>LIKE</span>子句，本語句只顯示與樣式相匹配的變數：</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;have%&#39;;</b></span></span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
				<pre><span>| have_archive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_bdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_blackhole_engine | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_compress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_crypt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_csv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_example_engine&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_federated_engine | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_geometry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;|</span></pre>
				<pre><span>| have_innodb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_ndbcluster&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | DISABLED |</span></pre>
				<pre><span>| have_openssl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_partition_engine | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_query_cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_raid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NO&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| have_rtree_keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| have_symlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | YES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------------+----------+</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-warnings"></a>13.5.4.22. SHOW 
				WARNINGS語法</h4></div></div></div><a class="indexterm" name="id2926135"></a>
				<pre><span>SHOW WARNINGS [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<pre><span>SHOW COUNT(*) WARNINGS</span></pre>
				<p><span>SHOW WARNINGS</span>顯示由上一個生成消息的語句導致的錯誤、警告和注意消息。如果上一個使用資料表的語句未生成消息，則什麼也不顯示。<span>SHOW 
				ERRORS</span>是其相關語句，只顯示錯誤。請參見<a href="sql-syntax.html#show-errors" title="13.5.4.9. SHOW ERRORS Syntax">13.5.4.9節，「SHOW 
			ERRORS語法」</a>。</p>
				<p>對於使用一個資料表的每個新語句，消息清單均重新設置。</p>
				<p><span>SHOW COUNT(*) WARNINGS</span>語句顯示錯誤、警告和注意的總數。您也可以從<span>warning_count</span>變數中找回此數目。</p>
				<pre><span>SHOW COUNT(*) WARNINGS;</span></pre>
				<pre><span>SELECT @@warning_count;</span></pre>
				<p>如果<span>max_error_count</span>系統變數設置得過低，以致於有的消息沒有被儲存，則<span>warning_count</span>值可能比由<span>SHOW 
				WARNINGS</span>顯示的消息數目要大。本節後部顯示的例子展示了這類情況是如何發生的。</p>
				<p><span>LIMIT</span>子句具有與<span>SELECT</span>語句相同的語法。請參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
				<p><span>MySQL</span>伺服器會發回由上一個語句引起的錯誤、警告和注意的總數。如果您正在使用<span>C 
				API</span>，則此值可以通過使用<span>mysql_warning_count()</span>來獲得。請參見<a href="apis.html#mysql-warning-count" title="25.2.3.69. mysql_warning_count()">25.2.3.69節，「mysql_warning_count()」</a>。</p>
				<p>對於如<span>LOAD DATA INFILE</span>等語句和如<span>INSERT, 
				UPDATE, CREATE TABLE</span>和<span>ALTER TABLE</span>等<span>DML</span>語句，會生成警告。</p>
				<p>以下<span>DROP TABLE</span>語句會導致一個注意：</p>
				<pre><span>mysql&gt; <span><b>DROP TABLE IF EXISTS no_such_table;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS;</b></span></span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<pre><span>| Level | Code | Message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<pre><span>| Note&nbsp; | 1051 | Unknown table &#39;no_such_table&#39; |</span></pre>
				<pre><span>+-------+------+-------------------------------+</span></pre>
				<p>以下是一個簡單的例子，顯示了對於<span>CREATE TABLE</span>的一個語法警告，和對於<span>INSERT</span>的轉換警告：</p>
				<pre><span>mysql&gt; <span><b>CREATE TABLE t1 (a TINYINT NOT NULL, b CHAR(4)) TYPE=MyISAM;</b></span></span></pre>
				<pre><span>Query OK, 0 rows affected, 1 warning (0.00 sec)</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1287</span></pre>
				<pre><span>Message: &#39;TYPE=storage_engine&#39; is deprecated, use</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;ENGINE=storage_engine&#39; instead</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>INSERT INTO t1 VALUES(10,&#39;mysql&#39;),(NULL,&#39;test&#39;),</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>(300,&#39;Open Source&#39;);</b></span></span></pre>
				<pre><span>Query OK, 3 rows affected, 4 warnings (0.01 sec)</span></pre>
				<pre><span>Records: 3&nbsp; Duplicates: 0&nbsp; Warnings: 4</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1265</span></pre>
				<pre><span>Message: Data truncated for column &#39;b&#39; at row 1</span></pre>
				<pre><span>*************************** 2. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1263</span></pre>
				<pre><span>Message: Data truncated, NULL supplied to NOT NULL column &#39;a&#39; at row 2</span></pre>
				<pre><span>*************************** 3. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1264</span></pre>
				<pre><span>Message: Data truncated, out of range for column &#39;a&#39; at row 3</span></pre>
				<pre><span>*************************** 4. row ***************************</span></pre>
				<pre><span>&nbsp; Level: Warning</span></pre>
				<pre><span>&nbsp;&nbsp; Code: 1265</span></pre>
				<pre><span>Message: Data truncated for column &#39;b&#39; at row 3</span></pre>
				<pre><span>4 rows in set (0.00 sec)</span></pre>
				<p>要儲存的錯誤、警告和注意消息的最大數目由<span>max_error_count</span>系統變數控制。預設情況下，該值為<span>64</span>。要更改您想要儲存的訊息的數目，需更改<span>max_error_count</span>值。在下面的例子中，<span>ALTER 
				TABLE</span>語句會產生三個警告消息，但是只有一個被儲存，因為<span>max_error_count</span>被設置為<span>1</span>：</p>
				<pre><span>mysql&gt; <span><b>SHOW VARIABLES LIKE &#39;max_error_count&#39;;</b></span></span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp; | Value |</span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>| max_error_count | 64&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------+-------+</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SET max_error_count=1;</b></span></span></pre>
				<pre><span>Query OK, 0 rows affected (0.00 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>ALTER TABLE t1 MODIFY b CHAR;</b></span></span></pre>
				<pre><span>Query OK, 3 rows affected, 3 warnings (0.00 sec)</span></pre>
				<pre><span>Records: 3&nbsp; Duplicates: 0&nbsp; Warnings: 3</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SELECT @@warning_count;</b></span></span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>| @@warning_count |</span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 |</span></pre>
				<pre><span>+-----------------+</span></pre>
				<pre><span>1 row in set (0.01 sec)</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>SHOW WARNINGS;</b></span></span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>| Level&nbsp;&nbsp; | Code | Message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>| Warning | 1263 | Data truncated for column &#39;b&#39; at row 1 |</span></pre>
				<pre><span>+---------+------+----------------------------------------+</span></pre>
				<pre><span>1 row in set (0.00 sec)</span></pre>
				<p>要禁用警告，需把<span>max_error_count</span>設置為<span>0</span>。在此情況下，<span>warning_count</span>仍然指示有多少警告已經發生，但是這些消息不被儲存。</p>
				<p>您可以把<span>SQL_NOTES</span>會話變數設置為<span>0</span>，使「注意」級別的警告不被記錄。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-administrative-sql"></a>
			13.5.5.&nbsp;其它管理語句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#cache-index">13.5.5.1. 
				CACHE INDEX語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flush">13.5.5.2. 
				FLUSH語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#kill">13.5.5.3. 
				KILL語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-index">13.5.5.4. 
				LOAD INDEX INTO CACHE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset">13.5.5.5. 
				RESET語法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-index"></a>13.5.5.1. CACHE 
				INDEX語法</h4></div></div></div><a class="indexterm" name="id2926488"></a><a class="indexterm" name="id2926497"></a><a class="indexterm" name="id2926508"></a>
				<pre><span>CACHE INDEX</span></pre>
				<pre><span>&nbsp; <span><i>tbl_index_list</i></span> [, <span><i>tbl_index_list</i></span>] ...</span></pre>
				<pre><span>&nbsp; IN <span><i>key_cache_name</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>tbl_index_list</span></i></span><span>:</span></pre>
				<pre><span>&nbsp; <span><i>tbl_name</i></span> [[INDEX|KEY] (<span><i>index_name</i></span>[, <span><i>index_name</i></span>] ...)]</span></pre>
				<p><span>CACHE INDEX</span>語句把資料表索引分配給某個關鍵緩存。該語句只用於<span>MyISAM</span>資料表。</p>
				<p>下列語句把索引從資料表<span>t1, t2</span>和<span>t3</span>分配到名為<span>hot_cache</span>的關鍵緩存：</p>
				<pre><span>mysql&gt; <span><b>CACHE INDEX t1, t2, t3 IN hot_cache;</b></span></span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|</span></pre>
				<pre><span>| test.t3 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<p><span>CACHE INDEX</span>語法允許您指定，只有來自資料表的特定索引應被分配給緩存。但是，當前的實施會把所有的資料表索引分配給緩存，所以必須指定資料表名稱，不能指定其它的。</p>
				<p>被引用到<span>CACHE INDEX</span>語句中的關鍵緩存可以這樣建立，即通過使用一個參數設置語句或在伺服器參數設置中設置其大小。舉例說明：</p>
				<pre><span>mysql&gt; <span><b>SET GLOBAL keycache1.key_buffer_size=128*1024;</b></span></span></pre>
				<p>關鍵緩存參數可以被作為一個結構化系統變數的成分進行訪問。請參見<a href="language-structure.html#structured-system-variables" title="9.4.1. Structured System Variables">9.4.1節，「結構式系統變數」</a>。</p>
				<p>在您可以把索引分配給一個關鍵緩存以前，緩存必須存在：</p>
				<pre><span>mysql&gt; <span><b>CACHE INDEX t1 IN non_existent_cache;</b></span></span></pre>
				<pre><span>ERROR 1284 (HY000): Unknown key cache &#39;non_existent_cache&#39;</span></pre>
				<p>
				預設情況下，資料表索引被分配給在伺服器啟動時被建立的主（預設）鍵緩存。當一個鍵高速緩衝被破壞時，所有被分配到此緩存中的索引會再次被分配給預設的
				鍵高速緩衝。</p>
				<p>
				索引的分配會對伺服器產生全局性影響：如果一個客戶端把一個索引分配給一個給定的緩存，則不論什麼客戶端發佈查詢，本緩存都被用於所有涉及索引的查詢。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="flush"></a>13.5.5.2. FLUSH語法</h4></div></div></div><a class="indexterm" name="id2926697"></a><a class="indexterm" name="id2926706"></a><a class="indexterm" name="id2926714"></a><a class="indexterm" name="id2926724"></a>
				<pre><span>FLUSH [LOCAL | NO_WRITE_TO_BINLOG] <span><i>flush_option</i></span> [, <span><i>flush_option</i></span>] ...</span></pre>
				<p>如果您想要清除<span>MySQL</span>使用的部分內部緩存，您應該使用<span>FLUSH</span>語句。要執行<span>FLUSH</span>，您必須擁有<span>RELOAD</span>權限。</p>
				<p><span>flush_option</span>可以為以下的任何一個：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				HOSTS</span><span> </span></p>
				<p>用於清空主機緩存資料表。如果有的主機更改了<span>IP</span>號或如果您得到了錯誤訊息<span>Host
				<i>host_name</i> is blocked</span>，則您應該刷新主機資料表。當在連接到<span>MySQL</span>伺服器時，如果對於一個給定的主機，接連出現錯誤「多於<span>max_connect_errors</span>」，此時，<span>MySQL</span>會假定出現了錯誤，並阻止主機後續的連接申請。刷新主機資料表允許主機嘗試再次連接。請參見<a href="problems.html#blocked-host" title="A.2.5. Host 'host_name' is blocked">A.2.5節，「主機的hos<em class="replaceable">t_name被屏蔽</em>」</a>。您可以使用<span>max_connect_errors=999999999</span>啟動<strong><span>mysqld</span></strong>，以避免此錯誤訊息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				DES_KEY_FILE</span><span> </span></p>
				<p>用於在伺服器啟動時，從採用<span>--des-key-file</span>選項指定的檔案重新載入<span>DES</span>關鍵字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>LOGS</span><span>
				</span></p>
				<p>
				用於關閉並重新打開所有的日誌檔案。如果您已經指定了一個更新日誌檔案或一個二進制日誌檔案，同時沒有延伸，則相對於前一個檔案，日誌檔案的延伸號增加<span>1</span>。如果您在檔案名稱中使用了一個延伸，則<span>MySQL</span>會關閉並重新打開日誌檔案。在<span>Unix</span>中，當相<span>mysqld</span>伺服器發送一個<span>SIGHUP</span>信號時，也會如此（例外情況是部分<span>Mac 
				OS X 10.3</span>版本。在這些版本中，<span>mysqld</span>忽略<span>SIGHUP</span>和<span>SIGQUIT</span>）。</p>
				<p>如果伺服器使用<span>--log-error</span>選項，則<span>FLUSH 
				LOGS</span>會導致錯誤日誌被重命名（使用後綴<span>-old</span>），同時<span>mysqld</span>會建立一個新的空日誌檔案。如果沒有給定<span>--log-error</span>選項，則不會進行重命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				PRIVILEGES</span><span> </span></p>
				<p>用於從<span>mysql</span>資料庫中的授權資料表重新載入權限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				QUERY CACHE</span><span> </span></p>
				<p>對查詢緩存進行整理碎片，以更好得利用儲存器。與<span>RESET 
				QUERY CACHE</span>不同，本語句不會從緩存中取消任何查詢。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				STATUS</span><span> </span></p>
				<p>
				用於把多數狀態變數重新設置為零。只在當調試查詢時，您才應該使用此項。請參見<a href="introduction.html#bug-reports" title="1.7.1.3. How to Report Bugs or Problems">1.7.1.3節，「如何通報問題和問題」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				{TABLE | TABLES} [<i>tbl_name</i> [, <i>tbl_name</i>] ...]</span><span>
				</span></p>
				<p>
				當沒有資料表被命名時，關閉所有打開的資料表，並迫使所有正在使用的資料表關閉。這也會刷新查詢緩存。此項含有一個或多個資料表名稱，只刷新給定的資料表。和<span>RESET 
				QUERY CACHE</span>語句一樣，<span>FLUSH TABLES</span>還會取消來自查詢緩存的所有查詢結果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				TABLES WITH READ LOCK</span><span> </span></p>
				<p>
				對於所有帶讀取鎖定的資料庫，關閉所有打開的資料表，並鎖定所有的資料表，直到您執行<span>UNLOCK 
				TABLES</span>為止。如果您擁有一個可以及時進行快照的檔案系統，比如<span>Veritas</span>，則這是進行備份的非常方便的方法。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				USER_RESOURCES</span><span> </span></p>
				<p>
				用於把所有每小時用戶資源重新設置為零。這可以使已經達到了每小時連接、查詢或更新限值的客戶端立刻重新恢復活性。<span>FLUSH 
				USER_RESOURCES</span>不適用於同時連接的最大限值。請參見<a href="sql-syntax.html#grant" title="13.5.1.3. GRANT and REVOKE Syntax">13.5.1.3節，「GRANT和REVOKE語法」</a>。</p>
				<p><span>FLUSH</span>語句被寫入二進制日誌，除非使用了自選的<span>NO_WRITE_TO_BINLOG</span>關鍵字（或其別名<span>LOCAL</span>）。
				註釋：在任何情況下，<span>FLUSH 
				LOGS</span><span>,
				<span>FLUSH MASTER</span>,
				<span>FLUSH SLAVE</span></span>和<span>FLUSH 
				TABLES WITH READ LOCK</span>都不會被記入日誌，因為如果它們被複製到一個從屬伺服器上，會導致出現問題。</p>
				<p>您也可以使用<span>flush-hosts</span><span>,
				<span>flush-logs</span>,
				<span>flush-privileges</span>,
				<span>flush-status</span></span>或<span>flush-tables</span>命令訪問含有<span>mysqladmin</span>應用程式的語句。</p>
				<p>註釋：在<span>MySQL 5.1.2-alpha</span>中，不可能在已儲存的函數或觸發程式中發佈<span>FLUSH</span>語句。不過，您可以在已儲存的過程中使用<span>FLUSH</span>，只要它們不會從已儲存的函數或觸發程式中被使用。請參見<a href="restrictions.html#routine-restrictions" title="I.1. Restrictions on Stored Routines and Triggers">I.1節，「對儲存子程式和觸發程式的限制」</a>。</p>
				<p>要瞭解有關<span>RESET</span>語句與複製同時使用的訊息，也可以見<a href="sql-syntax.html#reset" title="13.5.5.5. RESET Syntax">13.5.5.5節，「RESET語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="kill"></a>13.5.5.3. KILL語法</h4></div></div></div><a class="indexterm" name="id2927205"></a><a class="indexterm" name="id2927214"></a>
				<pre><span>KILL [CONNECTION | QUERY] <span><i>thread_id</i></span></span></pre>
				<p>每個與<span>mysqld</span>的連接都在一個獨立的線程裡運行，您可以使用<span>SHOW 
				PROCESSLIST</span>語句查看哪些線程正在運行，並使用<span>KILL
				<i>thread_id</i></span>語句終止一個線程。</p>
				<p><span>KILL</span>允許自選的<span>CONNECTION</span>或<span>QUERY</span>修改符：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>KILL CONNECTION</span>與不含修改符的<span>KILL</span>一樣：它會終止與給定的<span><i><span>thread_id</span></i></span>有關的連接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>KILL QUERY</span>會終止連接當前正在執行的語句，但是會保持連接的原狀。</p>
				<p>如果您擁有<span>PROCESS</span>權限，則您可以查看所有線程。如果您擁有<span>SUPER</span>權限，您可以終止所有線程和語句。否則，您只能查看和終止您自己的線程和語句。</p>
				<p>您也可以使用<strong><span>mysqladmin 
				processlist</span></strong>和<strong><span>mysqladmin 
				kill</span></strong>命令來檢查和終止線程。</p>
				<p>註釋：您不能同時使用<span>KILL</span>和<span>Embedded 
				MySQL Server</span>庫，因為內植的伺服器只運行主機應用程式的線程。它不能建立任何自身的連接線程。</p>
				<p>當您進行一個<span>KILL</span>時，對線程設置一個特有的終止標記。在多數情況下，線程終止可能要花一些時間，這是因為終止標記只會在在特定的間隔被檢查：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>SELECT, ORDER BY</span>和<span>GROUP 
				BY</span>循環中，在讀取一組行後檢查標記。如果設置了終止標記，則該語句被放棄。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>ALTER TABLE</span>過程中，在每組行從原來的資料表中被讀取前，檢查終止標記。如果設置了終止標記，則語句被放棄，臨時資料表被刪除。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在<span>UPDATE</span>或<span>DELETE</span>運行期間，在每個組讀取之後以及每個已更行或已刪除的行之後，檢查終止標記。如果終止標記被設置，則該語句被放棄。注意，如果您正在使用事務，則變更不會被
				回滾。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>GET_LOCK()</span>會放棄和返回<span>NULL</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>線程會快速地刷新（插入）它在儲存器中的所有的行，然後終止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果線程在資料表鎖定管理程式中（狀態：鎖定），則資料表鎖定被快速地放棄。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果在寫入使用中，線程正在等待空閒的磁盤空間，則寫入被放棄，並伴隨<span>&quot;disk 
				full&quot;</span>錯誤消息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>警告：對<span>MyISAM</span>資料表終止一個<span>REPAIR 
				TABLE</span>或<span>OPTIMIZE TABLE</span>操作會導致出現一個被損壞的沒有用的資料表。對這樣的資料表的任何讀取或寫入都會失敗，直到您再次最佳化或修復它（不中斷）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-index"></a>13.5.5.4. LOAD 
				INDEX INTO CACHE語法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>LOAD INDEX INTO CACHE</span></pre>
				<pre><span>&nbsp; <span><i>tbl_index_list</i></span> [, <span><i>tbl_index_list</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span><i><span>tbl_index_list</span></i></span><span>:</span></pre>
				<pre><span>&nbsp; <span><i>tbl_name</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [[INDEX|KEY] (<span><i>index_name</i></span>[, <span><i>index_name</i></span>] ...)]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE LEAVES]</span></pre>
				<p><span>LOAD INDEX INTO CACHE</span>語句會把一個資料表索引預載入到某個關鍵緩存中。它已經被一個明確的<span>CACHE 
				INDEX</span>語句分配到此關鍵緩存中。或者，資料表索引被預載入到預設的關鍵緩存中。<span>LOAD 
				INDEX INTO CACHE</span>只用於<span>MyISAM</span>資料表。</p>
				<p><span>IGNORE LEAVES</span>修改符只會導致索引的非葉子節點被預載入。</p>
				<p>對於資料表<span>t1</span>和<span>t2</span>，以下語句會預載入索引的節點（索引組）：</p>
				<pre><span>mysql&gt; <span><b>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</b></span></span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<p>本語句會預載入所有來自<span>t1</span>的索引組。它只預載入來自<span>t2</span>的非葉子節點的組。</p>
				<p><span>LOAD INDEX INTO CACHE</span>語法允許您指定，只有來自資料表的特定的索引應被預載入。但是，當前實施會把所有的資料表索引預載入緩存中，所以一定要指定資料表名稱，不能指定其它的。</p>
				<h4 class="title"><a name="reset"></a>13.5.5.5. RESET語法</h4></div></div></div>
				<pre><span>RESET <span><i>reset_option</i></span> [, <span><i>reset_option</i></span>] ...</span></pre>
				<p><span>RESET</span>語句被用於清除不同的伺服器操作的狀態。它也作為<span>FLUSH</span>語句的更強大的版本。請參見<a href="sql-syntax.html#flush" title="13.5.5.2. FLUSH Syntax">13.5.5.2節，「FLUSH語法」</a>。</p>
				<p>為了執行<span>RESET</span>，您必須擁有<span>RELOAD</span>權限。</p>
				<p><span>reset_option</span>可以為以下的任何一項：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				MASTER</span><span> </span></p>
				<p>
				可以刪除列於索引檔案中的所有二進制日誌，把二進制日誌索引檔案重新設置為空，並建立一個新的二進制日誌檔案。（在以前版本的<span>MySQL</span>中，被稱為<span>FLUSH 
				MASTER</span>。）見<a href="sql-syntax.html#replication-master-sql" title="13.6.1. SQL Statements for Controlling Master Servers">13.6.1節，「用於控制主伺服器的SQL語句」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				QUERY CACHE</span><span> </span></p>
				<p>從查詢緩存中取消所有的查詢結果。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				SLAVE</span><span> </span></p>
				<p>
				可以使從屬伺服器忘記其在主伺服器二進制日誌中的複製位置，另外，也可以通過刪除原有的中繼日誌檔案和開始一個新檔案來重新設置中繼日誌。請參見<a href="sql-syntax.html#replication-slave-sql" title="13.6.2. SQL Statements for Controlling Slave Servers">13.6.2節，「用於控制從伺服器的SQL語句」</a>。</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="replication-sql"></a>
		13.6.&nbsp;複製語句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">
			13.6.1. 用於控制主伺服器的SQL語句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">
			13.6.2. 用於控制從伺服器的SQL語句</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
			本節敘述了與複製有關的<span>SQL</span>語句。一組語句被用於控制主伺服器。其它的被用於控制從屬伺服器。<h3 class="title"><a name="replication-master-sql"></a>
			13.6.1.&nbsp;用於控制主伺服器的SQL語句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#purge-master-logs">13.6.1.1. 
				PURGE MASTER LOGS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-master">13.6.1.2. 
				RESET MASTER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-sql-log-bin">13.6.1.3. 
				SET SQL_LOG_BIN語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-binlog-events">13.6.1.4. 
				SHOW BINLOG EVENTS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-logs">13.6.1.5. 
				SHOW MASTER LOGS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-status">13.6.1.6. 
				SHOW MASTER STATUS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-hosts">13.6.1.7. 
				SHOW SLAVE HOSTS語法</a></span></dt></dl></div><a class="indexterm" name="id2927837"></a><a class="indexterm" name="id2927847"></a><a class="indexterm" name="id2927858"></a>
			<p>可以通過<span>SQL</span>界面控制複製。本節討論了用於管理主複製伺服器的語句。<a href="sql-syntax.html#replication-slave-sql" title="13.6.2. SQL Statements for Controlling Slave Servers">13.6.2節，「用於控制從伺服器的SQL語句」</a>討論了用於管理從屬伺服器的語句。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="purge-master-logs"></a>13.6.1.1. PURGE 
				MASTER LOGS語法</h4></div></div></div><a class="indexterm" name="id2927893"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>PURGE {MASTER | BINARY} LOGS TO &#39;<span><i>log_name</i></span>&#39;</span></pre>
				<pre><span>PURGE {MASTER | BINARY} LOGS BEFORE &#39;<span><i>date</i></span>&#39;</span></pre>
				<p>
				用於刪除列於在指定的日誌或日期之前的日誌索引中的所有二進制日誌。這些日誌也會從記錄在日誌索引檔案中的清單中被刪除，這樣被給定的日誌成為第一個。</p>
				<p>例如：</p>
				<pre><span>PURGE MASTER LOGS TO &#39;mysql-bin.010&#39;;</span></pre>
				<pre><span>PURGE MASTER LOGS BEFORE &#39;2003-04-02 22:46:26&#39;;</span></pre>
				<p><span>BEFORE</span>變數的<span>date</span>自變數可以為<span>&#39;YYYY-MM-DD 
				hh:mm:ss&#39;</span>格式。<span>MASTER</span>和<span>BINARY</span>是同義詞。</p>
				<p>
				如果您有一個活性的從屬伺服器，該伺服器當前正在讀取您正在試圖刪除的日誌之一，則本語句不會起作用，而是會失敗，並伴隨一個錯誤。不過，如果從屬伺服器是休止的，並且您碰巧清理了其想要讀取的日誌之一，則從屬伺服器啟動後不能複製。當從屬伺服器正在複製時，本語句可以安全運行。您不需要停止它們。</p>
				<p>要清理日誌，需按照以下步驟：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>在每個從屬伺服器上，使用<span>SHOW SLAVE STATUS</span>來檢查它正在讀取哪個日誌。</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>SHOW MASTER LOGS</span>獲得主伺服器上的一系列日誌。</p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				在所有的從屬伺服器中判定最早的日誌。這個是目標日誌。如果所有的從屬伺服器是更新的，這是清單上的最後一個日誌。</p>
				<p>
				<span>4.<span>&nbsp;&nbsp;&nbsp;
				</span></span>製作您將要刪除的所有日誌的備份。（這個步驟是自選的，但是建議採用。）</p>
				<p>
				<span>5.<span>&nbsp;&nbsp;&nbsp;
				</span></span>清理所有的日誌，但是不包括目標日誌。</p>
				<h4 class="title"><a name="reset-master"></a>13.6.1.2. RESET 
				MASTER語法</h4></div></div></div><a class="indexterm" name="id2928068"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RESET MASTER</span></pre>
				<p>可以刪除列於索引檔案中的所有二進制日誌，把二進制日誌索引檔案重新設置為空，並建立一個新的二進制日誌檔案。</p>
				<h4 class="title"><a name="set-sql-log-bin"></a>13.6.1.3. SET 
				SQL_LOG_BIN語法</h4></div></div></div><a class="indexterm" name="id2928127"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SET SQL_LOG_BIN = {0|1}</span></pre>
				<p>如果客戶端使用一個有<span>SUPER</span>權限的帳號連接，則可以禁用或啟用當前連接的二進制日誌記錄。如果客戶端沒有此權限，則語句被拒絕，並伴隨有錯誤。</p>
				<h4 class="title"><a name="show-binlog-events"></a>13.6.1.4. SHOW 
				BINLOG EVENTS語法</h4></div></div></div><a class="indexterm" name="id2928197"></a>
				<pre><span>SHOW BINLOG EVENTS</span></pre>
				<pre><span>&nbsp;&nbsp; [IN &#39;<span><i>log_name</i></span>&#39;] [FROM <span><i>pos</i></span>] [LIMIT [<span><i>offset</i></span>,] <span><i>row_count</i></span>]</span></pre>
				<p>用於在二進制日誌中顯示事件。如果您不指定<span>&#39;log_name&#39;</span>，則顯示第一個二進制日誌。</p>
				<p><span>LIMIT</span>子句和<span>SELECT</span>語句具有相同的語法。請參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
				<p>註釋：當服<span>務器把二進制日誌的完整內容（該日誌包括多數的由<span>MySQL</span>執行的查詢）轉儲到<span>stdout</span>時，發佈一個不含<span>LIMIT</span>子句的<span>SHOW 
				BINLOG EVENTS</span>可以啟動一個過程，該過程非常消耗時間並消耗資源</span>。要把二進制日誌保存到一個文本檔案中，用於以後的檢查和分析，需使用<span>mysqlbinlog</span>應用程式。請參見<a href="client-side-scripts.html#mysqlbinlog" title="8.6. mysqlbinlog — Utility for Processing Binary Log Files">8.6節，「mysqlbinlog：用於處理二進制日誌檔案的實用工具」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-logs"></a>13.6.1.5. SHOW 
				MASTER LOGS語法</h4></div></div></div><a class="indexterm" name="id2928328"></a><a class="indexterm" name="id2928337"></a>
				<pre><span>SHOW MASTER LOGS</span></pre>
				<pre><span>SHOW BINARY LOGS</span></pre>
				<p>用於列出伺服器中的二進制日誌檔案。本語句被用作<a href="sql-syntax.html#purge-master-logs" title="13.6.1.1. PURGE MASTER LOGS Syntax">13.6.1.1節，「PURGE 
			MASTER LOGS語法」</a>中所述的過程的一部分，用於確定哪些日誌可以被清理。</p>
				<pre><span>mysql&gt; <span><b>SHOW BINARY LOGS;</b></span></span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<pre><span>| Log_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | File_size |</span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<pre><span>| binlog.000015 |&nbsp;&nbsp;&nbsp; 724935 |</span></pre>
				<pre><span>| binlog.000016 |&nbsp;&nbsp;&nbsp; 733481 |</span></pre>
				<pre><span>+---------------+-----------+</span></pre>
				<p><span>SHOW BINARY LOGS</span>與<span>SHOW 
				MASTER LOGS</span>相當。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-status"></a>13.6.1.6. SHOW 
				MASTER STATUS語法</h4></div></div></div><a class="indexterm" name="id2928430"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SHOW MASTER STATUS</span></pre>
				<p>用於提供主伺服器二進制日誌檔案的狀態訊息。例如：</p>
				<pre><span>mysql &gt; SHOW MASTER STATUS;</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<pre><span>| File&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<pre><span>| mysql-bin.003 | 73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | manual,mysql&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------------+----------+--------------+------------------+</span></pre>
				<h4 class="title"><a name="show-slave-hosts"></a>13.6.1.7. SHOW 
				SLAVE HOSTS語法</h4></div></div></div><a class="indexterm" name="id2928510"></a></div></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>SHOW SLAVE HOSTS</span></pre>
			<p>用於顯示當前使用主伺服器註冊的複製從屬伺服器的清單。不以<span>--report-host=<i>slave_name</i></span>選項為開頭的從屬伺服器不會顯示在本清單中。</p>
			<h3 class="title"><a name="replication-slave-sql"></a>
			13.6.2.&nbsp;用於控制從伺服器的SQL語句</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#change-master-to">13.6.2.1. 
				CHANGE MASTER TO語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data-from-master">13.6.2.2. 
				LOAD DATA FROM MASTER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-table-from-master">13.6.2.3. 
				LOAD TABLE <em class="replaceable">tbl_name</em> 
				FROM MASTER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#master-pos-wait">13.6.2.4. 
				MASTER_POS_WAIT()語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-slave">13.6.2.5. 
				RESET SLAVE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-global-sql-slave-skip-counter">13.6.2.6. 
				SET GLOBAL SQL_SLAVE_SKIP_COUNTER語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-status">13.6.2.7. 
				SHOW SLAVE STATUS語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#start-slave">13.6.2.8. 
				START SLAVE語法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stop-slave">13.6.2.9. 
				STOP SLAVE語法<br>
&nbsp;</a></span></dt></dl></div><a class="indexterm" name="id2928576"></a><a class="indexterm" name="id2928587"></a><a class="indexterm" name="id2928597"></a>
			<p>複製操作可以通過<span>SQL</span>界面控制。本節討論了用於管理從屬複製伺服器的語句。<a href="sql-syntax.html#replication-master-sql" title="13.6.1. SQL Statements for Controlling Master Servers">13.6.1節，「用於控制主伺服器的SQL語句」</a>討論了用於管理主伺服器的語句。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-master-to"></a>13.6.2.1. CHANGE 
				MASTER TO語法</h4></div></div></div><a class="indexterm" name="id2928632"></a>
				<pre><span>&nbsp; CHANGE MASTER TO <span><i>master_def</i></span> [, <span><i>master_def</i></span>] ...</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>master_def:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MASTER_HOST = &#39;<span><i>host_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_USER = &#39;<span><i>user_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_PASSWORD = &#39;<span><i>password</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_PORT = <span><i>port_num</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_CONNECT_RETRY = <span><i>count</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_LOG_FILE = &#39;<span><i>master_log_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_LOG_POS = <span><i>master_log_pos</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | RELAY_LOG_FILE = &#39;<span><i>relay_log_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | RELAY_LOG_POS = <span><i>relay_log_pos</i></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL = {0|1}</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CA = &#39;<span><i>ca_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CAPATH = &#39;<span><i>ca_directory_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CERT = &#39;<span><i>cert_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_KEY = &#39;<span><i>key_file_name</i></span>&#39;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; | MASTER_SSL_CIPHER = &#39;<span><i>cipher_list</i></span>&#39;</span></pre>
				<p>可以更改從屬伺服器用於與主伺服器進行連接和通訊的參數。</p>
				<p><span>MASTER_USER</span><span>,
				<span>MASTER_PASSWORD</span>,
				<span>MASTER_SSL</span>,
				<span>MASTER_SSL_CA</span>,
				<span>MASTER_SSL_CAPATH</span>,
				<span>MASTER_SSL_CERT</span>,
				<span>MASTER_SSL_KEY</span></span>和<span>MASTER_SSL_CIPHER</span>用於向從屬伺服器提供有關如何與主伺服器連接的訊息。</p>
				<p>即使對於在編譯時沒有<span>SSL</span>支援的從屬伺服器，<span>SSL</span>選項<span>(<span>MASTER_SSL</span>,
				<span>MASTER_SSL_CA</span>,
				<span>MASTER_SSL_CAPATH</span>,
				<span>MASTER_SSL_CERT</span>,
				<span>MASTER_SSL_KEY</span></span>和<span>MASTER_SSL_CIPHER</span><span>)</span>也可以被更改。它們被保存到<span>master.info</span>檔案中，但是會被忽略，直到您使用一個<span>SSL</span>支援已啟用的伺服器。</p>
				<p>如果您不指定一個給定的參數，則它會保持其原有的值。例外情況在後面的討論中進行了說明。舉例說明，如果用於連接到您的<span>MySQL</span>主伺服器的
				密碼被更改了，您只需發佈這些語句，就可以告知從屬伺服器新的密碼：</p>
				<pre><span>mysql&gt; <span><b>STOP SLAVE; -- if replication was running</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO MASTER_PASSWORD=&#39;new3cret&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>START SLAVE; -- if you want to restart replication</b></span></span></pre>
				<p>沒有必要指定沒有改變的參數（主機、接口、用戶等）。</p>
				<p><span>MASTER_HOST</span>和<span>MASTER_PORT</span>是主伺服器主機和其<span>TCP/IP</span>接口的主機名（或<span>IP</span>地址）。注意，如果<span>MASTER_HOST</span>與<span>localhost</span>相等，那麼，和<span>MySQL</span>的其它部分一樣，接口可以被忽略（例如，如果可以使用<span>Unix</span>插槽檔案）。</p>
				<p>如果您指定了<span>MASTER_HOST</span>或<span>MASTER_PORT</span>，則從屬伺服器會假定主伺服器與以前不一樣（即使您指定的主機或接口值與當前值是一樣的。）在此情況下，主伺服器二進制日誌的名稱和位置的原有值不再適用，因此，如果您不指定語句中的<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>，<span>MASTER_LOG_FILE=&#39;&#39;</span>和<span>MASTER_LOG_POS=4</span>會被靜默地新增。</p>
				<p>在<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>坐標點，從屬伺服器<span>I/O</span>線程在啟動之後從主伺服器讀取。如果您只指定了其中一個，則從屬伺服器不能指定<span>RELAY_LOG_FILE</span>或<span>RELAY_LOG_POS</span>。如果<span>MSATER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>都沒有被指定，則從屬伺服器會使用在<span>CHANGE 
				MASTER</span>被發佈前的最後一個<span>slave SQL thread</span>坐標。當您只想改變要使用的
				密碼時，這可以確保複製的連續性。即使從屬伺服器<span>SQL</span>線程落後於從屬伺服器<span>I/O</span>線程，也可以確保複製的連續性。</p>
				<p><span>CHANGE MASTER</span>會刪除所有的中繼日誌檔案並啟動一個新的日誌，除非您指定了<span>RELAY_LOG_FILE</span>或<span>RELAY_LOG_POS</span>。在此情況下，中繼日誌被保持；<span>relay_log_purge</span>全局變數被靜默地設置為<span>0</span>。</p>
				<p><span>CHANGE MASTER TO</span>可以更新<span>master.info</span>和<span>relay-log.info</span>檔案的內容。</p>
				<p>當您擁有主伺服器快照並擁有日誌和對應的偏移量時，<span>CHANGE MASTER</span>對於設置從屬伺服器是有用的。在把快照載入從屬伺服器之後，您可以在從屬伺服器上運行<span>CHANGE 
				MASTER TO MASTER_LOG_FILE=&#39;<i>log_name_on_master</i>&#39;, 
				MASTER_LOG_POS=<i>log_offset_on_master</i></span>。</p>
				<p>舉例說明：</p>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_HOST=&#39;master2.mycompany.com&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_USER=&#39;replication&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_PASSWORD=&#39;bigs3cret&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_PORT=3306,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_LOG_FILE=&#39;master2-bin.001&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_LOG_POS=4,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_CONNECT_RETRY=10;</b></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_FILE=&#39;slave-relay-bin.006&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_POS=4025;</b></span></span></pre>
				<p>第一個例子可以更改主伺服器及其二進制日誌坐標。當想要設置從屬伺服器來複製主伺服器時使用。</p>
				<p>
				第二個例子顯示了較少被使用的一個操作。當從屬伺服器含有中繼日誌，並且您出於某種原因想要執行此日誌時使用。要這麼做時，不需要連接主伺服器。您只需要使用<span>CHANGE 
				MASTER TO</span>並啟動<span>SQL</span>線程（<span>START 
				SLAVE SQL_THREAD</span>）。</p>
				<p>
				您甚至可以在一個用於獨立非從屬伺服器的非複製型設置中使用第二種操作，在崩潰之後進行復原。假設您的伺服器已崩潰，同時您已恢復了備份。您想要重新播放伺服器自己的二進制日誌（不是中繼日誌，而是正規的二進制檔案），例如名為<span>myhost-bin.*</span>。首先，應在安全的地方製作這些二進制日誌的備份，以防您沒有完全遵守以下步驟，意外地讓伺服器清理了二進制檔案。使用<span>SET 
				GLOBAL relay_log_purge=0</span>，進一步增加安全性。然後啟動不含<span>--log-bin</span>選項的伺服器。使用<span>--replicate-same-server-id</span><span>,
				<span>--relay-log=myhost-bin</span></span>（讓伺服器相信，這些正規的二進制日誌是中繼日誌）和<span>--skip-slave-start</span><span> 
				options</span>選項。當伺服器啟動後，發佈以下語句：</p>
				<pre><span>mysql&gt; <span><b>CHANGE MASTER TO</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_FILE=&#39;myhost-bin.153&#39;,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>RELAY_LOG_POS=410,</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>MASTER_HOST=&#39;some_dummy_string&#39;;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>START SLAVE SQL_THREAD;</b></span></span></pre>
				<p>伺服器會讀取並執行自己的二進制日誌，完成崩潰復原。當復原完成後，運行<span>STOP SLAVE</span>，關閉伺服器，刪除<span>master.info</span>和<span>relay-log.info</span>，並使用原來的選項重新啟動伺服器。</p>
				<p>要讓伺服器認為它是一個從屬伺服器，需要指定<span>MASTER_HOST</span>（甚至使用假值）。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-from-master"></a>13.6.2.2. LOAD 
				DATA FROM MASTER語法</h4></div></div></div><a class="indexterm" name="id2929197"></a>
				<pre><span>LOAD DATA FROM MASTER</span></pre>
				<p>本命令用於對主伺服器進行快照，並拷貝到從屬伺服器上。它可以更新<span>MASTER_LOG_FILE</span>和<span>MASTER_LOG_POS</span>的值，這樣，從屬伺服器就可以從正確的位置開始進行複製。使用<span>--replicate-*-do-*</span>和<span>--replicate-*-ignore-*</span>選項指定的資料表和資料庫排除規則均被兌現。<span>--replicate-rewrite-db</span>沒有被考慮。這是因為使用本選項，用戶就可以設置一個例如<span>--replicate-rewrite-db=db1-&gt;db3</span>和<span>--replicate-rewrite-db=db2-&gt;db3</span>的非唯一映射。當從主伺服器載入資料表時，該映射會使從屬伺服器發生混淆。</p>
				<p>本語句的使用受以下條件的制約：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>只對<span>MyISAM</span>資料表起作用。如果試圖載入一個非<span>MyISAM</span>資料表，會導致以下錯誤：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1189 (08S01): Net error reading from master</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>當拍攝快照時，會獲得對主伺服器的全局讀取鎖定。在載入操作期間，該鎖定會阻止對主伺服器的更新。</p>
				<p>如果您正在載入大資料表，您可能必須對主伺服器和從屬伺服器均增加<span>net_read_timeout</span>和<span>net_write_timeout</span>值。請參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。</p>
				<p>注意，<span>LOAD DATA FROM MASTER</span>不從<span>mysql</span>資料庫拷貝任何資料表。這可以更容易地讓主伺服器和從屬伺服器擁有不同的用戶和權限。</p>
				<p><span>LOAD DATA FROM MASTER</span>語句要求用於連接主伺服器的複製帳戶，以便讓主伺服器擁有<span>RELOAD</span>和<span>SUPER</span>權限，並讓所有您想要載入的主伺服器資料表擁有<span>SELECT</span>權限。所有的用戶不擁有<span>SELECT</span>權限的主伺服器資料表均被<span>LOAD 
				DATA FROM MASTER</span>忽略。這是因為主伺服器會對用戶隱藏它們：<span>LOAD 
				DATA FROM MASTER</span>會使用<span>SHOW DATABASES</span>以瞭解要載入的主伺服器資料庫，但是<span>SHOW 
				DATABASES</span>只會返回用戶有部分權限的資料庫。請參見<a href="sql-syntax.html#show-databases" title="13.5.4.6. SHOW DATABASES Syntax">13.5.4.6節，「SHOW 
			DATABASES語法」</a>。在從屬伺服器方面，發佈<span>LOAD DATA FROM 
				MASTER</span>的用戶應擁有授權，以取消或建立被複製的資料庫和資料表。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-table-from-master"></a>13.6.2.3. LOAD 
				TABLE <em class="replaceable">tbl_name</em> FROM 
				MASTER語法</h4></div></div></div><a class="indexterm" name="id2929437"></a>
				<pre><span>LOAD TABLE <span><i>tbl_name</i></span> FROM MASTER</span></pre>
				<p>用於把資料表的拷貝從主伺服器轉移到從屬伺服器。本語句的主要作用是調試<span>LOAD DATA 
				FROM MASTER</span>。它要求用於連接主伺服器的帳戶擁有對主伺服器的<span>RELOAD</span>和<span>SUPER</span>權限，並擁有對要載入的主伺服器資料表的<span>SELECT</span>權限。在從屬伺服器方面，發佈<span>LOAD 
				TABLE FROM MASTER</span>的用戶應擁有取消和建立資料表的權限。</p>
				<p>用於<span>LOAD DATA FROM MASTER</span>的條件也適用於這裡。舉例說明，<span>LOAD 
				TABLE FROM MASTER</span>僅對於<span>MyISAM</span>資料表起作用。對<span>LOAD 
				DATA FROM MASTER</span>的暫停注意也適用。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="master-pos-wait"></a>13.6.2.4. MASTER_POS_WAIT()語法</h4>
						</div></div></div><a class="indexterm" name="id2929546">
				</a>
				<pre><span>SELECT MASTER_POS_WAIT(&#39;<span><i>master_log_file</i></span>&#39;, <span><i>master_log_pos</i></span>)</span></pre>
				<span>
				這實際上是一個函數，而不是一個語句。它被用於確認，從屬伺服器已讀取並執行了到達主伺服器二進制日誌的給定位置。要瞭解完整的描述，請參見</span><a href="functions.html#miscellaneous-functions" title="12.9.4. Miscellaneous Functions">12.9.4節，「其他函數」</a></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-slave"></a>13.6.2.5. RESET 
				SLAVE語法</h4></div></div></div><a class="indexterm" name="id2929592"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>RESET SLAVE</span></pre>
				<p>用於讓從屬伺服器忘記其在主伺服器的二進制日誌中的複製位置。本語句被用於進行一個明確的啟動：它會刪除<span>master.info</span>和<span>relay-log.info</span>檔案，以及所有的中繼日誌，並啟動一個新的中繼日誌。</p>
				<p>註釋：所有的中繼日誌被刪除，即使它們沒有被從屬伺服器<span>SQL</span>線程完全的執行。（如果您已經發佈了一個<span>SLAVE</span>語句或如果從屬伺服器的載入量很大，則這對於一個複製從屬伺服器是一個很可能出現的情況。）</p>
				<p>儲存在<span>master.info</span>檔案中的連接訊息通過使用在對應的啟動選項中指定的值，被立即重新設置了。此訊息包括主伺服器主機、主伺服器接口、主伺服器用戶和主伺服器
				密碼等值。當從屬伺服器<span>SQL</span>線程被中止時，它位於正在複製的臨時資料表的中間，並且發佈了<span>RESET 
				SLAVE</span>，則已被複製的臨時資料表在從屬伺服器中被刪除。</p>
				<h4 class="title"><a name="set-global-sql-slave-skip-counter"></a>13.6.2.6. SET 
				GLOBAL SQL_SLAVE_SKIP_COUNTER語法</h4></div></div></div><a class="indexterm" name="id2929698"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>SET GLOBAL SQL_SLAVE_SKIP_COUNTER = <span><i>n</i></span></span></pre>
				<p>從主伺服器中跳過後面的<span>n</span>個事件。要復原由語句導致的複製中止，這是有用的。</p>
				<p>僅當從屬線程沒有正在運行時，本語句時有效的。否則，會產生一個錯誤。</p>
				<h4 class="title"><a name="show-slave-status"></a>13.6.2.7. SHOW 
				SLAVE STATUS語法</h4></div></div></div><a class="indexterm" name="id2929771"></a>
				<pre><span>SHOW SLAVE STATUS</span></pre>
				<p>用於提供有關從屬伺服器線程的關鍵參數的訊息。如果您使用<span>mysql</span>客戶端發佈此語句，則您可以使用一個<span>\G</span>語句終止符來獲得更便於閱讀的豎向版面，而不是使用分號：</p>
				<pre><span>mysql&gt; <span><b>SHOW SLAVE STATUS\G</b></span></span></pre>
				<pre><span>*************************** 1. row ***************************</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Slave_IO_State: Waiting for master to send event</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Host: localhost</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_User: root</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Port: 3306</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connect_Retry: 3</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_Log_File: gbichot-bin.005</span></pre>
				<pre><span>&nbsp; Read_Master_Log_Pos: 79</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_File: gbichot-relay-bin.005</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_Pos: 548</span></pre>
				<pre><span>Relay_Master_Log_File: gbichot-bin.005</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; Slave_IO_Running: Yes</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; Slave_SQL_Running: Yes</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Replicate_Do_DB:</span></pre>
				<pre><span>&nbsp; Replicate_Ignore_DB:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Last_Errno: 0</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Last_Error:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skip_Counter: 0</span></pre>
				<pre><span>&nbsp; Exec_Master_Log_Pos: 79</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relay_Log_Space: 552</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Condition: None</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Log_File:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Until_Log_Pos: 0</span></pre>
				<pre><span>&nbsp; &nbsp;Master_SSL_Allowed: No</span></pre>
				<pre><span>&nbsp;&nbsp; Master_SSL_CA_File:</span></pre>
				<pre><span>&nbsp;&nbsp; Master_SSL_CA_Path:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_SSL_Cert:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; Master_SSL_Cipher:</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Master_SSL_Key:</span></pre>
				<pre><span>Seconds_Behind_Master: 8</span></pre>
				<p><span>SHOW SLAVE STATUS</span>會返回以下字段：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_IO_State</span><span> </span></p>
				<p><span>SHOW PROCESSLIST</span>輸出的<span>State</span>字段的拷貝。<span>SHOW 
				PROCESSLIST</span>用於從屬<span>I/O</span>線程。如果線程正在試圖連接到主伺服器，正在等待來自主伺服器的時間或正在連接到主伺服器等，本語句會通知您。在<a href="replication.html#replication-implementation-details" title="6.3. Replication Implementation Details">6.3節，「複製實施細節」</a>中列出了可能的狀態。舊版本的<span>MySQL</span>在連接主伺服器不成功時，允許線程繼續運行。對於舊版本的<span>MySQL</span>，觀看此字段是必須的。如果它正在運行，則無問題；如果它沒有運行，則您會在<span>Last_Error</span>字段中發現錯誤（後面有說明）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Host</span><span> </span></p>
				<p>當前的主伺服器主機。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_User</span><span> </span></p>
				<p>被用於連接主伺服器的當前用戶。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Port</span><span> </span></p>
				<p>當前的主伺服器接口。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Connect_Retry</span><span> </span></p>
				<p>
				<span>--master-connect-retry</span>選項的當前值</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_Log_File</span><span> </span></p>
				<p><span>I/O</span>線程當前正在讀取的主伺服器二進制日誌檔案的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Read_Master_Log_Pos</span><span> </span></p>
				<p>在當前的主伺服器二進制日誌中，<span>I/O</span>線程已經讀取的位置。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_File</span><span> </span></p>
				<p><span>SQL</span>線程當前正在讀取和執行的中繼日誌檔案的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_Pos</span><span> </span></p>
				<p>在當前的中繼日誌中，<span>SQL</span>線程已讀取和執行的位置。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Master_Log_File</span><span> </span></p>
				<p>由<span>SQL</span>線程執行的包含多數近期事件的主伺服器二進制日誌檔案的名稱。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_IO_Running</span><span> </span></p>
				<p><span>I/O</span>線程是否被啟動並成功地連接到主伺服器上。對於舊版本的<span>MySQL</span>（在<span>4.1.14</span>和<span>5.0.12</span>之前），如果<span>I/O</span>線程已被啟動，即使從屬伺服器仍沒有連接到主伺服器上，<span>Slave_IO_Running</span>也將被設置到<span>YES</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Slave_SQL_Running</span><span> </span></p>
				<p><span>SQL</span>線程是否被啟動。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Replicate_Do_DB</span><span>,
				<span>Replicate_Ignore_DB</span> </span>
				</p>
				<p>使用<span>--replicate-do-db</span>和<span>--replicate-ignore-db</span>選項指定的資料庫清單。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Replicate_Do_Table</span><span>,
				<span>Replicate_Ignore_Table</span>,
				<span>Replicate_Wild_Do_Table</span>,
				<span>Replicate_Wild_Ignore_Table</span>
				</span></p>
				<p>使用<span>--replicate-do-table</span><span>,
				<span>--replicate-ignore-table</span>,
				<span>--replicate-wild-do-table</span></span>和<span>--replicate-wild-ignore_table</span>選項指定的資料表清單。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Last_Errno</span><span>,
				<span>Last_Error</span> </span></p>
				<p>被多數最近被執行的查詢返回的錯誤數量和錯誤消息。錯誤數量為<span>0</span>並且消息為空字串意味著「沒有錯誤」。如果<span>Last_Error</span>值不是空值，它也會在從屬伺服器的錯誤日誌中作為消息顯示。</p>
				<p>舉例說明：</p>
				<pre><span>Last_Errno: 1051</span></pre>
				<pre><span>Last_Error: error &#39;Unknown table &#39;z&#39;&#39; on query &#39;drop table z&#39;</span></pre>
				<p>該消息指示，資料表<span>z</span>曾經存在於在主伺服器中並已被取消了，但是它沒有在從屬伺服器中存在過，因此對於從屬伺服器，<span>DROP 
				TABLE</span>失敗。（舉例說明，在設置複製時，如果您忘記了把此資料表拷貝到從屬伺服器中，則這有可能發生。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Skip_Counter</span><span> </span></p>
				<p>最近被使用的用於<span>SQL_SLAVE_SKIP_COUNTER</span>的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Exec_Master_Log_Pos</span><span> </span></p>
				<p>來自主伺服器的二進制日誌的由<span>SQL</span>線程執行的上一個時間的位置（<span>Relay_Master_Log_File</span>）。在主伺服器的二進制日誌中的<span>(<span>Relay_Master_Log_File</span>,
				<span>Exec_Master_Log_Pos</span>)</span>對應於在中繼日誌中的<span>(<span>Relay_Log_File</span>,
				<span>Relay_Log_Pos</span>)</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Relay_Log_Space</span><span> </span></p>
				<p>所有原有的中繼日誌結合起來的總大小。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Until_Condition</span><span>,
				<span>Until_Log_File</span>,
				<span>Until_Log_Pos</span> </span></p>
				<p>在<span>START SLAVE</span>語句的<span>UNTIL</span>子句中指定的值。</p>
				<p><span>Until_Condition</span>具有以下值：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果沒有指定<span>UNTIL</span>子句，則沒有值</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果從屬伺服器正在讀取，直到達到主伺服器的二進制日誌的給定位置為止，則值為<span>Master</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果從屬伺服器正在讀取，直到達到其中繼日誌的給定位置為止，則值為<span>Relay</span></p>
				<p><span>Until_Log_File</span>和<span>Until_Log_Pos</span>用於指示日誌檔案名和位置值。日誌檔案名和位置值定義了<span>SQL</span>線程在哪個點中止執行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Master_SSL_Allowed</span><span>,
				<span>Master_SSL_CA_File</span>,
				<span>Master_SSL_CA_Path</span>,
				<span>Master_SSL_Cert</span>,
				<span>Master_SSL_Cipher</span>,
				<span>Master_SSL_Key</span> </span></p>
				<p>這些字段顯示了被從屬伺服器使用的參數。這些參數用於連接主伺服器。</p>
				<p><span>
				Master_SSL_Allowed</span>具有以下值：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果允許對主伺服器進行<span>SSL</span>連接，則值為<span>Yes</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果不允許對主伺服器進行<span>SSL</span>連接，則值為<span>No</span></p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果允許<span>SSL</span>連接，但是從屬伺服器沒有讓<span>SSL</span>支援被啟用，則值為<span>Ignored</span>。</p>
				<p>與<span>SSL</span>有關的字段的值對應於<span>--master-ca</span><span>,
				<span>--master-capath</span>,
				<span>--master-cert</span>,
				<span>--master-cipher</span></span>和<span>--master-key</span>選項的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				Seconds_Behind_Master</span><span> </span></p>
				<p>本字段是從屬伺服器「落後」多少的一個指示。當從屬<span>SQL</span>線程正在運行時（處理更新），本字段為在主伺服器上由此線程執行的最近的一個事件的時間標記開始，已經過的秒數。當此線程被從屬伺服器<span>I/O</span>線程趕上，並進入閒置狀態，等待來自<span>I/O</span>線程的更多的事件時，本字段為零。總之，本字段測量從屬伺服器<span>SQL</span>線程和從屬伺服器<span>I/O</span>線程之間的時間差距，單位以秒計。</p>
				<p>如果主伺服器和從屬伺服器之間的網絡連接較快，則從屬伺服器<span>I/O</span>線程會非常接近主伺服器，所以本字段能夠十分近似地指示，從屬伺服器<span>SQL</span>線程比主伺服器落後多少。如果網絡較慢，則這種指示不準確；從屬<span>SQL</span>線程經常會趕上讀取速度較慢地從屬伺服器<span>I/O</span>線程，因此，<span>Seconds_Behind_Master</span>經常顯示值為<span>0</span>。即使<span>I/O</span>線程落後於主伺服器時，也是如此。換句話說，本列只對速度快的網絡有用。</p>
				<p>
				即使主伺服器和從屬伺服器不具有相同的時鐘，時間差計算也會起作用（當從屬伺服器<span>I/O</span>線程啟動時，計算時間差。並假定從此時以後，時間差保持不變）。如果從屬<span>SQL</span>線程不運行，或者如果從屬伺服器<span>I/O</span>線程不運行或未與主伺服器連接，則<span>Seconds_Behind_Master</span>為<span>NULL</span>（意義為「未知」）。舉例說明，如果在重新連接之前，從屬伺服器<span>I/O</span>線程休眠了<span>master-connect-retry</span>秒，則顯示<span>NULL</span>，因為從屬伺服器不知道主伺服器正在做什麼，也不能有把握地說落後多少。</p>
				<p>
				本字段有一個限制。時間標記通過複製被保留，這意味著，如果一個主伺服器<span>M1</span>本身是一個從屬伺服器<span>M0</span>，則來自<span>M1</span>的<span>binlog</span>的任何事件（通過複製來自<span>M0</span>的<span>binlog</span>的事件而產生），與原事件具有相同的時間標記。這可以使<span>MySQL</span>成功地複製<span>TIMESTAMP</span>。但是，<span>Seconds_Behind_Master</span>的缺點是，如果<span>M1</span>也收到來自客戶端的直接更新，則值會隨機變化，因為有時最近的<span>M1</span>時間來自<span>M0</span>，有時來自直接更新，最近的時間標記也是如此。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-slave"></a>13.6.2.8. START 
				SLAVE語法</h4></div></div></div><a class="indexterm" name="id2930616"></a></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>START SLAVE [<span><i>thread_type</i></span> [, <span><i>thread_type</i></span>] ... ]</span></pre>
				<pre><span>START SLAVE [SQL_THREAD] UNTIL</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; MASTER_LOG_FILE = &#39;<span><i>log_name</i></span>&#39;, MASTER_LOG_POS = <span><i>log_pos</i></span></span></pre>
				<pre><span>START SLAVE [SQL_THREAD] UNTIL</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; RELAY_LOG_FILE = &#39;<span><i>log_name</i></span>&#39;, RELAY_LOG_POS = <span><i>log_pos</i></span></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>thread_type: IO_THREAD | SQL_THREAD</span></pre>
				<p>不含選項的<span>START SLAVE</span>會同時啟動兩個從屬伺服器線程。<span>I/O</span>線程從主伺服器中讀取查詢，並把它們儲存在中繼日誌中。<span>SQL</span>線程讀取中繼日誌並執行查詢。<span>START 
				SLAVE</span>要求<span>SUPER</span>權限。</p>
				<p>如果<span>START SLAVE</span>成功地啟動了從屬伺服器線程，則會返回，不會出現錯誤。但是，即使在此情況下，也有可能出現這樣的現象——伺服器線程啟動了，然後又停止了（例如，因為它們沒有成功地連接到主伺服器上，或者沒有能讀取二進制日誌，或者出現了其它問題）。<span>START 
				SLAVE</span>對此不會發出警告。您必須檢查從屬伺服器的錯誤日誌，查看是否有由從屬伺服器線程產生的錯誤消息，或者使用<span>SHOW 
				SLAVE STATUS</span>檢查它們是否運行正常。</p>
				<p>您可以把<span>IO_THREAD</span>和<span>SQL_THREAD</span>選項新增到語句中，指明哪些線程將要啟動。</p>
				<p>可以新增一個<span>UNTIL</span>子句，指定從屬伺服器應啟動並運行，直到<span>SQL</span>線程達到主伺服器二進制日誌中的一個給定點為止。當<span>SQL</span>線程達到此點時，它會停止。如果在該語句中指定了<span>SQL_THREAD</span>選項，則它只會啟動<span>SQL</span>線程。否則，它會同時啟動兩個從屬伺服器線程。如果<span>SQL</span>線程正在運行，則<span>UNTIL</span>子句被忽略，並發佈一個警告。</p>
				<p>對於一個<span>UNTIL</span>子句，您必須同時指定一個日誌檔案名和位置。不要把主伺服器和中繼日誌選項混合在一起。</p>
				<p><span>UNTIL</span>條件由一個後續的<span>STOP 
				SLAVE</span>語句，或一個不包括<span>UNTIL</span>子句的<span>START 
				SLAVE</span>語句，或一個伺服器重啟命令重新設置。</p>
				<p><span>UNTIL</span>子句對於調試複製操作是有用的，或者可用於促使複製操作繼續，直到接近一個特定的點時為止，在此點，您想要避免讓從屬伺服器複製一個語句。舉例說明，如果在主服務上執行了一個不明智的<span>DROP 
				TABLE</span>語句，您可以使用<span>UNTIL</span>來告知從屬伺服器，執行到此點就停止，不要再繼續了。要搜尋該事件是什麼，需對主伺服器日誌或從屬中繼日誌使用<span>mysqlbinlog</span>，或通過使用<span>SHOW 
				BINLOG EVENTS</span>語句。</p>
				<p>如果您正在使用<span>UNTIL</span>，讓從屬伺服器成段地處理已複製的查詢，則建議您使用<span>--skip-slave-start</span>選項來啟動從屬伺服器，以防止當從屬伺服器啟動時，<span>SQL</span>線程運行。最好在一個選項檔案中使用此選項，而不是在命令行中使用，這樣，如果發生了意料外的伺服器重新啟動，它也不會被忘記。</p>
				<p><span>SHOW SLAVE STATUS</span>語句包括了輸出字段。這些字段顯示了<span>UNTIL</span>條件的當前值。</p>
				<p>在以前版本的<span>MySQL</span>中，本語句被稱為<span>SLAVE 
				START</span>。在<span>MySQL 5.1</span>中仍然接受這種用法，以便與以前版本兼容。但現在不贊成使用。</p>
				<h4 class="title"><a name="stop-slave"></a>13.6.2.9. STOP 
				SLAVE語法<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2930874"></a></div></div></div><div class="section"><div class="titlepage"><div><div>
		<pre><span>STOP SLAVE [<span><i>thread_type</i></span> [, <span><i>thread_type</i></span>] ... ]</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>thread_type: IO_THREAD | SQL_THREAD</span></pre>
		<p>用於中止從屬伺服器線程。<span>STOP SLAVE</span>要求<span>SUPER</span>權限。</p>
		<p>和<span>START SLAVE</span>相似，本語句在使用時可以加<span>IO_THREAD</span>和<span>SQL_THREAD</span>選項，指明將被中止的線程。</p>
		<p>在以前版本的<span>MySQL</span>中，本語句被稱為<span>SLAVE STOP</span>。在<span>MySQL 
		5.1</span>中仍然接受這種用法，以便與以前版本兼容。但是現在不贊成使用。</p>
		<h2 class="title"><a name="sqlps"></a>
		13.7.&nbsp;用於預處理語句的SQL語法</h2></div></div></div><a class="indexterm" name="id2930996"></a><a class="indexterm" name="id2931005"></a><a class="indexterm" name="id2931014"></a>
		<p><span>MySQL 5.1</span>對伺服器一方的預制語句提供支援。如果您使用合適的客戶端編程界面，則這種支援可以發揮在<span>MySQL 
		4.1</span>中實施的高效客戶端<span>/</span>伺服器二進制協議的優勢。候選界面包括<span>MySQL 
		C API</span>客戶端庫（用於<span>C</span>程式）、<span>MySQL 
		Connector/J</span>（用於<span>Java</span>程式）和<span>MySQL 
		Connector/NET</span>。例如，<span>C API</span>可以提供一套能組成預制語句<span>API</span>的函數使用。請參見<a href="apis.html#c-api-prepared-statements" title="25.2.4. C API Prepared Statements">25.2.4節，「C API預處理語句」</a>。其它語言界面可以對使用了二進制協議（通過在<span>C</span>客戶端庫中連結）的預制語句提供支援。有一個例子是<span><a target="_top"  href="http://php.net/mysqli">PHP 
		5.0<span>中的</span>mysqli<span>延伸</span></a></span>。</p>
		<p>對預制語句，還有一個<span>SQL</span>界面可以利用。與在整個預制語句<span>API</span>中使用二進制協議相比，本界面效率沒有那麼高，但是它不要求編程，因為在<span>SQL</span>層級，可以直接利用本界面：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>當您無法利用編程界面時，您可以使用本界面。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>有些程式允許您發送<span>SQL</span>語句到將被執行的伺服器中，比如<span>mysql</span>客戶端程式。您可以從這些程式中使用本界面。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>即使客戶端正在使用舊版本的客戶端庫，您也可以使用本界面。唯一的要求是，您能夠連接到一個支援預制語句<span>SQL</span>語法的伺服器上。</p>
		<p>預制語句的<span>SQL</span>語法在以下情況下使用：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>
		在編代碼前，您想要測試預制語句在您的應用程式中運行得如何。或者也許一個應用程式在執行預制語句時有問題，您想要確定問題是什麼。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>您想要建立一個測試案例，該案例描述了您使用預制語句時出現的問題，以便您編製程式錯誤報告。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>您需要使用預制語句，但是您無法使用支援預制語句的編程<span>API</span>。</p>
		<p>預制語句的<span>SQL</span>語法基於三個<span>SQL</span>語句：</p>
		<pre><span>PREPARE <span><i>stmt_name</i></span> FROM <span><i>preparable_stmt</i></span>;</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>EXECUTE <span><i>stmt_name</i></span> [USING @<span><i>var_name</i></span> [, @<span><i>var_name</i></span>] ...];</span></pre>
		<pre><span>&nbsp;</span></pre>
		<pre><span>{DEALLOCATE | DROP} PREPARE <span><i>stmt_name</i></span>;</span></pre>
		<p><span>PREPARE</span>語句用於預備一個語句，並賦予它名稱<span>stmt_name</span>，借此在以後引用該語句。語句名稱對案例不敏感。<span>preparable_stmt</span>可以是一個文字字串，也可以是一個包含了語句文本的用戶變數。該文本必須展現一個單一的<span>SQL</span>語句，而不是多個語句。使用本語句，『<span>?</span>』字元可以被用於製作參數，以指示當您執行查詢時，數據值在哪裡與查詢結合在一起。『<span>?</span>』字元不應加引號，即使您想要把它們與字串值結合在一起，也不要加引號。參數製作符只能被用於數據值應該出現的地方，不用於<span>SQL</span>關鍵詞和標識符等。</p>
		<p>
		如果帶有此名稱的預制語句已經存在，則在新的語言被預備以前，它會被隱含地解除分配。這意味著，如果新語句包含一個錯誤並且不能被預備，則會返回一個錯誤，並且不存在帶有給定名稱語句。</p>
		<p>預制語句的範圍是客戶端會話。在此會話內，語句被建立。其它客戶端看不到它。</p>
		<p>在預備了一個語句後，您可使用一個<span>EXECUTE</span>語句（該語句引用了預制語句名稱）來執行它。如果預制語句包含任何參數製造符，則您必須提供一個列舉了用戶變數（其中包含要與參數結合的值）的<span>USING</span>子句。參數值只能有用戶變數提供，<span>USING</span>子句必須準確地指明用戶變數。用戶變數的數目與語句中的參數製造符的數量一樣多。</p>
		<p>您可以多次執行一個給定的預制語句，在每次執行前，把不同的變數傳遞給它，或把變數設置為不同的值。</p>
		<p>要對一個預制語句解除分配，需使用<span>DEALLOCATE PREPARE</span>語句。嘗試在解除分配後執行一個預制語句會導致錯誤。</p>
		<p>如果您終止了一個客戶端會話，同時沒有對以前已預制的語句解除分配，則伺服器會自動解除分配。</p>
		<p>以下<span>SQL</span>語句可以被用在預制語句中：<span>CREATE 
		TABLE, <span>DELETE</span>,
		<span>DO</span>, <span>
		INSERT</span>, <span>REPLACE</span>,
		<span>SELECT</span>,
		<span>SET</span>, <span>
		UPDATE</span></span><span>和多數的<span>SHOW</span>語句。目前不支援其它語句。</span></p>
		<p>以下例子顯示了預備一個語句的兩種方法。該語句用於在給定了兩個邊的長度時，計算三角形的斜邊。</p>
		<p>第一個例子顯示如何通過使用文字字串來建立一個預制語句，以提供語句的文本：</p>
		<pre><span>mysql&gt; <span><b>PREPARE stmt1 FROM &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @a = 3;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @b = 4;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>EXECUTE stmt1 USING @a, @b;</b></span></span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>| hypotenuse |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>mysql&gt; <span><b>DEALLOCATE PREPARE stmt1;</b></span></span></pre>
		<p>第二個例子是相似的，不同的是提供了語句的文本，作為一個用戶變數：</p>
		<pre><span>mysql&gt; <span><b>SET @s = &#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse&#39;;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>PREPARE stmt2 FROM @s;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @a = 6;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>SET @b = 8;</b></span></span></pre>
		<pre><span>mysql&gt; <span><b>EXECUTE stmt2 USING @a, @b;</b></span></span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>| hypotenuse |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 |</span></pre>
		<pre><span>+------------+</span></pre>
		<pre><span>mysql&gt; <span><b>DEALLOCATE PREPARE stmt2;</b></span></span></pre>
		<p>預制語句的<span>SQL</span>語法不能被用於帶嵌套的風格中。也就是說，被傳遞給<span>PREPARE</span>的語句本身不能是一個<span>PREPARE, 
		EXECUTE</span>或<span>DEALLOCATE PREPARE</span>語句。</p>
		<p>預制語句的<span>SQL</span>語法與使用預制語句<span>API</span>使用不同。例如，您不能使用<span>mysql_stmt_prepare()</span><span> 
		C API</span>函數來預備一個<span>PREPARE, EXECUTE</span>或<span>DEALLOCATE 
		PREPARE</span>語句。</p>
		<p>預制語句的<span>SQL</span>語法可以在已儲存的過程中使用，但是不能在已儲存的函數或觸發程式中使用。</p>
		<p>當使用預制語句時，可以在<span>LIMIT</span>子句中使用佔位符。請參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</div></div><div><hr><p>
      這是MySQL參考手冊的翻譯版本，關於MySQL參考手冊，<span class="GramE">請訪問</span><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
		原始參考手冊為英文版，與英文版參考手冊相比，本翻譯版可能不是最新的。</p></div>
</body></html>
