<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 25. APIs and Libraries</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="precision-math.html" title="Chapter 24. Precision Math"><link rel="next" href="connectors.html" title="Chapter 26.   Connectors">
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="apis"></a>
	第25章：API和庫</h2></div></div></div><div class="toc"><p><b>
	目錄</b></p><dl><dt><span class="section"><a href="apis.html#libmysqld">25.1. 
			libmysqld，嵌入式MySQL伺服器庫</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#libmysqld-overview">25.1.1. 
				嵌入式MySQL伺服器庫概述</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-compiling">
				25.1.2. 使用libmysqld編譯程式<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-restrictions">
				25.1.3. 使用嵌入式MySQL伺服器時的限制</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-options">25.1.4. 
				與嵌入式伺服器一起使用的選項</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-todo">
				25.1.5. 嵌入式伺服器中尚需完成的事項(TODO)</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-example">
				25.1.6. 嵌入式伺服器示範</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-licensing">
				25.1.7. 嵌入式伺服器的授權</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#c">25.2. MySQL C API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#c-api-datatypes">
				25.2.1. C API數據類型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-function-overview">
				25.2.2. C API函數概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-functions">
				25.2.3. C API函數描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statements">
				25.2.4. C API預處理語句</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-datatypes">
				25.2.5. C API預處理語句的數據類型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-function-overview">
				25.2.6. C API預處理語句函數概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-functions">
				25.2.7. C API預處理語句函數描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-problems">
				25.2.8. C API預處理語句方面的問題</a></span></dt><dt><span class="section"><a href="apis.html#c-api-multiple-queries">
				25.2.9. 多查詢執行的C API處理</a></span></dt><dt><span class="section"><a href="apis.html#c-api-date-handling">
				25.2.10. 日期和時間值的C API處理</a></span></dt><dt><span class="section"><a href="apis.html#c-thread-functions">
				25.2.11. C API線程函數介紹</a></span></dt><dt><span class="section"><a href="apis.html#c-embedded-server-func">
				25.2.12. C API嵌入式伺服器函數介紹</a></span></dt><dt><span class="section"><a href="apis.html#c-api-problems">
				25.2.13. 使用C API時的常見問題</a></span></dt><dt><span class="section"><a href="apis.html#building-clients">
				25.2.14. 建立客戶端程式</a></span></dt><dt><span class="section"><a href="apis.html#threaded-clients">
				25.2.15. 如何生成線程式客戶端</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#php">25.3. MySQL PHP API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#php-problems">
				25.3.1. 使用MySQL和PHP的常見問題</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#perl">25.4. MySQL Perl API</a></span></dt><dt><span class="section"><a href="apis.html#cplusplus">25.5. MySQL C++ API</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#borland-c-plus-plus">25.5.1. Borland C++</a></span></dt></dl></dd><dt><span class="section"><a href="apis.html#python">25.6. MySQL Python API</a></span></dt><dt><span class="section"><a href="apis.html#tcl">25.7. MySQL Tcl API</a></span></dt><dt><span class="section"><a href="apis.html#eiffel">25.8. MySQL Eiffel Wrapper</a></span></dt><dt><span class="section"><a href="apis.html#programming-utilities">
			25.9. MySQL程式開發實用工具</a></span></dt><dd><dl><dt><span class="section"><a href="apis.html#msql2mysql">
				25.9.1. msql2mysql：轉換mSQL程式以用於MySQL</a></span></dt><dt><span class="section"><a href="apis.html#mysql-config">
				25.9.2. mysql_config：獲取編譯客戶端的編譯選項</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id3006679"></a><a class="indexterm" name="id3006686"></a><a class="indexterm" name="id3006692"></a><a class="indexterm" name="id3006701"></a><a class="indexterm" name="id3006710"></a><a class="indexterm" name="id3006721"></a><a class="indexterm" name="id3006732"></a>
	<p><a name="libmysqld0">本章介紹了MySQL可使用的API，從哪裡獲得它們，以及如何使用它們。</a> 詳細介紹C 
	API，這是因為它是由MySQL團隊開發的，而且它也是大多數其他API的基礎。 本章還介紹了<span>libmysqld</span>庫（嵌入式伺服器），以及對應用程式開發人員有用的一些程式。 
	</p>
	<div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="libmysqld"></a>
		25.1.&nbsp;libmysqld，嵌入式MySQL伺服器庫</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#libmysqld-overview">25.1.1. 
			嵌入式MySQL伺服器庫概述</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-compiling">
			25.1.2. 使用libmysqld編譯程式<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-restrictions">
			25.1.3. 使用嵌入式MySQL伺服器時的限制</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-options">25.1.4. 
			與嵌入式伺服器一起使用的選項</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-todo">
			25.1.5. 嵌入式伺服器中尚需完成的事項(TODO)</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-example">
			25.1.6. 嵌入式伺服器示範</a></span></dt><dt><span class="section"><a href="apis.html#libmysqld-licensing">
			25.1.7. 嵌入式伺服器的授權</a></span></dt></dl></div><a class="indexterm" name="id3006767"></a><a class="indexterm" name="id3006774"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-overview"></a>25.1.1. 嵌入式MySQL伺服器庫概述</h3></div></div></div>
			<p>使用嵌入式MySQL伺服器庫，能夠在客戶端應用程式中使用具備全部特性的MySQL伺服器。 
			主要優點在於，增加了速度，並使得嵌入式應用程式的管理更簡單。 </p>
			<p>嵌入式伺服器庫是以MySQL的客戶端／伺服器版本為基礎的，採用C/C++語言編寫。 
			其結果是嵌入式伺服器也是用C/C++語言編寫的。 在其他語言中，嵌入式伺服器不可用。 </p>
			<p>API與嵌入式MySQL版本和客戶端／伺服器版本等效。 
			要想更改舊的線程式應用程式以使用嵌入式庫，正常情況下，僅需新增對下述函數的使用即可。 </p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><b>函數</b></td>
					<td>
					<p><b>何時使用</b></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_server_init()</span></td>
					<td>
					<p>應在使用任何其他MySQL函數之前使用，最好是在<span>main()函數中使用。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_server_end()</span></td>
					<td>
					<p>應在程式退出前使用。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_thread_init()</span></td>
					<td>
					<p>應在您所建立的、用於訪問MySQL的每個線程中使用。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>mysql_thread_end()</span></td>
					<td>
					<p>應在使用<span>pthread_exit()之前使用。</span></td>
				</tr>
			</table>
			<p>隨後，必須將您的代碼與<span>libmysqld.a連結起來，而不是libmysqlclient.a。</span></p>
			<p>在<span>libmysqlclient.a中還包含mysql_server_<i>xxx</i>()</span>函數，使用這類函數，通過將應用程式連結到恰當的庫，即可在嵌入式版本和客戶端／伺服器版本之間切換。 
			請參見<a href="apis.html#mysql-server-init" title="25.2.12.1. mysql_server_init()">25.2.12.1節，「mysql_server_init()」</a>。 </p>
			<p>嵌入式伺服器和獨立伺服器之間的一項差別在於，對於嵌入式伺服器，預設情況下，連接鑒定是禁止的。 
			對於嵌入式伺服器，要想使用鑒定功能，可在激活「<strong><span>configure</span></strong>」以配置<span>MySQL</span>分發版時使用「<span>--with-embedded-privilege-control</span>」選項。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-compiling"></a>
			25.1.2.&nbsp;使用libmysqld編譯程式<code class="literal"></code></h3></div></div></div>
			<p>要想獲得<span><span>libmysqld</span>庫，應使用<span  >「</span><span>--with-embedded-server</span><span  >」</span>選項配置<span>MySQL</span>。</span> 
			請參見<a href="installing.html#configure-options" title="2.8.2. Typical configure Options">2.8.2節，「典型配置選項<span><strong class="command"></strong></span>」</a>。 </p>
			<p>將您的程式與<span>libmysqld連結時，還必須包含系統的pthread庫以及MySQL伺服器使用的一些庫。</span> 
			執行「<strong><span>mysql_config --libmysqld-libs</span></strong>」，可獲得庫的完整列資料表。 
			</p>
			<p>對於線程程式的編譯和連結，必須使用正確的標誌，即使您未在代碼中直接使用任何線程函數也同樣。 </p>
			<p>要想編譯C程式以包含必要檔案，並將MySQL伺服器庫嵌入到程式的編譯版本中，可使用GNU C編譯器（<span>gcc</span>）。 
			編譯器需要知道各種檔案的位置，並需瞭解如何編譯程式的指令。 在下面的示範中，介紹了如何從命令行編譯程式的方法： </p>
			<pre><span>gcc mysql_test.c -o mysql_test -lz \</span></pre>
			<pre><span>`/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`</span></pre>
			<p>在gcc命令後緊跟著未編譯C程式檔案的名稱。 接下來，給定的「<span>-o</span>」選項指明，它後面的檔案名是編譯器將輸出檔案的名稱，即編譯後的程式。 
			在下一行的代碼中，通知編譯器獲取包含檔案和庫的位置，以及在其上進行編譯的系統的其他設置。 由於「<strong><span>mysql_config</span></strong>」存在的問題，在此新增了「<span>-lz</span>」選項（壓縮）。 
			「<strong><span>mysql_config</span></strong>」部分包含在<span>backticks</span>中，而不是單引號內。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-restrictions"></a>
			25.1.3.&nbsp;使用嵌入式MySQL伺服器時的限制</h3></div></div></div>
			<p>嵌入式伺服器存在下述限制： </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不支援<span>ISAM資料表。</span> 
			（這樣做的主要目的是為了使庫更小）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>沒有自行定義函數（UDF）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>沒有對核心轉儲的堆棧跟蹤。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>沒有內部RAID支援。 （由於大多數當前作業系統均支援大檔案，通常情況下不需要它）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不能將其設置為「主」或「從」（無複製）。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在內存較低的系統上，可能無法使用很大的結果集。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不能使用套接字或TCP/IP從外部程序連接到嵌入式伺服器。 
			但是，您可以連接到中間應用程式，隨後，該中間應用程式可代資料表遠程客戶端或外部程序連接到嵌入式伺服器。 </p>
			<p>通過編輯「<span>mysql_embed.h</span>」包含檔案並重新編譯MySQL，可更改某些限制。 </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-options"></a>25.1.4. 與嵌入式伺服器一起使用的選項</h3></div></div></div><a class="indexterm" name="id3007169"></a><a class="indexterm" name="id3007180"></a><a class="indexterm" name="id3007190"></a><a class="indexterm" name="id3007200"></a>
			<p>對於任何能夠與<strong><span>mysqld</span></strong>伺服器端口監督程式一起給定的選項，也可以與嵌入式伺服器庫一起使用。在數組中，可將伺服器選項作為參量指定給用於初始化伺服器的<span>mysql_server_init()</span>。也能在諸如<span><span>my.cnf</span>的選項檔案中給定它們。</span>要想為<span>C</span>程式指定選項檔案，請使用「<span><span>--defaults-file</span><span  >」</span>選項作為函數<span>mysql_server_init()</span>的第<span>2</span>個參量的元素之一。關於<span>mysql_server_init()</span>函數的更多訊息，請參見</span><a href="apis.html#mysql-server-init" title="25.2.12.1. mysql_server_init()">25.2.12.1節，「mysql_server_init()」</a>。</p>
			<p>使用選項檔案，能夠簡化客戶端／伺服器應用程式和嵌入了<span>MySQL</span>的應用程式之間的切換。將常用選項置於<span>[server]</span>組。它們可被兩種<span>MySQL</span>版本讀取。客戶端／伺服器選項應被放在<span><span>[mysqld]</span>部分。將嵌入式<span>MySQL</span>伺服器庫的選項</span>放在<span><span>[embedded]</span>部分。將與應用程式相關的選項放在</span>標記為<span><span>[ApplicationName_SERVER]</span>的部分。</span>請參見<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2節，「使用選項檔案」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-todo"></a>
			25.1.5.&nbsp;嵌入式伺服器中尚需完成的事項(TODO)</h3></div></div></div><a class="indexterm" name="id3007292"></a><div class="itemizedlist">
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>我們將提供一些選項以省去<span>MySQL</span>的某些部分，從而使庫變得更小。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>仍有很多速度最佳化工作需要完成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>錯誤將被寫入<span><span>stderr</span>。我們將增加<span>1</span>個選項為它們指定檔案名。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>使用嵌入式版本時，需要更改<span>InnoDB</span>，使之不再冗長。如果您的資料庫不含<span>InnoDB</span>資料表，要想抑制相關消息，可為組<span><span>[libmysqd_server]</span>下的選項檔案增加</span>「<span><span>--skip-innodb」</span>選項，或在用</span><strong><span>mysql_server_init()</span></strong><span>初始化伺服器時新增該選項。</span></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-example"></a>
			25.1.6.&nbsp;嵌入式伺服器示範</h3></div></div></div>
			<p>在<span>Linux</span>或<span>FreeBSD</span>系統上，無需更改就能使用下面這兩個示範程式。對於其他作業系統，需要進行小的修改，主要是檔案路徑。設計這兩個示範的目的在於，為您提供足夠的細節訊息，以便理解問題，它們是實際應用程式的必要組成部份。第<span>1</span>個示範十分直觀。第<span>2</span>個示範採用了一些錯誤檢查功能，略為複雜。在第<span>1</span>個示範的後面，給出了用於編譯程式的命令行條目。在第<span>2</span>個示範的後面，給出了<span>GNUmake</span>檔案，該檔案可用於編譯。</p>
			<p><strong><span>示範：<span>1</span></span></strong><span>
			</span></p>
			<p><span>test1_libmysqld.c</span><span>
			</span></p>
			<pre><span>#include &lt;stdio.h&gt;</span></pre>
			<pre><span>#include &lt;stdlib.h&gt;</span></pre>
			<pre><span>#include &lt;stdarg.h&gt;</span></pre>
			<pre><span>#include &quot;mysql.h&quot;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *mysql;</span></pre>
			<pre><span>MYSQL_RES *results;</span></pre>
			<pre><span>MYSQL_ROW record;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static char *server_options[] = { &quot;mysql_test&quot;, &quot;--defaults-file=my.cnf&quot; };</span></pre>
			<pre><span>int num_elements = sizeof(server_options)/ sizeof(char *);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static char *server_groups[] = { &quot;libmysqld_server&quot;, &quot;libmysqld_client&quot; };</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>int main(void)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_server_init(num_elements, server_options, server_groups);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql = mysql_init(NULL);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_options(mysql, MYSQL_READ_DEFAULT_GROUP, &quot;libmysqld_client&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_options(mysql, MYSQL_OPT_USE_EMBEDDED_CONNECTION, NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_real_connect(mysql, NULL,NULL,NULL, &quot;database1&quot;, 0,NULL,0);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_query(mysql, &quot;SELECT column1, column2 FROM table1&quot;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; results = mysql_store_result(mysql);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; while((record = mysql_fetch_row(results))) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%s - %s \n&quot;, record[0], record[1]);</span></pre>
			<pre><span>&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_free_result(results);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_close(mysql);</span></pre>
			<pre><span>&nbsp;&nbsp; mysql_server_end();</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; return 0;</span></pre>
			<pre><span>}</span></pre>
			<p>下面給出了編譯上述程式的命令行命令：</p>
			<pre><span>gcc test1_libmysqld.c -o test1_libmysqld -lz \</span></pre>
			<pre><span> `/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`</span></pre>
			<p><strong><span>示範：<span>2</span></span></strong><span>
			</span></p>
			<p>要想檢驗該示範，建立一個與<span>MySQL</span>源目錄同級的<span>test2_libmysqld</span>目錄。將<span>test2_libmysqld.c</span>源檔案和<span><span>GNUmakefile</span>保存到該目錄，並在<span>test2_libmysqld</span>目錄下運行</span><span>GNU
			<span>make</span></span>。</p>
			<p><span>test2_libmysqld.c</span><span>
			</span></p>
			<pre><span>/*</span></pre>
			<pre><span> * A simple example client, using the embedded MySQL server library</span></pre>
			<pre><span>*/</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>#include &lt;mysql.h&gt;</span></pre>
			<pre><span>#include &lt;stdarg.h&gt;</span></pre>
			<pre><span>#include &lt;stdio.h&gt;</span></pre>
			<pre><span>#include &lt;stdlib.h&gt;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *db_connect(const char *dbname);</span></pre>
			<pre><span>void db_disconnect(MYSQL *db);</span></pre>
			<pre><span>void db_do_query(MYSQL *db, const char *query);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>const char *server_groups[] = {</span></pre>
			<pre><span>&nbsp; &quot;test2_libmysqld_SERVER&quot;, &quot;embedded&quot;, &quot;server&quot;, NULL</span></pre>
			<pre><span>};</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>int</span></pre>
			<pre><span>main(int argc, char **argv)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; MYSQL *one, *two;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; /* mysql_server_init() must be called before any other mysql</span></pre>
			<pre><span>&nbsp;&nbsp; * functions.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * You can use mysql_server_init(0, NULL, NULL), and it</span></pre>
			<pre><span>&nbsp;&nbsp; * initializes the server using groups = {</span></pre>
			<pre><span>&nbsp;&nbsp; *&nbsp;&nbsp; &quot;server&quot;, &quot;embedded&quot;, NULL</span></pre>
			<pre><span>&nbsp;&nbsp; *&nbsp; }.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * In your $HOME/.my.cnf file, you probably want to put:</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>[test2_libmysqld_SERVER]</span></pre>
			<pre><span>language = /path/to/source/of/mysql/sql/share/english</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp; * You could, of course, modify argc and argv before passing</span></pre>
			<pre><span>&nbsp;&nbsp; * them to this function.&nbsp; Or you could create new ones in any</span></pre>
			<pre><span>&nbsp;&nbsp; * way you like.&nbsp; But all of the arguments in argv (except for</span></pre>
			<pre><span>&nbsp;&nbsp; * argv[0], which is the program name) should be valid options</span></pre>
			<pre><span>&nbsp;&nbsp; * for the MySQL server.</span></pre>
			<pre><span>&nbsp;&nbsp; *</span></pre>
			<pre><span>&nbsp;&nbsp; * If you link this client against the normal mysqlclient</span></pre>
			<pre><span>&nbsp;&nbsp; * library, this function is just a stub that does nothing.</span></pre>
			<pre><span>&nbsp;&nbsp; */</span></pre>
			<pre><span>&nbsp; mysql_server_init(argc, argv, (char **)server_groups);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; one = db_connect(&quot;test&quot;);</span></pre>
			<pre><span>&nbsp; two = db_connect(NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; db_do_query(one, &quot;SHOW TABLE STATUS&quot;);</span></pre>
			<pre><span>&nbsp; db_do_query(two, &quot;SHOW DATABASES&quot;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; mysql_close(two);</span></pre>
			<pre><span>&nbsp; mysql_close(one);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; /* This must be called after all other mysql functions */</span></pre>
			<pre><span>&nbsp; mysql_server_end();</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; exit(EXIT_SUCCESS);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>static void</span></pre>
			<pre><span>die(MYSQL *db, char *fmt, ...)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; va_list ap;</span></pre>
			<pre><span>&nbsp; va_start(ap, fmt);</span></pre>
			<pre><span>&nbsp; vfprintf(stderr, fmt, ap);</span></pre>
			<pre><span>&nbsp; va_end(ap);</span></pre>
			<pre><span>&nbsp; (void)putc(&#39;\n&#39;, stderr);</span></pre>
			<pre><span>&nbsp; </span><span>if (db)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; db_disconnect(db);</span></pre>
			<pre><span>&nbsp; exit(EXIT_FAILURE);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>MYSQL *</span></pre>
			<pre><span>db_connect(const char *dbname)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; MYSQL *db = mysql_init(NULL);</span></pre>
			<pre><span>&nbsp; if (!db)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; die(db, &quot;mysql_init failed: no memory&quot;);</span></pre>
			<pre><span>&nbsp; /*</span></pre>
			<pre><span>&nbsp;&nbsp; * Notice that the client and server use separate group names.</span></pre>
			<pre><span>&nbsp;&nbsp; * This is critical, because the server does not accept the</span></pre>
			<pre><span>&nbsp;&nbsp; * client&#39;s options, and vice versa.</span></pre>
			<pre><span>&nbsp;&nbsp; */</span></pre>
			<pre><span>&nbsp; mysql_options(db, MYSQL_READ_DEFAULT_GROUP, &quot;test2_libmysqld_CLIENT&quot;);</span></pre>
			<pre><span>&nbsp; if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; die(db, &quot;mysql_real_connect failed: %s&quot;, mysql_error(db));</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; return db;</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>void</span></pre>
			<pre><span>db_disconnect(MYSQL *db)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; mysql_close(db);</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>void</span></pre>
			<pre><span>db_do_query(MYSQL *db, const char *query)</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; if (mysql_query(db, query) != 0)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; goto err;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; if (mysql_field_count(db) &gt; 0)</span></pre>
			<pre><span>&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; MYSQL_RES&nbsp;&nbsp; *res;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; MYSQL_ROW&nbsp;&nbsp;&nbsp; row, end_row;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; int num_fields;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; if (!(res = mysql_store_result(db)))</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto err;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(res);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; while ((row = mysql_fetch_row(res)))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)fputs(&quot;&gt;&gt; &quot;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (end_row = row + num_fields; row &lt; end_row; ++row)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void)printf(&quot;%s\t&quot;, row ? (char*)*row : &quot;NULL&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void)fputc(&#39;\n&#39;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; </span><span>(void)fputc(&#39;\n&#39;, stdout);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; </span><span>mysql_free_result(res);</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; else</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; (void)printf(&quot;Affected rows: %lld\n&quot;, mysql_affected_rows(db));</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp; return;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>err:</span></pre>
			<pre><span>&nbsp; die(db, &quot;db_do_query failed: %s [%s]&quot;, mysql_error(db), query);</span></pre>
			<pre><span>}</span></pre>
			<p><span>GNUmakefile</span><span>
			</span></p>
			<pre><span># This assumes the MySQL software is installed in /usr/local/mysql</span></pre>
			<pre><span>inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := /usr/local/mysql/include/mysql</span></pre>
			<pre><span>lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := /usr/local/mysql/lib</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span># If you have not installed the MySQL software yet, try this instead</span></pre>
			<pre><span>#inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(HOME)/mysql-5.1/include</span></pre>
			<pre><span>#lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(HOME)/mysql-5.1/libmysqld</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>CC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= gcc</span></pre>
			<pre><span>CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT</span></pre>
			<pre><span>CFLAGS&nbsp;&nbsp; := -g -W -Wall</span></pre>
			<pre><span>LDFLAGS&nbsp; := -static</span></pre>
			<pre><span># You can change -lmysqld to -lmysqlclient to use the</span></pre>
			<pre><span># client/server library</span></pre>
			<pre><span>LDLIBS&nbsp;&nbsp;&nbsp; = -L$(lib) -lmysqld -lz -lm -lcrypt</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&gt;/dev/null))</span></pre>
			<pre><span># FreeBSD</span></pre>
			<pre><span>LDFLAGS += -pthread</span></pre>
			<pre><span>else</span></pre>
			<pre><span># Assume Linux</span></pre>
			<pre><span>LDLIBS += -lpthread</span></pre>
			<pre><span>endif</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span># This works for simple one-file test programs</span></pre>
			<pre><span>sources := $(wildcard *.c)</span></pre>
			<pre><span>objects := $(patsubst %c,%o,$(sources))</span></pre>
			<pre><span>targets := $(basename $(sources))</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>all: $(targets)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>clean:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f $(targets) $(objects) *.core</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-licensing"></a>
			25.1.7.&nbsp;嵌入式伺服器的授權</h3></div></div></div>
			<p>我們鼓勵所有人在<span>GPL</span>或兼容授權的旗幟下通過發佈代碼來推廣免費軟件。對於有能力完成該類事項的人員，也可以選擇從<span>MySQL 
			AB</span>購買<span>MySQL</span>的商用授權。詳情請參見<span><a target="_top"  href="http://www.mysql.com/company/legal/licensing/">http://www.mysql.com/company/legal/licensing/</a></span>。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="c"></a>25.2. MySQL C API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#c-api-datatypes">
		25.2.1. C API數據類型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-function-overview">
		25.2.2. C API函數概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-functions">
		25.2.3. C API函數描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statements">
		25.2.4. C API預處理語句</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-datatypes">
		25.2.5. C API預處理語句的數據類型</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-function-overview">
		25.2.6. C API預處理語句函數概述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-functions">
		25.2.7. C API預處理語句函數描述</a></span></dt><dt><span class="section"><a href="apis.html#c-api-prepared-statement-problems">
		25.2.8. C API預處理語句方面的問題</a></span></dt><dt><span class="section"><a href="apis.html#c-api-multiple-queries">
		25.2.9. 多查詢執行的C API處理</a></span></dt><dt><span class="section"><a href="apis.html#c-api-date-handling">
		25.2.10. 日期和時間值的C API處理</a></span></dt><dt><span class="section"><a href="apis.html#c-thread-functions">
		25.2.11. C API線程函數介紹</a></span></dt><dt><span class="section"><a href="apis.html#c-embedded-server-func">
		25.2.12. C API嵌入式伺服器函數介紹</a></span></dt><dt><span class="section"><a href="apis.html#c-api-problems">
		25.2.13. 使用C API時的常見問題</a></span></dt><dt><span class="section"><a href="apis.html#building-clients">
		25.2.14. 建立客戶端程式</a></span></dt><dt><span class="section"><a href="apis.html#threaded-clients">
		25.2.15. 如何生成線程式客戶端</a></span></dt></dl></div><a class="indexterm" name="id3007623"></a><a class="indexterm" name="id3007633"></a>
		<p><span>C API</span>代碼是與<span>MySQL</span>一起提供的。它包含在<span><span>mysqlclient</span>庫中，並允許<span>C</span>程式訪問資料庫。</span></p>
		<p><span>MySQL</span>原始碼分發版的很多客戶端是用<span>C</span>語言編寫的。如果您正在尋找能演示如何使用<span>C 
		API</span>的示範，可參看這些客戶端程式。您可以在<span>MySQL</span>原始碼分發版的客戶端目錄下找到它們。</p>
		<p>大多數其他客戶端<span>API</span>（除了<span>Connector/J</span>和<span>Connector/NET</span>）採用<span>mysqlclient</span>庫來與<span>MySQL</span>伺服器進行通信。這意味著（例如），您可以利用很多相同環境變數（與其他客戶端程式使用的環境變數相同）帶來的好處，這是因為它們是從庫中引用的。關於這些變數的詳細清單，請參見<a href="client-side-scripts.html">第8章：</a><a href="client-side-scripts.html" title="Chapter 8. Client and Utility Programs"><i>客戶端和實用工具程式</i></a>。</p>
		<p>客戶端具有最大的通信緩衝區大小。初始分配的緩衝區大小（<span>16KB</span>）將自動增加到最大（最大為<span>16MB</span>）。由於緩衝區大小將按需增加，簡單地增加預設的最大限制，從其本身來說不會增加資源使用。該大小檢查主要是檢查錯誤查詢和通信訊息包。</p>
		<p>通信緩衝區必須足夠大，足以包含<span>1</span>條<span>SQL</span>語句（用於客戶端<span>-</span>伺服器通信）以及<span>1</span>行返回的數據（用於伺服器<span>-</span>客戶端通信）。每個線程的通信緩衝區將動態增加，以處理直至最大限制的任何查詢或行。例如，如果<span>BLOB</span>值包含高達<span>16MB</span>的數據，那麼通信緩衝區的大小限制至少為<span>16MB</span>（在伺服器和客戶端）。客戶端的預設最大值為<span>16MB</span>，但伺服器的預設最大值為<span>1MB</span>。也可以在啟動伺服器時，通過更改<span><span>max_allowed_packet</span>參數的值增加它。</span>請參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
		<p>每次查詢後，<span>MySQL</span>伺服器會將通信緩衝區的大小降至<span><span>net_buffer_length</span>字節。對於客戶端，不會降低與連接相關緩衝區大小，直至連接關閉為止，此時</span>，客戶端內存將被收回。</p>
		<p>關於使用線程的編程方法，請參見<a href="apis.html#threaded-clients" title="25.2.15. How to Make a Threaded Client">25.2.15節，「如何生成線程式客戶端」</a>。關於在相同程式建立包含「伺服器」和「客戶端」的獨立應用程式的更多訊息（不與外部<span>MySQL</span>伺服器通信），請參見<a href="apis.html#libmysqld" title="25.1. libmysqld, the Embedded MySQL Server Library">25.1節，「libmysqld，嵌入式MySQL伺服器庫」</a>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-datatypes"></a>
			25.2.1.&nbsp;C API數據類型</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a class="indexterm" name="id3007765"></a>

            MYSQL
          </p><p>
            <span>該結構代資料表<span>1</span>個資料庫連接的句柄。幾乎所有的<span>MySQL</span>函數均使用它。不應嘗試拷貝<span><span>MYSQL</span>結構。不保證這類拷貝結果會有用。</span></span>
          </p></li><li><p>
            <a class="indexterm" name="id3007796"></a>

            MYSQL_RES
          </p><p>
            <span>
			該結構代資料表返回行的查詢結果（<span>SELECT</span><span>,
			<span>SHOW</span>,
			<span>DESCRIBE</span>,
			<span>EXPLAIN</span></span>）。在本節的剩餘部分，將查詢返回的訊息稱為「結果集」。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007840"></a>

            MYSQL_ROW
          </p><p>
            <span>這是<span>1</span>行數據的「類型安全」資料表示。它目前是按照計數字節字串的數組實施的。（如果字段值可能包含二進制數據，不能將其當作<span>由Null</span>終結的字串對待，這是因為這類值可能會包含<span>Null</span>字節）。行是通過使用<span>mysql_fetch_row()</span>獲得的。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007873"></a>

            MYSQL_FIELD
          </p><p>
            <span>
			該結構包含關於字段的訊息，如字段名、類型和大小。這裡詳細介紹了其成員。通過重複使用<span><span>mysql_fetch_field()</span>，可為每個字段獲得<span>MYSQL_FIELD</span>結構。字段值不是該結構的組成部份，它們包含在<span>MYSQL_ROW</span></span>結構中。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007912"></a>

            MYSQL_FIELD_OFFSET
          </p><p>
            <span>這是<span>MySQL</span>字段列資料表偏移量的「類型安全」資料表示（由<span><span>mysql_field_seek()</span>使用</span>）。偏移量是行內的字段編號，從<span>0</span>開始。</span>
          </p></li><li><p>
            <a class="indexterm" name="id3007942"></a>

            <a class="indexterm" name="id3007951"></a>

            my_ulonglong
          </p><p>
            <span>
			用於行數以及<span>mysql_affected_rows()</span>、<span>mysql_num_rows()</span>和<span><span>mysql_insert_id()</span>的類型。該類型提供的範圍為<span>0</span></span>～<span>1.84e19</span>。</span>
          </p><p>
            <span>
			在某些系統上，不能打印類型<span>my_ulonglong</span>的值。要想打印這類值，請將其轉換為無符號長整數類型並使用<span><span>%lu</span>打印格式，例如：</span></span></p><pre class="programlisting">printf ("Number of rows: %lu\n", (unsigned long) mysql_num_rows(result));
</pre></li></ul></div>
			<p>下面列出了<span><span>MYSQL_FIELD</span>結構包含的成員：</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			name</span><span> </span></p>
			<p>字段名稱，由<span>Null</span>終結的字串。如果用<span>AS</span>子句為該字段指定了別名，名稱的值也是別名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			org_name</span><span> </span></p>
			<p>段名稱，由<span>Null</span>終結的字串。忽略別名。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			table</span><span> </span></p>
			<p>
			包含該字段的資料表的名稱，如果該字段不是計算出的字段的話。對於計算出的字段，資料表值為空的字串。如果用<span>AS</span>子句為該資料表指定了別名，資料表的值也是別名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			org_table</span><span> </span></p>
			<p>資料表的名稱，由<span>Null</span>終結的字串。忽略別名。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			db</span><span> </span></p>
			<p>字段源自的數據的名稱，由<span>Null</span>終結的字串。如果該字段是計算出的字段，<span><span>db</span>為空的字串。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			catalog</span><span> </span></p>
			<p><span>catalog</span>名稱。該值總是<span>&quot;def&quot;</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>char * 
			def</span><span> </span></p>
			<p>該字段的預設值，由<span>Null</span>終結的字串。僅當使用<span><span>mysql_list_fields()</span>時才設置它。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			long length</span><span> </span></p>
			<p>字段的寬度，如資料表定義中所指定的那樣。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			long max_length</span><span> </span></p>
			<p>
			用於結果集的字段的最大寬度（對於實際位於結果集中的行，最長字段值的長度）。如果使用<span>mysql_store_result()</span>或<span>mysql_list_fields()</span>，它將包含字段的最大長度。如果使用<span><span>mysql_use_result()</span>，該變數的值為<span>0</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int name_length</span><span> </span></p>
			<p>名稱的長度。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int org_name_length</span><span> </span></p>
			<p>
			<span>org_name</span>的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int table_length</span><span> </span></p>
			<p>資料表的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int org_table_length</span><span> </span></p>
			<p>
			<span>org_table</span>的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int db_length</span><span> </span></p>
			<p>
			<span>db</span>的長度。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int catalog_length</span><span> </span></p>
			<p>
			<span>catalog</span>的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int def_length</span><span> </span></p>
			<p>
			<span>def</span>的長度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int flags</span><span> </span></p>
			<p>用於字段的不同「位標誌」。標誌的值可以有<span>0</span>個或多個下述位集合：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>
					標誌值</span></strong></td>
					<td>
					<p><strong><span>
					標誌描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>NOT_NULL_FLAG</span></td>
					<td>
					<p>字段不能為<span>NULL</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>PRI_KEY_FLAG</span></td>
					<td>
					<p>字段是主鍵的組成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>UNIQUE_KEY_FLAG</span></td>
					<td>
					<p>字段是唯一鍵的組成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MULTIPLE_KEY_FLAG</span></td>
					<td>
					<p>字段是非唯一鍵的組成部分</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>UNSIGNED_FLAG</span></td>
					<td>
					<p>字段具有<span>UNSIGNED</span>屬性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ZEROFILL_FLAG</span></td>
					<td>
					<p>字段具有<span>ZEROFILL</span>屬性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BINARY_FLAG</span></td>
					<td>
					<p>字段具有<span>BINARY</span>屬性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>AUTO_INCREMENT_FLAG</span></td>
					<td>
					<p>字段具有<span>AUTO_INCREMENT</span>屬性</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ENUM_FLAG</span></td>
					<td>
					<p>字段是<span>ENUM</span>（不再重視）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>SET_FLAG</span></td>
					<td>
					<p>字段是 
					<span>SET</span>（不再重視）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BLOB_FLAG</span></td>
					<td>
					<p>字段是<span>BLOB</span>或<span>TEXT</span>（不再重視）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>TIMESTAMP_FLAG</span></td>
					<td>
					<p>字段是<span>TIMESTAMP</span>（不再重視）</td>
				</tr>
			</table>
			<p>不再重視<span><span>BLOB_FLAG</span>、<span>ENUM_FLAG</span></span>、<span>SET_FLAG</span>和<span>TIMESTAMP_FLAG</span>標誌，原因在於，它們指出了字段的類型，而不是類型的屬性。更可取的方式是使用<span>MYSQL_TYPE_BLOB</span>、<span>MYSQL_TYPE_ENUM</span>、<span>MYSQL_TYPE_SET</span>或<span>MYSQL_TYPE_TIMESTAMP</span>測試<span><span>field-&gt;type</span>。</span></p>
			<p>在下面的示範中，介紹了標誌值的典型用法：</p>
			<pre><span>if (field-&gt;flags &amp; NOT_NULL_FLAG)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field can&#39;t be null\n&quot;);</span></pre>
			<p>可以使用下述方面的宏來定義標誌值的布爾狀態：</p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p><strong><span>
					標誌狀態</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_NOT_NULL(flags)</span></td>
					<td>
					<p>如果該字段定義為<span><span>NOT 
					NULL</span>，為<span>「</span>真<span>」</span>。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_PRI_KEY(flags)</span></td>
					<td>
					<p>如果該字段是主鍵<span>，為<span>「</span>真<span>」</span>。</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>IS_BLOB(flags)</span></td>
					<td>
					<p>如果該字段是<span>BLOB</span>或<span>TEXT</span><span>，為<span>「</span>真<span>」</span>（不再重視</span>，用測試<span>field-&gt;type</span>取而代之）。</td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int decimals</span><span> </span></p>
			<p>用於數值字段的十進制數數目。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>unsigned 
			int charset_nr</span><span> </span></p>
			<p>用於字段的字元編碼編號。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>enum 
			enum_field_types type</span><span> </span></p>
			<p>字段的類型。類型值可以是下標所列的<span>MYSQL_TYPE_</span>符號之一：</p>
			<table border="1" cellpadding="0" id="table4">
				<tr>
					<td>
					<p><strong><span>
					類型值</span></strong></td>
					<td>
					<p><strong><span>
					類型描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY</span></td>
					<td>
					<p>
					<span>TINYINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SHORT</span></td>
					<td>
					<p>
					<span>SMALLINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG</span></td>
					<td>
					<p>
					<span>INTEGER</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_INT24</span></td>
					<td>
					<p>
					<span>MEDIUMINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONGLONG</span></td>
					<td>
					<p>
					<span>BIGINT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DECIMAL</span></td>
					<td>
					<p>
					<span>DECIMAL</span>或<span>NUMERIC</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_NEWDECIMAL</span></td>
					<td>
					<p>精度數學<span>DECIMAL</span>或<span>NUMERIC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_FLOAT</span></td>
					<td>
					<p>
					<span>FLOAT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DOUBLE</span></td>
					<td>
					<p>
					<span>DOUBLE</span>或<span>REAL</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BIT</span></td>
					<td>
					<p>
					<span>BIT</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIMESTAMP</span></td>
					<td>
					<p>
					<span>TIMESTAMP</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATE</span></td>
					<td>
					<p>
					<span>DATE</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIME</span></td>
					<td>
					<p>
					<span>TIME</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATETIME</span></td>
					<td>
					<p>
					<span>DATETIME</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_YEAR</span></td>
					<td>
					<p>
					<span>YEAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_STRING</span></td>
					<td>
					<p>
					<span>CHAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_VAR_STRING</span></td>
					<td>
					<p>
					<span>VARCHAR</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BLOB</span></td>
					<td>
					<p>
					<span>BLOB</span>或<span>TEXT</span>字段（使用<span><span>max_length</span>來確定最大長度）</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SET</span></td>
					<td>
					<p>
					<span>SET</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_ENUM</span></td>
					<td>
					<p>
					<span>ENUM</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_GEOMETRY</span></td>
					<td>
					<p><span>Spatial</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_NULL</span></td>
					<td>
					<p>
					<span>NULL</span><span>-type</span>字段</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_CHAR</span></td>
					<td>
					<p>不再重視，用<span>MYSQL_TYPE_TINY</span>取代</td>
				</tr>
			</table>
			<p>可以使用<span>IS_NUM()</span>宏來測試字段是否具有數值類型。將類型值傳遞給<span><span>IS_NUM()</span>，</span>如果字段為數值類型，會將其評估為「真」：</p>
			<pre><span>if (IS_NUM(field-&gt;type))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field is numeric\n&quot;);</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-function-overview"></a>
			25.2.2.&nbsp;C API函數概述</h3></div></div></div><a class="indexterm" name="id3009178"></a><a class="indexterm" name="id3009188"></a>
			<p>這裡歸納了<span>C API</span>可使用的函數，並在下一節詳細介紹了它們。請參見<a href="apis.html#c-api-functions" title="25.2.3. C API Function Descriptions">25.2.3節，「C API函數描述」</a>。</p>
			<table border="1" cellpadding="0" id="table5">
				<tr>
					<td>
					<p><strong><span>
					函數</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_affected_rows()</span></strong></td>
					<td>
					<p>返回上次<span>UPDATE</span>、<span>DELETE</span>或<span><span>INSERT</span>查詢更改／刪除／插入的行數。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_autocommit()</span></strong></td>
					<td>
					<p>切換<span> autocommit</span>模式，<span>ON/OFF</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_change_user()</span></strong></td>
					<td>
					<p>更改打開連接上的用戶和資料庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_charset_name()</span></strong></td>
					<td>
					<p>返回用於連接的預設字元編碼的名稱。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_close()</span></strong></td>
					<td>
					<p>關閉伺服器連接。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_commit()</span></strong></td>
					<td>
					<p>提交事務。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_connect()</span></strong></td>
					<td>
					<p>連接到<span>MySQL</span>伺服器。該函數已不再被重視，使用<span>mysql_real_connect()</span>取代。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_create_db()</span></strong></td>
					<td>
					<p>建立資料庫。該函數已不再被重視，使用<span>SQL</span>語句<span>CREATE 
					DATABASE</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_data_seek()</span></strong></td>
					<td>
					<p>在查詢結果集中搜尋屬性行編號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_debug()</span></strong></td>
					<td>
					<p>用給定的字串執行<span>DBUG_PUSH</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_drop_db()</span></strong></td>
					<td>
					<p>撤銷資料庫。該函數已不再被重視，使用<span>SQL</span>語句<span>DROP 
					DATABASE</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_dump_debug_info()</span></strong></td>
					<td>
					<p>讓伺服器將調試訊息寫入日誌。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_eof()</span></strong></td>
					<td>
					<p>確定是否讀取了結果集的最後一行。該函數已不再被重視，可以使用<span>mysql_errno()</span>或<span>mysql_error()</span>取而代之。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_errno()</span></strong></td>
					<td>
					<p>返回上次使用的<span>MySQL</span>函數的錯誤編號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_error()</span></strong></td>
					<td>
					<p>返回上次使用的<span>MySQL</span>函數的錯誤消息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_escape_string()</span></strong></td>
					<td>
					<p>為了用在<span>SQL</span>語句中，對特殊字元進行轉義處理。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_fetch_field()</span></strong></td>
					<td>
					<p>返回下一個資料表字段的類型。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_field_direct()</span></strong></td>
					<td>
					<p>給定字段編號，返回資料表字段的類型。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_fields()</span></strong></td>
					<td>
					<p>返回所有字段結構的數組。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_fetch_lengths()</span></strong></td>
					<td>
					<p>返回當前行中所有列的長度。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_fetch_row()</span></strong></td>
					<td>
					<p>從結果集中獲取下一行</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_seek()</span></strong></td>
					<td>
					<p>將列光標置於指定的列。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_count()</span></strong></td>
					<td>
					<p>返回上次執行語句的結果列的數目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_field_tell()</span></strong></td>
					<td>
					<p>返回上次<span><span>mysql_fetch_field()</span>所使用字段光標的位置。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_free_result()</span></strong></td>
					<td>
					<p>釋放結果集使用的內存。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_client_info()</span></strong></td>
					<td>
					<p>以字串形式返回客戶端版本訊息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_client_version()</span></strong></td>
					<td>
					<p>以整數形式返回客戶端版本訊息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_host_info()</span></strong></td>
					<td>
					<p>返回描述連接的字串。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_server_version()</span></strong></td>
					<td>
					<p>以整數形式返回伺服器的版本號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_proto_info()</span></strong></td>
					<td>
					<p>返回連接所使用的協議版本。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_get_server_info()</span></strong></td>
					<td>
					<p>返回伺服器的版本號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_info()</span></strong></td>
					<td>
					<p>返回關於最近所執行查詢的訊息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_init()</span></strong></td>
					<td>
					<p>獲取或初始化<span>MYSQL</span>結構。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_insert_id()</span></strong></td>
					<td>
					<p>返回上一個查詢為<span><span>AUTO_INCREMENT</span>列生成的</span><span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_kill()</span></strong></td>
					<td>
					<p>殺死給定的線程。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_library_end()</span></strong></td>
					<td>
					<p>最終確定<span>MySQL C API</span>庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_library_init()</span></strong></td>
					<td>
					<p>初始化<span>MySQL C API</span>庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_dbs()</span></strong></td>
					<td>
					<p>返回與簡單正則資料表達式匹配的資料庫名稱。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_fields()</span></strong></td>
					<td>
					<p>返回與簡單正則資料表達式匹配的字段名稱。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_list_processes()</span></strong></td>
					<td>
					<p>返回當前伺服器線程的列資料表。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_list_tables()</span></strong></td>
					<td>
					<p>返回與簡單正則資料表達式匹配的資料表名。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_more_results()</span></strong></td>
					<td>
					<p>檢查是否還存在其他結果。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_next_result()</span></strong></td>
					<td>
					<p>在多語句執行過程中返回<span>/</span>初始化下一個結果。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_num_fields()</span></strong></td>
					<td>
					<p>返回結果集中的列數。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_num_rows()</span></strong></td>
					<td>
					<p>返回結果集中的行數。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_options()</span></strong></td>
					<td>
					<p>為<span><span>mysql_connect()</span>設置連接選項。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_ping()</span></strong></td>
					<td>
					<p>檢查與伺服器的連接是否工作，如有必要重新連接。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_query()</span></strong></td>
					<td>
					<p>執行指定為「以<span>Null</span>終結的字串」的<span>SQL</span>查詢。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_real_connect()</span></strong></td>
					<td>
					<p>連接到<span>MySQL</span>伺服器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_real_escape_string()</span></strong></td>
					<td>
					<p>考慮到連接的當前字元編碼，為了在<span>SQL</span>語句中使用，對字串中的特殊字元進行轉義處理。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_real_query()</span></strong></td>
					<td>
					<p>執行指定為計數字串的<span>SQL</span>查詢。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_refresh()</span></strong></td>
					<td>
					<p>刷新或復位資料表和高速緩衝。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_reload()</span></strong></td>
					<td>
					<p>通知伺服器再次加載授權資料表。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_rollback()</span></strong></td>
					<td>
					<p>回滾事務。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_row_seek()</span></strong></td>
					<td>
					<p>使用從<span><span>mysql_row_tell()</span>返回的值，搜尋結果集中的行偏移。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_row_tell()</span></strong></td>
					<td>
					<p>返回行光標位置。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_select_db()</span></strong></td>
					<td>
					<p>選擇資料庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_server_end()</span></strong></td>
					<td>
					<p>最終確定嵌入式伺服器庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_server_init()</span></strong></td>
					<td>
					<p>初始化嵌入式伺服器庫。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_set_server_option()</span></strong></td>
					<td>
					<p>為連接設置選項（如多語句）。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_sqlstate()</span></strong></td>
					<td>
					<p>返回關於上一個錯誤的<span>SQLSTATE</span>錯誤代碼。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_shutdown()</span></strong></td>
					<td>
					<p>關閉資料庫伺服器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stat()</span></strong></td>
					<td>
					<p>以字串形式返回伺服器狀態。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_store_result()</span></strong></td>
					<td>
					<p>檢索完整的結果集至客戶端。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_thread_id()</span></strong></td>
					<td>
					<p>返回當前線程<span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_thread_safe()</span></strong></td>
					<td>
					<p>如果客戶端已編譯為線程安全的，返回<span>1</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_use_result()</span></strong></td>
					<td>
					<p>初始化逐行的結果集檢索。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_warning_count()</span></strong></td>
					<td>
					<p>返回上一個<span>SQL</span>語句的告警數。</td>
				</tr>
			</table>
			<p>與<span>MySQL</span>交互時，應用程式應使用該一般性原則：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過使用<span><span>mysql_library_init()</span>，初始化</span><span>MySQL</span>庫。庫可以是<span>mysqlclient</span><span> 
			C</span>客戶端庫，或<span>mysqld</span>嵌入式伺服器庫，具體情況取決於應用程式是否與「<span>-libmysqlclient」</span>或「<span><span>-libmysqld」</span>標誌連結。</span></p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過使用<span><span>mysql_init()</span>初始化連接處理程式，並通過使用<span>mysql_real_connect()</span>連接到伺服器。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>發出<span>SQL</span>語句並處理其結果。（在下面的討論中，詳細介紹了使用它的方法）。</p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過使用<span><span>mysql_close()</span>，關閉</span>與<span>MySQL</span>伺服器的連接。</p>
			<p>
			<span>5.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過使用<span><span>mysql_library_end()</span>，結束</span><span>MySQL</span>庫的使用。</p>
			<p>使用<span>mysql_library_init()</span>和<span><span>mysql_library_end()</span>的目的在於，為</span><span>MySQL</span>庫提供恰當的初始化和結束處理。對於與客戶端庫連結的應用程式，它們提供了改進的內存管理功能。如果不使用<span><span>mysql_library_end()</span>，內存塊仍將保持分配狀態（這不會增加應用程式使用的內存量，但某些內存洩漏檢測器將抗議它）</span>。對於與嵌入式伺服器連結的應用程式，這些使用會啟動並停止伺服器。</p>
			<p><span>mysql_library_init()</span>和<span>mysql_library_end()</span>實際上是<span>#define</span>符號，這類符號使得它們等效於<span>mysql_server_init()</span>和<span>mysql_server_end()</span>，但其名稱更清楚地指明，無論應用程式使用的是<span>mysqlclient</span>或<span><span>mysqld</span>庫，啟動或結束<span>MySQL</span>庫時，應使用它們。</span>對於早期的<span>MySQL</span>版本，可使用<span>mysql_server_init()</span>和<span>mysql_server_end()</span>取而代之。</p>
			<p>如果願意，可省略對<span><span>mysql_library_init()</span>的使用，這是因為，必要時，<span>mysql_init()</span>會自動使用它。</span></p>
			<p>要想連接到伺服器，可使用<span>mysql_init()</span>來初始化連接處理程式，然後用該處理程式（以及其他訊息，如主機名、帳號和密碼）使用<span>mysql_real_connect()</span>。建立連接後，在低於<span>5.0.3</span>版的<span>API</span>中，<span>mysql_real_connect()</span>會將再連接標誌（<span><span>MYSQL</span>結構的一部分</span>）設置為<span>1</span>，或在較新的版本中，將其設置為<span>0</span>。對於該標誌，值「<span>1</span>」指明，如果因連接丟失而無法執行語句，放棄之前，會嘗試再次連接到伺服器。從<span>MySQL 
			5.0.13</span>開始，可以在<span><span>mysql_options()</span>上使用<span>MYSQL_OPT_RECONNECT</span>選項，以控制再連接行為。完成連接後，使用<span>mysql_close()</span>中止它。</span></p>
			<p>當連接處於活動狀態時，客戶端或許會使用<span>mysql_query()</span>或<span><span>mysql_real_query()</span>向伺服器發出<span>SQL</span>查詢。兩者的差別在於，<span>mysql_query()</span></span>預期的查詢為指定的、由<span>Null</span>終結的字串，而<span><span>mysql_real_query()</span>預期的是計數字串。如果字串包含二進制數據（其中可能包含<span>Null</span>字節），就必須使用<span>mysql_real_query()</span></span>。</p>
			<p>對於每個非<span>SELECT</span>查詢（例如<span>INSERT</span>、<span>UPDATE</span>、<span>DELETE</span>），通過使用<span><span>mysql_affected_rows()</span>，可發現有多少行已被改變</span>（影響）。</p>
			<p>對於<span><span>SELECT</span>查詢，</span>能夠檢索作為結果集的行。注意，某些語句因其返回行，類似與<span><span>SELECT</span>。</span>包括<span>SHOW</span>、<span>DESCRIBE</span>和<span><span>EXPLAIN</span>。應按照對待<span>SELECT</span>語句的方式處理它們。</span></p>
			<p>客戶端處理結果集的方式有兩種。一種方式是，通過使用<span><span>mysql_store_result()</span>，一次性地檢索整個結果集。該函數</span>能從伺服器獲得查詢返回的所有行，並將它們保存在客戶端。第二種方式是針對客戶端的，通過使用<span><span>mysql_use_result()</span>，對<span>「</span>按行<span>」</span>結果集檢索進行初始化處理。該函數能初始化檢索結果，但不能從伺服器獲得任何實際行。</span></p>
			<p>在這兩種情況下，均能通過使用<span><span>mysql_fetch_row()</span>訪問行。通過<span>mysql_store_result()</span>，<span>mysql_fetch_row()</span></span>能夠訪問以前從伺服器獲得的行。通過<span>mysql_use_result()</span>，<span><span>mysql_fetch_row()</span>能夠實際地檢索來自伺服器的行。通過使用<span>mysql_fetch_lengths()</span>，能獲得關於各行中數據大小的訊息。</span></p>
			<p>完成結果集操作後，請使用<span>mysql_free_result()</span>釋放結果集使用的內存。</p>
			<p>這兩種檢索機制是互補的。客戶端程式應選擇最能滿足其要求的方法。實際上，客戶端最常使用的是<span><span>mysql_store_result()</span>。</span></p>
			<p><span><span>mysql_store_result()</span>的<span>1</span>個優點在於，</span>由於將行全部提取到了客戶端上，您不僅能連續訪問行，還能使用<span>mysql_data_seek()</span>或<span><span>mysql_row_seek()</span>在結果集中向前或向後移動，以更改結果集內當前行的位置。通過使用<span>mysql_num_rows()</span>，還能發現有多少行。另一方面，對於大的結果集，<span>mysql_store_result()</span>所需的內存可能會很大，您很可能遇到內存溢出狀況。</span></p>
			<p><span><span>mysql_use_result()</span>的<span>1</span>個優點在於，客戶端所需的用於</span>結果集的內存較少，原因在於，一次它僅維護一行（由於分配開銷較低，<span><span>mysql_use_result()</span>能更快</span>）。它的缺點在於，您必須快速處理每一行以避免妨礙伺服器，您不能隨機訪問結果集中的行（只能連續訪問行），您不知道結果集中有多少行，直至全部檢索了它們為止。不僅如此，即使在檢索過程中您判定已找到所尋找的訊息，也必須檢索所有的行。</p>
			<p>通過<span>API</span>，客戶端能夠恰當地對查詢作出響應（僅在必要時檢索行），而無需知道查詢是否是<span><span>SELECT</span>查詢。可以在每次<span>mysql_query()</span></span>或<span>mysql_real_query()</span>後，通過使用<span><span>mysql_store_result()</span>完成該操作。如果結果集使用成功，</span>查詢為<span><span>SELECT</span>，而且能夠讀取行。</span>如果結果集使用失敗，可使用<span>mysql_field_count()</span>來判斷結果是否的確是所預期的。如果<span><span>mysql_field_count()</span>返回<span>0</span>，</span>查詢不返回數據（表明它是<span>INSERT</span>、<span>UPDATE</span>、<span><span>DELETE</span>等），</span>而且不返回行。如果<span><span>mysql_field_count()</span>是非<span>0</span>值，</span>查詢應返回行，但沒有返回行。這表明查詢是失敗了的<span>SELECT</span>。關於如何實現該操作的示範，請參見關於<span><span>mysql_field_count()</span>的介紹。</span></p>
			<p>無論是<span><span>mysql_store_result()</span>還是<span>mysql_use_result()</span>，均允許您獲取關於構成結果集的字段的訊息</span>（字段數目，它們的名稱和類型等）。通過重複使用<span><span>mysql_fetch_field()</span>，可以按順序訪問行內的字段訊息，或者，通過使用<span>mysql_fetch_field_direct()</span>，能夠在行內按字段編號訪問字段訊息。通過使用<span>mysql_field_seek()</span>，可以改變當前字段的光標位置。對字段光標的設置將影響後續的<span>mysql_fetch_field()</span>使用。此外，您也能通過使用<span>mysql_fetch_fields()</span>，一次性地獲得關於字段的所有訊息。</span></p>
			<p>為了檢測和通報錯誤，<span>MySQL</span>提供了使用<span>mysql_errno()</span>和<span>mysql_error()</span>函數訪問錯誤訊息的機制。它們能返回關於最近使用的函數的錯誤代碼或錯誤消息，最近使用的函數可能成功也可能失敗，這樣，您就能判斷錯誤是在何時出現的，以及錯誤是什麼。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-functions"></a>
			25.2.3.&nbsp;C API函數描述</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-affected-rows">25.2.3.1. mysql_affected_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-autocommit">25.2.3.2. mysql_autocommit()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-change-user">25.2.3.3. mysql_change_user()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-character-set-name">25.2.3.4. mysql_character_set_name()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-close">25.2.3.5. mysql_close()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-commit">25.2.3.6. mysql_commit()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-connect">25.2.3.7. mysql_connect()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-create-db">25.2.3.8. mysql_create_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-data-seek">25.2.3.9. mysql_data_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-debug">25.2.3.10. mysql_debug()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-drop-db">25.2.3.11. mysql_drop_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-dump-debug-info">25.2.3.12. mysql_dump_debug_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-eof">25.2.3.13. mysql_eof()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-errno">25.2.3.14. mysql_errno()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-error">25.2.3.15. mysql_error()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-escape-string">25.2.3.16. mysql_escape_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-field">25.2.3.17. mysql_fetch_field()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-field-direct">25.2.3.18. mysql_fetch_field_direct()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-fields">25.2.3.19. mysql_fetch_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-lengths">25.2.3.20. mysql_fetch_lengths()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-fetch-row">25.2.3.21. mysql_fetch_row()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-count">25.2.3.22. mysql_field_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-seek">25.2.3.23. mysql_field_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-field-tell">25.2.3.24. mysql_field_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-free-result">25.2.3.25. mysql_free_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-character-set-info">25.2.3.26. mysql_get_character_set_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-client-info">25.2.3.27. mysql_get_client_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-client-version">25.2.3.28. mysql_get_client_version()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-host-info">25.2.3.29. mysql_get_host_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-proto-info">25.2.3.30. mysql_get_proto_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-server-info">25.2.3.31. mysql_get_server_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-get-server-version">25.2.3.32. mysql_get_server_version()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-hex-string">25.2.3.33. mysql_hex_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-info">25.2.3.34. mysql_info()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-init">25.2.3.35. mysql_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-insert-id">25.2.3.36. mysql_insert_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-kill">25.2.3.37. mysql_kill()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-library-end">25.2.3.38. mysql_library_end()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-library-init">25.2.3.39. mysql_library_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-dbs">25.2.3.40. mysql_list_dbs()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-fields">25.2.3.41. mysql_list_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-processes">25.2.3.42. mysql_list_processes()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-list-tables">25.2.3.43. mysql_list_tables()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-more-results">25.2.3.44. mysql_more_results()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-next-result">25.2.3.45. mysql_next_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-num-fields">25.2.3.46. mysql_num_fields()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-num-rows">25.2.3.47. mysql_num_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-options">25.2.3.48. mysql_options()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-ping">25.2.3.49. mysql_ping()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-query">25.2.3.50. mysql_query()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-connect">25.2.3.51. mysql_real_connect()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-escape-string">25.2.3.52. mysql_real_escape_string()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-real-query">25.2.3.53. mysql_real_query()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-refresh">25.2.3.54. mysql_refresh()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-reload">25.2.3.55. mysql_reload()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-rollback">25.2.3.56. mysql_rollback()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-row-seek">25.2.3.57. mysql_row_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-row-tell">25.2.3.58. mysql_row_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-select-db">25.2.3.59. mysql_select_db()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-set-character-set">25.2.3.60. mysql_set_character_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-set-server-option">25.2.3.61. mysql_set_server_option()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-shutdown">25.2.3.62. mysql_shutdown()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-sqlstate">25.2.3.63. mysql_sqlstate()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-ssl-set">25.2.3.64. mysql_ssl_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stat">25.2.3.65. mysql_stat()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-store-result">25.2.3.66. mysql_store_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-id">25.2.3.67. mysql_thread_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-use-result">25.2.3.68. mysql_use_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-warning-count">25.2.3.69. mysql_warning_count()</a></span></dt></dl></div>
			<p>在本節所作的介紹中，按照<span>C</span>編程語言，<span>為NULL</span>的參數或返回值資料表示<span>NULL</span>，而不是<span>MySQL 
			Null</span>值。</p>
			<p>返回值的函數通常會返回指針或整數。除非作了其他規定，返回指針的函數將返回非<span>Null</span>值，以指明成功，或返回<span>NULL</span>值以指明出錯。返回整數的函數將返回<span>0</span>以指明成功，或返回非<span>0</span>值以指明出錯。注意，非<span>0</span>值僅表明這點。除非在函數描述中作了其他說明，不要對非<span>0</span>值進行測試：</p>
			<pre><span>if (result)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* correct */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>if (result &lt; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* incorrect */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>if (result == -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* incorrect */</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ... error ...</span></pre>
			<p>當函數返回錯誤時，在函數描述的「錯誤」部分將列出可能的錯誤類型。通過使用<span><span>mysql_errno()</span>可發現出現的錯誤是什麼。通過使用<span>mysql_error()</span>，可獲得錯誤的字串資料表示。</span></p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-affected-rows"></a>25.2.3.1. mysql_affected_rows()</h4></div></div></div><a class="indexterm" name="id3010933"></a>
				<p><span>my_ulonglong 
				mysql_affected_rows(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上次<span>UPDATE</span>更改的行數，上次<span><span>DELETE</span>刪除的行數，或</span>上次<span><span>INSERT</span>語句插入的行數。對於<span>UPDATE</span>、<span>DELETE</span></span>或<span><span>INSERT</span>語句，可在<span>mysql_query()</span>後立刻使用。</span>對於<span>SELECT</span>語句，<span>mysql_affected_rows()</span>的工作方式與<span>mysql_num_rows()</span>類似。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>大於<span>0</span>的整數表明受影響或檢索的行數。「<span>0</span>」資料表示<span><span>UPDATE</span>語句未更新</span>記錄，在查詢中沒有與<span><span>WHERE</span>匹配的行</span>，或未執行查詢。「<span>-1</span>」資料表示查詢返回錯誤，或者，對於<span>SELECT</span>查詢，在使用<span><span>mysql_store_result()</span>之前使用了<span>mysql_affected_rows()</span></span>。由於<span><span>mysql_affected_rows()</span>返回無符號值，通過比較返回值和<span>「(my_ulonglong)-1」</span>或等效的<span>「(my_ulonglong</span><span  >)~</span><span>0」</span></span>，檢查是否為「<span>-1</span>」。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>mysql_query(&amp;mysql,&quot;UPDATE products SET cost=cost*1.25 WHERE group=10&quot;);</span></pre>
				<pre><span>printf(&quot;%ld products updated&quot;,(long) mysql_affected_rows(&amp;mysql));</span></pre>
				<p>如果在連接至<strong><span>mysqld</span></strong>時指定了標誌<span>CLIENT_FOUND_ROWS</span>，對於<span><span>UPDATE</span>語句，<span>mysql_affected_rows()</span></span>將返回<span><span>WHERE</span>語句匹配的行數。</span></p>
				<p>注意，使用<span><span>REPLACE</span>命令時，如果新行替代了舊行，<span>mysql_affected_rows()</span></span>返回<span>2</span>。這是因為，在該情況下，刪除了重複行後插入了<span>1</span>行。</p>
				<p>如果使用「<span>INSERT ... 
				ON DUPLICATE KEY UPDATE</span>」來插入行，如果行是作為新行插入的<span>，mysql_affected_rows()</span>返回<span>1</span>，如果是更新了已有的行，返回<span>2</span>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-autocommit"></a>25.2.3.2. mysql_autocommit()</h4></div></div></div><a class="indexterm" name="id3011153"></a>
				<p><span>my_bool 
				mysql_autocommit(MYSQL *mysql, my_bool mode)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果模式為「<span>1</span>」，啟用<span>autocommit</span>模式；如果模式為「<span>0</span>」，禁止<span>autocommit</span>模式。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出現錯誤，返回非<span>0</span>值。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-change-user"></a>25.2.3.3. mysql_change_user()</h4></div></div></div><a class="indexterm" name="id3011232"></a>
				<p><span>my_bool 
				mysql_change_user(MYSQL *mysql, const char *user, const char 
				*password, const char *db)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>更改用戶，並使由<span><span>db</span>指定的資料庫成為由<span>mysql</span>指定的連接上的預設資料庫（當前資料庫）。</span>在後續查詢中，對於不包含顯式資料庫區分符的資料表引用，該資料庫是預設資料庫。</p>
				<p><span>如果不能確定已連接的用戶或用戶不具有使用資料庫的權限，<span>mysql_change_user()</span></span>將失敗。在這種情況下，不會改變用戶和資料庫。</p>
				<p>如果不打算擁有預設資料庫，可將<span><span>db</span>參數設置為<span>NULL</span>。</span></p>
				<p>該命令總是會執行活動事務的<span><span>ROLLBACK</span>操作，關閉所有的臨時資料表，解鎖所有的鎖定資料表，並復位狀態，就像進行了新連接那樣。即使未更改用戶，也會出現該情況。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>與從<span>mysql_real_connect()</span>獲得的相同。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中丟失了與伺服器的連接。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_UNKNOWN_COM_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器未實施該命令（或許是較低版本的伺服器）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_ACCESS_DENIED_ERROR</span><span> </span></p>
				<p>用戶或密碼錯誤。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_BAD_DB_ERROR</span><span> </span></p>
				<p>資料庫不存在。<span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_DBACCESS_DENIED_ERROR</span><span> </span>
				</p>
				<p>用戶沒有訪問資料庫的權限。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_WRONG_DB_NAME</span><span> </span></p>
				<p>資料庫名稱過長。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>if (mysql_change_user(&amp;mysql, &quot;user&quot;, &quot;password&quot;, &quot;new_database&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to change user.&nbsp; </span><span>Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-character-set-name"></a>25.2.3.4. mysql_character_set_name()</h4></div></div></div><a class="indexterm" name="id3011504"></a>
				<p><span>const char *mysql_character_set_name(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>為當前連接返回預設的字元編碼。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>預設字元編碼。<span> </span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-close"></a>25.2.3.5. mysql_close()</h4></div></div></div><a class="indexterm" name="id3011574"></a>
				<p><span>void 
				mysql_close(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>關閉前面打開的連接。如果句柄是由<span>mysql_init()</span>或<span><span>mysql_connect()</span>自動分配的，<span>mysql_close()</span></span>還將解除分配由<span><span>mysql</span>指向</span>的連接句柄。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-commit"></a>25.2.3.6. mysql_commit()</h4></div></div></div><a class="indexterm" name="id3011660"></a>
				<p><span>my_bool 
				mysql_commit(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>提交當前事務。</p>
				<p>該函數的動作受<span><span>completion_type</span>系統變數的值控制。尤其是，</span>如果<span>completion_type</span>的值為<span>2</span>，終結事務並關閉客戶端連接後，伺服器將執行釋放操作。客戶端程式應使用<span><span>mysql_close()</span>，從客戶端一側關閉連接。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="mysql-connect"></a>25.2.3.7. mysql_connect()</h4>
						</div></div></div><a class="indexterm" name="id3011751">
				</a>
				<p><span>MYSQL *mysql_connect(MYSQL 
				*mysql, const char *host, const char *user, const char *passwd)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數已過時。最好使用<span>mysql_real_connect()</span>取而代之。</p>
				<p><span><span>mysql_connect()</span>試圖建立與運行在主機上的<span>MySQL</span>資料庫引擎的連接。在能夠執行任何其他<span>API</span>函數之前，<span>mysql_connect()</span></span>必須成功完成，但<span>mysql_get_client_info()</span>例外。</p>
				<p>這些參數的意義與<span><span>mysql_real_connect()</span>的對應參數的意義相同，</span>差別在於連接參數可以為<span>NULL</span>。在這種情況下，<span>C 
				API</span>將自動為連接結構分配內存，並當使用<span><span>mysql_close()</span>時釋放分配的內存。該方法的缺點是，如果連接失敗，您無法檢索錯誤消息。</span>要想從<span>mysql_errno()</span>或<span><span>mysql_error()</span>獲得錯誤消息，</span>必須提供有效的<span>MYSQL</span>指針。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>與<span>mysql_real_connect()</span>的相同。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>與<span>mysql_real_connect()</span>的相同。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-create-db"></a>25.2.3.8. mysql_create_db()</h4></div></div></div><a class="indexterm" name="id3011891"></a>
				<p><span>int 
				mysql_create_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>建立由<span><span>db</span>參數命名的資料庫。</span></p>
				<p>該函數已過時。最好使用<span>mysql_query()</span>來發出<span>SQL
				<span>CREATE DATABASE</span></span>語句。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果資料庫已成功建立，返回<span>0</span>，如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span>
				</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>if(mysql_create_db(&amp;mysql, &quot;my_database&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to create new database.&nbsp; </span><span>Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-data-seek"></a>25.2.3.9. mysql_data_seek()</h4></div></div></div><a class="indexterm" name="id3012053"></a>
				<p><span>void 
				mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在查詢結果集中尋找任意行。偏移值為行號，範圍從<span>0</span>到<span>mysql_num_rows(result)-1</span>。</p>
				<p>該函數要求結果集結構包含查詢的所有結果，因此，<span>so
				<span>mysql_data_seek()</span></span>僅應與<span><span>mysql_store_result()</span>聯合使用，而不是</span>與<span>mysql_use_result()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-debug"></a>25.2.3.10. mysql_debug()</h4></div></div></div><a class="indexterm" name="id3012152"></a>
				<p><span>void 
				mysql_debug(const char *debug)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>用給定的字串執行<span>DBUG_PUSH</span>。<span>mysql_debug()</span>採用<span>Fred 
				Fish</span>調試庫。要想使用該函數，必須編譯客戶端庫，使之支援調試功能。請參見<a href="porting.html#debugging-server" title="E.1. Debugging a MySQL Server">E.1節，「調試MySQL伺服器」</a>。請參見<a href="porting.html#debugging-client" title="E.2. Debugging a MySQL Client">E.2節，「調試MySQL客戶端」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<p>這裡給出的使用將使客戶端庫在客戶端機器的<span><span>/tmp/client.trace</span>中生成<span>1</span>個跟蹤檔案。</span></p>
				<pre><span>mysql_debug(&quot;d:t:O,/tmp/client.trace&quot;);</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-drop-db"></a>25.2.3.11. mysql_drop_db()</h4></div></div></div><a class="indexterm" name="id3012263"></a>
				<p><span>int 
				mysql_drop_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>撤銷由<span>db</span>參數命名資料庫。<span> </span>
				</p>
				<p>該函數已過時。最好使用<span>mysql_query()</span>來發出<span>SQL
				<span>DROP DATABASE</span></span>語句</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功撤銷了資料庫，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span>
				</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>if(mysql_drop_db(&amp;mysql, &quot;my_database&quot;))</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;Failed to drop the database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-dump-debug-info"></a>25.2.3.12. mysql_dump_debug_info()</h4></div></div></div><a class="indexterm" name="id3012424"></a>
				<p><span>int 
				mysql_dump_debug_info(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>指示伺服器將一些調試訊息寫入日誌。要想使之工作，已連接的用戶必須具有<span><span>SUPER</span>權限。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果命令成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-eof"></a>25.2.3.13. mysql_eof()</h4></div></div></div><a class="indexterm" name="id3012557"></a>
				<p><span>my_bool 
				mysql_eof(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數已過時。應使用<span>mysql_errno()</span>或<span>mysql_error()</span>取而代之。</p>
				<p><span>mysql_eof()</span>確定是否已讀取了結果集的最後<span>1</span>行。</p>
				<p>如果通過成功使用<span><span>mysql_store_result()</span>獲得了結果集，客戶端將在<span>1</span>次操作中收到整個結果集。在該情況下，</span>從<span><span>mysql_fetch_row()</span>返回的<span>NULL</span>總資料表示已到達結果集末尾，</span>而且沒必要使用<span><span>mysql_eof()</span>。</span>與<span>mysql_store_result()</span>一起使用時，<span><span>mysql_eof()</span>總返回<span>「</span>真<span>」</span>。</span></p>
				<p>另一方面，如果您使用<span>mysql_use_result()</span>來初始化結果集檢索，當重複使用<span><span>mysql_fetch_row()</span>時，將逐個地從伺服器獲取結果集的行。由於在該過程中，可能出現連接上的錯誤，從<span>mysql_fetch_row()</span>返回的<span>NULL</span>值不一定資料表示已正常地抵達結果集末尾。</span>在該情況下，可以使用<span><span>mysql_eof()</span>來判定出現了什麼情況。如果抵達結果集末尾，<span>mysql_eof()</span></span>返回非<span>0</span>值，如果出現錯誤，返回<span>0</span>。</p>
				<p>從歷史的角度上看，<span><span>mysql_eof()</span>在日期上早於</span>標準的<span>MySQL</span>錯誤函數<span>mysql_errno()</span>和<span>mysql_error()</span>。由於這類錯誤函數提供了相同的訊息，它們優先於已過時的<span>mysql_eof()</span>。事實上，它們提供了更多訊息，這是因為，<span><span>mysql_eof()</span>僅返回布爾值，</span>錯誤函數能夠在出現錯誤時指明錯誤的原因。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果未出現錯誤，返回<span>0</span>。如果抵達結果集的末尾，返回非<span>0</span>值。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<p>在下面的示範中，介紹了使用<span>mysql_eof()</span>的方法：</p>
				<pre><span>mysql_query(&amp;mysql,&quot;SELECT * FROM some_table&quot;);</span></pre>
				<pre><span>result = mysql_use_result(&amp;mysql);</span></pre>
				<pre><span>while((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // do something with data</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if(!mysql_eof(result))&nbsp; // mysql_fetch_row() failed due to an error</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>但是，您也能使用標準的<span>MySQL</span>錯誤函數實現相同的結果：</p>
				<pre><span>mysql_query(&amp;mysql,&quot;SELECT * FROM some_table&quot;);</span></pre>
				<pre><span>result = mysql_use_result(&amp;mysql);</span></pre>
				<pre><span>while((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // do something with data</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if(mysql_errno(&amp;mysql))&nbsp; // mysql_fetch_row() failed due to an error</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-errno"></a>25.2.3.14. mysql_errno()</h4></div></div></div><a class="indexterm" name="id3012790"></a>
				<p><span>unsigned int 
				mysql_errno(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>對於由<span><span>mysql</span>指定的連接，<span>mysql_errno()</span></span>返回最近使用的<span>API</span>函數的錯誤代碼，該函數使用可能成功也可能失敗。「<span>0</span>」返回值資料表示未出現錯誤。在<span>MySQL
				<span>errmsg.h</span></span><span>頭檔案中，列出了</span>客戶端錯誤消息編號。在<a href="error-handling.html">附錄B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>錯誤代碼和消息</i></a>中，也列出了這些錯誤。<span>
				</span></p>
				<p>注意，如果成功，某些函數，如<span><span>mysql_fetch_row()</span>等，不會設置<span>mysql_errno()</span></span>。</p>
				<p>經驗規則是，如果成功，所有向伺服器請求訊息的函數均會復位<span>mysql_errno()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果失敗，返回上次<span><span>mysql_<i>xxx</i>()</span>使用的錯誤代碼。<span>「0」</span>資料表示未出現錯誤。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-error"></a>25.2.3.15. mysql_error()</h4></div></div></div><a class="indexterm" name="id3012914"></a>
				<p><span>const char *mysql_error(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於由<span>mysql</span>指定的連接，對於失敗的最近使用的<span>API</span>函數，<span><span>mysql_error()</span>返回</span>包含錯誤消息的、由<span>Null</span>終結的字串。如果該函數未失敗，<span><span>mysql_error()</span>的返回值可能是以前的錯誤，或指明無錯誤的空字串。</span></p>
				<p>經驗規則是，如果成功，所有向伺服器請求訊息的函數均會復位<span>mysql_error()</span>。</p>
				<p>對於復位<span>mysql_errno()</span>的函數，下述兩個測試是等效的：</p>
				<pre><span>if(mysql_errno(&amp;mysql))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if(mysql_error(&amp;mysql)[0] != &#39;\0&#39;)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<p>通過重新編譯<span>MySQL</span>客戶端庫，可以更改客戶端錯誤消息的語言。目前，能夠選擇數種語言顯示錯誤消息，請參見<a href="database-administration.html#languages" title="5.10.2. Setting the Error Message Language">5.10.2節，「設置錯誤消息語言」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>返回描述錯誤的、由<span>Null</span>終結的字串。如果未出現錯誤，返回空字串。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-escape-string"></a>25.2.3.16. mysql_escape_string()</h4></div></div></div><a class="indexterm" name="id3013037"></a>
				<p>應使用<span>mysql_real_escape_string()</span>取而代之！</p>
				<p>該函數與<span><span>mysql_real_escape_string()</span>等同，</span>但<span>mysql_real_escape_string()</span>會將連接處理程式作為其第<span>1</span>個參量，並按照當前字元編碼對字串進行轉義處理。<span>mysql_escape_string()</span>不採用連接參量，而且不考慮當前字元編碼設置。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field"></a>25.2.3.17. mysql_fetch_field()</h4></div></div></div><a class="indexterm" name="id3013089"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回採用<span><span>MYSQL_FIELD</span>結構的結果集的列。</span>重複使用該函數，以檢索關於結果集中所有列的訊息。未剩餘字段時，<span>mysql_fetch_field()</span>返回<span>NULL</span>。</p>
				<p><span>每次執行新的<span>SELECT</span>查詢時，將復位<span>mysql_fetch_field()</span></span>，以返回關於第<span>1</span>個字段的訊息。使用<span><span>mysql_field_seek()</span>也會影響<span>mysql_fetch_field()</span>返回的字段。</span></p>
				<p>如果使用了<span><span>mysql_query()</span>以在資料表上執行<span>SELECT</span>，</span>但未使用<span>mysql_store_result()</span>，如果使用了<span><span>mysql_fetch_field()</span>以請求<span>BLOB</span>字段的長度，</span><span>MySQL</span>將返回預設的<span>Blob</span>長度（<span>8KB</span>）。之所以選擇<span>8KB</span>是因為<span>MySQL</span>不知道<span><span>BLOB</span>的最大長度。應在日後使其成為可配置的。</span>一旦檢索了結果集，<span><span>field-&gt;max_length</span>將包含特定查詢中該列的最大值的長度。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>當前列的<span><span>MYSQL_FIELD</span>結構。如果未剩餘任何列，返回<span>NULL</span></span>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL_FIELD *field;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>while((field = mysql_fetch_field(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;field name %s\n&quot;, field-&gt;name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field-direct"></a>25.2.3.18. mysql_fetch_field_direct()</h4></div></div></div><a class="indexterm" name="id3013256"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES 
				*result, unsigned int fieldnr)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>給定結果集內某<span>1</span>列的字段編號<span><span>fieldnr</span>，以<span>MYSQL_FIELD</span>結構形式返回列的字段定義</span>。可以使用該函數檢索任意列的定義。<span><span>Fieldnr</span>的值應在從<span>0</span>到<span>mysql_num_fields(result)-1</span></span>的範圍內。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>對於指定列，返回<span><span>MYSQL_FIELD</span>結構。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>MYSQL_FIELD *field;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; field = mysql_fetch_field_direct(result, i);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;Field %u is %s\n&quot;, i, field-&gt;name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-fields"></a>25.2.3.19. mysql_fetch_fields()</h4></div></div></div><a class="indexterm" name="id3013370"></a>
				<p><span>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於結果集，返回所有<span>MYSQL_FIELD</span>結構的數組。每個結構提供了結果集中<span>1</span>列的字段定義。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>關於結果集所有列的<span><span>MYSQL_FIELD</span>結構的數組。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>MYSQL_FIELD *fields;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>fields = mysql_fetch_fields(result);</span></pre>
				<pre><span>for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; printf(&quot;Field %u is %s\n&quot;, i, fields[i].name);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-lengths"></a>25.2.3.20. mysql_fetch_lengths()</h4></div></div></div><a class="indexterm" name="id3013467"></a>
				<p><span>unsigned long *mysql_fetch_lengths(MYSQL_RES 
				*result)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回結果集內當前行的列的長度。如果打算複製字段值，該長度訊息有助於最佳化，這是因為，您能避免使用<span><span>strlen()</span>。此外，</span>如果結果集包含二進制數據，必須使用該函數來確定數據的大小，原因在於，對於包含<span>Null</span>字元的任何字段，<span><span>strlen()</span>將返回錯誤的結果。</span></p>
				<p>對於空列以及包含<span>NULL</span>值的列，其長度為<span>0</span>。要想瞭解區分這兩類情況的方法，請參見關於<span>mysql_fetch_row()</span>的介紹。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無符號長整數的數組資料表示各列的大小（不包括任何終結<span>NULL</span>字元）。如果出現錯誤，返回<span>NULL</span>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p><span>
				mysql_fetch_lengths()</span>僅對結果集的當前行有效。如果在使用<span><span>mysql_fetch_row()</span>之前或檢索了結果集中的所有行後使用了它，</span>將返回<span>NULL</span>。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL_ROW row;</span></pre>
				<pre><span>unsigned long *lengths;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>row = mysql_fetch_row(result);</span></pre>
				<pre><span>if (row)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; lengths = mysql_fetch_lengths(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Column %u is %lu bytes in length.\n&quot;, i, lengths[i]);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-row"></a>25.2.3.21. mysql_fetch_row()</h4></div></div></div><a class="indexterm" name="id3013610"></a>
				<p><span>MYSQL_ROW 
				mysql_fetch_row(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>檢索結果集的下一行。在<span><span>mysql_store_result()</span>之後使用時，如果沒有要檢索的行，<span>mysql_fetch_row()</span></span>返回<span>NULL</span>。在<span>mysql_use_result()</span>之後使用時，<span>如果沒有要檢索的行或出現了錯誤，<span>mysql_fetch_row()</span></span>返回<span><span>NULL</span>。</span></p>
				<p>行內值的數目由<span><span>mysql_num_fields(result)</span>給出。如果行中保存了使用<span>mysql_fetch_row()</span>返回的值，將按照<span>row[0]</span>到<span>row[mysql_num_fields(result)-1]</span>，訪問這些值的指針。行中的<span>NULL</span></span>值由<span><span>NULL</span>指針指明。</span></p>
				<p>可以通過使用<span><span>mysql_fetch_lengths()</span>來獲得行中字段值的長度。對於空字段以及包含<span>NULL</span>的字段，長度為<span>0</span>。通過檢查字段值的指針，能夠區分它們。如果指針為<span>NULL</span>，字段為<span>NULL</span>，否則字段為空。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>下一行的<span><span>MYSQL_ROW</span>結構。如果沒有更多要檢索的行或出現了錯誤，返回<span>NULL</span>。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>注意，在對<span><span>mysql_fetch_row()</span>的兩次使用之間，不會復位錯誤。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span>
				</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL_ROW row;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int i;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>while ((row = mysql_fetch_row(result)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; unsigned long *lengths;</span></pre>
				<pre><span>&nbsp;&nbsp; lengths = mysql_fetch_lengths(result);</span></pre>
				<pre><span>&nbsp;&nbsp; for(i = 0; i &lt; num_fields; i++)</span></pre>
				<pre><span>&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;[%.*s] &quot;, (int) lengths[i], row[i] ? row[i] : &quot;NULL&quot;);</span></pre>
				<pre><span>&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp; printf(&quot;\n&quot;);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-count"></a>25.2.3.22. mysql_field_count()</h4></div></div></div><a class="indexterm" name="id3013828"></a>
				<p><span>unsigned int 
				mysql_field_count(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回作用在連接上的最近查詢的列數。</p>
				<p>該函數的正常使用是在<span><span>mysql_store_result()</span>返回<span>NULL</span>（因而沒有結果集指針）時。在這種情況下，</span>可使用<span><span>mysql_field_count()</span>來判定<span>mysql_store_result()</span>是否應生成非空結果。這樣，客戶端就能採取恰當的動作，而無需知道</span>查詢是否是<span><span>SELECT</span>（或類似<span>SELECT</span>的）語句。</span>在這裡給出的示範中，演示了完成它的方法。</p>
				<p>請參見<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1節，「為什麼在mysql_query()返回成功後，mysql_store_result()有時會返回NULL<code class="literal"></code>」</a><span>.
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示結果集中列數的無符號整數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL_RES *result;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int num_rows;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(&amp;mysql,query_string))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // error</span></pre>
				<pre><span>}</span></pre>
				<pre><span>else // query succeeded, process any data returned by it</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; result = mysql_store_result(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; if (result)&nbsp; // there are rows</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve rows, then call mysql_free_result(result)</span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;}</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; else&nbsp; // mysql_store_result() returned nothing; should it have?</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(mysql_field_count(&amp;mysql) == 0)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query does not return data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (it was not a SELECT)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_rows = mysql_affected_rows(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // mysql_store_result() should have returned data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
				<p>另一種可選的方法是，用<span><span>mysql_errno(&amp;mysql)</span>替換<span>mysql_field_count(&amp;mysql)</span>使用。</span>在該情況下，無論語句是否是<span><span>SELECT</span>，</span>您將直接從<span><span>mysql_store_result()</span>搜尋錯誤，</span>而不是從<span><span>mysql_field_count()</span>的值進行推斷。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-seek"></a>25.2.3.23. mysql_field_seek()</h4></div></div></div><a class="indexterm" name="id3014006"></a>
				<p><span>
				MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, 
				MYSQL_FIELD_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>將字段光標設置到給定的偏移處。對<span><span>mysql_fetch_field()</span>的下一次使用將檢索與該偏移相關的列定義。</span></p>
				<p>要想搜尋行的開始，請傳遞值為<span>0</span>的偏移量。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字段光標的前一個值。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-tell"></a>25.2.3.24. mysql_field_tell()</h4></div></div></div><a class="indexterm" name="id3014090"></a>
				<p><span>
				MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上一個<span><span>mysql_fetch_field()</span>所使用的字段光標的定義。該值可用作<span>mysql_field_seek()</span></span>的參量。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字段光標的當前偏移量。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-free-result"></a>25.2.3.25. mysql_free_result()</h4></div></div></div><a class="indexterm" name="id3014168"></a>
				<p><span>void 
				mysql_free_result(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>釋放由<span>mysql_store_result()</span>、<span>mysql_use_result()</span>、<span><span>mysql_list_dbs()</span>等為結果集分配的內存</span>。完成對結果集的操作後，必須使用<span><span>mysql_free_result()</span>釋放結果集使用的內存。</span></p>
				<p>釋放完成後，不要嘗試訪問結果集。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-character-set-info"></a>25.2.3.26. mysql_get_character_set_info()</h4></div></div></div><a class="indexterm" name="id3014260"></a>
				<p><span>void 
				mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數提供了關於預設客戶端字元編碼的訊息。可以使用<span><span>mysql_set_character_set()</span>函數更改預設的字元編碼。</span></p>
				<p>該函數是在<span>MySQL 5.0.10</span>中增加的。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>if (!mysql_set_character_set(&amp;mysql, &quot;utf8&quot;))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; MY_CHARSET_INFO cs;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; mysql_get_character_set_info(&amp;mysql, &amp;cs);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;character set information:\n&quot;);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;character set name: %s\n&quot;, cs.name);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;collation name: %s\n&quot;, cs.csname);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;comment: %s\n&quot;, cs.comment);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;directory: %s\n&quot;, cs.dir);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;multi byte character min. length: %d\n&quot;, cs.mbminlen);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;multi byte character max. length: %d\n&quot;, cs.mbmaxlen);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-info"></a>25.2.3.27. mysql_get_client_info()</h4></div></div></div><a class="indexterm" name="id3014349"></a>
				<p><span>char *mysql_get_client_info(void)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回資料表示客戶端庫版本的字串。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示<span>MySQL</span>客戶端庫版本的字串。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-version"></a>25.2.3.28. mysql_get_client_version()</h4></div></div></div><a class="indexterm" name="id3014419"></a>
				<p><span>unsigned long 
				mysql_get_client_version(void)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回資料表示客戶端庫版本的整數。該值的格式是<span><span>XYYZZ</span>，其中<span>X</span></span>是主版本號，<span>YY</span>是發佈級別，<span><span>ZZ</span>是發佈級別內的版本號。</span>例如，值<span><span>40102</span>資料表示客戶端庫的版本是<span>4.1.2</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示<span>MySQL</span>客戶端庫版本的整數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-host-info"></a>25.2.3.29. mysql_get_host_info()</h4></div></div></div><a class="indexterm" name="id3014516"></a>
				<p><span>char *mysql_get_host_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回描述了所使用連接類型的字串，包括伺服器主機名。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代資料表伺服器主機名和連接類型的字串。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-proto-info"></a>25.2.3.30. mysql_get_proto_info()</h4></div></div></div><a class="indexterm" name="id3014587"></a>
				<p><span>unsigned int 
				mysql_get_proto_info(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回當前連接所使用的協議版本。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代資料表當前連接所使用協議版本的無符號整數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-info"></a>25.2.3.31. mysql_get_server_info()</h4></div></div></div><a class="indexterm" name="id3014659"></a>
				<p><span>char *mysql_get_server_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回代資料表伺服器版本號的字串。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>代資料表伺服器版本號的字串。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-version"></a>25.2.3.32. mysql_get_server_version()</h4></div></div></div><a class="indexterm" name="id3014729"></a>
				<p><span>unsigned long 
				mysql_get_server_version(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>以整數形式返回伺服器的版本號。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示<span>MySQL</span>伺服器版本的數值，格式如下：</p>
				<pre><span>major_version*10000 + minor_version *100 + sub_version</span></pre>
				<p>例如，對於<span>5.0.12</span>，返回<span>500012</span>。</p>
				<p>在客戶端程式中，為了快速確定某些與版本相關的伺服器功能是否存在，該函數很有用。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-hex-string"></a>25.2.3.33. mysql_hex_string()</h4></div></div></div><a class="indexterm" name="id3014815"></a>
				<p><span>unsigned long 
				mysql_hex_string(char *to, const char *from, unsigned long 
				length)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數用於建立可用在<span>SQL</span>語句中的合法<span>SQL</span>字串。請參見<a href="language-structure.html#string-syntax" title="9.1.1. Strings">9.1.1節，「字串」</a>。</p>
				<p>該字串從形式上編碼為十六進制格式，每個字元編碼為<span>2</span>個十六進制數。結果被置入其中，並新增<span>1</span>個終結<span>Null</span>字節。</p>
				<p>「<span>from</span>」所指向的字串必須是長度字節「<span>long</span>」。必須為「<span>to</span>」分配緩衝區，緩衝區至少為<span><span>length*2+1</span>字節長。當<span>mysql_hex_string()</span>返回時，<span>「to」</span>的內容為由<span>Null</span>終結的字串。返回值是</span>編碼字串的長度，不包括終結用<span>Null</span>字元。</p>
				<p>可採用<span>0x<i>value</i></span>或<span><span>X&#39;<i>value</i>&#39;</span>格式將返回值置於<span>SQL</span>語句中。但是，</span>返回值不包括<span>0x</span>或<span>X&#39;...&#39;</span>。使用者必須提供所希望的格式是何種。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>char query[1000],*end;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>end = strmov(query,&quot;INSERT INTO test_table values(&quot;);</span></pre>
				<pre><span>end = strmov(end,&quot;0x&quot;);</span></pre>
				<pre><span>end += mysql_hex_string(end,&quot;What&#39;s this&quot;,11);</span></pre>
				<pre><span>end = strmov(end,&quot;,0x&quot;);</span></pre>
				<pre><span>end += mysql_hex_string(end,&quot;binary data: \0\r\n&quot;,16);</span></pre>
				<pre><span>*end++ = &#39;)&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to insert row, Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>示範中所使用的<span><span>strmov()</span>函數包含在<span>mysqlclient</span>庫中，</span>它的工作方式類似於<span><span>strcpy()</span>，但返回指向第<span>1</span>個參數終結<span>Null</span>的指針。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>置於「<span>to</span>」中的值的長度，不包括終結用<span>Null</span>字元。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-info"></a>25.2.3.34. mysql_info()</h4></div></div></div><a class="indexterm" name="id3015005"></a>
				<p><span>char *mysql_info(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>檢索字串，該字串提供了關於最近執行查詢的訊息，但僅對這裡列出的語句有效。對於其他語句，<span>mysql_info()</span>返回<span>NULL</span>。字串的格式取決於查詢的類型，如本節所述。數值僅是說明性的，字串包含與查詢相適應的值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				INSERT INTO ... SELECT ...</span><span> </span>
				</p>
				<p>字串格式：<span>記錄，<span>100</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				INSERT INTO ... VALUES (...),(...),(...)...</span><span>
				</span></p>
				<p>字串格式：<span>記錄，<span>3</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>LOAD 
				DATA INFILE ...</span><span> </span></p>
				<p>字串格式：<span>記錄，<span>1</span>；刪除，<span>0</span>；跳過，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ALTER TABLE</span><span> </span></p>
				<p>字串格式：<span>記錄，<span>3</span>；副本，<span>0</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				UPDATE</span><span> </span></p>
				<p>字串格式：<span>匹配行，<span>40</span>；更改，<span>40</span>；警告，<span>0</span></span><span>
				</span></p>
				<p>注意，<span><span>mysql_info()</span>為<span>INSERT 
				... VALUES</span>返回</span>非<span><span>NULL</span>值，<span>INSERT 
				... VALUES</span>僅用於</span>多行形式的語句（也就是說，僅當指定了多個值列資料表時）。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>字串，它資料表示最近所執行查詢的額外訊息。如果該查詢無可用訊息，返回<span><span>NULL</span>。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-init"></a>25.2.3.35. mysql_init()</h4></div></div></div><a class="indexterm" name="id3015205"></a>
				<p><span>MYSQL *mysql_init(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>分配或初始化與<span><span>mysql_real_connect()</span>相適應的<span>MYSQL</span>對象。</span>如果<span><span>mysql</span>是<span>NULL</span>指針，</span>該函數將分配、初始化、並返回新對象。否則，將初始化對象，並返回對象的地址。如果<span>mysql_init()</span>分配了新的對象，當使用<span><span>mysql_close()</span>來關閉連接時。將釋放該對象。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>初始化的<span><span>MYSQL*</span>句柄。如果無足夠內存以分配新的對象，返回<span>NULL</span>。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>在內存不足的情況下，返回<span><span>NULL</span>。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-insert-id"></a>25.2.3.36. mysql_insert_id()</h4></div></div></div><a class="indexterm" name="id3015315"></a>
				<p><span>my_ulonglong 
				mysql_insert_id(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由以前的<span>INSERT</span>或<span><span>UPDATE</span>語句為<span>AUTO_INCREMENT</span>列生成的值。在包含<span>AUTO_INCREMENT</span>字段的資料表中執行了<span>INSERT</span>語句後，應使用該函數。</span></p>
				<p>更準確地講，將在下述條件下更新<span>mysql_insert_id()</span>：</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>將值保存到<span>AUTO_INCREMENT</span>列中的<span>INSERT</span>語句。無論值是通過在列中儲存特殊值<span>NULL</span>或<span>0</span>自動生成的，還是確切的非特殊值，都成立。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在有多行<span><span>INSERT</span>語句的情況下，<span>mysql_insert_id()</span>返回第<span>1</span>個自動生成的<span>AUTO_INCREMENT</span>值，</span>如果未生成這類值，將返回插入在<span><span>AUTO_INCREMENT</span>列中的</span>最後<span>1</span>個確切值。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>通過將<span>LAST_INSERT_ID(<i>expr</i>)</span>插入到任意列中以生成<span>AUTO_INCREMENT</span>值的<span>INSERT</span>語句。</span></p>
				<p>
				<span>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>通過更新任意列至<span>LAST_INSERT_ID(<i>expr</i>)</span>以生成<span>AUTO_INCREMENT</span>值的<span>INSERT</span>語句。</span></p>
				<p>
				<span>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>mysql_insert_id()</span>的值不受諸如<span>SELECT</span>等返回結果集的語句的影響。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果前面的語句返回了錯誤，<span><span>mysql_insert_id()</span>的值</span>將是不確定的。</p>
				<p>注意，如果前面的語句未使用<span><span>AUTO_INCREMENT</span>，<span>mysql_insert_id()</span></span>返回<span>0</span>。如果需要保存值，在生成值的語句後，務必立刻使用<span>mysql_insert_id()</span>。</p>
				<p><span><span>mysql_insert_id()</span>的值僅受在當前客戶端連接內發出的語句的影響。不受由其他客戶端發出的語句的影響。</span></p>
				<p>請參見<a href="functions.html#information-functions" title="12.9.3. Information Functions">12.9.3節，「訊息函數」</a>。</p>
				<p>此外還應注意，<span>SQL <span>
				LAST_INSERT_ID()</span></span>函數的值總包含最近生成的<span><span>AUTO_INCREMENT</span>值，而且在語句之間不會被復位，</span>原因在於該函數的值是在伺服器中維護的。另一個區別是，如果設置了<span><span>AUTO_INCREMENT</span>列來指定非特殊值，不會更新<span>LAST_INSERT_ID()</span>。</span></p>
				<p><span>LAST_INSERT_ID()</span>不同於<span><span>mysql_insert_id()</span>的原因在於，<span>LAST_INSERT_ID()</span>在指令中很容易使用，</span>而<span><span>mysql_insert_id()</span>則試圖提供關於在<span>AUTO_INCREMENT</span>列中出現情況的更準確訊息。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>在前面的討論中予以了介紹。<span> </span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-kill"></a>25.2.3.37. mysql_kill()</h4></div></div></div><a class="indexterm" name="id3015646"></a>
				<p><span>int 
				mysql_kill(MYSQL *mysql, unsigned long pid)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>請求伺服器殺死由<span>pid</span>指定的線程。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-end"></a>25.2.3.38. mysql_library_end()</h4></div></div></div><a class="indexterm" name="id3015778"></a>
				<p><span>void 
				mysql_library_end(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>它是<span>mysql_server_end()</span>函數的同義詞。</p>
				<p>關於具體的用法，請參見<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2節，「C API函數概述」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-init"></a>25.2.3.39. mysql_library_init()</h4></div></div></div><a class="indexterm" name="id3015834"></a>
				<p><span>int 
				mysql_library_init(int argc, char **argv, char **groups)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>這是<span>mysql_server_init()</span>函數的同義詞。</p>
				<p>關於具體的用法，請參見<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2節，「C API函數概述」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-dbs"></a>25.2.3.40. mysql_list_dbs()</h4></div></div></div><a class="indexterm" name="id3015891"></a>
				<p><span>MYSQL_RES *mysql_list_dbs(MYSQL 
				*mysql, const char *wild)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由伺服器上的資料庫名稱組成的結果集，該伺服器與由通配符參數指定的簡單正則資料表達式匹配。通配符參數可以包含通配符「<span>%</span>」或「<span>_</span>」，也可以是<span>NULL</span>指針，以便與所有的資料庫匹配。使用<span><span>mysql_list_dbs()</span>的方法類似於執行</span>查詢<span>SHOW 
				database [LIKE wild]</span>。</p>
				<p>必須用<span>mysql_free_result()</span>釋放結果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功後返回<span>MYSQL_RES</span>結果集。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-fields"></a>25.2.3.41. mysql_list_fields()</h4></div></div></div><a class="indexterm" name="id3016079"></a>
				<p><span>MYSQL_RES *mysql_list_fields(MYSQL 
				*mysql, const char *table, const char *wild)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由給定資料表中的字段名稱組成的結果集，給定資料表與由通配符參數指定的簡單正則資料表達式匹配。通配符參數可以包含通配符「<span>%</span>」或「<span>_</span>」，也可以是<span>NULL</span>指針，以便與所有的字段匹配。使用<span><span>mysql_list_fields()</span>的方法類似於執行</span>查詢<span>SHOW 
				COLUMNS FROM <i>tbl_name</i> [LIKE <i>wild</i>]</span>。</p>
				<p>注意，建議使用<span>SHOW 
				COLUMNS FROM <i>tbl_name</i></span>，而不是<span>mysql_list_fields()</span>。</p>
				<p>必須用<span>mysql_free_result()</span>釋放結果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>結果集。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-processes"></a>25.2.3.42. mysql_list_processes()</h4></div></div></div><a class="indexterm" name="id3016277"></a>
				<p><span>MYSQL_RES *mysql_list_processes(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回描述當前伺服器線程的結果集。該類訊息與<strong><span>mysqladmin 
				processlist</span></strong>或<span><span>SHOW 
				PROCESSLIST</span>查詢給出的訊息相同。</span></p>
				<p>必須用<span>mysql_free_result()</span>釋放結果集。 </p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>結果集。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-tables"></a>25.2.3.43. mysql_list_tables()</h4></div></div></div><a class="indexterm" name="id3016429"></a>
				<p><span>MYSQL_RES *mysql_list_tables(MYSQL 
				*mysql, const char *wild)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由當前資料庫內的資料表名組成的結果集，當前資料庫與由通配符參數指定的簡單正則資料表達式匹配。通配符參數可以包含通配符「<span>%</span>」或「<span>_</span>」，也可以是<span>NULL</span>指針，以便與所有的資料表匹配。使用<span><span>mysql_list_tables()</span>的方法類似於執行</span>查詢<span>HOW 
				tables [LIKE <i>wild</i>]</span>。</p>
				<p>必須用<span>mysql_free_result()</span>釋放結果集。<span>
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>MYSQL_RES</span>結果集。 
				<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-more-results"></a>25.2.3.44. mysql_more_results()</h4></div></div></div><a class="indexterm" name="id3016608"></a>
				<p><span>my_bool 
				mysql_more_results(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果當前執行的查詢存在多個結果，返回「真」，而且應用程式必須使用<span><span>mysql_next_result()</span>來獲取結果。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果存在多個結果，返回<span>「</span>真<span>」</span>（<span>1</span>），如果不存在多個結果，返回<span>「</span>假<span>」</span>（<span>0</span>）。</span></p>
				<p>在大多數情況下，可使用<span>mysql_next_result()</span>來測試是否存在多個結果，如果存在多個結果，對檢索進行初始化操作。</p>
				<p>請參見<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9節，「多查詢執行的C API處理」</a>。請參見<a href="apis.html#mysql-next-result" title="25.2.3.45. mysql_next_result()">25.2.3.45節，「mysql_next_result()」</a>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-next-result"></a>25.2.3.45. mysql_next_result()</h4></div></div></div><a class="indexterm" name="id3016714"></a>
				<p><span>int 
				mysql_next_result(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果存在多個查詢結果，<span><span>mysql_next_result()</span>將讀取下一個查詢結果，並將狀態返回給應用程式。</span></p>
				<p>如果前面的查詢返回了結果集，必須為其使用<span><span>mysql_free_result()</span>。</span></p>
				<p>使用了<span><span>mysql_next_result()</span>後，連接狀態就像您已為下一查詢使用了<span>mysql_real_query()</span></span>或<span>mysql_query()</span>時的一樣。這意味著您能使用<span><span>mysql_store_result()</span>、<span>mysql_warning_count()</span>、<span>mysql_affected_rows()</span>等等。</span></p>
				<p>如果<span>mysql_next_result()</span>返回錯誤，將不執行任何其他語句，也不會獲取任何更多的結果，</p>
				<p>請參見<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9節，「多查詢執行的C API處理」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<table border="1" cellpadding="0" id="table6">
					<tr>
						<td>
						<p><strong>
						<span>返回值</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p><span>0</span></td>
						<td>
						<p>成功並有多個結果。</td>
					</tr>
					<tr>
						<td>
						<p><span>-1</span></td>
						<td>
						<p>成功但沒有多個結果。</td>
					</tr>
					<tr>
						<td>
						<p><span>&gt;0</span></td>
						<td>
						<p>出錯</td>
					</tr>
				</table>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。例如，沒有為前面的結果集使用<span><span>mysql_use_result()</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-fields"></a>25.2.3.46. mysql_num_fields()</h4></div></div></div><a class="indexterm" name="id3016973"></a><a class="indexterm" name="id3016983"></a>
				<p><span>unsigned int 
				mysql_num_fields(MYSQL_RES *result)</span><span>
				</span></p>
				<p>要想傳遞<span>MYSQL*</span>參量取而代之，請使用無符號整數<span>mysql_field_count(MYSQL 
				*mysql)</span>。</p>
				<p><strong><span>描述</span></strong></p>
				<p>返回結果集中的行數。</p>
				<p>注意，您可以從指向結果集的指針或指向連接句柄的指針獲得行數。如果<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>返回<span>NULL</span>，</span>應使用連接句柄（因而沒有結果集指針）。在該情況下，可使用<span>mysql_field_count()</span>來判斷<span>mysql_store_result()</span>是否生成了非空結果。這樣，客戶端程式就能採取恰當的行動，而不需要知道查詢是否是<span><span>SELECT</span>語句（或類似<span>SELECT</span>的語句）。</span>在下面的示範中，介紹了執行該操作的方式。<span>
				</span></p>
				<p>請參見<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1節，「為什麼在mysql_query()返回成功後，mysql_store_result()有時會返回NULL<code class="literal"></code>」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示結果集中行數的無符號整數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL_RES *result;</span></pre>
				<pre><span>unsigned int num_fields;</span></pre>
				<pre><span>unsigned int num_rows;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(&amp;mysql,query_string))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; // error</span></pre>
				<pre><span>}</span></pre>
				<pre><span>else // query succeeded, process any data returned by it</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; result = mysql_store_result(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; if (result)&nbsp; // there are rows</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_fields = mysql_num_fields(result);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve rows, then call mysql_free_result(result)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; else&nbsp; // mysql_store_result() returned nothing; should it have?</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mysql_errno(&amp;mysql))</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error: %s\n&quot;, mysql_error(&amp;mysql));</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (mysql_field_count(&amp;mysql) == 0)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query does not return data</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (it was not a SELECT)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_rows = mysql_affected_rows(&amp;mysql);</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
				<pre><span>}</span></pre>
				<p>另一種可選方式是（如果您知道您的查詢應返回結果集），使用檢查「<span>mysql_field_count(&amp;mysql) 
				is </span><span>= 0<span>」來替換</span><span>mysql_errno(&amp;mysql)</span></span>使用。僅當出錯時才應使用它。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-rows"></a>25.2.3.47. mysql_num_rows()</h4></div></div></div><a class="indexterm" name="id3017164"></a>
				<p><span>my_ulonglong 
				mysql_num_rows(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回結果集中的行數。<span> </span></p>
				<p><span><span>mysql_num_rows()</span>的使用取決於</span>是否採用了<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>來返回結果集。</span>如果使用了<span>mysql_store_result()</span>，可以立刻使用<span>mysql_num_rows()</span>。如果使用了<span>mysql_use_result()</span>，<span>mysql_num_rows()</span>不返回正確的值，直至檢索了結果集中的所有行為止。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>結果集中的行數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-options"></a>25.2.3.48. mysql_options()</h4></div></div></div><a class="indexterm" name="id3017268"></a>
				<p><span>int 
				mysql_options(MYSQL *mysql, enum mysql_option option, const char 
				*arg)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>可用於設置額外的連接選項，並影響連接的行為。可多次使用該函數來設置數個選項。</p>
				<p><span>應在<span>mysql_init()</span>之後、以及<span>mysql_connect()</span></span>或<span><span>mysql_real_connect()</span>之前使用<span>mysql_options()</span></span>。</p>
				<p>選項參量指的是您打算設置的選項。<span>Arg</span>參量是選項的值。如果選項是整數，那麼<span><span>arg</span>應指向</span>整數的值。</p>
				<p>可能的選項值：</p>
				<table border="1" cellpadding="0" width="612" style="width: 459.0pt" id="table7">
					<tr>
						<td>
						<p><strong>
						<span>選項</span></strong></td>
						<td>
						<p><strong>
						<span>參量類型</span></strong></td>
						<td>
						<p><strong>
						<span>功能</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_INIT_COMMAND</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>連接到<span>MySQL</span>伺服器時將執行的命令。再次連接時將自動地再次執行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_COMPRESS</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>使用壓縮客戶端／伺服器協議</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_CONNECT_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>以秒為單位的連接超時。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_GUESS_CONNECTION</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>對於與<span><span>libmysqld</span>連結的應用程式，允許庫<span>「</span>猜測<span>」</span>是否使用</span>嵌入式伺服器或遠程伺服器。「<span class="quote">猜測</span>」資料表示，如果設置了主機名但不是本地主機，將使用遠程伺服器。該行為是預設行為。 
						可使用<span>MYSQL_OPT_USE_EMBEDDED_CONNECTION</span><span>
						</span>和<span><span>MYSQL_OPT_USE_REMOTE_CONNECTION</span>覆蓋它。</span>對於與<span><span>libmysqlclient</span>連結的應用程式，該選項將被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_LOCAL_INFILE</span></td>
						<td>
						<p>指向單元的可選指針</td>
						<td>
						<p>如果未給定指針，或指針指向「<span><span>unsigned 
						int != 0」</span>，將允許</span>命令<span>LOAD 
						LOCAL INFILE</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_NAMED_PIPE</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>使用命名管道連接到<span>NT</span>平台上的<span>MySQL</span>伺服器。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_PROTOCOL</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>要使用的協議類型。應是<span><span>mysql.h</span>中定義的<span>mysql_protocol_type</span>的枚舉值之一。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_READ_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>從伺服器讀取訊息的超時（目前僅在<span>Windows</span>平台的<span>TCP/IP</span>連接上有效）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_RECONNECT</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>如果發現連接丟失，啟動或禁止與伺服器的自動再連接。從<span>MySQL 
						5.0.3開始，預設情況下禁止再連接，這是5.0.13</span>中的新選項，提供了一種以顯式方式設置再連接行為的方法。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_SET_CLIENT_IP</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>對於與<span><span>libmysqld</span>連結的應用程式（具備鑒定支援特性的已編譯<span>libmysqld</span>）</span>，它意味著，出於鑒定目的，用戶將被視為從指定的<span>IP</span>地址（指定為字串）進行連接。對於與<span><span>libmysqlclient</span>連結的應用程式，，該選項將被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_EMBEDDED_CONNECTION</span></td>
						<td valign="top">
						<p>未使用</td>
						<td>
						<p>對於與<span><span>libmysqld</span>連結的應用程式，對於連接來說，它將強制使用嵌入式伺服器</span>。對於與<span><span>libmysqlclient</span>連結的應用程式，，該選項將被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_REMOTE_CONNECTION</span></td>
						<td valign="top">
						<p>未使用</td>
						<td>
						<p>對於與<span><span>libmysqld</span>連結的應用程式，對於連接來說，它將強制使用遠程伺服器</span>。對於與<span><span>libmysqlclient</span>連結的應用程式，，該選項將被忽略。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_USE_RESULT</span></td>
						<td>
						<p>未使用</td>
						<td>
						<p>不使用該選項。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_OPT_WRITE_TIMEOUT</span></td>
						<td>
						<p>
						<span>unsigned int *</span></td>
						<td>
						<p>寫入伺服器的超時（目前僅在<span>Windows</span>平台的<span>TCP/IP</span>連接上有效）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_READ_DEFAULT_FILE</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>從命名選項檔案而不是從<span><span>my.cnf</span>讀取選項。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_READ_DEFAULT_GROUP</span></td>
						<td>
						<p>
						<span>char *</span></td>
						<td>
						<p>從<span><span>my.cnf</span>或用<span>MYSQL_READ_DEFAULT_FILE</span>指定的檔案中的命名組讀取選項。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_REPORT_DATA_TRUNCATION</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>通過<span><span>MYSQL_BIND.error</span>，對於預處理語句，允許或禁止通報數據截斷錯誤</span>（預設為禁止）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SECURE_AUTH</span></td>
						<td>
						<p>
						<span>my_bool*</span></td>
						<td>
						<p>是否連接到不支援密碼混編功能的伺服器，在<span>MySQL 
						4.1.1</span>和更高版本中，使用了密碼混編功能。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SET_CHARSET_DIR</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>指向包含字元編碼定義檔案的目錄的路徑名。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SET_CHARSET_NAME</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>用作預設字元編碼的字元編碼的名稱。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_SHARED_MEMORY_BASE_NAME</span></td>
						<td>
						<p>
						<span>char*</span></td>
						<td>
						<p>命名為與伺服器進行通信的共享內存對象。應與您打算連接的<span>mysqld</span>伺服器使用的選項「<span><span>-shared-memory-base-name」</span>相同。</span></td>
					</tr>
				</table>
				<p>注意，如果使用了<span>MYSQL_READ_DEFAULT_FILE</span>或<span><span>MYSQL_READ_DEFAULT_GROUP</span>，總會讀取客戶端組。</span></p>
				<p>選項檔案中指定的組可能包含下述選項：</p>
				<table border="1" cellpadding="0" id="table8">
					<tr>
						<td>
						<p><strong>
						<span>選項</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>connect-timeout</span></td>
						<td>
						<p>以秒為單位的連接超時。在<span>Linux</span>平台上，該超時也用作等待伺服器首次回應的時間。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>compress</span></td>
						<td>
						<p>使用壓縮客戶端／伺服器協議。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>database</span></td>
						<td>
						<p>如果在連接命令中未指定資料庫，連接到該資料庫。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>debug</span></td>
						<td>
						<p>調試選項。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>disable-local-infile</span></td>
						<td>
						<p>禁止使用<span>LOAD 
						DATA LOCAL</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>host</span></td>
						<td>
						<p>預設主機名。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>init-command</span></td>
						<td>
						<p>連接到<span>MySQL</span>伺服器時將執行的命令。再次連接時將自動地再次執行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>interactive-timeout</span></td>
						<td>
						<p>等同於將<span>CLIENT_INTERACTIVE</span>指定為<span>mysql_real_connect()</span>。請參見<a href="apis.html#mysql-real-connect" title="25.2.3.51. mysql_real_connect()">25.2.3.51節，「mysql_real_connect()」</a>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>local-infile[=(0|1)]</span></td>
						<td>
						<p>如果無參量或參量<span>!= 0</span>，那麼將允許使用<span>LOAD 
						DATA LOCAL</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>max_allowed_packet</span></td>
						<td>
						<p>客戶端能夠從伺服器讀取的最大訊息包。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>multi-results</span></td>
						<td>
						<p>允許多語句執行或儲存程式的多個結果集。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>multi-statements</span></td>
						<td>
						<p>允許客戶端在<span>1</span>個字串內發送多條語句。（由「<span>;</span>」隔開）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>password</span></td>
						<td>
						<p>預設密碼。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>pipe</span></td>
						<td>
						<p>使用命名管道連接到<span>NT</span>平台上的<span>MySQL</span>伺服器。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>protocol={TCP | SOCKET | PIPE | 
						MEMORY}</span></td>
						<td>
						<p>連接到伺服器時將使用的協議。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>port</span></td>
						<td>
						<p>預設端口號。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>return-found-rows</span></td>
						<td>
						<p>通知<span><span>mysql_info()</span>返回發現的行，而不是使用<span>UPDATE</span>時更新的行</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>shared-memory-base-name=<i>name</i></span></td>
						<td>
						<p>共享內存名稱，用於連接到伺服器（預設為<span>&quot;MYSQL&quot;</span>）。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>socket</span></td>
						<td>
						<p>預設的套接字檔案。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>user</span></td>
						<td>
						<p>預設用戶。</td>
					</tr>
				</table>
				<p>注意，「<span><span>timeout」</span>（超時）已被</span>「<span><span>connect-timeout」</span>（連接超時）取代，但為了保持向後兼容，</span>在<span>MySQL 
				5.1.2-alpha</span>中仍支援「<span><span>timeout」</span>（超時）。</span></p>
				<p>關於選項檔案的更多訊息，請參見<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2節，「使用選項檔案」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功時返回<span>0</span>。如果使用了未知選項，返回非<span>0</span>值。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,0);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,&quot;odbc&quot;);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>該代碼請求客戶端使用壓縮客戶端／伺服器協議，並從<span><span>my.cnf</span>檔案的<span>obdc</span>部分讀取額外選項。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ping"></a>25.2.3.49. mysql_ping()</h4></div></div></div><a class="indexterm" name="id3018282"></a>
				<p><span>int 
				mysql_ping(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>檢查與伺服器的連接是否工作。如果連接丟失，將自動嘗試再連接。</p>
				<p>該函數可被閒置了較長時間的客戶端使用，用以檢查伺服器是否已關閉了連接，並在必要時再次連接。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果與伺服器的連接有效返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。返回的非<span>0</span>值不資料表示<span>MySQL</span>伺服器本身是否已關閉，連接可能因其他原因終端，如網絡問題等。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-query"></a>25.2.3.50. mysql_query()</h4></div></div></div><a class="indexterm" name="id3018406"></a>
				<p><span>int 
				mysql_query(MYSQL *mysql, const char *query)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>執行由「<span>Null</span>終結的字串」查詢指向的<span>SQL</span>查詢。正常情況下，字串必須包含<span>1</span>條<span>SQL</span>語句，而且不應為語句新增終結分號（『<span>;</span>』）或「<span><span>\g」</span>。如果允許多語句執行，</span>字串可包含多條由分號隔開的語句。請參見<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9節，「多查詢執行的C API處理」</a>。</p>
				<p><span>mysql_query()</span>不能用於包含二進制數據的查詢，應使用<span>mysql_real_query()</span>取而代之（二進制數據可能包含字元『<span><span>\0』<span>，</span>mysql_query()</span>會將該字元解釋為查詢字串結束）。</span></p>
				<p>如果希望瞭解查詢是否應返回結果集，可使用<span>mysql_field_count()</span>進行檢查。請參見<a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22節，「mysql_field_count()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果查詢成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-connect"></a>25.2.3.51. mysql_real_connect()</h4></div></div></div><a class="indexterm" name="id3018593"></a>
				<p><span>MYSQL *mysql_real_connect(MYSQL 
				*mysql, const char *host, const char *user, const char *passwd, 
				const char *db, unsigned int port, const char *unix_socket, 
				unsigned long client_flag)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_real_connect()</span>嘗試與運行在主機上的<span>MySQL</span>資料庫引擎建立連接。在您能夠執行需要有效<span>MySQL</span>連接句柄結構的任何其他<span>API</span>函數之前，<span>mysql_real_connect()</span>必須成功完成。</p>
				<p>參數的指定方式如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第<span>1</span>個參數應是已有<span><span>MYSQL</span>結構的地址。</span>使用<span>mysql_real_connect()</span>之前，必須使用<span><span>mysql_init()</span>來初始化<span>MYSQL</span>結構。通過<span>mysql_options()</span>使用，</span>可更改多種連接選項。請參見<a href="apis.html#mysql-options" title="25.2.3.48. mysql_options()">25.2.3.48節，「mysql_options()」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>「<span>host</span>」的值必須是主機名或<span>IP</span>地址。如果「<span>host</span>」是<span><span>NULL</span>或字串<span>&quot;localhost&quot;</span></span>，連接將被視為與本地主機的連接。如果作業系統支援套接字（<span>Unix</span>）或命名管道（<span>Windows</span>），將使用它們而不是<span>TCP/IP</span>連接到伺服器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>「<span><span>user」</span>參數</span>包含用戶的<span>MySQL</span>登錄<span>ID</span>。如果「<span><span>user」</span>是<span>NULL</span>或空字串<span>&quot;&quot;</span></span>，用戶將被視為當前用戶。在<span>UNIX</span>環境下，它是當前的登錄名。在<span>Windows 
				ODBC</span>下，必須明確指定當前帳號。請參見<a href="connectors.html#dsn-on-windows" title="26.1.9.2. Configuring a MyODBC DSN on Windows">26.1.9.2節，「在Windows上配置MyODBC DSN」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>「<span><span>passwd」</span>參數包含用戶的密碼。</span>如果「<span><span>passwd」</span>是<span>NULL</span>，</span>僅會對該用戶的（擁有<span>1</span>個空密碼字段的）用戶資料表中的條目進行匹配檢查。這樣，資料庫管理員就能按特定的方式設置<span>MySQL</span>權限系統，根據用戶是否擁有指定的密碼，用戶將獲得不同的權限。</p>
				<p><strong>
				<span>註釋：</span></strong>使用<span><span>mysql_real_connect()</span>之前，不要嘗試加密密碼，密碼加密將由客戶端<span>API</span>自動處理。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>「db」</span>是資料庫名稱。如果<span><span>db</span>為<span>NULL</span>，</span>連接會將預設的資料庫設為該值。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果「<span><span>port」</span>不是<span>0</span>，</span>其值將用作<span>TCP/IP</span>連接的端口號。注意，「<span>host</span>」參數決定了連接的類型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果<span>unix_socket</span>不是<span>NULL</span>，該字串描述了應使用的套接字或命名管道。注意，「<span>host</span>」參數決定了連接的類型。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>client_flag</span>的值通常為<span>0</span>，但是，也能將其設置為下述標誌的組合，以允許特定功能：</span></p>
				<table border="1" cellpadding="0" id="table9">
					<tr>
						<td>
						<p><strong>
						<span>標誌名稱</span></strong></td>
						<td>
						<p><strong>
						<span>標誌描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_COMPRESS</span></td>
						<td>
						<p>使用壓縮協議。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_FOUND_ROWS</span></td>
						<td>
						<p>返回發現的行數（匹配的），而不是受影響的行數。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_IGNORE_SPACE</span></td>
						<td>
						<p>允許在函數名後使用空格。使所有的函數名成為保留字。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_INTERACTIVE</span></td>
						<td>
						<p>關閉連接之前，允許<span><span>interactive_timeout</span>（取代了<span>wait_timeout</span>）秒的不活動時間。</span>客戶端的會話<span><span>wait_timeout</span>變數被設為會話<span>interactive_timeout</span>變數的值。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_LOCAL_FILES</span></td>
						<td>
						<p>允許<span>LOAD 
						DATA LOCAL</span>處理功能。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_MULTI_STATEMENTS</span></td>
						<td>
						<p>通知伺服器，客戶端可能在單個字串內發送多條語句（由『<span>;</span>』隔開）。如果未設置該標誌，將禁止多語句執行。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_MULTI_RESULTS</span></td>
						<td>
						<p>
						通知伺服器，客戶端能夠處理來自多語句執行或儲存程式的多個結果集。如果設置了<span><span>CLIENT_MULTI_STATEMENTS</span>，將自動設置它。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_NO_SCHEMA</span></td>
						<td>
						<p>禁止<span><i><span>db_name.tbl_name.col_name</span></i></span>語法。它用於<span>ODBC</span>。如果使用了該語法，它會使分析程式生成錯誤，在捕獲某些<span>ODBC</span>程式中的問題時，它很有用。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_ODBC</span></td>
						<td>
						<p>客戶端是<span>ODBC</span>客戶端。它將<strong><span>mysqld</span></strong>變得更為<span>ODBC</span>友好。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>CLIENT_SSL</span></td>
						<td>
						<p>使用<span>SSL</span>（加密協議）。該選項不應由應用程式設置，它是在客戶端庫內部設置的。</td>
					</tr>
				</table>
				<p>對於某些參數，能夠從選項檔案獲得取值，而不是取得<span><span>mysql_real_connect()</span>使用中的確切值。為此，在使用<span>mysql_real_connect()</span>之前，應與<span>MYSQL_READ_DEFAULT_FILE</span></span>或<span><span>MYSQL_READ_DEFAULT_GROUP</span>選項一起使用<span>mysql_options()</span>。隨後，在<span>mysql_real_connect()</span></span>使用中，為準備從選項檔案讀取值的每個參數指定「<span class="quote">無值</span>」值：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span><span>host</span>，指定<span>NULL</span>值或空字串</span><span>(<span>&quot;&quot;</span>)</span>。</p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span><span>user</span>，指定<span>NULL</span>值或空字串。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span><span>passwd</span>，指定<span>NULL</span>值。（對於密碼，<span>mysql_real_connect()</span>使用中的空字串的值不能被選項檔案中的字串覆蓋，這是因為，空字串明確指明</span><span>MySQL</span>帳號必須有空密碼）。</p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span><span>db</span>，指定<span>NULL</span>值或空字串</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span><span>port</span>，指定<span>「0」</span>值。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>unix_socket</span>，<span>指定<span>NULL</span>值。</span></p>
				<p>對於某一參數，如果在選項檔案中未發現值，將使用它的預設值，如本節前面介紹的那樣。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果連接成功，返回<span><span>MYSQL*</span>連接句柄。如果連接失敗，返回<span>NULL</span>。對於成功的連接，返回值與第<span>1</span>個參數的值相同。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_CONN_HOST_ERROR</span><span> </span></p>
				<p>無法連接到<span>MySQL</span>伺服器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_CONNECTION_ERROR</span><span> </span></p>
				<p>無法連接到本地<span>MySQL</span>伺服器。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_IPSOCK_ERROR</span><span> </span></p>
				<p>無法建立<span>IP</span>套接字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SOCKET_CREATE_ERROR</span><span> </span></p>
				<p>無法建立<span>Unix</span>套接字。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_HOST</span><span> </span></p>
				<p>無法找到主機名的<span>IP</span>地址。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_VERSION_ERROR</span><span> </span></p>
				<p>
				協議不匹配，起因於：試圖連接到具有特定客戶端庫（該客戶端庫使用了不同的協議版本）的伺服器。如果使用很早的客戶端庫來建立與較新的伺服器（未使用「<span>--old-protocol</span>」選項開始的）的連接，就會出現該情況。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPEOPEN_ERROR</span><span> </span></p>
				<p>無法在<span>Windows</span>平台下建立命名管道。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPEWAIT_ERROR</span><span> </span></p>
				<p>在<span>Windows</span>平台下等待命名管道失敗。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NAMEDPIPESETSTATE_ERROR</span><span> </span>
				</p>
				<p>在<span>Windows</span>平台下獲取管道處理程式失敗。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>如果<span>connect_timeout</span><span> 
				&gt; 0</span>，而且在連接伺服器時所用時間長於<span><span>connect_timeout</span>秒，或在執行<span>init-command</span>時伺服器</span>消失。</p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,&quot;your_prog_name&quot;);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>通過使用<span><span>mysql_options()</span>，</span><span>MySQL</span>庫將讀取<span><span>my.cnf</span>檔案的<span>[client]</span></span>和<span>[your_prog_name]</span>部分，以確保程式工作，即使某人以某種非標準的方式設置<span>MySQL</span>也同樣。</p>
				<p>注意，一旦建立了連接，<span><span>mysql_real_connect()</span>將設置再連接標誌（<span>MYSQL</span>結構的組成部份）的值，在低於</span><span>5.0.3</span>版的<span>API</span>中，將其設為「<span>1</span>」，在較新的版本中，將其設為「<span>0</span>」。對於該標誌，值「<span>1</span>」資料表示，如果因連接丟失而無法執行語句，放棄前，將嘗試再次連接到伺服器。從<span>MySQL 
				5.0.13</span>開始，可以對<span><span>mysql_options()</span>使用<span>MYSQL_OPT_RECONNECT</span>選項，對再連接行為進行控制。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-escape-string"></a>25.2.3.52. mysql_real_escape_string()</h4></div></div></div><a class="indexterm" name="id3019536"></a>
				<p><span>unsigned long 
				mysql_real_escape_string(MYSQL *mysql, char *to, const char 
				*from, unsigned long length)</span><span>
				</span></p>
				<p>注意，<span><span>mysql</span>必須是有效的開放式連接。</span>之所以需要它是因為，轉義功能取決於伺服器使用的字元編碼。</p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數用於建立可在<span>SQL</span>語句中使用的合法<span>SQL</span>字串。請參見<a href="language-structure.html#string-syntax" title="9.1.1. Strings">9.1.1節，「字串」</a>。</p>
				<p>按照連接的當前字元編碼，將「<span>from</span>」中的字串編碼為轉義<span>SQL</span>字串。將結果置於「<span><span>to」</span>中，並新增<span>1</span>個終結用<span>NULL</span>字節。編碼的字元為<span>NUL</span></span><span> 
				(ASCII 0)</span>、『<span>\n</span>』、『<span>\r</span>』、『<span>\</span>』、『<span>&#39;</span>』、『<span>&quot;</span>』、以及<span>Control-Z</span>（請參見<a href="language-structure.html#literals" title="9.1. Literal Values">9.1節，「文字值」</a>）。（嚴格地講，<span>MySQL</span>僅需要反斜槓和引號字元，用於引用轉義查詢中的字串。該函數能引用其他字元，從而使得它們在日誌檔案中具有更好的可讀性）。</p>
				<p>「<span>from</span>」指向的字串必須是長度字節「<span>long</span>」。必須為「<span>to</span>」緩衝區分配至少<span><span>length*2+1</span>字節。</span>在最壞的情況下，每個字元或許需要使用<span>2</span>個字節進行編碼，而且還需要終結<span>Null</span>字節。當<span><span>mysql_real_escape_string()</span>返回時，</span>「<span>to</span>」的內容是由<span>Null</span>終結的字串。返回值是編碼字串的長度，不包括終結用<span>Null</span>字元。</p>
				<p>如果需要更改連接的字元編碼，應使用<span>mysql_set_character_set()</span>函數，而不是執行<span>SET 
				NAMES</span><span> (</span>或<span>SET 
				CHARACTER SET</span><span>)</span>語句。<span><span>mysql_set_character_set()</span>的工作方式類似於<span>SET 
				NAMES</span>，但它還能影響<span>mysql_real_escape_string()</span>所使用的字元編碼，而<span>SET 
				NAMES</span>則不能。</span></p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>char query[1000],*end;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>end = strmov(query,&quot;INSERT INTO test_table values(&quot;);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>end += mysql_real_escape_string(&amp;mysql, end,&quot;What&#39;s this&quot;,11);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>*end++ = &#39;,&#39;;</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>end += mysql_real_escape_string(&amp;mysql, end,&quot;binary data: \0\r\n&quot;,16);</span></pre>
				<pre><span>*end++ = &#39;\&#39;&#39;;</span></pre>
				<pre><span>*end++ = &#39;)&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp; fprintf(stderr, &quot;Failed to insert row, Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<p>該示範中使用的<span><span>strmov()</span>函數包含在<span>mysqlclient</span>庫中，工作方式與<span>strcpy()</span>類似，</span>但會返回指向第<span>1</span>個參數終結用<span>Null</span>的指針。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>置於「<span>to</span>」中的值的長度，不包括終結用<span>Null</span>字元。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-query"></a>25.2.3.53. mysql_real_query()</h4></div></div></div><a class="indexterm" name="id3019781"></a>
				<p><span>int 
				mysql_real_query(MYSQL *mysql, const char *query, unsigned long 
				length)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>執行由「<span>query</span>」指向的<span>SQL</span>查詢，它應是字串長度字節「<span>long</span>」。正常情況下，<span>字串必須包含<span>1</span>條<span>SQL</span>語句，而且不應為語句新增</span>終結分號（『<span>;</span>』）或「<span>\g</span>」。如果允許多語句執行，字串可包含由分號隔開的多條語句。請參見<a href="apis.html#c-api-multiple-queries" title="25.2.9. C API Handling of Multiple Query Execution">25.2.9節，「多查詢執行的C API處理」</a>。</p>
				<p>對於包含二進制數據的查詢，必須使用<span><span>mysql_real_query()</span>而不是<span>mysql_query()</span>，這是因為，二進制數據可能會包含</span>『<span><span>\0』<span>字元。此外，</span>mysql_real_query()</span>比<span>mysql_query()</span>快，這是因為它不會在查詢字串上使用<span>strlen()</span>。</span></p>
				<p>如果希望知道查詢是否應返回結果集，可使用<span><span>mysql_field_count()</span>進行檢查</span><a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22節，「mysql_field_count()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果查詢成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-refresh"></a>25.2.3.54. mysql_refresh()</h4></div></div></div><a class="indexterm" name="id3019989"></a>
				<p><span>int 
				mysql_refresh(MYSQL *mysql, unsigned int options)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數用於刷新資料表或高速緩衝，或復位複製伺服器訊息。連接的用戶必須具有<span><span>RELOAD</span>權限。</span></p>
				<p>「<span><span>options」</span>參量是</span>一種位掩碼，由下述值的任意組合構成。能夠以「<span>Or</span>」（或）方式將多個值組合在一起，用一次使用執行多項操作。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_GRANT</span><span> </span></p>
				<p>刷新授權資料表，與<span>FLUSH 
				PRIVILEGES</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_LOG</span><span> </span></p>
				<p>刷新日誌，與<span>FLUSH 
				LOGS</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_TABLES</span><span> </span></p>
				<p>刷新資料表高速緩衝，與<span>FLUSH 
				TABLES</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_HOSTS</span><span> </span></p>
				<p>刷新主機高速緩衝，與<span>FLUSH 
				HOSTS</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_STATUS</span><span> </span></p>
				<p>復位狀態變數，與<span>FLUSH 
				STATUS</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_THREADS</span><span> </span></p>
				<p>刷新線程高速緩衝。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_SLAVE</span><span> </span></p>
				<p>在從複製伺服器上，復位主伺服器訊息，並重新啟動從伺服器，與<span>RESET 
				SLAVE</span>類似。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				REFRESH_MASTER</span><span> </span></p>
				<p>
				在主複製伺服器上，刪除二進制日誌索引中列出的二進制日誌檔案，並截短索引檔案，與<span>RESET 
				MASTER</span>類似。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-reload"></a>25.2.3.55. mysql_reload()</h4></div></div></div><a class="indexterm" name="id3020280"></a>
				<p><span>int 
				mysql_reload(MYSQL *mysql)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>請求<span>MySQL</span>伺服器重新加載授權資料表。連接的用戶必須具有<span>RELOAD</span>權限。</p>
				<p>該函數已過時。最好使用<span>mysql_query()</span>來發出<span>SQL
				<span>FLUSH PRIVILEGES</span></span><span>語句。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-rollback"></a>25.2.3.56. mysql_rollback()</h4></div></div></div><a class="indexterm" name="id3020424"></a>
				<p><span>my_bool 
				mysql_rollback(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>回滾當前事務。</p>
				<p>該函數的動作取決於<span><span>completion_type</span>系統變數的值。</span>尤其是，如果<span><span>completion_type</span>的值為<span>「2」</span></span>，終結事務後，伺服器將執行釋放操作，並關閉客戶端連接。客戶端程式應使用<span><span>mysql_close()</span>，</span>從客戶端一側關閉連接。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出現錯誤，返回非<span>0</span>值。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-seek"></a>25.2.3.57. mysql_row_seek()</h4></div></div></div><a class="indexterm" name="id3020516"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, 
				MYSQL_ROW_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>將行光標置於查詢結果集中的任意行。「<span><span>offset」</span>值是行偏移量，它應是</span>從<span>mysql_row_tell()</span>或<span><span>mysql_row_seek()</span>返回的值。該值不是行編號，如果您打算按編號搜尋結果集中的行，</span>請使用<span>mysql_data_seek()</span>。</p>
				<p>該函數要求在結果集的結構中包含查詢的全部結果，因此，<span><span>mysql_row_seek()</span>僅應與<span>mysql_store_result()</span>一起使用，而不是與<span>mysql_use_result()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光標的前一個值。該值可傳遞給對<span>mysql_row_seek()</span>的後續使用。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-tell"></a>25.2.3.58. mysql_row_tell()</h4></div></div></div><a class="indexterm" name="id3020628"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於上一個<span><span>mysql_fetch_row()</span>，</span>返回行光標的當前位置。該值可用作<span>mysql_row_seek()</span>的參量。</p>
				<p>僅應在<span>mysql_store_result()</span>之後，而不是<span><span>mysql_use_result()</span>之後使用<span>mysql_row_tell()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光標的當前偏移量。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-select-db"></a>25.2.3.59. mysql_select_db()</h4></div></div></div><a class="indexterm" name="id3020723"></a>
				<p><span>int 
				mysql_select_db(MYSQL *mysql, const char *db)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>使由<span>db</span>指定的資料庫成為由<span><span>mysql</span>指定的連接上的</span>預設資料庫（當前資料庫）。在後續查詢中，該資料庫將是未包含明確資料庫區分符的資料表引用的預設資料庫。</p>
				<p><span>除非已連接的用戶具有使用資料庫的權限，否則<span>mysql_select_db()</span>將失敗。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-character-set"></a>25.2.3.60. mysql_set_character_set()</h4></div></div></div><a class="indexterm" name="id3020871"></a>
				<p><span>int 
				mysql_set_character_set(MYSQL *mysql, char *csname)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數用於為當前連接設置預設的字元編碼。字串<span>csname</span>指定了<span>1</span>個有效的字元編碼名稱。連接校對成為字元編碼的預設校對。該函數的工作方式與<span><span>SET 
				NAMES</span>語句類似，</span>但它還能設置<span>mysql-&gt;charset</span>的值，從而影響了由<span><span>mysql_real_escape_string()</span>設置的字元編碼。</span></p>
				<p>該函數是在<span>MySQL 5.0.7</span>中增加的。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>MYSQL mysql;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql_init(&amp;mysql);</span></pre>
				<pre><span>if (!mysql_real_connect(&amp;mysql,&quot;host&quot;,&quot;user&quot;,&quot;passwd&quot;,&quot;database&quot;,0,NULL,0))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Failed to connect to database: Error: %s\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_error(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (!mysql_set_charset_name(&amp;mysql, &quot;utf8&quot;)) </span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; printf(&quot;New client character set: %s\n&quot;, mysql_character_set_name(&amp;mysql));</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-server-option"></a>25.2.3.61. mysql_set_server_option()</h4></div></div></div><a class="indexterm" name="id3020976"></a>
				<p><span>int 
				mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option 
				option)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>允許或禁止連接的選項。<span>選項可以取下述值之一：</span></p>
				<table border="1" cellpadding="0" id="table10">
					<tr>
						<td>
						<p><span>
						MYSQL_OPTION_MULTI_STATEMENTS_ON</span></td>
						<td>
						<p>允許多語句支援。</td>
					</tr>
					<tr>
						<td>
						<p><span>
						MYSQL_OPTION_MULTI_STATEMENTS_OFF</span></td>
						<td>
						<p>禁止多語句支援。</td>
					</tr>
				</table>
				<p><strong><span>返回值</span></strong></p>
				<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				ER_UNKNOWN_COM_ERROR</span><span> </span></p>
				<p>伺服器不支援<span><span>mysql_set_server_option()</span>（當伺服器版本低於</span><span>4.1.1</span>時），或伺服器不支援試圖設置的選項。</p>
				<div class="itemizedlist">&nbsp;</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-shutdown"></a>25.2.3.62. mysql_shutdown()</h4></div></div></div><a class="indexterm" name="id3021157"></a>
			<p><span>int 
			mysql_shutdown(MYSQL *mysql, enum enum_shutdown_level shutdown_level)</span><span>
			</span></p>
			<p><strong><span>描述</span></strong></p>
			<p>請求資料庫伺服器關閉。已連接的用戶必須具有<span>SHUTDOWN</span>權限。<span>MySQL 
			5.1</span>伺服器僅支援<span>1</span>種關閉類型，<span>shutdown_level</span>必須<span>等效於SHUTDOWN_DEFAULT</span>。設計規劃了額外的關閉級別，以便能夠選擇所需的級別。對於用舊版本<span><span>libmysqlclient</span>頭檔案編譯並使用<span>mysql_shutdown()</span>的動態連結可執行程式，需要與舊版的<span>libmysqlclient</span>動態庫一起使用。</span></p>
			<p>在<a href="database-administration.html#server-shutdown" title="5.5. The MySQL Server Shutdown Process">5.5節，「MySQL伺服器關機程序」</a>中，介紹了關機程序。</p>
			<p><strong><span>返回值</span></strong></p>
			<p><span>0</span>資料表示成功，非<span>0</span>值資料表示出現錯誤。<span>
			</span></p>
			<p><strong><span>錯誤</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_COMMANDS_OUT_OF_SYNC</span><span> </span></p>
			<p>以不恰當的順序執行了命令。<span> </span>
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_GONE_ERROR</span><span> </span></p>
			<p><span>MySQL</span>伺服器不可用。<span>
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_LOST</span><span> </span></p>
			<p>在查詢過程中，與伺服器的連接丟失。<span>
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_UNKNOWN_ERROR</span><span> </span></p>
			<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-sqlstate"></a>25.2.3.63. mysql_sqlstate()</h4></div></div></div><a class="indexterm" name="id3021331"></a>
				<p><span>const char *mysql_sqlstate(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回由<span>Null</span>終結的字串，該字串包含關於上次錯誤的<span>SQLSTATE</span>錯誤代碼。錯誤代碼包含<span>5</span>個字元。<span><span>&#39;00000&#39;</span>資料表示</span>無錯誤。其值由<span>ANSI 
				SQL</span>和<span>ODBC</span>指定。關於可能取值的列資料表，請參見<a href="error-handling.html">附錄B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>錯誤代碼和消息</i></a>。</p>
				<p>注意，並非所有的<span>MySQL</span>錯誤均會被映射到<span>SQLSTATE</span>錯誤代碼。值<span>&#39;HY000&#39;</span>（一般錯誤）用於未映射的錯誤。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>包含<span>SQLSTATE</span>錯誤碼的、由<span>Null</span>終結的字串。</p>
				<p><strong><span>另請參見：</span></strong></p>
				<p>請參見<a href="apis.html#mysql-errno" title="25.2.3.14. mysql_errno()">25.2.3.14節，「mysql_errno()」</a>。請參見<a href="apis.html#mysql-error" title="25.2.3.15. mysql_error()">25.2.3.15節，「mysql_error()」</a>。請參見<a href="apis.html#mysql-stmt-sqlstate" title="25.2.7.26. mysql_stmt_sqlstate()">25.2.7.26節，「mysql_stmt_sqlstate()」</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ssl-set"></a>25.2.3.64. mysql_ssl_set()</h4></div></div></div><a class="indexterm" name="id3021440"></a>
				<p><span>int 
				mysql_ssl_set(MYSQL *mysql, const char *key, const char *cert, 
				const char *ca, const char *capath, const char *cipher)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>使用<span>mysql_ssl_set()</span>，可採用<span>SSL</span>建立安全連接。必須在<span>mysql_real_connect()</span>之前使用它。</span></p>
				<p><span>除非在客戶端庫中允許了</span><span>OpenSSL</span>支援，否則<span>mysql_ssl_set()</span>不作任何事。</p>
				<p><span><span>Mysql</span>是從<span>mysql_init()</span>返回的連接處理程式。</span>其他參數的指定如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>key</span>是<span>key</span>檔案的路徑名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>cert</span>是證書檔案的路徑名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ca</span>是證書授權檔案的路徑名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span><span>
				capath</span>是指向目錄的路徑名，該目錄中</span>包含以<span>pem</span>格式給出的受信任<span>SSL 
				CA</span>證書。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				cipher</span>是允許密碼的列資料表，用於<span>SSL</span>加密。</p>
				<p>對於任何未使用的<span>SSL</span>參數，可為其給定<span>NULL</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>該函數總返回<span>0</span>。如果<span>SSL</span>設置不正確，當您嘗試連接時，<span><span>mysql_real_connect()</span>將返回錯誤。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stat"></a>25.2.3.65. mysql_stat()</h4></div></div></div><a class="indexterm" name="id3021604"></a>
				<p><span>char *mysql_stat(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回包含特定訊息的字串，該訊息與<strong><span>mysqladmin 
				status</span></strong>命令提供的訊息類似。包括以秒為單位的正常運行時間，以及運行線程的數目，問題數，再加載次數，以及打開的資料表數目。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>描述伺服器狀態的字元編碼。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-store-result"></a>25.2.3.66. mysql_store_result()</h4></div></div></div><a class="indexterm" name="id3021742"></a>
				<p><span>MYSQL_RES *mysql_store_result(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於成功檢索了數據的每個查詢（<span>SELECT</span>、<span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span>、<span><span>CHECK 
				TABLE</span>等</span>），必須使用<span>mysql_store_result()</span>或<span>mysql_use_result()</span><span>
				</span>。</p>
				<p>對於其他查詢，不需要使用<span>mysql_store_result()</span>或<span>mysql_use_result()</span>，但是如果在任何情況下均使用了<span><span>mysql_store_result()</span>，</span>它也不會導致任何傷害或性能降低。通過檢查<span><span>mysql_store_result()</span>是否返回<span>0</span>，可檢測查詢是否沒有結果集</span>（以後會更多）。</p>
				<p>如果希望瞭解查詢是否應返回結果集，可使用<span>mysql_field_count()</span>進行檢查。請參見<a href="apis.html#mysql-field-count" title="25.2.3.22. mysql_field_count()">25.2.3.22節，「mysql_field_count()」</a>。</p>
				<p><span><span>
				mysql_store_result()</span>將查詢的全部結果讀取到客戶端，</span>分配<span>1</span>個<span><span>MYSQL_RES</span>結構，</span>並將結果置於該結構中。</p>
				<p><span>如果查詢未返回結果集，<span>mysql_store_result()</span></span>將返回<span>Null</span>指針（例如，如果查詢是<span><span>INSERT</span>語句</span>）。</p>
				<p><span>如果讀取結果集失敗，<span>mysql_store_result()</span></span>還會返回<span>Null</span>指針。通過檢查<span><span>mysql_error()</span>是否返回非空字串，<span>mysql_errno()</span>是否返回非<span>0</span>值，或<span>mysql_field_count()</span>是否返回<span>0</span>，可以檢查是否出現了錯誤。</span></p>
				<p>如果未返回行，將返回空的結果集。（空結果集設置不同於作為返回值的空指針）。</p>
				<p>一旦使用了<span><span>mysql_store_result()</span>並獲得了不是<span>Null</span>指針的結果，</span>可使用<span><span>mysql_num_rows()</span>來找出結果集中的行數。</span></p>
				<p>可以使用<span>mysql_fetch_row()</span>來獲取結果集中的行，或使用<span>mysql_row_seek()</span>和<span><span>mysql_row_tell()</span>來獲取或設置結果集中的當前行位置。</span></p>
				<p>一旦完成了對結果集的操作，必須使用<span>mysql_free_result()</span>。</p>
				<p>請參見<a href="apis.html#null-mysql-store-result" title="25.2.13.1. Why mysql_store_result() Sometimes Returns NULL After mysql_query() Returns Success">25.2.13.1節，「為什麼在mysql_query()返回成功後，mysql_store_result()有時會返回NULL<code class="literal"></code>」</a><span>.
				</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>具有多個結果的<span>MYSQL_RES</span>結果集合。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p><span>如果成功，<span>mysql_store_result()</span>將</span>復位<span>mysql_error()</span>和<span>mysql_errno()</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-id"></a>25.2.3.67. mysql_thread_id()</h4></div></div></div><a class="indexterm" name="id3022075"></a>
				<p><span>unsigned long 
				mysql_thread_id(MYSQL *mysql)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回當前連接的線程<span>ID</span>。該值可用作<span><span>mysql_kill()</span>的參量以殺死線程。</span></p>
				<p>如果連接丟失，並使用<span><span>mysql_ping()</span>進行了再連接，</span>線程<span>ID</span>將改變。這意味著您不應獲取線程<span>ID</span>並保存它供以後使用。應在需要時獲取它。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>當前連接的線程<span>ID</span>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-use-result"></a>25.2.3.68. mysql_use_result()</h4></div></div></div><a class="indexterm" name="id3022161"></a>
				<p><span>MYSQL_RES *mysql_use_result(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於成功檢索數據的每個查詢（<span>SELECT</span>、<span><span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span></span>），必須使用<span>mysql_store_result()</span>或<span><span>mysql_use_result()</span>。</span></p>
				<p><span>
				mysql_use_result()</span>將初始化結果集檢索，但並不像<span><span>mysql_store_result()</span>那樣將結果集實際讀取到客戶端。</span>它必須通過對<span><span>mysql_fetch_row()</span>的使用，對每一行分別進行檢索。</span>這將直接從伺服器讀取結果，而不會將其保存在臨時資料表或本地緩衝區內，與<span><span>mysql_store_result()</span>相比，速度更快而且使用的內存也更少。客戶端僅為當前行和通信緩衝區分配內存，</span>分配的內存可增加到<span>max_allowed_packet</span>字節。</p>
				<p>另一方面，如果您正在客戶端一側為各行進行大量的處理操作，或者將輸出發送到了用戶可能會鍵入「<span>^S</span>」（停止滾動）的屏幕，就不應使用<span>mysql_use_result()</span>。這會綁定伺服器，並阻止其他線程更新任何資料表（數據從這類資料表獲得）。</p>
				<p>使用<span>mysql_use_result()</span>時，必須執行<span>mysql_fetch_row()</span>，直至返回<span><span>NULL</span>值，否則，未獲取的行將作為下一個檢索的一部分返回。</span><span>C 
				API</span>給出命令不同步錯誤，如果忘記了執行該操作，將不能<span>運行該命令。</span></p>
				<p>不應與從<span><span>mysql_use_result()</span>返回的結果一起使用<span>mysql_data_seek()</span></span>、<span>mysql_row_seek()</span>、<span>mysql_row_tell()</span>、<span>mysql_num_rows()</span>或<span><span>mysql_affected_rows()</span>，也不應發出其他查詢，直至<span>mysql_use_result()</span></span>完成為止。（但是，提取了所有行後，<span><span>mysql_num_rows()</span>將準確返回提取的行數）。</span></p>
				<p>一旦完成了對結果集的操作，必須使用<span>mysql_free_result()</span>。</p>
				<p>使用<span><span>libmysqld</span>嵌入式伺服器時，由於在使用<span>mysql_free_result()</span>之前，內存使用將隨著每個檢索的行增加，內存</span>效益將基本喪失。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>MYSQL_RES</span>結果結構。<span>如果出現錯誤，返回<span>NULL</span>。</span><span>
				</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p><span>如果成功，<span>mysql_use_result()</span></span>將復位<span>mysql_error()</span>和<span><span>mysql_errno()</span>。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。<span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。<span>
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。<span> </span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-warning-count"></a>25.2.3.69. mysql_warning_count()</h4></div></div></div><a class="indexterm" name="id3022482"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<span>unsigned int 
		mysql_warning_count(MYSQL *mysql)</span><span> </span>
		<p><strong><span>錯誤</span></strong></p>
		<p>返回執行前一個<span>SQL</span>語句期間生成的告警數目。</p>
		<p><strong><span>返回值</span></strong></p>
		<p>告警計數。</p>
		<p><strong><span>錯誤</span></strong></p>
		<p>無。</p>
		<h3 class="title"><a name="c-api-prepared-statements"></a>
			25.2.4.&nbsp;C API預處理語句</h3></div></div></div>
		<p><span>MySQL</span>客戶端／伺服器協議提供了預處理語句。該功能採用了由<span><span>mysql_stmt_init()</span>初始化函數返回的<span>MYSQL_STMT</span>語句處理程式數據結構。對於多次執行的語句，預處理執行是一種有效的方式。</span>首先對語句進行解析，為執行作好準備。接下來，在以後使用初始化函數返回的語句句柄執行一次或多次。</p>
		<p><span>對於多次執行的語句，預處理執行比直接執行快，主要原因在於</span>，僅對查詢執行一次解析操作。在直接執行的情況下，每次執行語句時，均將進行查詢。此外，由於每次執行預處理語句時僅需發送參數的數據，從而減少了網絡通信量。</p>
		<p>預處理語句的另一個優點是，它採用了二進制協議，從而使得客戶端和伺服器之間的數據傳輸更有效率。</p>
		<p>下述語句可用作預處理語句：<span>CREATE 
		TABLE</span>、<span>DELETE</span>、<span>DO</span>、<span>INSERT</span>、<span>REPLACE</span>、<span>SELECT</span>、<span>SET</span>、<span>UPDATE</span>、以及大多數<span><span>SHOW</span>語句。</span>在<span>MySQL 
		5.1</span>中，不支援其他語句。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-datatypes"></a>
			25.2.5.&nbsp;C API預處理語句的數據類型</h3></div></div></div>
			<p>預處理語句主要使用<span>MYSQL_STMT</span>和<span><span>MYSQL_BIND</span>數據結構。</span>第<span>3</span>種結構<span><span>MYSQL_TIME</span>用於傳輸暫時性數據。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_STMT</span><span> </span>

            <a class="indexterm" name="id3032628"></a>
          	</p>
			<p>該結構資料表示預處理語句。通過使用<span>mysql_stmt_init()</span>建立語句，返回語句句柄，即指向<span><span>MYSQL_STMT</span>的指針。該句柄用戶所有後續的與語句有關的函數，直至使用<span>mysql_stmt_close()</span></span>關閉了它為止。</p>
			<p><span>
			<span>MYSQL_STMT</span>結構沒有供應用程式使用的參數。此外，不應嘗試複製<span>MYSQL_STMT</span></span>結構。不保證這類複製物會有用。</p>
			<p>多個語句句柄能夠與單個連接關聯起來。對句柄數目的限制取決於系統資源。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_BIND</span><a class="indexterm" name="id3032629"></a><span>
			</span></p>
			<p>
			該結構用於語句輸入（發送給伺服器的數據值）和輸出（從伺服器返回的結果值）。對於輸入，它與<span><span>mysql_stmt_bind_param()</span>一起使用，用於將參數數據值綁定到緩衝區上，以供<span>mysql_stmt_execute()</span>使用。對於輸出，它與<span>mysql_stmt_bind_result()</span>一起使用，用於綁定結果緩衝區，</span>以便用於<span>with
			<span>mysql_stmt_fetch()</span></span><span>以獲取行。</span></p>
			<p>
			<span>MYSQL_BIND</span>結構包含下述供應用程式使用的成員。每個成員用於輸入和輸出，但在某些時候，也能用於不同的目的，具體情況取決於數據傳輸的方向。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>enum 
			enum_field_types buffer_type</span><span> </span>
			</p>
			<p>緩衝的類型。在本節後面列出了允許的<span><span>buffer_type</span>值。對於</span>輸入，<span><span>buffer_type</span>指明了與語句參數捆綁的值類型。對於輸出，</span>它指明了您希望從結果緩衝收到的值類型。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>void *buffer</span><span>
			</span></p>
			<p>
			對於輸入，這是指向儲存語句參數數據值的緩衝的指針。對於輸出，它是指向返回結果集列值的緩衝的指針。對於數值列類型，緩衝應指向恰當的<span>C</span>類型變數（如果將該變數與具有<span><span>UNSIGNED</span>屬性的列關聯起來，</span>變數<span>unsigned</span><span> 
			C</span>類型。通過使用<span><span>is_unsigned</span>成員，指明變數是</span><span>signed</span>或<span>unsigned</span>類型，詳情請參見本節後面的介紹）。對於日期和時間列類型，緩衝應指向<span><span>MYSQL_TIME</span>結構。</span>對於字元和二進制字串列類型，緩衝應指向字元緩衝區。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			buffer_length</span><span> </span></p>
			<p><span>
			<span>*buffer</span>的實際大小，單位為字節。</span>它指明了可保存在緩衝區內的最大數據。對於字元和二進制<span>C</span>數據，<span>buffer_length</span>值指定了與<span><span>mysql_stmt_bind_param()</span>一起使用時的<span>*buffer</span></span>長度，或與<span><span>mysql_stmt_bind_result()</span>一起使用時能夠提取到緩衝區內的最大數據。</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			*length</span><span> </span></p>
			<p>指向<span><span>unsigned 
			long</span>變數的指針，該變數指明了儲存在<span>*buffer</span>中數據的實際字節數。<span>「length」</span>用於字元或二進制<span>C</span>數據。對於輸入參數數據綁定，<span>「length」</span>指向<span>unsigned 
			long</span>變數，該變數指明了儲存在<span>*buffer</span>中參數值的長度，供<span>mysql_stmt_execute()</span>使用。對於</span>輸出值綁定，<span><span>mysql_stmt_fetch()</span>會將返回的列值保存到<span>「length」</span>指向的</span>變數中。</p>
			<p><span>
			對於數值和臨時數據類型，<span>「length」</span>將被忽略，原因在於，</span>數據值的長度是由<span>buffer_type</span>值決定的。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool *is_null</span><span>
			</span></p>
			<p>該成員指向<span><span>my_bool</span>變數，如果值為<span>NULL</span>，該變數為<span>「</span>真<span>」</span>，如果值為非<span>Null</span>，</span>該變數為「假」。對於輸入，將<span>*is_null</span>設置為「真」，指明以語句參數的形式傳遞<span>NULL</span>值。對於輸出，如果從語句返回的結果集列值為<span>NULL</span>，當獲取了行後，該值將被設為「真」。</p>
			<p><span>
			<span>「is_null」</span>是指向布爾類型的指針，而不是布爾標量，以便能以下述方式使用它：</span></p>
			<p >
			<span  >§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果數據值總是<span>NULL</span>，使用<span><span>MYSQL_TYPE_NULL</span>綁定列。</span></p>
			<p >
			<span >
			§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果數據值總是<span><span>NOT 
			NULL</span>，設置<span>is_null = (my_bool*) 0</span></span>。</p>
			<p >
			<span  >§<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在所有其他情況下，應將<span><span>is_null</span>設置為<span>my_bool</span></span>變數的地址，並在各次執行之間恰當地更改變數的值，以指明數據值是<span>NULL</span>或<span>NOT 
			NULL</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool 
			is_unsigned</span><span> </span></p>
			<p>該成員用於整數類型。（對應於<span>MYSQL_TYPE_TINY</span>、<span>MYSQL_TYPE_SHORT</span>、<span>MYSQL_TYPE_LONG</span>、以及<span><span>MYSQL_TYPE_LONGLONG</span>類型的代碼）。對於無符號類型，應將</span>「<span><span>is_unsigned」</span>設置為<span>「</span>真<span>」</span>，對於帶符號類型，應將其設置為<span>「</span>假<span>」</span>。</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool error</span><span>
			</span></p>
			<p>對於輸出，該成員用於通報數據截短錯誤。必須通過使用帶有<span><span>MYSQL_REPORT_DATA_TRUNCATION</span>選項的<span>mysql_options()</span>，啟用</span>截短通報功能。允許該功能後，<span>mysql_stmt_fetch()</span>返回<span><span>MYSQL_DATA_TRUNCATED</span>，而且對於出現截短情況的參數，在<span>MYSQL_BIND</span>結構中，錯誤標誌為<span>「</span>真<span>」</span>。截短指明丟失了符號或有效位數，或字串過長以至於無法容納在<span>1</span>列中。</span></p>
			<p>要想使用<span>MYSQL_BIND</span>結構，應將其內容置為<span>0</span>以便初始化它，然後對其進行設置，恰當地描述它。例如，要想聲明並初始化<span>三個MYSQL_BIND</span><span>結構的數組，可使用下述代碼：</span></p>
			<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[3];</span></pre>
			<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			MYSQL_TIME</span><a class="indexterm" name="id3032630"></a><span>
			</span></p>
			<p>該結構用於將<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>和<span>TIMESTAMP</span>數據直接發送到伺服器，或從伺服器直接接收這類數據。將<span><span>MYSQL_BIND</span>結構的<span>buffer_type</span>成員設置為臨時值之一，並將<span>buffer</span>成員設置為指向<span>MYSQL_TIME</span></span>結構，即可實現該點。</p>
			<p><span>
			<span>MYSQL_TIME</span>結構包含下述成員：</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			year</span><span> </span></p>
			<p>年份</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			month</span><span> </span></p>
			<p>月份</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			day</span><span> </span></p>
			<p>天</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			hour</span><span> </span></p>
			<p>小時</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			minute</span><span> </span></p>
			<p>分鐘</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned int 
			second</span><span> </span></p>
			<p>秒</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>my_bool neg</span><span>
			</span></p>
			<p>布爾標誌，用於指明時間是否為負數。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>unsigned long 
			second_part</span><span> </span></p>
			<p>秒的分數部分。該成員目前不使用。</p>
			<p>僅使用施加在給定臨時類型值上的<span><span>MYSQL_TIME</span>結構的部分</span>：用於<span>DATE</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>的</span>年、月、日部分。用於<span>TIME</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>值的小時、分鐘、秒部分</span>。請參見<a href="apis.html#c-api-date-handling" title="25.2.10. C API Handling of Date and Time Values">25.2.10節，「日期和時間值的C API處理」</a>。</p>
			<p>在下面的資料表格中，給出了可在<span><span>MYSQL_BIND</span>結構的<span>buffer_type</span>成員中指定的允許值。在該資料表中，還給出了與每個<span>buffer_type</span>值最接近的對應</span><span>SQL</span>類型，對於數值和臨時類型，給出了對應的<span>C</span>類型。</p>
			<table border="1" cellpadding="0" id="table11">
				<tr>
					<td>
					<p>
					<span>buffer_type</span><strong><span>值</span></strong></td>
					<td>
					<p><strong>
					<span>SQL</span><span>類型</span></strong></td>
					<td>
					<p><strong>
					<span>C</span><span>類型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY</span></td>
					<td>
					<p>
					<span>TINYINT</span></td>
					<td>
					<p>
					<span>char</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_SHORT</span></td>
					<td>
					<p>
					<span>SMALLINT</span></td>
					<td>
					<p>
					<span>short int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG</span></td>
					<td>
					<p>
					<span>INT</span></td>
					<td>
					<p>
					<span>int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONGLONG</span></td>
					<td>
					<p>
					<span>BIGINT</span></td>
					<td>
					<p>
					<span>long long int</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_FLOAT</span></td>
					<td>
					<p>
					<span>FLOAT</span></td>
					<td>
					<p>
					<span>float</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DOUBLE</span></td>
					<td>
					<p>
					<span>DOUBLE</span></td>
					<td>
					<p>
					<span>double</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIME</span></td>
					<td>
					<p>
					<span>TIME</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATE</span></td>
					<td>
					<p>
					<span>DATE</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_DATETIME</span></td>
					<td>
					<p>
					<span>DATETIME</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TIMESTAMP</span></td>
					<td>
					<p>
					<span>TIMESTAMP</span></td>
					<td>
					<p>
					<span>MYSQL_TIME</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_STRING</span></td>
					<td>
					<p>
					<span>CHAR</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_VAR_STRING</span></td>
					<td>
					<p>
					<span>VARCHAR</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_TINY_BLOB</span></td>
					<td>
					<p>
					<span>TINYBLOB/TINYTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_BLOB</span></td>
					<td>
					<p>
					<span>BLOB/TEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_MEDIUM_BLOB</span></td>
					<td>
					<p>
					<span>MEDIUMBLOB/MEDIUMTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MYSQL_TYPE_LONG_BLOB</span></td>
					<td>
					<p>
					<span>LONGBLOB/LONGTEXT</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
			</table>
			<p>隱式類型轉換可沿兩個方向執行。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-function-overview"></a>
			25.2.6.&nbsp;C API預處理語句函數概述</h3></div></div></div><a class="indexterm" name="id3023820"></a><a class="indexterm" name="id3023830"></a>
			<p>在此歸納了預處理語句處理功能可使用的函數，並在後面的章節中詳細介紹了它。請參見<a href="apis.html#c-api-prepared-statement-functions" title="25.2.7. C API Prepared Statement Function Descriptions">25.2.7節，「C API預處理語句函數描述」</a>。</p>
			<table border="1" cellpadding="0" id="table12">
				<tr>
					<td>
					<p><strong><span>
					函數</span></strong></td>
					<td>
					<p><strong><span>
					描述</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_affected_rows()</span></strong></td>
					<td>
					<p>返回由預處理語句<span>UPDATE</span>、<span>DELETE</span>或<span>INSERT</span>變更、刪除或插入的行數目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_attr_get()</span></strong></td>
					<td>
					<p>獲取預處理語句屬性的值。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_attr_set()</span></strong></td>
					<td>
					<p>設置預處理語句的屬性。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_bind_param()</span></strong></td>
					<td>
					<p>將應用程式數據緩衝與預處理<span>SQL</span>語句中的參數標記符關聯起來。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_bind_result()</span></strong></td>
					<td>
					<p>將應用程式數據緩衝與結果集中的列關聯起來。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_close()</span></strong></td>
					<td>
					<p>釋放預處理語句使用的內存。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_data_seek()</span></strong></td>
					<td>
					<p>尋找語句結果集中的任意行編號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_errno()</span></strong></td>
					<td>
					<p>返回上次語句執行的錯誤編號。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_error()</span></strong></td>
					<td>
					<p>返回上次語句執行的錯誤消息。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_execute()</span></strong></td>
					<td>
					<p>執行預處理語句。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_fetch()</span></strong></td>
					<td>
					<p>從結果集獲取數據的下一行，並返回所有綁定列的數據。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_fetch_column()</span></strong></td>
					<td>
					<p>獲取結果集當前行中某列的數據。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_field_count()</span></strong></td>
					<td>
					<p>對於最近的語句，返回結果行的數目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_free_result()</span></strong></td>
					<td>
					<p>釋放分配給語句句柄的資源。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_init()</span></strong></td>
					<td>
					<p><span>為<span>MYSQL_STMT</span>結構分配內存並初始化它</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_insert_id()</span></strong></td>
					<td>
					<p>對於預處理語句的<span><span>AUTO_INCREMENT</span>列，</span>返回生成的<span>ID</span>。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_num_rows()</span></strong></td>
					<td>
					<p>從語句緩衝結果集返回總行數。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_param_count()</span></strong></td>
					<td>
					<p>返回預處理<span>SQL</span>語句中的參數數目。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_param_metadata()</span></strong></td>
					<td>
					<p>返回結果集的參數元數據。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_prepare()</span></strong></td>
					<td>
					<p>為執行操作準備<span>SQL</span>字串。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>mysql_stmt_reset()</span></strong></td>
					<td>
					<p>復位伺服器中的語句緩衝區。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_result_metadata()</span></strong></td>
					<td>
					<p>以結果集形式返回預處理語句元數據。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_row_seek()</span></strong></td>
					<td>
					<p>使用從<span><span>mysql_stmt_row_tell()</span>返回的值，搜尋語句結果集中的行偏移。</span></td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_row_tell()</span></strong></td>
					<td>
					<p>返回語句行光標位置。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_send_long_data()</span></strong></td>
					<td>
					<p>將程式塊中的長數據發送到伺服器。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_sqlstate()</span></strong></td>
					<td>
					<p>返回關於上次語句執行的<span>SQLSTATE</span>錯誤代碼。</td>
				</tr>
				<tr>
					<td>
					<p><strong>
					<span>
					mysql_stmt_store_result()</span></strong></td>
					<td>
					<p>將完整的結果集檢索到客戶端。</td>
				</tr>
			</table>
			<p>使用<span>mysql_stmt_init()</span>以建立語句句柄，然後使用<span>mysql_stmt_prepare</span>準備語句，使用<span>mysql_stmt_bind_param()</span>提供參數數據，並使用<span><span>mysql_stmt_execute()</span>執行語句。通過更改<span>mysql_stmt_bind_param()</span>提供的相應緩衝區中的參數值，可重複執行<span>mysql_stmt_execute()</span>。</span></p>
			<p>如果語句是<span><span>SELECT</span>或任何其他能生成結果集的語句，<span>mysql_stmt_prepare()</span></span>也會通過<span><span>mysql_stmt_result_metadata()</span>以<span>MYSQL_RES</span>結果集的形式</span>返回結果集元數據訊息。</p>
			<p>您可以使用<span><span>mysql_stmt_bind_result()</span>提供結果緩衝，以便<span>mysql_stmt_fetch()</span>能自動將數據返回給這些緩衝。</span>這是一種按行獲取方式。</p>
			<p>此外，您也能使用<span><span>mysql_stmt_send_long_data()</span>將程式塊中的文本或二進制數據發送到伺服器。</span>請參見<a href="apis.html#mysql-stmt-send-long-data" title="25.2.7.25. mysql_stmt_send_long_data()">25.2.7.25節，「mysql_stmt_send_long_data()」</a>。</p>
			<p>完成語句執行後，必須使用<span><span>mysql_stmt_close()</span>關閉語句句柄，以便與之相關的所有資源均能被釋放。</span></p>
			<p>如果通過使用<span><span>mysql_stmt_result_metadata()</span>獲得了<span>SELECT</span>語句的結果集</span>元數據，也應<span>使用mysql_free_result()</span>釋放元數據。</p>
			<p><strong><span>執行步驟</span></strong></p>
			<p>要想準備和執行語句，應用程式必須採取下述步驟：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>用<span><span>msyql_stmt_init()</span>建立預處理語句句柄。要想在伺服器上準備預處理語句，可使用<span>mysql_stmt_prepare()</span>，並為其傳遞包含<span>SQL</span>語句的字串。</span></p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果語句生成了結果集，使用<span>mysql_stmt_result_metadata()</span>以獲得結果集元數據。雖然與包含查詢返回列的結果集不同，該元數據本身也採用了結果集的形式。元數據結果集指明了結果中包含多少列，並包含每一列的訊息。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_bind_param()</span>設置任何參數的值。必須設置所有參數。否則，語句執行將返回錯誤，或生成無法預料的結果。</span></p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_execute()</span>執行語句。</span></p>
			<p>
			<span>5.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果語句生成了結果集，捆綁數據緩衝，通過使用<span><span>mysql_stmt_bind_result()</span>，檢索行值。</span></p>
			<p>
			<span>6.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過重複使用<span><span>mysql_stmt_fetch()</span>，按行將數據提取到緩衝區</span>，直至未發現更多行為止。</p>
			<p>
			<span>7.<span>&nbsp;&nbsp;&nbsp;
			</span></span>通過更改參數值並再次執行語句，重複步驟<span>3</span>到步驟<span>6</span>。</p>
			<p>使用<span><span>mysql_stmt_prepare()</span>時，</span><span>MySQL</span>客戶端／伺服器協議將執行下述動作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>伺服器解析語句，並通過賦值語句<span>ID</span>將<span>OK</span>狀態發回客戶端。此外，如果它是面向結果集的語句，還將發送總的參數數目，列計數和元數據。在此使用過程中，伺服器將檢查語句的所有語法和語義。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>客戶端採用該語句<span>ID</span>用於進一步操作，以便伺服器能從其語句池中識別語句。</p>
			<p>使用<span><span>mysql_stmt_execute()</span>時，</span><span>MySQL</span>客戶端／伺服器協議將執行下述動作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>客戶端使用語句句柄，並將參數數據發送到伺服器。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>伺服器使用由客戶端提供的<span>ID</span>來識別語句，用新提供的數據替換參數標記符，並執行語句。如果語句生成了結果集，伺服器將數據發回客戶端。否則，伺服器會將發送<span>OK</span>狀態，以及總的變更、刪除和插入行數。</p>
			<p>使用<span><span>mysql_stmt_fetch()</span>時，</span><span>MySQL</span>客戶端／伺服器協議將執行下述動作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			客戶端按行從訊息包讀取數據，並通過執行必要的轉換操作將其放入應用程式數據緩衝中。如果應用程式的緩衝類型與伺服器返回的字段類型相同，轉換十分簡明。</p>
			<p>如果出現了錯誤，可分別使用<span>mysql_stmt_errno()</span>、<span>mysql_stmt_error()</span>和<span>mysql_stmt_sqlstate()</span>獲取語句錯誤代碼、錯誤消息和<span>SQLSTATE</span>值。</p>
			<p><strong><span>預處理語句日誌功能</span></strong></p>
			<p>對於與<span>mysql_stmt_prepare()</span>和<span>mysql_stmt_execute()</span><span> 
			C API</span>函數一起執行的預處理語句，伺服器會將「準備」和「執行」行寫入一般查詢日誌，以便您能瞭解語句是在何時準備和執行的。</p>
			<p>假定按下述方式準備和執行了語句：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_prepare()</span>以準備</span>語句字串<span>&quot;SELECT 
			?&quot;</span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_bind_param()</span>將值<span>「3」</span>綁定到預處理語句中的參數。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><span>mysql_stmt_execute()</span>，執行預處理語句。</span></p>
			<p>上述使用的結果是，伺服器將下述行寫入一般查詢日誌：</p>
			<pre><span>Prepare&nbsp; [1] SELECT ?</span></pre>
			<pre><span>Execute&nbsp; [1] SELECT 3</span></pre>
			<p>日誌中的每個「準備」和「執行」行均具有<span><span>[<i>n</i>]</span>語句<span>ID</span>標識，這樣，您就能跟蹤已記錄的預處理語句。<i><span>N</span></i></span>是正整數。對於客戶端，如果同時有多個活動的預處理語句，<span><i><span>n</span></i></span>可能會大於<span>1</span>。替換了「<span>?</span>」參數的數據值後，每個「執行」行將顯示一條預處理語句。</p>
			<p>版本說明：在<span>MySQL 4.1.10</span>之前，顯示的「準備」行無<span><span>[<i>n</i>]</span>標識。在</span><span>MySQL 
			4.1.10</span>之前，不顯示「執行」行。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-functions"></a>
			25.2.7.&nbsp;C API預處理語句函數描述</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-stmt-affected-rows">25.2.7.1. mysql_stmt_affected_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-attr-get">25.2.7.2. mysql_stmt_attr_get()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-attr-set">25.2.7.3. mysql_stmt_attr_set()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-bind-param">25.2.7.4. mysql_stmt_bind_param()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-bind-result">25.2.7.5. mysql_stmt_bind_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-close">25.2.7.6. mysql_stmt_close()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-data-seek">25.2.7.7. mysql_stmt_data_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-errno">25.2.7.8. mysql_stmt_errno()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-error">25.2.7.9. mysql_stmt_error()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-execute">25.2.7.10. mysql_stmt_execute()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-fetch">25.2.7.11. mysql_stmt_fetch()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-fetch-column">25.2.7.12. mysql_stmt_fetch_column()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-field-count">25.2.7.13. mysql_stmt_field_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-free-result">25.2.7.14. mysql_stmt_free_result()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-init">25.2.7.15. mysql_stmt_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-insert-id">25.2.7.16. mysql_stmt_insert_id()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-num-rows">25.2.7.17. mysql_stmt_num_rows()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-param-count">25.2.7.18. mysql_stmt_param_count()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-param-metadata">25.2.7.19. mysql_stmt_param_metadata()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-prepare">25.2.7.20. mysql_stmt_prepare()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-reset">25.2.7.21. mysql_stmt_reset()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-result-metadata">25.2.7.22. mysql_stmt_result_metadata()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-row-seek">25.2.7.23. mysql_stmt_row_seek()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-row-tell">25.2.7.24. mysql_stmt_row_tell()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-send-long-data">25.2.7.25. mysql_stmt_send_long_data()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-sqlstate">25.2.7.26. mysql_stmt_sqlstate()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-stmt-store-result">25.2.7.27. mysql_stmt_store_result()</a></span></dt></dl></div>
			<p>為了準備和執行查詢，請使用下述部分詳細介紹的函數。</p>
			<p>注意，與<span><span>MYSQL_STMT</span>結構一起使用的所有函數均以前綴<span>mysql_stmt_</span></span>開始。</p>
			<p>要想建立<span><span>MYSQL_STMT</span>句柄，請使用<span>mysql_stmt_init()</span></span>函數。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-affected-rows"></a>25.2.7.1. mysql_stmt_affected_rows()</h4></div></div></div><a class="indexterm" name="id3024852"></a>
				<p><span>my_ulonglong 
				mysql_stmt_affected_rows(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回上次執行語句更改、刪除或插入的總行數。對於<span>UPDATE</span>、<span>DELETE</span>或<span>INSERT</span>語句，可在<span><span>mysql_stmt_execute()</span>之後立刻使用它們。</span>對於<span>SELECT</span>語句，<span><span>mysql_stmt_affected_rows()</span>的工作方式類似於<span>mysql_num_rows()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>大於<span>0</span>的整數指明了受影響或檢索的行數。對於<span>UPDATE</span>語句，「<span>0</span>」表明未更新任何記錄，在查詢中沒有與<span><span>WHERE</span>子句匹配的行，或尚未執行任何查詢。</span>「<span>-1</span>」表明返回了錯誤，或對<span>SELECT</span>查詢，在使用<span><span>mysql_stmt_store_result()</span>之前使用了<span>mysql_stmt_affected_rows()</span></span>。由於<span>mysql_stmt_affected_rows()</span>返回無符號值，可通過比較返回值和「<span><span>(my_ulonglong)-1」</span>（或等效的<span>「(my_ulonglong)~0」</span>）</span>，檢查「<span>-1</span>」。</p>
				<p>關於返回值的額外訊息，請參見<a href="apis.html#mysql-affected-rows" title="25.2.3.1. mysql_affected_rows()">25.2.3.1節，「mysql_affected_rows()」</a>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_affected_rows()</span>的用法，</span>請參閱<a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-get"></a>25.2.7.2. mysql_stmt_attr_get()</h4></div></div></div><a class="indexterm" name="id3025030"></a>
				<p><span>int 
				mysql_stmt_attr_get(MYSQL_STMT *stmt, enum enum_stmt_attr_type 
				option, void *arg)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>可用於獲得語句屬性的當前值。</p>
				<p>「<span><span>option」</span>參量是希望獲取的選項，<span>「arg」</span>應指向包含選項值的變數。如果</span>「<span>option</span>」是整數，那麼「<span><span>arg」</span>應指向</span>整數的值。</p>
				<p>關於選項和選項類型的清單，請參見<a href="apis.html#mysql-stmt-attr-set" title="25.2.7.3. mysql_stmt_attr_set()">25.2.7.3節，「mysql_stmt_attr_set()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果<span>OK</span>，返回<span>0</span>。</span>如果選項未知，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-set"></a>25.2.7.3. mysql_stmt_attr_set()</h4></div></div></div><a class="indexterm" name="id3025135"></a>
				<p><span>int 
				mysql_stmt_attr_set(MYSQL_STMT *stmt, enum enum_stmt_attr_type 
				option, const void *arg)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>可用於影響預處理語句的行為。可多次使用該函數來設置多個選項。</p>
				<p>「<span><span>option」</span>參量是希望設置的選項，</span>「<span><span>arg」</span>參量</span>是選項的值。<span>如果</span>「<span>option</span>」是整數，那麼「<span><span>arg」</span>應指向</span>整數的值。</p>
				<p>可能的選項值：</p>
				<table border="1" cellpadding="0" id="table13">
					<tr>
						<td>
						<p><strong>
						<span>選項</span></strong></td>
						<td>
						<p><strong>
						<span>參量類型</span></strong></td>
						<td>
						<p><strong>
						<span>功能</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_UPDATE_MAX_LENGTH</span></td>
						<td>
						<p>
						<span>my_bool *</span></td>
						<td>
						<p>如果設為<span>1</span>：更新<span><span>mysql_stmt_store_result()</span>中的</span>元數據<span>MYSQL_FIELD-&gt;max_length</span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_CURSOR_TYPE</span></td>
						<td>
						<p>
						<span>unsigned long *</span></td>
						<td>
						<p>使用<span><span>mysql_stmt_execute()</span>時，語句將打開的光標類型。<span>*arg</span>可以是<span>CURSOR_TYPE_NO_CURSOR</span>（預設值）或<span>CURSOR_TYPE_READ_ONLY</span></span>。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>STMT_ATTR_PREFETCH_ROWS</span></td>
						<td>
						<p>
						<span>unsigned long *</span></td>
						<td>
						<p>使用光標時，一次從伺服器獲取的行數。<span><span>*arg</span>的範圍從<span>1</span>到<span>unsigned 
						long</span>的最大值。預設值為<span>1</span>。</span></td>
					</tr>
				</table>
				<p>如果與<span><span>CURSOR_TYPE_READ_ONLY</span>一起使用了<span>STMT_ATTR_CURSOR_TYPE</span></span>選項，當使用了<span><span>mysql_stmt_execute()</span>時，將為語句打開光標。如果存在由前一個<span>mysql_stmt_execute()</span>使用打開的光標，在打開新的光標前，將關閉該光標。此外，為再執行而準備語句之前，<span>mysql_stmt_reset()</span>還將關閉任何打開的光標。<span>mysql_stmt_free_result()</span>將關閉任何打開的光標。</span></p>
				<p>如果為預處理語句打開了光標，沒必要使用<span>mysql_stmt_store_result()</span>，這是因為，該函數會導致在客戶端一側對結果集進行緩衝處理。</p>
				<p>在<span>MySQL 5.0.2<span>中增加了</span><span>STMT_ATTR_CURSOR_TYPE</span></span>選項。在<span>MySQL 
				5.0.6</span>中，增加了<span><span>STMT_ATTR_PREFETCH_ROWS</span>選項。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>如果<span>OK</span>，返回<span>0</span>。</span>如果選項未知，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<p>在下述示範中，為預處理語句打開了<span>1</span>個光標，並將每次獲取的行數設為<span>5</span>：</p>
				<pre><span>MYSQL_STMT *stmt;</span></pre>
				<pre><span>int rc;</span></pre>
				<pre><span>unsigned long type;</span></pre>
				<pre><span>unsigned long prefetch_rows = 5;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>type = (unsigned long) CURSOR_TYPE_READ_ONLY;</span></pre>
				<pre><span>rc = mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &amp;type);</span></pre>
				<pre><span>/* ... check return value ... */</span></pre>
				<pre><span>rc = mysql_stmt_attr_set(stmt, STMT_ATTR_PREFETCH_ROWS,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; (void*) &amp;prefetch_rows);</span></pre>
				<pre><span>/* ... check return value ... */</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-param"></a>25.2.7.4. mysql_stmt_bind_param()</h4></div></div></div><a class="indexterm" name="id3025455"></a>
				<p><span>my_bool 
				mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span><span>
				mysql_stmt_bind_param()</span>用於</span>為<span>SQL</span>語句中的參數標記符綁定數據，以傳遞給<span><span>mysql_stmt_prepare()</span>。它使用<span>MYSQL_BIND</span>結構來提供數據。</span>「<span><span>bind」</span>是<span>MYSQL_BIND</span>結構的某一數組的地址。按照客戶端庫的預期，對於查詢中出現的每個<span>「?」</span>參數標記符，數組中均包含<span>1</span>個元素。</span></p>
				<p>假定您準備了下述語句：</p>
				<pre><span>INSERT INTO mytbl VALUES(?,?,?)</span></pre>
				<p>綁定參數時，<span><span>MYSQL_BIND</span>結構的數組包含</span><span>3</span>個元素，並能聲明如下：</p>
				<pre><span>MYSQL_BIND bind[3];</span></pre>
				<p>在<a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5節，「C API預處理語句的數據類型」</a>中，介紹了應設置的每個<span><span>MYSQL_BIND</span>元素的成員。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果綁定成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_INVALID_BUFFER_USE</span><span> </span></p>
				<p>指明「<span>bind</span>」（綁定）是否將提供程式塊中的長數據，以及緩衝類型是否為非字串或二進制類型。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>不支援該轉換。或許<span><span>buffer_type</span>值是非法的，或不是所支援的類型之一。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_bind_param()</span>的用法，請參見</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-result"></a>25.2.7.5. mysql_stmt_bind_result()</h4></div></div></div><a class="indexterm" name="id3025676"></a>
				<p><span>my_bool 
				mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_bind_result()</span>用於將結果集中的列與數據緩衝和長度緩衝關聯（綁定）起來。當使用<span><span>mysql_stmt_fetch()</span>以獲取數據時，</span><span>MySQL</span>客戶端／伺服器協議會將綁定列的數據置於指定的緩衝區內。</p>
				<p>使用<span><span>mysql_stmt_fetch()</span>之前，必須</span>將所有列綁定到緩衝。<span><span>「bind」</span>是<span>MYSQL_BIND</span>結構某一數組的地址。</span>按照客戶端庫的預期，對於結果集中的每一列，數組應包含相應的元素。如果未將列綁定到<span>MYSQL_BIND</span>結構，<span>mysql_stmt_fetch()</span>將簡單地忽略數據獲取操作。緩衝區應足夠大，足以容納數據值，這是因為協議不返回成塊的數據值。</p>
				<p>可以在任何時候綁定或再綁定列，即使已部分檢索了結果集後也同樣。新的綁定將在下一次使用<span><span>mysql_stmt_fetch()</span>時起作用。假定某一應用程式綁定了結果集中的列，並使用了<span>mysql_stmt_fetch()</span>。客戶端／伺服器協議將返回綁定緩衝區中的數據。接下來，假定應用程式將多個列綁定到不同的緩衝。該協議不會將數據置於新綁定的緩衝區，直至</span>下次使用<span>mysql_stmt_fetch()</span>為止。</p>
				<p>要想綁定列，應用程式將使用<span><span>mysql_stmt_bind_result()</span>，並傳遞類型、地址、以及長度緩衝的地址。在</span><a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5節，「C API預處理語句的數據類型」</a>中，介紹了應設置的各<span><span>MYSQL_BIND</span>元素的成員。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果綁定成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>不支援該轉換。或許<span>buffer_type</span>值是非法的，或不是所支援的類型之一。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_bind_result()</span>的用法，請參見</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11節，「mysql_stmt_fetch()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-close"></a>25.2.7.6. mysql_stmt_close()</h4></div></div></div><a class="indexterm" name="id3025901"></a>
				<p><span>my_bool 
				mysql_stmt_close(MYSQL_STMT *)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>關閉預處理語句。此外，<span><span>mysql_stmt_close()</span>還會取消由<span>「stmt」</span>指向的語句句柄分配。</span></p>
				<p>如果當前語句已掛起或未讀取結果，該函數將取消它們，以便能執行下一個查詢，</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功釋放了語句，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_close()</span>的用法，請參見</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-data-seek"></a>25.2.7.7. mysql_stmt_data_seek()</h4></div></div></div><a class="indexterm" name="id3026036"></a>
				<p><span>void 
				mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>搜尋語句結果集中的任意行。偏移量為行編號，應位於從<span>0</span>到<span>mysql_stmt_num_rows(stmt)-1</span>的範圍內。</p>
				<p>該函數要求語句結果集結構包含上次執行查詢的全部結果，這樣，<span><span>mysql_stmt_data_seek()</span>就能與<span>mysql_stmt_store_result()</span></span>一起使用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-errno"></a>25.2.7.8. mysql_stmt_errno()</h4></div></div></div><a class="indexterm" name="id3026132"></a>
				<p><span>unsigned int 
				mysql_stmt_errno(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於由<span><span>stmt</span>指定的語句，<span>mysql_stmt_errno()</span>將返回最近使用的語句<span>API</span>函數的錯誤代碼，該函數或成功或失敗。</span>「<span>0</span>」返回值資料表示未出現錯誤。在<span>MySQL
				<span>errmsg.h</span></span><span>頭檔案中列出了客戶端錯誤消息編號。在<span>mysqld_error.h</span>中，列出了伺服器錯誤消息。</span>此外，在<a href="error-handling.html">附錄B：</a><a href="error-handling.html" title="Appendix B. Error Codes and Messages"><i>錯誤代碼和消息</i></a>中，也列出了錯誤消息。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>錯誤代碼值。如果未出現錯誤，返回<span>0</span>。 </p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-error"></a>25.2.7.9. mysql_stmt_error()</h4></div></div></div><a class="indexterm" name="id3026228"></a>
				<p><span>const char *mysql_stmt_error(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於由<span><span>stmt</span>指定的語句，<span>mysql_stmt_error()</span>返回由<span>Null</span>終結的字串，該字串包含最近使用的語句<span>API</span>函數的錯誤消息，該函數或成功或失敗。如果未出現錯誤，返回</span>空字串<span>(<span>&quot;&quot;</span>)</span>。這意味著下述兩個測試是等效的：</p>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_stmt_errno(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_stmt_error(stmt)[0])</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; // an error occurred</span></pre>
				<pre><span>}</span></pre>
				<p>通過重新編譯<span>MySQL</span>客戶端庫，可更改客戶端錯誤消息的語言。目前，能夠選擇數種語言之一顯示錯誤消息。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>描述了錯誤的字串。如果未出現錯誤，返回空字串。 </p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-execute"></a>25.2.7.10. mysql_stmt_execute()</h4></div></div></div><a class="indexterm" name="id3026327"></a>
				<p><span>int 
				mysql_stmt_execute(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_execute()</span>執行與語句句柄相關的預處理查詢。在該使用期間，將當前綁定的參數標記符的值發送到伺服器，伺服器用新提供的數據替換標記符。</p>
				<p>如果語句是<span>UPDATE</span>、<span>DELETE</span>或<span><span>INSERT</span>，通過使用<span>mysql_stmt_affected_rows()</span>，可發現</span>更改、刪除或插入的總行數。如果這是諸如<span>SELECT</span>等能生成結果集的語句，使用任何其他能導致查詢處理的函數之前，必須使用<span><span>mysql_stmt_fetch()</span>來獲取數據。關於如何獲取結果的更多訊息，請參見</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11節，「mysql_stmt_fetch()」</a>。</p>
				<p>對於生成結果集的語句，執行語句之前，可通過使用<span><span>mysql_stmt_attr_set()</span>，</span>請求<span><span>mysql_stmt_execute()</span>為語句打開光標。</span>如果多次執行某一語句，在打開新的光標前，<span>mysql_stmt_execute()</span>將關閉任何已打開的光標。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果執行成功，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>在下面的示範中，介紹了使用<span>mysql_stmt_init()</span>、<span>mysql_stmt_prepare()</span>、<span>mysql_stmt_param_count()</span>、<span>mysql_stmt_bind_param()</span>、<span><span>mysql_stmt_execute()</span>、以及<span>mysql_stmt_affected_rows()</span>建立和填充資料表的方法。假定<span>mysql</span>變數具有有效的連接句柄。</span></p>
				<pre><span>#define STRING_SIZE 50</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>#define DROP_SAMPLE_TABLE &quot;DROP TABLE IF EXISTS test_table&quot;</span></pre>
				<pre><span>#define CREATE_SAMPLE_TABLE &quot;CREATE TABLE test_table(col1 INT,\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 VARCHAR(40),\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col3 SMALLINT,\</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col4 TIMESTAMP)&quot;</span></pre>
				<pre><span>#define INSERT_SAMPLE &quot;INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_STMT&nbsp;&nbsp;&nbsp; *stmt;</span></pre>
				<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[3];</span></pre>
				<pre><span>my_ulonglong&nbsp; affected_rows;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param_count;</span></pre>
				<pre><span>short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small_data;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int_data;</span></pre>
				<pre><span>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_data[STRING_SIZE];</span></pre>
				<pre><span>unsigned long str_length;</span></pre>
				<pre><span>my_bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_null;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(mysql, DROP_SAMPLE_TABLE))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; DROP TABLE failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_error(mysql));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (mysql_query(mysql, CREATE_SAMPLE_TABLE))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; CREATE TABLE failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_error(mysql));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Prepare an INSERT query with 3 parameters */</span></pre>
				<pre><span>/* (the TIMESTAMP column is not named; the server */</span></pre>
				<pre><span>/*&nbsp; sets it to the current date and time) */</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_prepare(), INSERT failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>fprintf(stdout, &quot; prepare, INSERT successful\n&quot;);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the parameter count from the statement */</span></pre>
				<pre><span>param_count= mysql_stmt_param_count(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total parameters in INSERT: %d\n&quot;, param_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (param_count != 3) /* validate parameter count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid parameter count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the data for all 3 parameters */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INTEGER PARAM */</span></pre>
				<pre><span>/* This is a number type, so there is no need to specify buffer_length */</span></pre>
				<pre><span>bind[0].buffer_type= MYSQL_TYPE_LONG;</span></pre>
				<pre><span>bind[0].buffer= (char *)&amp;int_data;</span></pre>
				<pre><span>bind[0].is_null= 0;</span></pre>
				<pre><span>bind[0].length= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* STRING PARAM */</span></pre>
				<pre><span>bind[1].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span>bind[1].buffer= (char *)str_data;</span></pre>
				<pre><span>bind[1].buffer_length= STRING_SIZE;</span></pre>
				<pre><span>bind[1].is_null= 0;</span></pre>
				<pre><span>bind[1].length= &amp;str_length;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* SMALLINT PARAM */</span></pre>
				<pre><span>bind[2].buffer_type= MYSQL_TYPE_SHORT;</span></pre>
				<pre><span>bind[2].buffer= (char *)&amp;small_data;</span></pre>
				<pre><span>bind[2].is_null= &amp;is_null;</span></pre>
				<pre><span>bind[2].length= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_param(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_bind_param() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Specify the data values for the first row */</span></pre>
				<pre><span>int_data= 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* integer */</span></pre>
				<pre><span>strncpy(str_data, &quot;MySQL&quot;, STRING_SIZE); /* string&nbsp; */</span></pre>
				<pre><span>str_length= strlen(str_data);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INSERT SMALLINT data as NULL */</span></pre>
				<pre><span>is_null= 1;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the INSERT statement - 1*/</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute(), 1 failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the total number of affected rows */</span></pre>
				<pre><span>affected_rows= mysql_stmt_affected_rows(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total affected rows(insert 1): %lu\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) affected_rows);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (affected_rows != 1) /* validate affected rows */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid affected rows by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Specify data values for second row, then re-execute the statement */</span></pre>
				<pre><span>int_data= 1000;</span></pre>
				<pre><span>strncpy(str_data, &quot;The most popular Open Source database&quot;, STRING_SIZE);</span></pre>
				<pre><span>str_length= strlen(str_data);</span></pre>
				<pre><span>small_data= 1000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* smallint */</span></pre>
				<pre><span>is_null= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reset */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the INSERT statement - 2*/</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute, 2 failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the total rows affected */</span></pre>
				<pre><span>affected_rows= mysql_stmt_affected_rows(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total affected rows(insert 2): %lu\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) affected_rows);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (affected_rows != 1) /* validate affected rows */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid affected rows by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Close the statement */</span></pre>
				<pre><span>if (mysql_stmt_close(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; failed while closing the statement\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<p><strong><span>註釋</span></strong>：關於使用預處理語句函數的完整示範，請參見檔案<span>tests/mysql_client_test.c</span>。該檔案可從<span>MySQL</span>原始碼分發版獲得，或從<span>BitKeeper</span>原始碼倉庫獲得。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch"></a>25.2.7.11. mysql_stmt_fetch()</h4></div></div></div><a class="indexterm" name="id3026780"></a>
				<p><span>int 
				mysql_stmt_fetch(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p><span>
				mysql_stmt_fetch()</span>返回結果集中的下一行。僅能當結果集存在時使用它，也就是說，使用了能建立結果集的<span><span>mysql_stmt_execute()</span>之後，</span>或當<span><span>mysql_stmt_execute()</span>對整個結果集即行緩衝處理後</span>使用了<span><span>mysql_stmt_store_result()</span>。</span></p>
				<p><span>使用<span>mysql_stmt_bind_result()</span>綁定的緩衝，<span>mysql_stmt_fetch()</span></span>返回行數據。對於當前列集合中的所有列，它將返回緩衝內的數據，並將長度返回到長度指針。</p>
				<p>使用<span><span>mysql_stmt_fetch()</span>之前，應用程式必須綁定所有列。</span></p>
				<p>如果獲取的數據值是<span>NULL</span>值，對應<span><span>MYSQL_BIND</span>結構的<span>*is_null</span>值將包含</span><span>TRUE 
				(1)</span>。否則，將根據應用程式指定的緩衝類型，在<span>*buffer</span>和<span><span>*length</span>內返回數據及其長度。每個數值類型和臨時類型都有固定的長度，請參見下面的資料表格。字串類型的長度取決於由<span>data_length</span>指明的</span>實際數據值的長度。</p>
				<table border="1" cellpadding="0" id="table14">
					<tr>
						<td>
						<p><strong>
						<span>類型</span></strong></td>
						<td>
						<p><strong>
						<span>長度</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_TINY</span></td>
						<td>
						<p><span>1</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_SHORT</span></td>
						<td>
						<p><span>2</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_LONG</span></td>
						<td>
						<p><span>4</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_LONGLONG</span></td>
						<td>
						<p><span>8</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_FLOAT</span></td>
						<td>
						<p><span>4</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DOUBLE</span></td>
						<td>
						<p><span>8</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_TIME</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DATE</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_DATETIME</span></td>
						<td>
						<p>
						<span>sizeof(MYSQL_TIME)</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_STRING</span></td>
						<td>
						<p>
						<span>data length</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_TYPE_BLOB</span></td>
						<td>
						<p>
						<span>data_length</span></td>
					</tr>
				</table>
				<p><strong><span>返回值</span></strong></p>
				<table border="1" cellpadding="0" id="table15">
					<tr>
						<td>
						<p><strong>
						<span>返回值</span></strong></td>
						<td>
						<p><strong>
						<span>描述</span></strong></td>
					</tr>
					<tr>
						<td>
						<p><span>0</span></td>
						<td>
						<p>成功，數據被提取到應用程式數據緩衝區。</td>
					</tr>
					<tr>
						<td>
						<p><span>1</span></td>
						<td>
						<p>出現錯誤。通過使用<span>mysql_stmt_errno()</span>和<span><span>mysql_stmt_error()</span>，可獲取錯誤代碼和錯誤消息。</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_NO_DATA</span></td>
						<td>
						<p>不存在行／數據。</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>MYSQL_DATA_TRUNCATED</span></td>
						<td>
						<p>出現數據截短。</td>
					</tr>
				</table>
				<p><span>不返回<span>MYSQL_DATA_TRUNCATED</span>，除非用<span>mysql_options()</span>啟用了截短通報功能。返回該值時，為了確定截短的參數是哪個，</span>可檢查<span><span>MYSQL_BIND</span>參數結構的錯誤成員。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNSUPPORTED_PARAM_TYPE</span><span> </span>
				</p>
				<p>緩衝類型為<span>MYSQL_TYPE_DATE</span>、<span>MYSQL_TYPE_TIME</span>、<span>MYSQL_TYPE_DATETIME</span>、或<span><span>MYSQL_TYPE_TIMESTAMP</span>，但數據類型</span>不是<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>、或<span>TIMESTAMP</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>從<span><span>mysql_stmt_bind_result()</span>返回所有其他不支援的轉換錯誤。</span></p>
				<p><strong><span>示範：</span></strong></p>
				<p>在下面的示範中，介紹了使用<span>mysql_stmt_result_metadata()</span>、<span><span>mysql_stmt_bind_result()</span>和<span>mysql_stmt_fetch()</span>從資料表中獲取數據的方法。（在本示範中，將檢索在</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>一節的示範中插入的兩行內容<span>）</span>。假定<span>mysql</span>變數具有有效的連接句柄。 
				</p>
				<pre><span>#define STRING_SIZE 50</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>#define SELECT_SAMPLE &quot;SELECT col1, col2, col3, col4 FROM test_table&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_STMT&nbsp;&nbsp;&nbsp; *stmt;</span></pre>
				<pre><span>MYSQL_BIND&nbsp;&nbsp;&nbsp; bind[4];</span></pre>
				<pre><span>MYSQL_RES&nbsp;&nbsp;&nbsp;&nbsp; *prepare_meta_result;</span></pre>
				<pre><span>MYSQL_TIME&nbsp;&nbsp;&nbsp; ts;</span></pre>
				<pre><span>unsigned long length[4];</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param_count, column_count, row_count;</span></pre>
				<pre><span>short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small_data;</span></pre>
				<pre><span>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int_data;</span></pre>
				<pre><span>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_data[STRING_SIZE];</span></pre>
				<pre><span>my_bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_null[4];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Prepare a SELECT query to fetch data from test_table */</span></pre>
				<pre><span>stmt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, SELECT_SAMPLE, strlen(SELECT_SAMPLE)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_prepare(), SELECT failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>fprintf(stdout, &quot; prepare, SELECT successful\n&quot;);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get the parameter count from the statement */</span></pre>
				<pre><span>param_count= mysql_stmt_param_count(stmt);</span></pre>
				<pre><span>fprintf(stdout, &quot; total parameters in SELECT: %d\n&quot;, param_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (param_count != 0) /* validate parameter count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid parameter count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Fetch result set meta information */</span></pre>
				<pre><span>prepare_meta_result = mysql_stmt_result_metadata(stmt);</span></pre>
				<pre><span>if (!prepare_meta_result)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; mysql_stmt_result_metadata(), returned no meta information\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Get total columns in the query */</span></pre>
				<pre><span>column_count= mysql_num_fields(prepare_meta_result);</span></pre>
				<pre><span>fprintf(stdout, &quot; total columns in SELECT statement: %d\n&quot;, column_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>if (column_count != 4) /* validate column count */</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; invalid column count returned by MySQL\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Execute the SELECT query */</span></pre>
				<pre><span>if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_execute(), failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the result buffers for all 4 columns before fetching them */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* INTEGER COLUMN */</span></pre>
				<pre><span>bind[0].buffer_type= MYSQL_TYPE_LONG;</span></pre>
				<pre><span>bind[0].buffer= (char *)&amp;int_data;</span></pre>
				<pre><span>bind[0].is_null= &amp;is_null[0];</span></pre>
				<pre><span>bind[0].length= &amp;length[0];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* STRING COLUMN */</span></pre>
				<pre><span>bind[1].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span>bind[1].buffer= (char *)str_data;</span></pre>
				<pre><span>bind[1].buffer_length= STRING_SIZE;</span></pre>
				<pre><span>bind[1].is_null= &amp;is_null[1];</span></pre>
				<pre><span>bind[1].length= &amp;length[1];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* SMALLINT COLUMN */</span></pre>
				<pre><span>bind[2].buffer_type= MYSQL_TYPE_SHORT;</span></pre>
				<pre><span>bind[2].buffer= (char *)&amp;small_data;</span></pre>
				<pre><span>bind[2].is_null= &amp;is_null[2];</span></pre>
				<pre><span>bind[2].length= &amp;length[2];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* TIMESTAMP COLUMN */</span></pre>
				<pre><span>bind[3].buffer_type= MYSQL_TYPE_TIMESTAMP;</span></pre>
				<pre><span>bind[3].buffer= (char *)&amp;ts;</span></pre>
				<pre><span>bind[3].is_null= &amp;is_null[3];</span></pre>
				<pre><span>bind[3].length= &amp;length[3];</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the result buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_result(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_bind_result() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Now buffer all results to client */</span></pre>
				<pre><span>if (mysql_stmt_store_result(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_store_result() failed\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Fetch all rows */</span></pre>
				<pre><span>row_count= 0;</span></pre>
				<pre><span>fprintf(stdout, &quot;Fetching results ...\n&quot;);</span></pre>
				<pre><span>while (!mysql_stmt_fetch(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; row_count++;</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp; row %d\n&quot;, row_count);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 1 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column1 (integer)&nbsp; : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[0])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %d(%ld)\n&quot;, int_data, length[0]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 2 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column2 (string)&nbsp;&nbsp; : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[1])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %s(%ld)\n&quot;, str_data, length[1]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 3 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column3 (smallint) : &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[2])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %d(%ld)\n&quot;, small_data, length[2]);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* column 4 */</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;&nbsp;&nbsp; column4 (timestamp): &quot;);</span></pre>
				<pre><span>&nbsp; if (is_null[3])</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; NULL\n&quot;);</span></pre>
				<pre><span>&nbsp; else</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot; %04d-%02d-%02d %02d:%02d:%02d (%ld)\n&quot;,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts.year, ts.month, ts.day,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts.hour, ts.minute, ts.second,</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length[3]);</span></pre>
				<pre><span>&nbsp; fprintf(stdout, &quot;\n&quot;);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Validate rows fetched */</span></pre>
				<pre><span>fprintf(stdout, &quot; total rows fetched: %d\n&quot;, row_count);</span></pre>
				<pre><span>if (row_count != 2)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; MySQL failed to return all rows\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Free the prepared result metadata */</span></pre>
				<pre><span>mysql_free_result(prepare_meta_result);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Close the statement */</span></pre>
				<pre><span>if (mysql_stmt_close(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; failed while closing the statement\n&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; %s\n&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch-column"></a>25.2.7.12. mysql_stmt_fetch_column()</h4></div></div></div><a class="indexterm" name="id3027579"></a>
				<p><span>int 
				mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *bind, 
				unsigned int column, unsigned long offset)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>從當前結果集行獲取<span>1</span>列。「<span><span>bind」</span>提供了應將數據置於其中的緩衝。其設置方法應與</span>設置<span><span>mysql_stmt_bind_result()</span>的相同。</span>「<span><span>column」</span>指明了將獲取哪個列。第<span>1</span>列編號為<span>0</span>。</span>「<span><span>offset」</span>是數據值內的偏移量，將從該處開始檢索數據。可將其用於獲取碎片形式的數據值。</span>值開始部分的偏移量為<span>0</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功獲取了值，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_INVALID_PARAMETER_NO</span><span> </span>
				</p>
				<p><span>Invalid column 
				number. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_NO_DATA</span><span> </span></p>
				<p>已抵達結果集的末尾。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-field-count"></a>25.2.7.13. mysql_stmt_field_count()</h4></div></div></div><a class="indexterm" name="id3027701"></a>
				<p><span>unsigned int 
				mysql_stmt_field_count(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>為語句處理程式返回關於最近語句的行數。對於諸如<span>INSERT</span>或<span><span>DELETE</span>等不生成結果集的語句，該值為<span>0</span>。</span></p>
				<p><span>通過使用<span>mysql_stmt_prepare()</span>準備好了語句後，可使用<span>mysql_stmt_field_count()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示結果集中行數的無符號整數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-free-result"></a>25.2.7.14. mysql_stmt_free_result()</h4></div></div></div><a class="indexterm" name="id3027795"></a>
				<p><span>my_bool 
				mysql_stmt_free_result(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>釋放與執行預處理語句生成的結果集有關的內存。對於該語句，如果存在打開的光標，<span>mysql_stmt_free_result()</span>將關閉它。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功釋放了結果集，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-init"></a>25.2.7.15. mysql_stmt_init()</h4></div></div></div><a class="indexterm" name="id3027868"></a>
				<p><span>MYSQL_STMT *mysql_stmt_init(MYSQL 
				*mysql)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>建立<span><span>MYSQL_STMT</span>句柄。</span>對於該句柄，應使用<span><span>mysql_stmt_close(MYSQL_STMT 
				*)</span>釋放。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>成功時，返回指向<span><span>MYSQL_STMT</span>結構的指針</span>。如果內存溢出，返回<span>NULL</span>。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-insert-id"></a>25.2.7.16. mysql_stmt_insert_id()</h4></div></div></div><a class="indexterm" name="id3027967"></a>
				<p><span>my_ulonglong 
				mysql_stmt_insert_id(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回預處理<span>INSERT</span>或<span><span>UPDATE</span>語句</span>為<span><span>AUTO_INCREMENT</span>列生成的值。在包含<span>AUTO_INCREMENT</span>字段的資料表上執行了預處理<span>INSERT</span>語句後，使用該函數。</span></p>
				<p>更多訊息，請參見<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36節，「mysql_insert_id()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>為在執行預處理語句期間自動生成或明確設置的<span><span>AUTO_INCREMENT</span>列返回值，或</span>由<span>LAST_INSERT_ID(<i>expr</i>)</span>函數生成的值。如果語句未設置<span><span>AUTO_INCREMENT</span>值，返回值不確定。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-num-rows"></a>25.2.7.17. mysql_stmt_num_rows()</h4></div></div></div><a class="indexterm" name="id3028095"></a>
				<p><span>my_ulonglong 
				mysql_stmt_num_rows(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回結果集中的行數。 </p>
				<p><span><span>
				mysql_stmt_num_rows()</span>的用法取決於是否使用了<span>mysql_stmt_store_result()</span>來對語句句柄中的全部結果集進行了緩衝處理。</span></p>
				<p>如果使用了<span><span>mysql_stmt_store_result()</span>，可立刻使用<span>mysql_stmt_num_rows()</span></span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>結果集中的行數。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-count"></a>25.2.7.18. mysql_stmt_param_count()</h4></div></div></div><a class="indexterm" name="id3028198"></a>
				<p><span>unsigned long 
				mysql_stmt_param_count(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回預處理語句中參數標記符的數目。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>資料表示語句中參數數目的無符號長整數。 </p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_param_count()</span>的用法，請參見</span><a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-metadata"></a>25.2.7.19. mysql_stmt_param_metadata()</h4></div></div></div><a class="indexterm" name="id3028293"></a></div><div class="section"><div class="titlepage"><div><div>
			<span>MYSQL_RES *mysql_stmt_param_metadata(MYSQL_STMT 
			*stmt)</span><span> </span>
			<p>該函數目前不做任何事。 </p>
			<p><strong><span>描述</span></strong></p>
			<p><strong><span>返回值</span></strong></p>
			<p><strong><span>錯誤</span></strong></p>
			<h4 class="title"><a name="mysql-stmt-prepare"></a>25.2.7.20. mysql_stmt_prepare()</h4></div></div></div><a class="indexterm" name="id3028355"></a>
			<p><span>int 
			mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, unsigned 
			long length)</span><span> </span></p>
			<p><strong><span>描述</span></strong></p>
			<p>給定<span><span>mysql_stmt_init()</span>返回的語句句柄，準備字串查詢指向的</span><span>SQL</span>語句，並返回狀態值。字串長度應由「<span>length</span>」參量給出。字串必須包含<span>1</span>條<span>SQL</span>語句。不應為語句新增終結用分號<span>(</span>『<span>;</span>』<span>)</span>或<span>\g</span>。 
			</p>
			<p>通過將問號字元「<span>?</span>」嵌入到<span>SQL</span>字串的恰當位置，應用程式可包含<span>SQL</span>語句中的一個或多個參數標記符。</p>
			<p>標記符僅在<span>SQL</span>語句中的特定位置時才是合法的。例如，它可以在<span>INSERT</span>語句的<span><span>VALUES()</span>列資料表中</span>（為行指定列值），或與<span>WHERE</span>子句中某列的比較部分（用以指定比較值）。但是，對於<span>ID</span>（例如資料表名或列名），不允許使用它們，不允許指定二進制操作符（如等於號「<span>=</span>」）的操作數。後一個限制是有必要的，原因在於，無法確定參數類型。一般而言，參數僅在<span>DML</span>（數據操作語言）語句中才是合法的，在<span>DDL</span>（數據定義語言）語句中不合法。</p>
			<p>執行語句之前，必須使用<span><span>mysql_stmt_bind_param()</span>，將參數標記符與應用程式變數綁定在一起。</span></p>
			<p><strong><span>返回值</span></strong></p>
			<p>如果成功處理了語句，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
			</p>
			<p><strong><span>錯誤</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_COMMANDS_OUT_OF_SYNC</span><span> </span></p>
			<p>以不恰當的順序執行了命令。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_OUT_OF_MEMORY</span><span> </span></p>
			<p>內存溢出。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_GONE_ERROR</span><span> </span></p>
			<p><span>MySQL</span>伺服器不可用。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_SERVER_LOST</span><span> </span></p>
			<p>查詢過程中，與伺服器的連接丟失。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CR_UNKNOWN_ERROR</span><span> </span></p>
			<p>出現未知錯誤。 </p>
			<p>如果準備操作失敗（即<span>mysql_stmt_prepare()</span>返回非<span>0</span>值），可通過使用<span><span>mysql_stmt_error()</span>獲取錯誤消息。</span></p>
			<p><strong><span>示範：</span></strong></p>
			<p>關於<span>mysql_stmt_prepare()</span>的用法，請參見<a href="apis.html#mysql-stmt-execute" title="25.2.7.10. mysql_stmt_execute()">25.2.7.10節，「mysql_stmt_execute()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-reset"></a>25.2.7.21. mysql_stmt_reset()</h4></div></div></div><a class="indexterm" name="id3028616"></a>
				<p><span>my_bool 
				mysql_stmt_reset(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在客戶端和伺服器上，將預處理語句復位為完成準備後的狀態。主要用於復位用<span><span>mysql_stmt_send_long_data()</span>發出的數據。對於語句，任何已打開的光標將被關閉。</span></p>
				<p>要想重新準備用於另一查詢的語句，可使用<span>mysql_stmt_prepare()</span>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果語句成功復位，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>查詢過程中，與伺服器的連接丟失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-result-metadata"></a>25.2.7.22. mysql_stmt_result_metadata()</h4></div></div></div><a class="indexterm" name="id3028759"></a>
				<p><span>MYSQL_RES *mysql_stmt_result_metadata(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>如果傳遞給<span><span>mysql_stmt_prepare()</span>的語句能夠成生結果集，<span>mysql_stmt_result_metadata()</span>將以指針的形式返回結果集元數據，該指針指向<span>MYSQL_RES</span>結構，可用於處理元訊息，如</span>總的字段數以及單獨的字段訊息。該結果集指針可作為參量傳遞給任何基於字段且用於處理結果集元數據的<span>API</span>函數，如：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_num_fields()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_field()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_field_direct()</span><span> </span>
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_fetch_fields()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_count()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_seek()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_field_tell()</span><span> </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				mysql_free_result()</span><span> </span></p>
				<p>完成操作後，應釋放結果集結構，可通過將其傳遞給<span><span>mysql_free_result()</span>完成</span>。它與釋放通過<span>mysql_store_result()</span>使用獲得的結果集的方法類似。</p>
				<p><span>
				mysql_stmt_result_metadata()</span>返回的結果集僅包含元數據。不含任何行結果。與<span><span>mysql_stmt_fetch()</span>一起使用語句句柄，可獲取行。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p><span>MYSQL_RES</span>結果結構。如果不存在關於預處理查詢的任何元訊息，返回<span><span>NULL</span>。</span></p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>關於<span><span>mysql_stmt_result_metadata()</span>的用法，請參見</span><a href="apis.html#mysql-stmt-fetch" title="25.2.7.11. mysql_stmt_fetch()">25.2.7.11節，「mysql_stmt_fetch()」</a>中給出的示範。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-seek"></a>25.2.7.23. mysql_stmt_row_seek()</h4></div></div></div><a class="indexterm" name="id3029020"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_stmt_row_seek(MYSQL_STMT *stmt, 
				MYSQL_ROW_OFFSET offset)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>將行光標設置到語句結果集中的任意行。「<span><span>offset」</span>值是行偏移的值，行偏移應是</span>從<span>mysql_stmt_row_tell()</span>或<span><span>mysql_stmt_row_seek()</span>返回的值。</span>該值不是行編號，如果打算按編號搜尋結果集中的行，可使用<span><span>mysql_stmt_data_seek()</span>取而代之。</span></p>
				<p>該函數要求結果集結構包含查詢的全部結果，以便<span>mysql_stmt_row_seek()</span>能夠僅與<span>mysql_stmt_store_result()</span>一起使用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光標的前一個值。可以將該值換遞給後續的<span>mysql_stmt_row_seek()</span>使用。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-tell"></a>25.2.7.24. mysql_stmt_row_tell()</h4></div></div></div><a class="indexterm" name="id3029139"></a>
				<p><span>
				MYSQL_ROW_OFFSET mysql_stmt_row_tell(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>返回針對前一個<span><span>mysql_stmt_fetch()</span>的行光標的當前位置。該值可用作<span>mysql_stmt_row_seek()</span></span>的參量。</p>
				<p>僅應在<span><span>mysql_stmt_store_result()</span>之後使用<span>mysql_stmt_row_tell()</span>。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>行光標的當前偏移量。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-send-long-data"></a>25.2.7.25. mysql_stmt_send_long_data()</h4></div></div></div><a class="indexterm" name="id3029230"></a>
				<p><span>my_bool 
				mysql_stmt_send_long_data(MYSQL_STMT *stmt, unsigned int 
				parameter_number, const char *data, unsigned long length)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>
				允許應用程式分段地（分塊）將參數數據發送到伺服器。可以多次使用該函數，以便發送關於某一列的字元或二進制數據的不同部分，列必須是<span>TEXT</span>或<span>BLOB</span>數據類型之一。</p>
				<p><span><span>
				「parameter_number」</span>指明了與數據關聯的參數。參數從<span>0</span>開始編號。<span>「data」</span>是指向包含將要發送的數據的緩衝區的指針，</span>「<span><span>length」</span>指明了緩衝區內的字節數。</span></p>
				<p><strong><span>註釋：</span></strong>自上一個<span>mysql_stmt_execute()</span>或<span><span>mysql_stmt_reset()</span>後，對於與<span>mysql_stmt_send_long_data()</span>一起使用的所有參數，下一個<span>mysql_stmt_execute()</span>使用將忽略</span>綁定緩衝。</p>
				<p>如果希望復位／忽略已發送的數據，可使用<span>mysql_stmt_reset()</span>。請參見<a href="apis.html#mysql-stmt-reset" title="25.2.7.21. mysql_stmt_reset()">25.2.7.21節，「mysql_stmt_reset()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功地將數據發送到伺服器，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。 
				</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </p>
				<p><strong><span>示範：</span></strong></p>
				<p>在下面的示範中，介紹了以訊息塊形式為<span>TEXT</span>列發送數據的方法。它會將數據值「<span><span>MySQL</span>，最流行的開放原始碼資料庫</span>」插入到<span><span>text_column</span>列中。</span>假定<span>mysql</span>變數具有有效的連接句柄。 
				</p>
				<pre><span>#define INSERT_QUERY &quot;INSERT INTO test_long_data(text_column) VALUES(?)&quot;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>MYSQL_BIND bind[1];</span></pre>
				<pre><span>long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>smtt = mysql_stmt_init(mysql);</span></pre>
				<pre><span>if (!stmt)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot; mysql_stmt_init(), out of memory\n&quot;);</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>if (mysql_stmt_prepare(stmt, INSERT_QUERY, strlen(INSERT_QUERY)))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n mysql_stmt_prepare(), INSERT failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span> memset(bind, 0, sizeof(bind));</span></pre>
				<pre><span> bind[0].buffer_type= MYSQL_TYPE_STRING;</span></pre>
				<pre><span> bind[0].length= &amp;length;</span></pre>
				<pre><span> bind[0].is_null= 0;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>/* Bind the buffers */</span></pre>
				<pre><span>if (mysql_stmt_bind_param(stmt, bind))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n param bind failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Supply data in chunks to server */</span></pre>
				<pre><span> if (!mysql_stmt_send_long_data(stmt,0,&quot;MySQL&quot;,5))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n send_long_data failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Supply the next piece of data */</span></pre>
				<pre><span> if (mysql_stmt_send_long_data(stmt,0,&quot; - The most popular Open Source database&quot;,40))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n send_long_data failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span> /* Now, execute the query */</span></pre>
				<pre><span> if (mysql_stmt_execute(stmt))</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n mysql_stmt_execute failed&quot;);</span></pre>
				<pre><span>&nbsp; fprintf(stderr, &quot;\n %s&quot;, mysql_stmt_error(stmt));</span></pre>
				<pre><span>&nbsp; exit(0);</span></pre>
				<pre><span>}</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-sqlstate"></a>25.2.7.26. mysql_stmt_sqlstate()</h4></div></div></div><a class="indexterm" name="id3029537"></a>
				<p><span>const char *mysql_stmt_sqlstate(MYSQL_STMT 
				*stmt)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於由<span><span>stmt</span>指定的語句，<span>mysql_stmt_sqlstate()</span></span>返回由<span>Null</span>終結的字串，該字串包含針對最近使用預處理語句<span>API</span>函數的<span>SQLSTATE</span>錯誤代碼，該函數或成功或失敗。錯誤代碼由<span>5</span>個字元構成。<span><span>&quot;00000&quot;</span>資料表示</span>「無錯誤」。這些值由<span>ANSI 
				SQL</span>和<span>ODBC</span>指定。關於可能值的列資料表，請參見<a href="error-handling.html" title="Appendix B. Error Codes and Messages">附錄B：錯誤代碼和消息</a><span>。 
				</span></p>
				<p>注意，並非所有的<span>MySQL</span>錯誤均會被映射到<span>SQLSTATE</span>代碼。值<span>&quot;HY000&quot;</span>（一般錯誤）用於未映射的錯誤。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>包含<span>SQLSTATE</span>錯誤代碼、由<span>Null</span>終結的字串。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-store-result"></a>25.2.7.27. mysql_stmt_store_result()</h4></div></div></div><a class="indexterm" name="id3029630"></a>
				<p><span>int 
				mysql_stmt_store_result(MYSQL_STMT *stmt)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>對於成功生成結果集的所有語句（<span>SELECT</span>、<span>SHOW</span>、<span>DESCRIBE</span>、<span>EXPLAIN</span>），而且僅當您打算對客戶端的全部結果集進行緩衝處理時，必須使用<span><span>mysql_stmt_store_result()</span>，以便後續的<span>mysql_stmt_fetch()</span></span>使用能返回緩衝數據。</p>
				<p>對於其他語句，沒有必要使用<span><span>mysql_stmt_store_result()</span>，但如果使用了它，</span>也不會造成任何傷害或導致任何性能問題。通過檢查<span><span>mysql_stmt_result_metadata()</span>是否</span>返回<span><span>NULL</span>，可檢測語句是否生成了結果集。</span>更多訊息，請參見<a href="apis.html#mysql-stmt-result-metadata" title="25.2.7.22. mysql_stmt_result_metadata()">25.2.7.22節，「mysql_stmt_result_metadata()」</a>。</p>
				<p><strong><span>註釋：</span><span>預設情況下，對於</span></strong><span><span>mysql_stmt_store_result()</span>中的所有列，</span><span>MySQL</span>不計算<span>MYSQL_FIELD-&gt;max_length</span>，這是因為，計算它會顯著降低<span><span>mysql_stmt_store_result()</span>的性能，而且大多數應用程式</span>不需要<span>max_length</span>。如果打算更新<span><span>max_length</span>，</span>可通過使用<span>mysql_stmt_attr_set(MYSQL_STMT, 
				STMT_ATTR_UPDATE_MAX_LENGTH, &amp;flag)</span>啟用它。請參見<a href="apis.html#mysql-stmt-attr-set" title="25.2.7.3. mysql_stmt_attr_set()">25.2.7.3節，「mysql_stmt_attr_set()」</a>。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功完成了對結果的緩衝處理，返回<span>0</span>。如果出現錯誤，返回非<span>0</span>值。</p>
				<p><strong><span>錯誤</span></strong></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_COMMANDS_OUT_OF_SYNC</span><span> </span>
				</p>
				<p>以不恰當的順序執行了命令。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_OUT_OF_MEMORY</span><span> </span></p>
				<p>內存溢出。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_GONE_ERROR</span><span> </span></p>
				<p><span>MySQL</span>伺服器不可用。 
				</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_SERVER_LOST</span><span> </span></p>
				<p>在查詢過程中，與伺服器的連接丟失。 </p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				CR_UNKNOWN_ERROR</span><span> </span></p>
				<p>出現未知錯誤。 </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-problems"></a>
			25.2.8.&nbsp;C API預處理語句方面的問題</h3></div></div></div>
			<p>下面列出了一些目前已知的與預處理語句有關的問題：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>TIME</span>、<span><span>TIMESTAMP</span>和<span>DATETIME</span></span>不支援秒部分，例如來自<span><span>DATE_FORMAT()</span>的秒部分</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>將整數轉換為字串時，在某些情況下，當<span>MySQL</span>不打印前導<span>0</span>時，可與預處理語句一起使用<span>ZEROFILL</span>。例如，與<span><span>MIN(number-with-zerofill)</span>一起。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>將浮點數轉換為客戶端中的字串時，被轉換值最右側的位可能會與原始值的有所不同。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><em><span>
			預處理語句不使用查詢高速緩衝，即使當查詢不含任何佔位符時也同樣。。</span></em>請參見<a href="database-administration.html#query-cache-how" title="5.13.1. How the Query Cache Operates">5.13.1節，「查詢高速緩衝如何工作」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-multiple-queries"></a>
			25.2.9.&nbsp;多查詢執行的C API處理</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<span>MySQL 5.1</span>支援在單個查詢字串中指定的多語句的執行。要想與給定的連接一起使用該功能，打開連接時，必須將標誌參數中的<span><span>CLIENT_MULTI_STATEMENTS</span>選項指定給<span>mysql_real_connect()</span>。</span>也可以通過使用<span><span>mysql_set_server_option(MYSQL_OPTION_MULTI_STATEMENTS_ON)</span>，為已有的連接設置它。</span><p>
			在預設情況下，<span>mysql_query()</span>和<span>mysql_real_query()</span>僅返回第<span>1</span>個查詢的狀態，並能使用<span>mysql_more_results()</span>和<span>mysql_next_result()</span>對後續查詢的狀態進行處理。</p>
			<pre><span>/* Connect to server with option CLIENT_MULTI_STATEMENTS */</span></pre>
			<pre><span>mysql_real_connect(..., CLIENT_MULTI_STATEMENTS);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>/* Now execute multiple queries */</span></pre>
			<pre><span>mysql_query(mysql,&quot;DROP TABLE IF EXISTS test_table;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CREATE TABLE test_table(id INT);\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO test_table VALUES(10);\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPDATE test_table SET id=20 WHERE id=10;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT * FROM test_table;\</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;DROP TABLE test_table&quot;);</span></pre>
			<pre><span>do</span></pre>
			<pre><span>{</span></pre>
			<pre><span>&nbsp; /* Process all results */</span></pre>
			<pre><span>&nbsp; ...</span></pre>
			<pre><span>&nbsp; printf(&quot;total affected rows: %lld&quot;, mysql_affected_rows(mysql));</span></pre>
			<pre><span>&nbsp; ...</span></pre>
			<pre><span>&nbsp; if (!(result= mysql_store_result(mysql)))</span></pre>
			<pre><span>&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; printf(stderr, &quot;Got fatal error processing query\n&quot;);</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; exit(1);</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; process_result_set(result); /* client function */</span></pre>
			<pre><span>&nbsp; mysql_free_result(result);</span></pre>
			<pre><span>} while (!mysql_next_result(mysql));</span></pre>
			<p>多語句功能可與<span>mysql_query()</span>或<span><span>mysql_real_query()</span>一起使用。它不能與預處理語句接口一起使用。按照定義，預處理語句僅能與包含單個語句的字串一起使用。</span></p>
			<h3 class="title"><a name="c-api-date-handling"></a>
			25.2.10.&nbsp;日期和時間值的C API處理</h3></div></div></div>
			<p>二進制協議允許您使用<span><span>MYSQL_TIME</span>結構</span>發送和接受日期和時間值（<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>和<span><span>TIMESTAMP</span>）。</span>在<a href="apis.html#c-api-prepared-statement-datatypes" title="25.2.5. C API Prepared Statement Data types">25.2.5節，「C API預處理語句的數據類型」</a>中，介紹了該結構的成員。</p>
			<p>要想發送臨時數據值，可使用<span><span>mysql_stmt_prepare()</span>建立預處理語句。然後，在使用<span>mysql_stmt_execute()</span>執行語句之前，可採用下述步驟設置每個臨時參數：</span></p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在與數據值相關的<span><span>MYSQL_BIND</span>結構中，將<span>buffer_type</span>成員設置為相應的類型，該類型指明了發送的臨時值類型。</span>對於<span>DATE</span>、<span>TIME</span>、<span>DATETIME</span>或<span><span>TIMESTAMP</span>值，</span>將<span><span>buffer_type</span>分別設置為<span>MYSQL_TYPE_DATE</span>、<span>MYSQL_TYPE_TIME</span>、<span>MYSQL_TYPE_DATETIME</span></span>或<span>MYSQL_TYPE_TIMESTAMP</span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>將<span><span>MYSQL_BIND</span>結構的</span>緩衝成員設置為用於傳遞臨時值的<span><span>MYSQL_TIME</span>結構的地址。</span></p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>填充<span><span>MYSQL_TIME</span>結構的成員，使之與打算傳遞的臨時支的類型相符。</span></p>
			<p>使用<span><span>mysql_stmt_bind_param()</span>將參數數據綁定到語句。然後可使用<span>mysql_stmt_execute()</span></span>。</p>
			<p>要想檢索臨時值，可採用類似的步驟，但應將<span><span>buffer_type</span>成員設置為打算接受的值的類型，並將</span>緩衝成員設為應將返回值置於其中的<span><span>MYSQL_TIME</span>結構的地址。使用<span>mysql_stmt_execute()</span>之後，並在獲取結果之前，使用<span>mysql_bind_results()</span>將緩衝綁定到語句上。</span></p>
			<p>下面給出了一個插入<span>DATE</span>、<span>TIME</span>和<span><span>TIMESTAMP</span>數據的簡單示範</span>。假定<span>mysql</span>變數具有有效的連接句柄。 
			</p>
			<pre class="programlisting">
  MYSQL_TIME  ts;
  MYSQL_BIND  bind[3];
  MYSQL_STMT  *stmt;

  strmov(query, "INSERT INTO test_table(date_field, time_field,
                                        timestamp_field) VALUES(?,?,?");

  stmt = mysql_stmt_init(mysql);
  if (!stmt)
  {
    fprintf(stderr, " mysql_stmt_init(), out of memory\n");
    exit(0);
  }
  if (mysql_stmt_prepare(mysql, query, strlen(query)))
  {
    fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
    fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
    exit(0);
  }

  /* set up input buffers for all 3 parameters */
  bind[0].buffer_type= MYSQL_TYPE_DATE;
  bind[0].buffer= (char *)&amp;ts;
  bind[0].is_null= 0;
  bind[0].length= 0;
  ...
  bind[1]= bind[2]= bind[0];
  ...

  mysql_stmt_bind_param(stmt, bind);

  /* supply the data to be sent in the ts structure */
  ts.year= 2002;
  ts.month= 02;
  ts.day= 03;

  ts.hour= 10;
  ts.minute= 45;
  ts.second= 20;

  mysql_stmt_execute(stmt);
  ..

</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-thread-functions"></a>
			25.2.11.&nbsp;C API線程函數介紹</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#my-init">25.2.11.1. my_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-init">25.2.11.2. mysql_thread_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-end">25.2.11.3. mysql_thread_end()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-thread-safe">25.2.11.4. mysql_thread_safe()</a></span></dt></dl></div>
			<p>當您打算建立線程客戶端時，需要使用下述函數。請參見<a href="apis.html#threaded-clients" title="25.2.15. How to Make a Threaded Client">25.2.15節，「如何生成線程式客戶端」</a>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="my-init"></a>25.2.11.1. my_init()</h4></div></div></div><a class="indexterm" name="id3030299"></a>
				<p><span>void 
				my_init(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>使用任何<span>MySQL</span>函數之前，需要在程式中使用該函數。它將初始化<span>MySQL</span>所需的某些全局變數。如果您正在使用線程安全客戶端庫，它還能為該線程使用<span><span>mysql_thread_init()</span>。</span></p>
				<p>通過<span>mysql_init()</span>、<span>mysql_library_init()</span>、<span>mysql_server_init()</span>和<span><span>mysql_connect()</span>，可自動使用該函數。</span></p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-init"></a>25.2.11.2. mysql_thread_init()</h4></div></div></div><a class="indexterm" name="id3030382"></a>
				<p><span>my_bool 
				mysql_thread_init(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>對於每個建立的線程，需要使用該函數來初始化與線程相關的變數。</p>
				<p>它可由<span>my_init()</span>和<span>mysql_connect()</span>自動使用。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果成功，返回<span>0</span>，如果出現錯誤，返回非<span>0</span>值。 </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-end"></a>25.2.11.3. mysql_thread_end()</h4></div></div></div><a class="indexterm" name="id3030452"></a>
				<p><span>void 
				mysql_thread_end(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>使用<span><span>pthread_exit()</span>來釋放<span>mysql_thread_init()</span>分配的內存之前，需要使用該函數。</span></p>
				<p>注意，該函數不會被客戶端庫自動使用。必須明確使用它以避免內存洩漏。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-safe"></a>25.2.11.4. mysql_thread_safe()</h4></div></div></div><a class="indexterm" name="id3030526"></a>
				<p><span>unsigned int 
				mysql_thread_safe(void)</span><span> </span>
				</p>
				<p><strong><span>描述</span></strong></p>
				<p>該函數指明了客戶端是否編譯為線程安全的。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>如果客戶端是線程安全的，返回<span>1</span>，否則返回<span>0</span>。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-embedded-server-func"></a>
			25.2.12.&nbsp;C API嵌入式伺服器函數介紹</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#mysql-server-init">25.2.12.1. mysql_server_init()</a></span></dt><dt><span class="section"><a href="apis.html#mysql-server-end">25.2.12.2. mysql_server_end()</a></span></dt></dl></div>
			<p>如果希望允許應用程式連結到嵌入式<span>MySQL</span>伺服器庫，必須使用<span>mysql_server_init()</span>和<span>mysql_server_end()</span>函數。請參見<a href="apis.html#libmysqld" title="25.1. libmysqld, the Embedded MySQL Server Library">25.1節，「libmysqld，嵌入式MySQL伺服器庫」</a>。</p>
			<p>但是，要想提供改進的內存管理，即使是對與「<span>-lmysqlclient</span>」而不是與「<span>-lmysqld</span>」連結的程式，也應包含啟用和結束庫使用的使用。<span>mysql_library_init()</span>和<span><span>mysql_library_end()</span>函數可用於該目的。它們實際上是使其等效於<span>mysql_server_init()</span></span>和<span><span>mysql_server_end()</span>的<span>#define</span>符號</span>，但它們的名稱更清楚地指明，無論應用程式使用的是<span>libmysqlclient</span>或<span><span>libmysqld</span>，開始使用或結束</span><span>MySQL 
			C API</span>庫的使用時，應使用它們。關於更多訊息，請參見<a href="apis.html#c-api-function-overview" title="25.2.2. C API Function Overview">25.2.2節，「C API函數概述」</a>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-init"></a>25.2.12.1. mysql_server_init()</h4></div></div></div><a class="indexterm" name="id3030666"></a>
				<p><span>int 
				mysql_server_init(int argc, char **argv, char **groups)</span><span>
				</span></p>
				<p><strong><span>描述</span></strong></p>
				<p>使用任何其他<span>MySQL</span>函數之前，必須在使用嵌入式伺服器的程式中使用該函數。它將啟動伺服器，並初始化伺服器使用的任何子系統（<span><span>mysys</span>、<span>InnoDB</span></span>等）。如果未使用該函數，對<span><span>mysql_init()</span>的下一次使用將執行<span>mysql_server_init()</span></span>。如果您正在使用與<span>MySQL</span>一起提供的<span>DBUG</span>軟件包，應在使用了<span>my_init()</span>之後使用它。</p>
				<p>對於<span><span>main()</span>的參量，<span>argc</span>和<span>argv</span>是類似的參量。<span>argv</span>的第<span>1</span>個元素將被忽略</span>（典型情況下，它包含程式名）。為了方便起見，如果沒有針對伺服器的命令行參量，<span>argc</span>可以是<span>0</span>。<span><span>mysql_server_init()</span>將複製參量，以便能夠在使用之後安全地摧毀<span>argv</span></span>或<span>groups</span>。</p>
				<p>如果打算連接到外部伺服器而不啟動嵌入式伺服器，應為<span>argc</span>指定負值。</p>
				<p>「<span>groups</span>」中以<span>Null</span>終結的字串列資料表選擇了選項檔案中的活動「<span>groups</span>」。請參見<a href="using-mysql-programs.html#option-files" title="4.3.2. Using Option Files">4.3.2節，「使用選項檔案」</a>。為了方便起見，<span><span>groups</span>可以是<span>NULL</span>，在該情況下，<span>[server]</span>和<span>[embedded]</span>組是活動的。</span></p>
				<p><strong><span>示範：</span></strong></p>
				<pre><span>#include &lt;mysql.h&gt;</span></pre>
				<pre><span>#include &lt;stdlib.h&gt;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>static char *server_args[] = {</span></pre>
				<pre><span>&nbsp; &quot;this_program&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* this string is not used */</span></pre>
				<pre><span>&nbsp; &quot;--datadir=.&quot;,</span></pre>
				<pre><span>&nbsp; &quot;--key_buffer_size=32M&quot;</span></pre>
				<pre><span>};</span></pre>
				<pre><span>static char *server_groups[] = {</span></pre>
				<pre><span>&nbsp; &quot;embedded&quot;,</span></pre>
				<pre><span>&nbsp; &quot;server&quot;,</span></pre>
				<pre><span>&nbsp; &quot;this_program_SERVER&quot;,</span></pre>
				<pre><span>&nbsp; (char *)NULL</span></pre>
				<pre><span>};</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>int main(void) {</span></pre>
				<pre><span>&nbsp; if (mysql_server_init(sizeof(server_args) / sizeof(char *),</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; server_args, server_groups))</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; exit(1);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; /* Use any MySQL API functions here */</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; mysql_server_end();</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>&nbsp; return EXIT_SUCCESS;</span></pre>
				<pre><span>}</span></pre>
				<p><strong><span>返回值</span></strong></p>
				<p>如果<span>OK</span>，返回<span>0</span>。如果出現錯誤，返回<span>1</span>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-end"></a>25.2.12.2. mysql_server_end()</h4></div></div></div><a class="indexterm" name="id3030870"></a>
				<p><span>void 
				mysql_server_end(void)</span><span> </span></p>
				<p><strong><span>描述</span></strong></p>
				<p>在所有其他<span>MySQL</span>函數後，在程式中必須使用該函數一次。它將關閉嵌入式伺服器。</p>
				<p><strong><span>返回值</span></strong></p>
				<p>無。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-problems"></a>
			25.2.13.&nbsp;使用C API時的常見問題</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#null-mysql-store-result">
				25.2.13.1. 為什麼在mysql_query()返回成功後，mysql_store_result()有時會返回NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="apis.html#query-results">25.2.13.2. What Results You Can Get from a Query</a></span></dt><dt><span class="section"><a href="apis.html#getting-unique-id">
				25.2.13.3. 如何獲得上次插入行的唯一ID</a></span></dt><dt><span class="section"><a href="apis.html#c-api-linking-problems">
				25.2.13.4. 與C API有關的問題</a></span></dt></dl></div><a class="indexterm" name="id3030934"></a><a class="indexterm" name="id3030944"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="null-mysql-store-result"></a>
				25.2.13.1.&nbsp;為什麼在mysql_query()返回成功後，mysql_store_result()有時會返回NULL<code class="literal"></code></h4></div></div></div>
				<p>成功使用<span><span>mysql_query()</span>後，<span>mysql_store_result()</span>能夠返回<span>NULL</span>。出現該情況時，</span>表明出現了下述條件之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>出現了<span><span>malloc()</span>故障（例如，如果結果集過大</span>）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>無法讀取數據（在連接上出現了錯誤）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查詢未返回數據（例如，它是<span>INSERT</span>、<span>UPDATE</span>或<span>DELETE</span>）。</p>
				<p>通過使用<span><span>mysql_field_count()</span>，</span>始終能檢查語句是否應生成非空結果。如果<span><span>mysql_field_count()</span>返回<span>0</span>，結果為空，而且上一個查詢</span>是未返回值的語句（例如<span>INSERT</span>或<span>DELETE</span>）。如果<span><span>mysql_field_count()</span>返回非<span>0</span>值，語句應生成非空結果</span>。關於這方面的示範，請參見<span><span>mysql_field_count()</span>函數介紹。</span></p>
				<p>通過使用<span>mysql_error()</span>或<span><span>mysql_errno()</span>，</span>可測試是否出現了錯誤。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-results"></a>25.2.13.2. What Results You Can Get from a Query</h4></div></div></div>
				<p>除了查詢返回的結果集外，還能獲取下述訊息：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>執行<span>INSERT</span></span>、<span>UPDATE</span>或<span><span>DELETE</span>時，<span>mysql_affected_rows()</span></span>返回上次查詢影響的行數。</p>
				<p>對於快速在建立，請使用<span>TRUNCATE 
				TABLE</span>。</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>mysql_num_rows()</span></span>返回結果集中的行數。使用<span>mysql_store_result()</span>，一旦<span><span>mysql_store_result()</span>返回，就能使用<span>mysql_num_rows()</span></span>。使用<span><span>mysql_use_result()</span>，僅當用<span>mysql_fetch_row()</span>獲取了所有行後，才能使用<span>mysql_num_rows()</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span><span>
				mysql_insert_id()</span>返回上次查詢生成的<span>ID</span>，該查詢使用<span>AUTO_INCREMENT</span>索引將行插入到資料表內</span>。請參見<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36節，「mysql_insert_id()」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>某些查詢（<span>LOAD 
				DATA INFILE ...</span>、<span>INSERT 
				INTO ... SELECT ...</span>、<span><span>UPDATE</span>）將返回額外訊息。</span>結果由<span><span>mysql_info()</span>返回。關於它返回的字串格式，</span>請參見關於<span><span>mysql_info()</span>的介紹。如果沒有額外訊息，<span>mysql_info()</span>將返回<span>NULL</span>指針。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="getting-unique-id"></a>
				25.2.13.3.&nbsp;如何獲得上次插入行的唯一ID</h4></div></div></div><a class="indexterm" name="id3031244"></a><a class="indexterm" name="id3031251"></a><a class="indexterm" name="id3031261"></a><a class="indexterm" name="id3031271"></a>
				<p>如果將記錄插入包含<span><span>AUTO_INCREMENT</span>列的資料表中，通過使用<span>mysql_insert_id()</span>函數，可獲取</span>保存在該列中的值。</p>
				<p>通過執行下述代碼，可從<span>C</span>應用程式檢查某一值是否保存在<span>AUTO_INCREMENT</span>列中（假定該語句已成功執行）。它能確定查詢是否是具有<span><span>AUTO_INCREMENT</span>索引的<span>INSERT</span>：</span></p>
				<pre><span>if ((result = mysql_store_result(&amp;mysql)) == 0 &amp;&amp;</span></pre>
				<pre><span>&nbsp; &nbsp;&nbsp;mysql_field_count(&amp;mysql) == 0 &amp;&amp;</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; mysql_insert_id(&amp;mysql) != 0)</span></pre>
				<pre><span>{</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; used_id = mysql_insert_id(&amp;mysql);</span></pre>
				<pre><span>}</span></pre>
				<p>關於更多訊息，請參見<a href="apis.html#mysql-insert-id" title="25.2.3.36. mysql_insert_id()">25.2.3.36節，「mysql_insert_id()」</a>。</p>
				<p>生成新的<span><span>AUTO_INCREMENT</span>值時，也能與<span>mysql_query()</span>一起通過執行<span>SELECT 
				LAST_INSERT_ID()</span>語句獲得它，並從該語句返回的結果集檢索該值。</span></p>
				<p>對於<span><span>LAST_INSERT_ID()</span>，最近生成的<span>ID</span>是在伺服器上按連接維護的。它不會被另一個客戶端改變。即使用</span><span>non-magic</span>值（即非<span>Null</span>非<span>0</span>值）更新了另一個<span><span>AUTO_INCREMENT</span>列，也不會更改它。</span></p>
				<p>如果打算使用從某一資料表生成的<span>ID</span>，並將其插入到第<span>2</span>個資料表中，可使用如下所示的<span>SQL</span>語句：</p>
				<pre><span>INSERT INTO foo (auto,text)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; VALUES(NULL,&#39;text&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # generate ID by inserting NULL</span></pre>
				<pre><span>INSERT INTO foo2 (id,text)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; VALUES(LAST_INSERT_ID(),&#39;text&#39;);&nbsp; # use ID in second table</span></pre>
				<p>注意，<span><span>mysql_insert_id()</span>返回保存在<span>AUTO_INCREMENT</span>列中的值，無論該值是因儲存<span>NULL</span>或<span>0</span>而自動生成的，或是明確指定的，均如此。<span>LAST_INSERT_ID()</span>僅返回自動生成的<span>AUTO_INCREMENT</span>值。</span>如果您保存了除<span>NULL</span>或<span>0</span>之外的確切值，不會影響<span>LAST_INSERT_ID()</span>返回的值。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-linking-problems"></a>
				25.2.13.4.&nbsp;與C API有關的問題</h4></div></div></div><a class="indexterm" name="id3031439"></a><a class="indexterm" name="id3031449"></a></div></div><div class="section"><div class="titlepage"><div><div>
			與<span>C API</span>連結時，在某些系統上可能出現下述錯誤：<pre><span>gcc -g -o client test.o -L/usr/local/lib/mysql -lmysqlclient -lsocket -lnsl</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>Undefined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first referenced</span></pre>
			<pre><span> symbol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in file</span></pre>
			<pre><span>floor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/local/lib/mysql/libmysqlclient.a(password.o)</span></pre>
			<pre><span>ld: fatal: Symbol referencing errors. No output written to client</span></pre>
			<p>如果在您的系統上出現了該情況，必須在編譯<span>/</span>連結行的末尾增加「<span>-lm</span>」，通過該方式包含數學庫。</p>
			<h3 class="title"><a name="building-clients"></a>
			25.2.14.&nbsp;建立客戶端程式</h3></div></div></div><a class="indexterm" name="id3031495"></a><a class="indexterm" name="id3031505"></a><a class="indexterm" name="id3031512"></a><a class="indexterm" name="id3031522"></a>
			<p>如果您編譯了自己編寫的<span>MySQL</span>客戶端，或編譯了從第三方獲取的<span>MySQL</span>客戶端，必須在連結命令中使用「<span>-lmysqlclient 
			-lz</span>」選項連結它們。您或許還應指定「<span><span>-L」</span>選項，通知</span>連結程式到哪裡找到庫。例如，如果將庫安裝到了<span><span>/usr/local/mysql/lib</span>，可在連結命令中使用<span>sr/local/mysql/lib 
			-lmysqlclient –lz</span>。</span></p>
			<p>對於使用<span>MySQL</span>頭檔案的客戶端，編譯它們時還須指定「<span><span>-I」</span>選項（例如</span>，<span><span>-I/usr/local/mysql/include</span>），以便</span>編譯器能找到頭檔案。</p>
			<p>為了使在<span>Unix</span>平台上編譯<span>MySQL</span>程式變得簡單，提供了<strong><span>mysql_config</span></strong>指令。請參見<a href="apis.html#mysql-config" title="25.9.2. mysql_config — Get Compile Options for Compiling Clients">25.9.2節，「mysql_config：獲取編譯客戶端的編譯選項」</a>。</p>
			<p>您也可以使用它來編譯<span>MySQL</span>客戶端，如下所述：</p>
			<pre><span>CFG=/usr/local/mysql/bin/mysql_config</span></pre>
			<pre><span>sh -c &quot;gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`&quot;</span></pre>
			<p>需要使用「<span><span>sh –c」</span>，使得<span>shell</span>不將</span><strong><span>mysql_config</span></strong><span>的輸出當作<span>1</span>個詞對待。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="threaded-clients"></a>
			25.2.15.&nbsp;如何生成線程式客戶端</h3></div></div></div><a class="indexterm" name="id3031620"></a><a class="indexterm" name="id3031630"></a>
			<p>客戶端庫總是線程安全的。最大的問題在於從套接字讀取的<span><span>net.c</span>中的子程式並不是中斷安全的。或許您可能希望用自己的告警中斷對伺服器的長時間讀取，以此來解決問題。如果為<span>SIGPIPE</span>中斷安裝了中斷處理程式，套接字處理功能應是線程安全的。</span></p>
			<p>為了避免連接中斷時放棄程式，<span>MySQL</span>將在首次使用<span>mysql_server_init</span><span>()</span>、<span>mysql_init()</span>或<span><span>mysql_connect()</span>時屏蔽<span>SIGPIPE</span></span>。如果您打算使用自己的<span><span>SIGPIPE</span>處理程式，</span>首先應使用<span><span>mysql_server_init()</span>，然後安裝您的處理程式，</span></p>
			<p>在較舊的發佈在我方網站上（<span><a target="_top"  href="http://www.mysql.com/">http://www.mysql.com/</a></span>）的二進製版本中，未用線程安全的選項對客戶端庫進行正常編譯（預設情況下，編譯的<span>Windows</span>二進製版本是線程安全的）。較新的二進制分發版應是正常的和線程安全的客戶端庫。</p>
			<p>為了獲得能從其他線程中斷客戶端的線程式客戶端，並在與<span>MySQL</span>伺服器通信時設置超時，應使用「<span>-lmysys</span>」、「<span><span>-lmystrings」</span>和</span>「<span><span>-ldbug」</span>庫，以及伺服器使用的<span>net_serv.o</span></span>代碼。</p>
			<p>如果您不需要使用中斷或超時，可編譯線程安全客戶端庫（<span>mysqlclient_r</span>）並使用它。。請參見<a href="apis.html#c" title="25.2. MySQL C API">25.2節，「MySQL C API」</a>。在該情況下，不必擔心<span><span>net_serv.o</span>對像檔案或其他</span><span>MySQL</span>庫。</p>
			<p>使用線程式客戶端並打算使用超時或中斷時，可更好地利用<span><span>thr_alarm.c</span>檔案中的子程式。如果您正在使用來自<span>mysys</span>庫的子程式，唯一需要記住的事是首先使用<span>my_init()</span>！請參見</span><a href="apis.html#c-thread-functions" title="25.2.11. C API Threaded Function Descriptions">25.2.11節，「C API線程函數介紹」</a>。</p>
			<p>對於除<span><span>mysql_real_connect()</span>外的所有函數，在預設情況下它們均是線程安全的。在下面的說明中，介紹了編譯線程安全客戶端庫的方法，</span>以及以線程安全方式使用它的方法。（下面關於<span><span>mysql_real_connect()</span>的說明實際上也適用於<span>mysql_connect()</span></span>，但由於<span><span>mysql_connect()</span>已不再被重視，</span>總應盡量使用<span>mysql_real_connect()</span>）。</p>
			<p>要想使<span><span>mysql_real_connect()</span>成為線程安全的，必須用下述命令再次編譯</span>客戶端庫：</p>
			<pre><span>shell&gt; <span><b>./configure --enable-thread-safe-client</b></span></span></pre>
			<p>它建立了線程安全客戶端庫<span><span>libmysqlclient_r</span>。（假定</span>您的作業系統有線程安全的<span><span>gethostbyname_r()</span>函數）。按照連接，</span>該庫是線程安全的。可遵循下述警告，使兩個線程共享相同的連接： 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在相同的連接上，兩個線程不能同時將查詢發送到<span>MySQL</span>伺服器。尤其是，必須確保在<span>mysql_query()</span>和<span><span>mysql_store_result()</span>之間，沒有使用相同連接的其他線程。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>很多線程均能訪問由<span><span>mysql_store_result()</span>檢索的不同結果集。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用了<span><span>mysql_use_result</span>，務必確保無其他線程正在使用相同的連接，直至關閉了結果集為止。然而，對於線程式客戶端，最好是共享相同的連接以使用<span>mysql_store_result()</span></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果打算在相同的連接上使用多個線程，必須在<span>mysql_query()</span>和<span><span>mysql_store_result()</span>使用組合上擁有互斥鎖。</span>一旦<span><span>mysql_store_result()</span>準備就緒，可釋放鎖定，其他線程可在相同的連接上執行查詢。</span>
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用<span>POSIX</span>線程進行編程，可使用<span>pthread_mutex_lock()</span>和<span><span>pthread_mutex_unlock()</span>來建立並釋放互斥鎖。</span>
			</p>
			<p>如果您有<span>1</span>個使用<span>MySQL</span>函數的線程，而該函數未建立與<span>MySQL</span>資料庫的連接，就需瞭解下述事宜：</p>
			<p>使用<span>mysql_init()</span>或<span>mysql_connect()</span>時，<span>MySQL</span>會為調試庫使用的線程建立與線程相關的變數（尤其）。</p>
			<p>線上程使用<span>mysql_init()</span>或<span><span>mysql_connect()</span>之前，</span>如果使用了<span>MySQL</span>函數，該線程將沒有所需的線程類變數，而且您很可能或早或晚結束於內核轉儲。</p>
			<p>要想使這些操作平穩工作，需要採取下述措施：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>如果程式在使用<span><span>mysql_real_connect()</span>之前需要使用任何其他<span>MySQL</span>函數，請在啟動程式時使用<span>my_init()</span></span>。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span><span>使用任何<span>MySQL</span>函數之前，線上程處理程式中使用<span>mysql_thread_init()</span></span>。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>線上程中，使用<span><span>pthread_exit()</span>之前請使用<span>mysql_thread_end()</span></span>。這樣，就能釋放<span>MySQL</span>線程類變數使用的內存。 
			</p>
			<p>將客戶端連結到<span>libmysqlclient_r</span>時，如果存在未定義的符號，可能會出錯。在大多數情況下，其原因在於，未將線程庫包含在<span>link/compile</span>行上。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="php"></a>25.3. MySQL PHP API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#php-problems">
		25.3.1. 使用MySQL和PHP的常見問題</a></span></dt></dl></div><a class="indexterm" name="id3032032"></a>
		<p><span>PHP</span>是一種伺服器端、<span>HTML</span>嵌入式指令處理語言，可使用該語言建立動態網頁。它可用於大多數作業系統和<span>Web</span>伺服器，也能訪問大多數常見資料庫，包括<span>MySQL</span>。<span>PHP</span>可以作為單獨程式運行，也能編譯為模塊，用於<span>Apache 
		Web</span>伺服器。</p>
		<p><span>PHP</span>實際上提供了兩種不同的<span>MySQL API</span>延伸：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>mysql</span>：適用於<span>PHP</span>版本<span>4</span>和<span>5</span>，該延伸用於<span>MySQL 
		4.1</span>之前的<span>MySQL</span>版本。該延伸不支援<span>MySQL 
		5.1</span>中採用的、改進的鑒定協議，也不支援與預處理語句或多語句。如果打算與<span>MySQL 5.1</span>一起使用該延伸，應配置<span>MySQL</span>伺服器，以使用「<strong><span>--old-passwords</span></strong>」選項（請參見<a href="problems.html#old-client" title="A.2.3. Client does not support authentication protocol">A.2.3節，「客戶端不支援鑒定協議」</a>）。在<span>PHP</span>網站的文檔中記錄了該該延伸<span><a target="_top"  href="http://php.net/mysql">http://php.net/mysql</a></span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span><span>mysqli</span>是「<span class="quote"><span>MySQL, 
		Improved</span></span>」的縮寫，該延伸僅適用於<span>PHP 5</span>。它能用於<span>MySQL 
		4.1.1</span>和更高版本。該延伸完全支援<span>MySQL 5.1</span>中採用的鑒定協議，也支援預處理語句和多語句<span>API</span>。此外，該延伸還提供了先進的、面向對象的編程接口。在<span><a target="_top"  href="http://php.net/mysqli">http://php.net/mysqli</a></span>上，可找到關於<span>mysqli</span>延伸的文檔。在<span><a target="_top"  href="http://www.zend.com/php5/articles/php5-mysqli.php">http://www.zend.com/php5/articles/php5-mysqli.php</a></span>處，給出了一篇有用的文章。</p>
		<p><span>PHP</span>分發版和文檔均能從<span><a target="_top"  href="http://www.php.net/">PHP<span>網站</span></a></span>獲得。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="php-problems"></a>
			25.3.1.&nbsp;使用MySQL和PHP的常見問題</h3></div></div></div><div class="itemizedlist">
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>錯誤：超出了最大執行時間，這是一種</span><span>PHP</span>限制，如果需要，進入檔案<span><span>php.ini</span>，並設置最大執行時間（開始為<span>30</span>秒）。此外，還可以將每指令允許使用的<span>RAM</span>增加一倍，</span>從<span>8MB</span>變為<span>16MB</span>，這也是個不錯的主意。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>致命錯誤：在<span>…</span>中使用了不支援或未定義的<span>mysql_connect()</span>函數，這意味著，您的</span><span>PHP</span>版本不支援<span>MySQL</span>。您可以編譯動態<span>MySQL</span>模塊並將其加載到<span>PHP</span>，或使用內置的<span>MySQL</span>支援重新編譯<span>PHP</span>。在<span>PHP</span>手冊中，詳細介紹了該程序。 
				</p>
				<p>
				<span>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>錯誤：對<span>&#39;uncompress&#39;</span>的未定義引用，</span>這意味著所編譯的客戶端庫支援壓縮客戶端／伺服器協議。更正方法是，用「<span>-lmysqlclient</span>」進行連結時，在最後新增「<span><span>-lz」</span>。</span></p>
				<p>
				<span>
				·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>錯誤：客戶端不支援鑒定協議，與</span><span>MySQL 
				4.1.1</span>和更高版本一起使用較舊的<span>mysql</span>延伸時常會遇到該問題。可能的解決方案是：降級到<span>MySQL 
				4.0</span>，轉向<span>PHP 5</span>和較新的<span><span>mysqli</span>延伸，或用<span>「--old-passwords」</span>配置<span>MySQL</span>伺服器</span>（更多訊息，請參見<a href="problems.html#old-client" title="A.2.3. Client does not support authentication protocol">A.2.3節，「客戶端不支援鑒定協議」</a>）。</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="perl"></a>25.4. MySQL Perl API</h2></div></div></div><a class="indexterm" name="id3032259"></a><a class="indexterm" name="id3032269"></a><a class="indexterm" name="id3032276"></a><a class="indexterm" name="id3032284"></a>
		<p><span>Perl <span>DBI</span></span><span>模塊為資料庫訪問提供了一個通用接口。</span>能夠編寫無需更改就能與不同的資料庫引擎一起工作的<span>DBI</span>指令。要想使用<span>DBI</span>，必須安裝<span>DBI</span>模塊，並為打算訪問的每種伺服器安裝資料庫驅動程式（<span>DBD</span>）模塊。對於<span>MySQL</span>，該驅動程式是<span>DBD::mysql</span>模塊。</p>
		<p><span>Perl DBI</span>是推薦的<span>Perl</span>接口。它取代了舊的名為<span><span>mysqlperl</span>的接口，<span>mysqlperl</span>已過時。</span></p>
		<p>關於<span>Perl DBI</span>支援的安裝說明，請參見<a href="installing.html#perl-support" title="2.13. Perl Installation Notes">2.13節，「Perl安裝注意事項」</a>。</p>
		<p><span>DBI</span>訊息能夠在命令行上提供，也能以線上方式提供，或採用印刷形式：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>一旦安裝了<span>DBI</span>和<span>DBD::mysql</span>模塊，可使用<span>perldoc</span><span>
		</span>命令在命令行上獲取關於它們的訊息：</p>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBI</b></span></span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBI::FAQ</b></span></span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; <span><b>perldoc DBD::mysql</b></span></span></pre>
		<p>也可以使用<span>pod2man</span>、<span><span>pod2html</span>等</span>將這類訊息轉換為其他格式。 
		</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>關於<span>Perl DBI</span>的線上訊息，請訪問<span>DBI</span>網站，<span><a target="_top"  href="http://dbi.perl.org/">http://dbi.perl.org/</a></span>。該站點還提供了<span>1</span>個一般性<span>DBI</span>郵件列資料表。<span>MySQL 
		AB</span>提供了<span>1</span>個專門針對<span>DBD::mysql</span><span>
		</span>的郵件列資料表，請參見<span><a title="1.7.1.1.&nbsp;The MySQL Mailing Lists"  href="file:///H:/introduction.html#mailing-list">1.7.1.1
		<span>「</span>MySQL<span>郵件列資料表」</span></a></span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>至於印刷版訊息，官方的<span>DBI</span>書籍是<em><span>編程<span>Perl 
		DBI</span></span></em>（<span>Alligator Descartes</span>和<span>Tim 
		Bunce</span>，<span>O&#39;Reilly &amp; Associates, 2000</span>）。關於該書的訊息，請訪問<span>DBI</span>網站<span><a target="_top"  href="http://dbi.perl.org/">http://dbi.perl.org/</a></span>。</p>
		<p>關於與<span>MySQL</span>一起使用<span>DBI</span>的專門訊息，請參見<em><span>針對<span>Web</span>的<span>MySQL</span>和<span>Perl</span>（</span></em><span>Paul 
		DuBois, New Riders, 2001</span>）。該書的網站是<span><a target="_top"  href="http://www.kitebird.com/mysql-perl/">http://www.kitebird.com/mysql-perl/</a></span>。</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="cplusplus"></a>25.5. MySQL C++ API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#borland-c-plus-plus">25.5.1. Borland C++</a></span></dt></dl></div><a class="indexterm" name="id3032468"></a><a class="indexterm" name="id3032474"></a>
		<p><span>MySQL++</span>是用於<span>C++</span>的<span>MySQL 
		API</span>。<span>Warren Young</span>負責該項目。要想瞭解更多訊息，請訪問<span><a target="_top"  href="http://www.mysql.com/products/mysql++/">http://www.mysql.com/products/mysql++/</a></span>。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="borland-c-plus-plus"></a>25.5.1. Borland C++</h3></div></div></div><a class="indexterm" name="id3032506"></a></div></div><div class="section"><div class="titlepage"><div><div>
	可以使用<span>Borland C++ 5.02</span>編譯<span>MySQL Windows</span>原始碼（<span>Windows</span>原始碼僅包括用於<span>Microsoft 
	VC++</span>的項目，對於<span>Borland C++</span>，您將不得不自己編製項目檔案）。<p>使用<span>Borland 
	C++</span>時的<span>1</span>個已知問題是，它採用了不同於<span>VC++</span>的結構對齊方式。這意味著，如果您打算與<span>Borland 
	C++</span>一起使用預設的<span>libmysql.dll</span>庫（它是使用<span>VC++</span>編譯的），將會遇到問題。為了避免該問題，僅應使用將<span>Null</span>作為參量的<span><span>mysql_init()</span>，而不是預先分配<span>MYSQL</span>結構。</span></p>
	<h2 class="title"><a name="python"></a>25.6. MySQL Python API</h2></div></div></div><a class="indexterm" name="id3032556"></a></div><div class="section"><div class="titlepage"><div><div>
		<span><span>MySQLdb</span>為</span><span>Python</span>提供了<span>MySQL</span>支援，它符合<span>Python 
		DB API</span>版本<span>2.0</span>的要求，可在<span><a target="_top"  href="http://sourceforge.net/projects/mysql-python/">http://sourceforge.net/projects/mysql-python/</a></span>上找到它。<h2 class="title"><a name="tcl"></a>25.7. MySQL Tcl API</h2></div></div></div><a class="indexterm" name="id3032588"></a></div><div class="section"><div class="titlepage"><div><div>
		<span>MySQLtcl</span>是一種簡單的<span>API</span>，用於從<span>Tcl</span>編程語言訪問<span>MySQL</span>資料庫伺服器。可在<span><a target="_top"  href="http://www.xdobry.de/mysqltcl/">http://www.xdobry.de/mysqltcl/</a></span>上找到它。<h2 class="title"><a name="eiffel"></a>25.8. MySQL Eiffel Wrapper</h2></div></div></div><a class="indexterm" name="id3032620"></a><a class="indexterm" name="id3032627"></a>
		<p><span>Eiffel MySQL</span>是一種與<span>MySQL</span>資料庫伺服器的接口，它採用的是<span>Eiffel</span>編程語言，由<span>Michael 
		Ravits</span>編寫。可在<span><a target="_top"  href="http://efsa.sourceforge.net/archive/ravits/mysql.htm">http://efsa.sourceforge.net/archive/ravits/mysql.htm</a></span>上找到它。</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="programming-utilities"></a>
		25.9.&nbsp;MySQL程式開發實用工具</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="apis.html#msql2mysql">
			25.9.1. msql2mysql：轉換mSQL程式以用於MySQL</a></span></dt><dt><span class="section"><a href="apis.html#mysql-config">
			25.9.2. mysql_config：獲取編譯客戶端的編譯選項</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
			在本節中，介紹了開發<span>MySQL</span>程式時可能會有用的一些實用工具。<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			msql2mysql</span><span> </span></p>
			<p><span>1</span>種<span>shell</span>指令，用於將<span><span>mSQL</span>程式轉換為</span><span>MySQL</span>程式。它不能處理所有情況，但能為轉換提供良好的開端。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			mysql_config</span><span> </span></p>
			<p><span>1</span>種<span>shell</span>指令，能生成編譯<span>MySQL</span>程式時所需的選項值。</p>
			<h3 class="title"><a name="msql2mysql"></a>
			25.9.1.&nbsp;msql2mysql：轉換mSQL程式以用於MySQL</h3></div></div></div>
			<p>最初，開發的<span>MySQL C API</span>很類似為<span>mSQL</span>資料庫系統開發的<span>API</span>。正因為如此，通過更改<span>C 
			API</span>函數的名稱，通常能相對容易地轉換<span>mSQL</span>程式，使之用於<span>MySQL</span>。</p>
			<p><strong><span>msql2mysql</span></strong>實用工具用於將<span>mSQL 
			C API</span>函數使用轉換為其<span>MySQL</span>對等物。<strong><span>msql2mysql</span></strong>能夠轉換位於恰當位置輸入檔案，在執行具體轉換之前複製原件。例如，可採用下述方式使用<strong><span>msql2mysql</span></strong>：</p>
			<pre><span>shell&gt; <span><b>cp client-prog.c client-prog.c.orig</b></span></span></pre>
			<pre><span>shell&gt; <span><b>msql2mysql client-prog.c</b></span></span></pre>
			<pre><span>client-prog.c converted</span></pre>
			<p>然後，檢查<span><span>client-prog.c</span>，並執行可能需要的</span>後期轉換修訂。</p>
			<p><strong><span>msql2mysql</span></strong>使用<strong><span>replace</span></strong>實用工具來替換函數名。請參見<a href="client-side-scripts.html#replace-utility" title="8.14. replace — A String-Replacement Utility">8.14節，「replace：字串替換實用工具」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-config"></a>
			25.9.2.&nbsp;mysql_config：獲取編譯客戶端的編譯選項</h3></div></div></div>
			<p><strong><span>mysql_config</span></strong>提供了關於編譯<span>MySQL</span>客戶端以及將其連接到<span>MySQL</span>的有用訊息。</p>
			<p><strong><span>mysql_config</span></strong>支援下述選項：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--cflags</span><span>
			</span></p>
			<p>編譯器標誌，用於搜尋包含檔案，以及編譯<span><span>libmysqlclient</span>庫時所要使用的</span>關鍵編譯器標誌和定義。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			--include</span><span> </span></p>
			<p>編譯器選項，用於搜尋<span>MySQL</span>包含檔案（注意，正常情況下應使用「<span><span>—cflags」</span>而不是該選項）。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libmysqld-libs</span><span>,
			<span>---embedded</span> </span></p>
			<p>與<span>MySQL</span>嵌入式伺服器進行連結所需的庫和選項。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libs</span><span>
			</span></p>
			<p>與<span>MySQL</span>客戶端庫進行連結所需的庫和選項。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--libs_r</span><span>
			</span></p>
			<p>與線程安全<span>MySQL</span>客戶端庫進行連結所需的庫和選項。 
			</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--port</span><span>
			</span></p>
			<p>預設的<span>TCP/IP</span>端口號，配置<span>MySQL</span>時定義。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>--socket</span><span>
			</span></p>
			<p>預設的<span>Unix</span>套接字檔案，配置<span>MySQL</span>時定義。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			--version</span><span> </span></p>
			<p>版本號以及<span>MySQL</span>分發版的版本。 
			</p>
			<p>如果未使用任何選項使用了<strong><span>mysql_config</span></strong>，將顯示它所支援的所有選項的列資料表，以及它們的值：</p>
			<pre><span>shell&gt; <span><b>mysql_config</b></span></span></pre>
			<pre><span>Usage: /usr/local/mysql/bin/mysql_config [options]</span></pre>
			<pre><span>Options:</span></pre>
			<pre><span>&nbsp; --cflags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-I/usr/local/mysql/include/mysql -mcpu=pentiumpro]</span></pre>
			<pre><span>&nbsp; --include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-I/usr/local/mysql/include/mysql]</span></pre>
			<pre><span>&nbsp; --libs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-L/usr/local/mysql/lib/mysql -lmysqlclient -lz</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lcrypt -lnsl -lm -L/usr/lib -lssl -lcrypto]</span></pre>
			<pre><span>&nbsp; --libs_r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-L/usr/local/mysql/lib/mysql -lmysqlclient_r</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lpthread -lz -lcrypt -lnsl -lm -lpthread]</span></pre>
			<pre><span>&nbsp; </span><span>--socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [/tmp/mysql.sock]</span></pre>
			<pre><span>&nbsp; --port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;[3306]</span></pre>
			<pre><span>&nbsp; --version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [4.0.16]</span></pre>
			<pre><span>&nbsp; </span><span>--libmysqld-libs [-L/usr/local/mysql/lib/mysql -lmysqld -lpthread -lz</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -lcrypt -lnsl -lm -lpthread -lrt]</span></pre>
			<p>可以在命令行上使用<strong><span>mysql_config</span></strong>，並包含針對特定選項的值。例如，要想編譯<span>MySQL</span>客戶端程式，可使用<strong><span>mysql_config</span></strong>，如下例所示：</p>
			<pre><span>shell&gt; <span><b>CFG=/usr/local/mysql/bin/mysql_config</b></span></span></pre>
			<pre><span>shell&gt; <span><b>sh -c &quot;gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`&quot;</b></span></span></pre>
			<p>以這種方式使用<strong><span>mysql_config</span></strong>時，務必在字元<span>(</span>『<span>`</span>』<span>)</span>內使用它。這樣，就能通知<span>shell</span>執行它，並將其輸出代入到環境命令中。</div></div></div><div><hr>
	<p><a name="OLE_LINK1">這是MySQL參考手冊的翻譯版本，關於MySQL參考手冊，請訪問</a><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
	原始參考手冊為英文版，與英文版參考手冊相比，本翻譯版可能不是最新的。 </div>
</body></html>
