<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 7. Optimization</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="replication.html" title="Chapter 6. Replication in MySQL"><link rel="next" href="client-side-scripts.html" title="Chapter 8. Client and Utility Programs">
<style>
<!--
span.GramE
	{}
 li.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	
	; margin-left:0cm; margin-right:0cm; margin-top:0cm}
span.quote
	{}
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	
	}
-->
</style>
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="optimization"></a>
	第7章：最佳化</h2></div></div></div><div class="toc"><p><b>
	目錄</b></p><dl><dt><span class="section"><a href="optimization.html#optimize-overview">7.1. 
			最佳化概述</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design-limitations">7.1.1. 
				MySQL設計局限與折衷</a></span></dt><dt><span class="section"><a href="optimization.html#portability">
				7.1.2. 為可移植性設計應用程式</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">
				7.1.3. 我們已將MySQL用在何處？</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">
				7.1.4. MySQL基準套件</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">
				7.1.5. 使用自己的基準</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#query-speed">
			7.2. 最佳化SELECT語句和其它查詢</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#explain">7.2.1. 
				EXPLAIN語法（獲取SELECT相關訊息）<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">
				7.2.2. 估計查詢性能</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">
				7.2.3. SELECT查詢的速度</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">
				7.2.4. MySQL怎樣最佳化WHERE子句<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">
				7.2.5. 範圍最佳化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">
				7.2.6. 索引合併最佳化</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">
				7.2.7. MySQL如何最佳化IS NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">
				7.2.8. MySQL如何最佳化DISTINCT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">
				7.2.9. MySQL如何最佳化LEFT JOIN和RIGHT JOIN</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">
				7.2.10. MySQL如何最佳化嵌套Join</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">
				7.2.11. MySQL如何簡化外部聯合</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">
				7.2.12. MySQL如何最佳化ORDER BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">
				7.2.13. MySQL如何最佳化GROUP BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">
				7.2.14. MySQL如何最佳化LIMIT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">
				7.2.15. 如何避免資料表掃瞄</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">
				7.2.16. INSERT語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">
				7.2.17. UPDATE語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">
				7.2.18. DELETE語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#tips">
				7.2.19. 其它最佳化技巧</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">
			7.3. 鎖定事宜</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">
				7.3.1. 鎖定方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">
				7.3.2. 資料表鎖定事宜</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">
			7.4. 最佳化資料庫結構</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design">
				7.4.1. 設計選擇</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">
				7.4.2. 使您的數據盡可能小</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">
				7.4.3. 列索引</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">
				7.4.4. 多列索引</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">
				7.4.5. MySQL如何使用索引</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">
				7.4.6. MyISAM鍵高速緩衝</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. 
				MyISAM索引統計集合</a></span></dt><dt><span class="section"><a href="optimization.html#open-tables">
				7.4.8. MySQL如何計算打開的資料表</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">
				7.4.9. MySQL如何打開和關閉資料表</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">
				7.4.10. 在同一個資料庫中建立多個資料表的問題</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-the-server">
			7.5. 最佳化MySQL伺服器</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#system">
				7.5.1. 系統因素和啟動參數的調節</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">
				7.5.2. 調節伺服器參數</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">
				7.5.3. 控制查詢最佳化器的性能</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">
				7.5.4. 編譯和連結怎樣影響MySQL的速度</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">
				7.5.5. MySQL如何使用內存</a></span></dt><dt><span class="section"><a href="optimization.html#dns">
				7.5.6. MySQL如何使用DNS</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#disk-issues">
			7.6. 磁盤事宜</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#symbolic-links">
				7.6.1. 使用符號連結</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div>
		<p>
		最佳化是一個複雜的任務，因為最終要求瞭解整個待最佳化的系統。儘管可以進行局部最佳化而不需要瞭解系統或應用程式，為了最佳化得更好，您必須知道更多的訊息。</p>
		<p>
		本章解釋並給出不同的最佳化<span>MySQL</span>的方法示範。但要記住總有一些其它方法使系統更快，儘管需要更多的工作。</p>
		<h2 class="title"><a name="optimize-overview"></a>7.1. 最佳化概述</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design-limitations">
		7.1.1. MySQL設計局限與折衷</a></span></dt><dt><span class="section"><a href="optimization.html#portability">
		7.1.2. 為可移植性設計應用程式</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">
		7.1.3. 我們已將MySQL用在何處？</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">
		7.1.4. MySQL基準套件</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">
		7.1.5. 使用自己的基準</a></span></dt></dl></div>
		<p>
		使一個系統更快的最重要因素當然是基本設計。此外，還需要知道系統正做什麼樣的事情，以及瓶頸是什麼。</p>
		<p>
		最常見的系統瓶頸是：</p>
		<ul type="disc">
			<li>
			磁盤搜索。需要花時間從磁盤上找到一個數據，用在現代磁盤的平均時間通常小於<span>10ms</span>，因此理論上我們能夠每秒大約搜索<span>1000</span>次。這個時間在新磁盤上提高不大並且很難為一個資料表進行最佳化。最佳化它的方法是將數據分佈在多個磁盤上。</li>
			<li>
			磁盤讀<span>/</span>寫。當磁盤放入正確位置後，我們需要從中讀取數據。對於現代的磁盤，一個磁盤至少傳輸<span>10-20Mb/s</span>的吞吐。這比搜索要容易最佳化，因為您能從多個磁盤並行地讀。</li>
			<li>
			<span>CPU</span>週期。我們將數據讀入內存後，需要對它進行處理以獲得我們需要的結果。資料表相對於內存較小是最常見的限制因素。但是對於小資料表，速度通常不成問題。</li>
		</ul>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>內存帶寬。當<span>CPU</span>需要的數據超出<span>CPU</span>緩存時，主緩存帶寬就成為內存的一個瓶頸。這在大多數系統正是一個不常見的瓶頸但是您應該知道它。</p>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="design-limitations"></a>
			7.1.1.&nbsp;MySQL設計局限與折衷</h3></div></div></div><a class="indexterm" name="id2798886"></a><a class="indexterm" name="id2798896"></a>
			<p>
			當使用<span>MyISAM</span>儲存引擎時，<span>MySQL</span>使用極快速的資料表鎖定，以便允許多次讀或一次寫。使用該儲存引擎的最大問題出現在同一個資料表中進行混合穩定數據流更新與慢速選擇。如果這只是某些資料表的問題，您可以使用另一個儲存引擎。參見<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>儲存引擎和資料表類型</i></a>。</p>
			<p>
			<span>MySQL</span>可以使用事務資料表和非事務資料表。為了更容易地讓非事務資料表順利工作<span>(</span>如果出現問題不能回滾<span>)</span>，<span>MySQL</span>採用下述規則。請注意這些規則<em><span>只適用於</span></em>不運行在嚴格模式下或為<span>INSERT</span>或<span>UPDATE</span>使用<span>IGNORE</span>規定程式時。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有列有預設值。請注意當運行在嚴格<span>SQL</span>模式<span>(</span>包括<span>TRADITIONAL</span><span> 
			SQL</span>模式<span>)</span>時，必須為<span>NOT 
			NULL</span>列指定預設值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果向列內插入不合適的或超出範圍的值，<span>MySQL</span>將該列設定為「最好的可能的<span class="quote">值</span>」，而不是報告錯誤。對於數字值，為<span>0</span>、可能的最小值或最大值。對於字串，為空字串或列內可以保存的字串。請注意當運行在嚴格模式或<span>TRADITIONAL</span><span> 
			SQL</span>模式時該行為不 適用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有資料表達式的計算結果返回一個資料表示錯誤狀況的信號。例如，<span>1/0</span>返回<span>NULL</span>。<span>(</span>使用<span>ERROR_FOR_DIVISION_BY_ZERO</span><span> 
			SQL</span>模式可以更改該行為<span>)</span>。</p>
			<p>
			如果正使用非事務資料表，不應該使用<span>MySQL</span>來檢查列的內容。一般情況，最安全的<span>(</span>通常是最快的<span>)</span>方法徑是讓應用程式確保只向資料庫傳遞合法值。</p>
			<p>
			相關詳細訊息參見<a href="introduction.html#constraints" title="1.8.6. How MySQL Deals with Constraints">1.8.6節，「MySQL處理約束的方式」</a>和<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4節，「INSERT語法」</a>或<a href="database-administration.html#server-sql-mode" title="5.3.2. The Server SQL Mode">5.3.2節，「SQL伺服器模式」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="portability"></a>
			7.1.2.&nbsp;為可移植性設計應用程式</h3></div></div></div><a class="indexterm" name="id2799063"></a><a class="indexterm" name="id2799069"></a><a class="indexterm" name="id2799076"></a>
			<p>
			<span>因為不同<span>SQL</span>伺服器實現了標準<span>SQL</span>的不同部分，需要花功夫來編寫可移植的<span>SQL</span>應用程式。對很簡單的選擇<span>/</span>插入，很容易實現移植，但是需要的功能越多則越困難。如果想要應用程式對很多資料庫系統都快，它變得更難！</span></p>
			<p>
			為了使一個複雜應用程式可移植，您需要選擇它應該工作的<span>SQL</span>伺服器，並確定這些伺服器支援什麼特性。</p>
			<p>
			所有資料庫都有一些弱點。這就是它們不同的設計折衷導致的不同行為。</p>
			<p>
			可以使用<strong><span>MySQL</span></strong>的<b><span>crash-me</span></b>程式來找出能用於資料庫伺服器選擇的函數、類型和限制。<b><span>crash-me</span></b>並不能找出所有的特性，但是其廣度仍然很合理，可以進行大約<span>450</span>個測試。</p>
			<p>
			<strong><span>crash-me</span></strong>可以提供的一種類型的訊息的例子：如果想要使用<span>Informix</span>或<span>DB2</span>，不應該使用超過<span>18</span>個字元的列名。</p>
			<p><b><span>
			crash-me</span></b>程式和<strong><span>MySQL</span></strong>基準程式是獨立於資料庫的。通過觀察它們是如何編寫的，編可以知道必須為編寫獨立於資料庫的應用程式做什麼。基準本身可在<strong><span>MySQL</span></strong>原始碼分發的<tt ><span>「sql-bench」</span></tt>目錄下找到。它們用<span>DBI</span>資料庫接口以<span>Perl</span>寫成。使用<span>DBI</span>本身即可以解決部分移植性問題，因為它提供與資料庫無關的的存取方法。</p>
			<p>
			關於<strong><span>crash-me</span></strong>結果，訪問<span><a target="_top"  href="http://dev.mysql.com/tech-resources/crash-me.php">http://dev.mysql.com/tech-resources/crash-me.php</a></span>。到<span><a target="_top"  href="http://dev.mysql.com/tech-resources/benchmarks/">http://dev.mysql.com/tech-resources/benchmarks/</a></span>看這個基準的結果。</p>
			<p>如果您為資料庫的獨立性而努力，需要很好地瞭解每個<span>SQL</span>伺服器的瓶頸。例如，<strong><span style="font-family:
細明體;">MySQL</span></strong>在檢索和更新<span>MyISAM</span>資料表記錄方面很快，但是在同一個資料表上混合慢速讀者和寫者方面有一個問題。另一方面，當您試圖訪問最近更新了<span>(</span>直到它們被刷新到磁盤上<span>)</span>的行時，在<span>Oracle</span>中有一個很大的問題。事務資料庫總的來說在從記錄檔案資料表中生成總結資料表方面不是很好，因為在這種情況下，行鎖定幾乎沒有用。</p>
			<p>
			為了使應用程式「確實」獨立於資料庫，需要定義一個容易延伸的接口，用它可操縱數據。因為<span>C++</span>在大多數系統上可以適用，使用資料庫的一個<span>C++
			</span>類接口是有意義的。</p>
			<p>如果您使用某個資料庫特定的功能<span>(</span>例如<strong><span>MySQL</span><span>專用的</span></strong><span>REPLACE</span>語句<span>)</span>，應該為<span>SQL</span>伺服器編碼一個方法以實現同樣的功能。儘管慢些，但確允許其它伺服器執行同樣的任務。</p>
			<p>用<strong><span>MySQL</span></strong>，可以使用<span>/*! 
			*/</span>語法把<strong><span style="font-family:
細明體;">MySQL</span></strong>特定的關鍵詞加到查詢中。在<span>/**/</span>中的代碼將被其它大多數<span>SQL</span>伺服器視為註釋<span>(</span>並被忽略<span>)</span>。</p>
			<p>如果高性能真的比準確性更重要，就像在一些<span>web</span>應用程式那樣，一種可行的方法是建立一個應用層，緩存所有的結果以便得到更高的性能。通過只是讓舊的結果在短時間後『過期』，能保持緩存合理地刷新。這在極高負載的情況下是相當不錯的，在此情況下，能動態地增加緩存並且設定較高的過期時限直到一切恢復正常。</p>
			<p>
			在這種情況下，資料表建立訊息應該包含緩存初始大小和資料表刷新頻率等訊息。</p>
			<p>
			實施應用程式緩存的一種方法是使用<span>MySQL</span>查詢緩存。啟用查詢緩存後，伺服器可以確定是否可以重新使用查詢結果。這樣簡化了您的應用程式。參見<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13節，「MySQL查詢高速緩衝」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-use"></a>
			7.1.3.&nbsp;我們已將MySQL用在何處？</h3></div></div></div><a class="indexterm" name="id2799272"></a><a class="indexterm" name="id2799282"></a>
			<p>
			該節描述了<span>Mysql</span>的早期應用程式。</p>
			<p>在<span>MySQL</span>最初開發期間，<span>MySQL</span>的功能適合大多數客戶。<span>MySQL</span>為瑞典的一些最大的零售商處理數據倉庫。</p>
			<p>
			我們從所有商店得到所有紅利卡交易的每週總結，並且我們期望為所有店主提供有用的訊息以幫助他們得出他們的廣告戰如何影響他們的顧客。</p>
			<p>數據是相當巨量的<span>(</span>大約每月<span>7</span>百萬宗交易總結<span>)</span>並且我們保存<span>4-10</span>年來的數據需要呈現給用戶。我們每週從顧客那裡得到請求，他們想要「立刻」訪問來自該數據的新報告。</p>
			<p>
			我們通過每月將所有訊息儲存在壓縮的「交易」資料表中來解決它。我們有一套簡單的宏<span>/</span>指令用來生成來自交易資料表的不同條件<span>(
			</span>產品組、顧客<span>id</span>，商店<span>...)</span>的總結資料表。報告是由一個進行語法分析網頁的小<span>perl</span>指令動態生成的網頁，在指令中執行<span>SQL</span>語句並且插入結果。我們很想使用<span>PHP</span>或<b><span>mod_perl</span></b>，但是那時它們還不可用。</p>
			<p>對圖形數據，我們用<span>C</span>語言編寫了一個簡單的工具，它能基於那些結果處理<span>SQL</span>查詢結果並生成<span>GIF</span>圖形。該工具也從分析<span>Web</span>網頁的<span>perl</span>指令中動態地執行。</p>
			<p>
			在大多數情況下，一個新的報告通過簡單地複製一個現有指令並且修改其中的<span>SQL</span>查詢來完成。在一些情況下，我們將需要把更多的列加到一個現有的總結資料表中或產生一個新的，但是這也相當簡單，因為我們在磁盤上保存所有交易資料表。（目前我們大約有<span>50G</span>的交易資料表和<span>200G</span>的其它顧客數據<span>)</span>。 
			</p>
			<p>我們也讓我們的顧客直接用<span>ODBC</span>訪問總結資料表以便高級用戶能自己用這些數據進行試驗。</p>
			<p>
			該系統工作得很好，我們可以毫無問題地用很適度的<span>Sun Ultra SPARC</span>工作站硬件<span>(2x200MHz)</span>來處理數據。該系統被逐步移植到了<span>Linux</span>中。</p>
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title"><a name="mysql-benchmarks"></a>7.1.4.&nbsp;MySQL基準套件</h3>
					</div></div></div><a class="indexterm" name="id2799384"></a>
			<a class="indexterm" name="id2799391"></a>
			<p>
			<span>本節應該包含<strong><span>MySQL</span></strong>基準套件<span>(</span>和</span><span><b><span>crash-me</span></b></span><span>)</span><span>的技術描述，但是該描述還沒寫成。目前，您可以通過在</span><span >MySQL</span><span>原始碼</span><span>分發中的</span><tt ><span>「sql-bench」</span></tt><span>目錄下的代碼和結果瞭解基準套件是如何工作的。</span></p>
			<p>
			<span>通過基準用戶可以瞭解一個給定的<span>SQL</span>實現在哪方面執行得很好或很糟糕。</span></p>
			<p>
			注意，這個基準是單線程的，它可以測量操作執行的最小時間。我們計劃將來在基準套件中新增多線程測試。</p>
			<p>
			要使用基準套件，必須滿足下面的要求：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>基準套件隨<span>MySQL</span>原始碼分發提供。可以從<span><a target="_top"  href="http://dev.mysql.com/downloads/">http://dev.mysql.com/downloads/</a></span>下載分發，或者使用當前的開發原始碼樹<span>(</span>參見<a href="installing.html#installing-source-tree" title="2.8.3. Installing from the Development Source Tree">2.8.3節，「從開發原始碼樹安裝」</a><span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>基準指令用<span>Perl</span>編寫而成，使用<span>Perl 
			DBI</span>模塊訪問資料庫伺服器，因此必須安裝<span>DBI</span>。還需要為每個待測試的伺服器提供伺服器專用<span>DBD</span>驅動程式。例如，要測試<span>MySQL</span>、<span>PostgreSQL</span>和<span>DB2</span>，必須安裝<span><span>DBD::mysql</span><span>、<span>DBD::Pg</span></span></span>和<span>DBD::DB2</span>模塊。參見<a href="installing.html#perl-support" title="2.13. Perl Installation Notes">2.13節，「Perl安裝注意事項」</a>。</p>
			<p>
			獲得<span>MySQL</span>原始碼分發後，可以在<span>sql-bench</span>目錄找到基準套件。要運行基準測試，應構建<span>MySQL</span>，然後進入<span>sql-bench</span>目錄並執行<span>run-all-tests</span>指令：</p>
			<p><span>shell&gt; <b>cd sql-bench</b></span></p>
			<p><span>shell&gt; <b>perl run-all-tests 
			--server=<i>server_name</i></b></span></p>
			<p>
			<span><i>
			<span>server_name</span></i></span>是一個支援的伺服器。要獲得所有選項和支援的伺服器，使用命令：</p>
			<pre><span >shell&gt; </span><b><span >perl run-all-tests --help</span></b></pre>
			<p>
			<strong><span>crash-me</span></strong>指令也位於<span>sql-bench</span>目錄。<strong><span>crash-me</span></strong>嘗試通過實際運行查詢確定資料庫支援的特性以及其功能和限制。例如，它確定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支援什麼列類型</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支援多少索引</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>支援什麼函數</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>查詢可以多大</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>VARCHAR</span>列可以多大</p>
			<p>
			可以從<span><a target="_top"  href="http://dev.mysql.com/tech-resources/crash-me.php">http://dev.mysql.com/tech-resources/crash-me.php</a></span>發現許多不同資料庫伺服器的<strong><span>crash-me</span></strong>的結果。關於基準測試結果的詳細訊息，訪問<span><a target="_top"  href="http://dev.mysql.com/tech-resources/benchmarks/">http://dev.mysql.com/tech-resources/benchmarks/</a></span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-benchmarks"></a>
			7.1.5.&nbsp;使用自己的基準</h3></div></div></div><a class="indexterm" name="id2799639"></a><a class="indexterm" name="id2799646"></a>
			<p>
			一定要測試應用程式和資料庫，以發現瓶頸在哪兒。通過修正它<span>(</span>或通過用一個「啞模塊」代替瓶頸<span>)</span>，可以很容易地確定下一個瓶頸。即使您的應用程式的整體性能目前可以接受，至少應該對每個瓶頸做一個計劃，如果某天確實需要更好的性能，應知道如何解決它。</p>
			<p>
			關於一些可移植的基準程式的例子，參見<span>MySQL</span>基準套件。請參見<a href="optimization.html#mysql-benchmarks" title="7.1.4. The MySQL Benchmark Suite">7.1.4節，「MySQL基準套件」</a>。可以利用這個套件的任何程式並且根據您的需要修改它。通過這樣做，可以嘗試不同的問題的解決方案並測試哪一個是最好的解決方案。</p>
			<p>
			另一個免費基準套件是開放原始碼資料庫基準套件，參見<span><a target="_top"  href="http://osdb.sourceforge.net/">http://osdb.sourceforge.net/</a></span>。</p>
			<p>
			在系統負載繁重時出現一些問題是很普遍的，並且很多客戶已經與我們聯繫了，他們在生產系統中有一個<span>(</span>測試<span>)</span>系統並且有負載問題。大多數情況下，性能問題經證明是與基本資料庫設計有關的問題<span>(</span>例如，資料表掃瞄在高負載時資料表現不好<span>)</span>或作業系統或庫問題。如果系統已經不在生產系統中，它們大多數將<strong><span>很</span></strong>容易修正。</p>
			<p>
			為了避免這樣的問題，應該把工作重點放在在可能最壞的負載下測試您的整個應用程式。您可以使用<span>Super 
			Smack</span>。該工具可以從<span><a target="_top"  href="http://jeremy.zawodny.com/mysql/super-smack/">http://jeremy.zawodny.com/mysql/super-smack/</a></span>獲得。正如它的名字所建議，它可以根據您的需要提供合理的系統，因此確保只用於您的開發系統。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="query-speed"></a>
		7.2.&nbsp;最佳化SELECT語句和其它查詢</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#explain">7.2.1. 
			EXPLAIN語法（獲取SELECT相關訊息）<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">
			7.2.2. 估計查詢性能</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">
			7.2.3. SELECT查詢的速度</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">
			7.2.4. MySQL怎樣最佳化WHERE子句<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">
			7.2.5. 範圍最佳化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">
			7.2.6. 索引合併最佳化</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">
			7.2.7. MySQL如何最佳化IS NULL<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">
			7.2.8. MySQL如何最佳化DISTINCT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">
			7.2.9. MySQL如何最佳化LEFT JOIN和RIGHT JOIN</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">
			7.2.10. MySQL如何最佳化嵌套Join</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">
			7.2.11. MySQL如何簡化外部聯合</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">
			7.2.12. MySQL如何最佳化ORDER BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">
			7.2.13. MySQL如何最佳化GROUP BY<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">
			7.2.14. MySQL如何最佳化LIMIT<code class="literal"></code></a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">
			7.2.15. 如何避免資料表掃瞄</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">
			7.2.16. INSERT語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">
			7.2.17. UPDATE語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">
			7.2.18. DELETE語句的速度</a></span></dt><dt><span class="section"><a href="optimization.html#tips">
			7.2.19. 其它最佳化技巧</a></span></dt></dl></div><a class="indexterm" name="id2799739"></a><a class="indexterm" name="id2799749"></a><a class="indexterm" name="id2799759"></a><div class="section"><div class="titlepage"><div><div>
			<p>
			首先，影響所有語句的一個因素是：您的授權設置得越複雜，所需要的開銷越多。</p>
			<p>
			執行<span>GRANT</span>語句時使用簡單的授權，當客戶執行語句時，可以使<span>MySQL</span>降低授權檢查開銷。例如，如果未授予任何資料表級或列級權限，伺服器不需要檢查<span >tables_priv</span>和<span >columns_priv</span>資料表的內容。同樣地，如果不對任何
			帳號進行限制，伺服器不需要對資源進行統計。如果查詢量很高，可以花一些時間使用簡化的授權結構來降低授權檢查開銷。</p>
			<p>
			如果您的問題是與具體<span>MySQL</span>資料表達式或函數有關，可以使用<strong><span>mysql</span></strong>客戶程式所帶的<span>BENCHMARK()</span>函數執行定時測試。其語法為<span >BENCHMARK(<i>loop_count</i>,<i>expression</i>)</span>。例如：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT BENCHMARK(1000000,1+1)</span><span>；</span></b></span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>| BENCHMARK(1000000,1+1) |</span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 |</span></pre>
			<pre><span>+------------------------+</span></pre>
			<pre><span>1 row in set (0.32 sec)</span></pre>
			<p>
			上面結果在<span>PentiumII 
			400MHz</span>系統上獲得。它顯示<strong><span>MySQL</span></strong>在該系統上在<span>0.32</span>秒內可以執行<span>1,000,000</span>個簡單的<span>+</span>資料表達式運算。</p>
			<p>所有<strong><span style="font-family:
細明體;">MySQL</span></strong>函數應該被高度最佳化，但是總有可能有一些例外。<span >BENCHMARK()</span>是一個找出是否查詢有問題的優秀的工具。</p>
			<h3 class="title"><a name="explain"></a>7.2.1. EXPLAIN語法（獲取SELECT相關訊息）<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2799867"></a><a class="indexterm" name="id2799876"></a>
			<pre><span>EXPLAIN </span><span><i><span>tbl_name</span></i></span></pre>
			<p>
			或：</p>
			<pre><span>EXPLAIN [EXTENDED] SELECT </span><span><i><span>select_options</span></i></span></pre>
			<p>
			<span>EXPLAIN</span>語句可以用作<span >DESCRIBE</span>的一個同義詞，或獲得關於<span>MySQL</span>如何執行<span>SELECT</span>語句的訊息：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>EXPLAIN <i>tbl_name</i></span>是<span >DESCRIBE
			<i>tbl_name</i></span>或<span >SHOW 
			COLUMNS FROM <i>tbl_name</i></span>的一個同義詞。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果在<span>SELECT</span>語句前放上關鍵詞<span>EXPLAIN</span>，<strong><span>MySQL</span></strong>將解釋它如何處理<span>SELECT</span>，提供有關資料表如何聯接和聯接的次序。</p>
			<p>
			該節解釋<span>EXPLAIN</span>的第<span>2</span>個用法。</p>
			<p>
			借助於<span>EXPLAIN</span>，可以知道什麼時候必須為資料表加入索引以得到一個使用索引來尋找記錄的更快的<span>SELECT</span>。</p>
			<p>
			如果由於使用不正確的索引出現了問題，應運行<span>ANALYZE 
			TABLE</span>更新資料表的統計（例如關鍵字集的勢），這樣會影響最佳化器進行的選擇。參見<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1節，「ANALYZE 
		TABLE語法」</a>。</p>
			<p>
			還可以知道最佳化器是否以一個最佳次序聯接資料表。為了強制最佳化器讓一個<span>SELECT</span>語句按照資料表命名順序的聯接次序，語句應以<span>STRAIGHT_JOIN</span>而不只是<span >SELECT</span>開頭。</p>
			<p>
			<span>EXPLAIN</span>為用於<span>SELECT</span>語句中的每個資料表返回一行訊息。資料表以它們在處理查詢過程中將被<span>MySQL</span>讀入的順序被列出。<strong><span>MySQL</span></strong>用一遍掃瞄多次聯接（<em><span>single-sweep 
			multi-join</span></em>）的方式解決所有聯接。這意味著<strong><span>MySQL</span></strong>從第一個資料表中讀一行，然後找到在第二個資料表中的一個匹配行，然後在第<span>3</span>個資料表中等等。當所有的資料表處理完後，它輸出選中的列並且返回資料表清單直到找到一個有更多的匹配行的資料表。從該資料表讀入下一行並繼續處理下一個資料表。</p>
			<p>
			當使用<span>EXTENDED</span>關鍵字時，<span>EXPLAIN</span>產生附加訊息，可以用<span>SHOW 
			WARNINGS</span>瀏覽。該訊息顯示最佳化器限定<span>SELECT</span>語句中的資料表和列名，重寫並且執行最佳化規則後<span>SELECT</span>語句是什麼樣子，並且還可能包括最佳化過程的其它註解。</p>
			<p>
			<span>EXPLAIN</span>的每個輸出行提供一個資料表的相關訊息，並且每個行包括下面的列：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>id</span></p>
			<p>
			<span>SELECT</span>識別符。這是<span>SELECT</span>的查詢序列號。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>select_type</span></p>
			<p>
			<span>SELECT</span>類型，可以為以下任何一種：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>SIMPLE</span></p>
			<p>
			簡單<span>SELECT</span><span>(</span>不使用<span>UNION</span>或子查詢<span>)
			</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>PRIMARY</span></p>
			<p>
			最外面的<span>SELECT</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>UNION</span></p>
			<p>
			<span>UNION</span>中的第二個或後面的<span>SELECT</span>語句</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DEPENDENT UNION</span></p>
			<p>
			<span>UNION</span>中的第二個或後面的<span>SELECT</span>語句，取決於外面的查詢</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >UNION RESULT</span></p>
			<p>
			<span>UNION</span>的結果。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>SUBQUERY</span></p>
			<p>
			子查詢中的第一個<span>SELECT</span></p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DEPENDENT SUBQUERY</span></p>
			<p>
			子查詢中的第一個<span>SELECT</span>，取決於外面的查詢</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>DERIVED</span></p>
			<p>
			導出資料表的<span>SELECT</span><span>(</span><span >FROM</span>子句的子查詢<span>)</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span >table</span></p>
			<p>
			輸出的行所引用的資料表。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>type</span></p>
			<p>
			聯接類型。下面給出各種聯接類型，按照從最佳類型到最壞類型進行排序：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >system</span></p>
			<p>
			資料表僅有一行<span>(=</span>系統資料表<span>)</span>。這是<span>const</span>聯接類型的一個特例。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>const</span></p>
			<p>
			資料表最多有一個匹配行，它將在查詢開始時被讀取。因為僅有一行，在這行的列值可被最佳化器剩餘部分認為是常數。<span>const</span>資料表很快，因為它們只讀取一次！</p>
			<p>
			<span>const</span>用於用常數值比較<span>PRIMARY 
			KEY</span>或<span>UNIQUE</span>索引的所有部分時。在下面的查詢中，<span><i><span>tbl_name</span></i></span>可以用於<span>const</span>資料表：</p>
			<pre><span>SELECT * from </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>primary_key</span></i></span><span>=1</span>；</pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * from </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>primary_key_part1</span></i></span><span>=1</span>和 <span><i><span>primary_key_part2</span></i></span><span>=2</span>；</pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>eq_ref</span></p>
			<p>
			對於每個來自於前面的資料表的行組合，從該資料表中讀取一行。這可能是最好的聯接類型，除了<span>const</span>類型。它用在一個索引的所有部分被聯接使用並且索引是<span>UNIQUE</span>或<span>PRIMARY 
			KEY</span>。</p>
			<p>
			<span>eq_ref</span>可以用於使用<span>=</span><span>
			</span>操作符比較的帶索引的列。比較值可以為常量或一個使用在該資料表前面所讀取的資料表的列的資料表達式。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>eq_ref</span>聯接來處理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part1</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part2</span></i></span><span>=1;</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>ref</span></p>
			<p>
			對於每個來自於前面的資料表的行組合，所有有匹配索引值的行將從這張資料表中讀取。如果聯接只使用鍵的最左邊的前綴，或如果鍵不是<span>UNIQUE</span>或<span>PRIMARY 
			KEY</span>（換句話說，如果聯接不能基於關鍵字選擇單個行的話），則使用<span>ref</span>。如果使用的鍵僅僅匹配少量行，該聯接類型是不錯的。</p>
			<p>
			<span>ref</span>可以用於使用<span>=</span>或<span>&lt;=&gt;</span>操作符的帶索引的列。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>ref</span>聯接來處理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span> WHERE </span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>expr</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span><span>,</span><span><i><span>other_table</span></i></span></pre>
			<pre><span>&nbsp; WHERE </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part1</span></i></span><span>=</span><span><i><span>other_table</span></i></span><span>.</span><span><i><span>column</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND </span><span><i><span>ref_table</span></i></span><span>.</span><span><i><span>key_column_part2</span></i></span><span>=1;</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>ref_or_null</span></p>
			<p>
			該聯接類型如同<span>ref</span>，但是新增了<span>MySQL</span>可以專門搜索包含<span>NULL</span>值的行。在解決子查詢中經常使用該聯接類型的最佳化。</p>
			<p>
			在下面的例子中，<span>MySQL</span>可以使用<span>ref_or_null</span>聯接來處理<span><i><span>ref_tables</span></i></span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>ref_table</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span>=</span><span><i><span>expr</span></i></span><span> OR </span><span><i><span>key_column</span></i></span><span> IS NULL;</span></pre>
			<p>
			參見<a href="optimization.html#is-null-optimization" title="7.2.7. How MySQL Optimizes IS NULL">7.2.7節，「MySQL如何最佳化IS NULL<code class="literal"></code>」</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>index_merge</span></p>
			<p>
			該聯接類型資料表示使用了索引合併最佳化方法。在這種情況下，<span>key</span>列包含了使用的索引的清單，<span>key_len</span>包含了使用的索引的最長的關鍵元素。詳細訊息參見<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6節，「索引合併最佳化」</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>unique_subquery</span></p>
			<p>
			該類型替換了下面形式的<span>IN</span>子查詢的<span>ref</span>：</p>
			<pre><span><i><span>value</span></i></span><span> IN (SELECT </span><span><i><span>primary_key</span></i></span><span> FROM </span><span><i><span>single_table</span></i></span><span> WHERE </span><span><i><span>some_expr</span></i></span><span>)</span></pre>
			<p>
			<span>unique_subquery</span>是一個索引搜尋函數，可以完全替換子查詢，效率更高。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>index_subquery</span></p>
			<p>
			該聯接類型類似於<span>unique_subquery</span>。可以替換<span>IN</span>子查詢，但只適合下列形式的子查詢中的非唯一索引：</p>
			<pre><span><i><span>value</span></i></span><span> IN (SELECT </span><span><i><span>key_column</span></i></span><span> FROM </span><span><i><span>single_table</span></i></span><span> WHERE </span><span><i><span>some_expr</span></i></span><span>)</span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>range</span></p>
			<p>
			只檢索給定範圍的行，使用一個索引來選擇行。<span>key</span>列顯示使用了哪個索引。<span>key_len</span>包含所使用索引的最長關鍵元素。在該類型中<span>ref</span>列為<span>NULL</span>。</p>
			<p>
			當使用<span>=</span>、<span>&lt;&gt;</span>、<span>&gt;</span>、<span>&gt;=</span>、<span>&lt;</span>、<span>&lt;=</span>、<span>IS 
			NULL</span>、<span>&lt;=&gt;</span>、<span>BETWEEN</span>或者<span>IN</span>操作符，用常量比較關鍵字列時，可以使用<span>range</span>：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> = 10;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> BETWEEN 10 and 20;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_column</span></i></span><span> IN (10,20,30);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>WHERE </span><span><i><span>key_part1</span></i></span><span>= 10 AND </span><span><i>key_part2<span> IN (10,20,30);</span></i></span></pre>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >index</span></p>
			<p>
			該聯接類型與<span>ALL</span>相同，除了只有索引樹被掃瞄。這通常比<span>ALL</span>快，因為索引檔案通常比數據檔案小。</p>
			<p>
			當查詢只使用作為單索引一部分的列時，<span>MySQL</span>可以使用該聯接類型。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >ALL</span></p>
			<p>
			對於每個來自於先前的資料表的行組合，進行完整的資料表掃瞄。如果資料表是第一個沒標記<span>const</span>的資料表，這通常不好，並且通常在它情況下<strong><i><span>很</span></i></strong>差。通常可以增加更多的索引而不要使用<span>ALL</span>，使得行能基於前面的資料表中的常數值或列值被檢索出。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>possible_keys</span></p>
			<p>
			<span>possible_keys</span>列指出<strong><span>MySQL</span></strong>能使用哪個索引在該資料表中找到行。注意，該列完全獨立於<span >EXPLAIN</span>輸出所示的資料表的次序。這意味著在<span>possible_keys</span>中的某些鍵實際上不能按生成的資料表次序使用。</p>
			<p>
			如果該列是<span >NULL</span>，則沒有相關的索引。在這種情況下，可以通過檢查<span>WHERE</span>子句看是否它引用某些列或適合索引的列來提高您的查詢性能。如果是這樣，創造一個適當的索引並且再次用<span>EXPLAIN</span>檢查查詢。參見<a href="sql-syntax.html#alter-table" title="13.1.2. ALTER TABLE Syntax">13.1.2節，「ALTER 
			TABLE語法」</a>。</p>
			<p>
			為了看清一張資料表有什麼索引，使用<span >SHOW 
			INDEX FROM <i>tbl_name</i></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>key</span></p>
			<p>
			<span>key</span>列顯示<strong><span>MySQL</span></strong>實際決定使用的鍵（索引）。如果沒有選擇索引，鍵是<span>NULL</span>。要想強制<span>MySQL</span>使用或忽視<span>possible_keys</span>列中的索引，在查詢中使用<span>FORCE 
			INDEX</span>、<span >USE 
			INDEX</span>或者<span >IGNORE 
			INDEX</span>。參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
			<p>
			對於<span>MyISAM</span>和<span>BDB</span>資料表，運行<span>ANALYZE 
			TABLE</span>可以幫助最佳化器選擇更好的索引。對於<span>MyISAM</span>資料表，可以使用<strong><span>myisamchk 
			--analyze</span></strong>。參見<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1節，「ANALYZE 
			TABLE語法」</a>和<a href="database-administration.html#table-maintenance" title="5.9.4. Table Maintenance and Crash Recovery">5.9.4節，「資料表維護和崩潰恢復」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>key_len</span></p>
			<p>
			<span>key_len</span>列顯示<strong><span>MySQL</span></strong>決定使用的鍵長度。如果鍵是<span>NULL</span>，則長度為<span>NULL</span>。注意通過<span >key_len</span>值我們可以確定<span>MySQL</span>將實際使用一個多部關鍵字的幾個部分。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>ref</span></p>
			<p>
			<span>ref</span>列顯示使用哪個列或常數與<span>key</span>一起從資料表中選擇行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span >rows</span></p>
			<p>
			<span>rows</span>列顯示<strong><span>MySQL</span></strong>認為它執行查詢時必須檢查的行數。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>Extra</span></p>
			<p>
			該列包含<span>MySQL</span>解決查詢的詳細訊息。下面解釋了該列可以顯示的不同的文本字串：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			<span>Distinct</span></p>
			<p><span>MySQL</span>發現第<span>1</span>個匹配行後，停止為當前的行組合搜索更多的行。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Not exists</span></p>
			<p>
			<span>MySQL</span>能夠對查詢進行<span>LEFT 
			JOIN</span>最佳化，發現<span>1</span>個匹配<span >LEFT 
			JOIN</span>標準的行後，不再為前面的的行組合在該資料表內檢查更多的行。</p>
			<p>
			下面是一個可以這樣最佳化的查詢類型的例子：</p>
			<pre><span>SELECT * </span>從<span>t1 LEFT JOIN t2 ON t1.id=t2.id</span></pre>
			<pre><span>&nbsp; WHERE t2.id IS NULL</span>；</pre>
			<p>
			假定<span>t2.id</span>定義為<span>NOT 
			NULL</span>。在這種情況下，<span>MySQL</span>使用<span>t1.id</span>的值掃瞄<span>t1</span>並搜尋<span>t2</span>中的行。如果<span>MySQL</span>在<span>t2</span>中發現一個匹配的行，它知道<span>t2.id</span>絕不會為<span>NULL</span>，並且不再掃瞄<span>t2</span>內有相同的<span>id</span>值的行。換句話說，對於<span>t1</span>的每個行，<span>MySQL</span>只需要在<span>t2</span>中搜尋一次，無論<span>t2</span>內實際有多少匹配的行。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>range checked 
			for each record (index map: </span>
			<span>#)</span></span></p>
			<p>
			<span>MySQL</span>沒有發現好的可以使用的索引，但發現如果來自前面的資料表的列值已知，可能部分索引可以使用。對前面的資料表的每個行組合，<span>MySQL</span>檢查是否可以使用<span>range</span>或<span>index_merge</span>訪問方法來索取行。關於適用性標準的描述參見<a href="optimization.html#range-optimization" title="7.2.5. Range Optimization">7.2.5節，「範圍最佳化」</a>和<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6節，「索引合併最佳化」</a>，不同的是前面資料表的所有列值已知並且認為是常量。</p>
			<p>這並不很快，但比執行沒有索引的聯接要快得多。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using filesort</span></p>
			<p>
			<span>MySQL</span>需要額外的一次傳遞，以找出如何按排序順序檢索行。通過根據聯接類型瀏覽所有行並為所有匹配<span>WHERE</span>子句的行保存排序關鍵字和行的指針來完成排序。然後關鍵字被排序，並按排序順序檢索行。參見<a href="optimization.html#order-by-optimization" title="7.2.12. How MySQL Optimizes ORDER BY">7.2.12節，「MySQL如何最佳化ORDER BY<code class="literal"></code>」</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using index</span></p>
			<p>
			從只使用索引樹中的訊息而不需要進一步搜索讀取實際的行來檢索資料表中的列訊息。當查詢只使用作為單一索引一部分的列時，可以使用該策略。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using temporary</span></p>
			<p>
			為了解決查詢，<span>MySQL</span>需要建立一個臨時資料表來容納結果。典型情況如查詢包含可以按不同情況列出列的<span>GROUP 
			BY</span>和<span>ORDER 
			BY</span>子句時。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using where</span></p>
			<p>
			<span>WHERE</span>子句用於限制哪一個行匹配下一個資料表或發送到客戶。除非您專門從資料表中索取或檢查所有行，如果<span>Extra</span>值不為<span>Using 
			where</span>並且資料表聯接類型為<span >ALL</span>或<span >index</span>，查詢可能會有一些錯誤。</p>
			<p>
			如果想要使查詢盡可能快，應找出<span>Using 
			filesort </span>和<span>Using 
			temporary</span>的<span>Extra</span>值。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using 
			sort_union(...)</span><span>, </span>
			<span >Using union(...)</span><span>,
			</span><span >Using 
			intersect(...)</span></p>
			<p>
			這些函數說明如何為<span>index_merge</span>聯接類型合併索引掃瞄。詳細訊息參見<a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">7.2.6節，「索引合併最佳化」</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span >Using index for 
			group-by</span></p>
			<p>
			類似於訪問資料表的<span>Using 
			index</span>方式，<span>Using 
			index for group-by</span>資料表示<span>MySQL</span>發現了一個索引，可以用來查詢<span>GROUP 
			BY</span>或<span>DISTINCT</span>查詢的所有列，而不要額外搜索硬盤訪問實際的資料表。並且，按最有效的方式使用索引，以便對於每個組，只讀取少量索引條目。詳情參見<a href="optimization.html#group-by-optimization" title="7.2.13. How MySQL Optimizes GROUP BY">7.2.13節，「MySQL如何最佳化GROUP BY<code class="literal"></code>」</a>。</p>
			<p>
			通過相乘<span>EXPLAIN</span>輸出的<span>rows</span>列的所有值，您能得到一個關於一個聯接如何的提示。這應該粗略地告訴您<strong><span>MySQL</span></strong>必須檢查多少行以執行查詢。當您使用<span>max_join_size</span>變數限制查詢時，也用這個乘積來確定執行哪個多資料表<span >SELECT</span>語句。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
			<p>
			下列例子顯示出一個多資料表<span>JOIN</span>如何能使用<span>EXPLAIN</span>提供的訊息逐步被最佳化。</p>
			<p>假定您有下面所示的<span>SELECT</span>語句，計劃使用<span>EXPLAIN</span>來檢查它：</p>
			<pre><span>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ProjectReference, tt.EstimatedShipDate,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualShipDate, tt.ClientID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ServiceCodes, tt.RepetitiveID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.CurrentProcess, tt.CurrentDPPerson,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.RecordVolume, tt.DPPrinted, et.COUNTRY,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et_1.COUNTRY, do.CUSTNAME</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM tt, et, et AS et_1, do</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE tt.SubmitTime IS NULL</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ActualPC = et.EMPLOYID</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.AssignedPC = et_1.EMPLOYID</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ClientID = do.CUSTNMBR;</span></pre>
			<p>
			對於這個例子，假定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被比較的列聲明如下：</p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><strong><span>資料表</span></strong></td>
					<td width="113">
					<p><strong><span>列</span></strong></td>
					<td width="105">
					<p><strong><span>
					列類型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>ActualPC</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>AssignedPC</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td width="113">
					<p>
					<span>ClientID</span></td>
					<td width="105">
					<p>
					<span>CHAR(10)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>et</span></td>
					<td width="113">
					<p>
					<span>EMPLOYID</span></td>
					<td width="105">
					<p>
					<span>CHAR(15)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>do</span></td>
					<td width="113">
					<p>
					<span>CUSTNMBR</span></td>
					<td width="105">
					<p>
					<span>CHAR(15)</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表有下面的索引：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>資料表</span></strong></td>
					<td>
					<p><strong><span>索引</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>ActualPC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>AssignedPC</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>tt</span></td>
					<td>
					<p>
					<span>ClientID</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>et</span></td>
					<td>
					<p>
					<span>EMPLOYID</span><span>(</span>主鍵<span>)</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>do</span></td>
					<td>
					<p>
					<span>CUSTNMBR</span><span>(</span>主鍵<span>)</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			tt.ActualPC</span>值不是均勻分佈的。</p>
			<p>
			開始，在進行最佳化前，<span>EXPLAIN</span>語句產生下列訊息：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>table type possible_keys key&nbsp; key_len ref&nbsp; rows&nbsp; Extra</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 2135</span></pre>
			<pre><span>et_1&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL&nbsp; AssignedPC,&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 3872</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 35)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			因為<span>type</span>對每張資料表是<span>ALL</span>，這個輸出顯示<strong><span>MySQL</span></strong>正在對所有資料表產生一個笛卡爾乘積；即每一個行的組合！這將花相當長的時間，因為必須檢查每張資料表的行數的乘積！對於一個實例，這是<span>74 
			* 2135 * 74 * 3872 = 45,268,558,720</span>行。如果資料表更大，您只能想像它將花多長時間……
			</p>
			<p>
			這裡的一個問題是<strong><span>MySQL</span></strong>能更高效地在聲明具有相同類型和尺寸的列上使用索引。在本文中，<span>VARCHAR</span>和<span>CHAR</span>是相同的，除非它們聲明為不同的長度。因為<span>tt.ActualPC</span>被聲明為<span>CHAR(10)</span>並且<span>et.EMPLOYID</span>被聲明為<span>CHAR(15)</span>，長度不匹配。</p>
			<p>
			為了修正在列長度上的不同，使用<span>ALTER 
			TABLE</span>將<span>ActualPC</span>的長度從<span>10</span>個字元變為<span>15</span>個字元：</p>
			<pre><span>mysql&gt; </span><span><b><span>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</span></b></span></pre>
			<p>
			現在<span>tt.ActualPC</span>和<span>et.EMPLOYID</span>都是<span>VARCHAR(15)</span>，再執行<span>EXPLAIN</span>語句產生這個結果：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows&nbsp;&nbsp;&nbsp; Extra</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL &nbsp;&nbsp;&nbsp;AssignedPC,&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872&nbsp;&nbsp;&nbsp; Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2135</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)</span></pre>
			<pre><span>et_1&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			這不是完美的，但是好一些了：<span>rows</span>值的乘積少了一個因子<span>74</span>。這個版本在幾秒內執行完。</p>
			<p>
			第<span>2</span>種方法能消除<span>tt.AssignedPC 
			= et_1.EMPLOYID</span>和<span>tt.ClientID 
			= do.CUSTNMBR</span>比較的列的長度失配問題：</p>
			<pre><span>mysql&gt; </span><span><b><span>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>MODIFY ClientID&nbsp;&nbsp; VARCHAR(15);</span></b></span></pre>
			<p><span>EXPLAIN</span>產生的輸出顯示在下面：</p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ref&nbsp;&nbsp;&nbsp; AssignedPC,&nbsp;&nbsp; ActualPC 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et.EMPLOYID&nbsp;&nbsp; 52&nbsp;&nbsp; Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			這幾乎很好了。 </p>
			<p>
			剩下的問題是，預設情況，<strong><span>MySQL</span></strong>假設在<span>tt.ActualPC</span>列的值是均勻分佈的，並且對<span>tt</span>資料表不是這樣。幸好，很容易告訴<strong><span>MySQL</span></strong>來分析關鍵字分佈：</p>
			<pre><span>mysql&gt; </span><span><b><span>ANALYZE TABLE tt</span><span>；</span></b></span></pre>
			<p>
			現在聯接是「完美」的了，而且<span>EXPLAIN</span>產生這個結果：</p>
			<pre><span>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra</span></pre>
			<pre><span>tt&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; AssignedPC&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872 Using</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC</span></pre>
			<pre><span>et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC&nbsp;&nbsp; 1</span></pre>
			<pre><span>et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1</span></pre>
			<pre><span>do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1</span></pre>
			<p>注意在從<span>EXPLAIN</span>輸出的<span>rows</span>列是一個來自<strong><span>MySQL</span></strong>聯接最佳化器的「教育猜測」。您應該檢查數字是否接近事實。如果不是，可以通過在<span>SELECT</span>語句裡面使用<span>STRAIGHT_JOIN</span>並且試著在<span>FROM</span>子句以不同的次序列出資料表，可能得到更好的性能。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="estimating-performance"></a>
			7.2.2.&nbsp;估計查詢性能</h3></div></div></div><a class="indexterm" name="id2802305"></a><a class="indexterm" name="id2802316"></a><a class="indexterm" name="id2802326"></a>
			<p>
			在大多數情況下，可以通過計算磁盤搜索來估計性能。對小的資料表，通常能在<span>1</span>次磁盤搜索中找到行<span>(</span>因為索引可能被緩存<span>)</span>。對更大的資料表，可以使用<span>B</span>－樹索引進行估計，將需要<span >log(<i>row_count</i>)/log(<i>index_block_length</i>/3 
			* 2/(<i>index_length</i> + <i>data_pointer_length</i>))+1</span>次搜索才能找到行。</p>
			<p>
			在<strong><span style="font-family:
細明體;">MySQL</span></strong>中，索引塊通常是<span>1024</span>個字節，數據指針通常是<span>4</span>個字節，這對於有一個長度為<span>3(</span>中等整數<span>)</span>的索引的<span>500,000</span>行的資料表，通過公式可以計算出<span>log(500,000)/log(1024/3*2/(3+4))+1</span><span>= 
			4</span>次搜索。</p>
			<p>
			上面的索引需要大約<span>500,000 * 7 * 3/2 = 5.2</span><span>MB</span>，<span>(</span>假設典型情況下索引緩存區填充率為<span>2/3)</span>，可以將大部分索引保存在內存中，僅需要<span>1-2</span>使用從<span>OS</span>讀數據來找出行。</p>
			<p>
			然而對於寫，將需要<span>4</span>次搜索請求<span>(</span>如上<span>)</span>來找到在哪兒存放新索引，並且通常需要<span>2</span>次搜索來更新這個索引並且寫入行。</p>
			<p>注意，上述討論並不意味著應用程式的性能將緩慢地以<span>log<i>N</i> </span>
			退化！當資料表格變得更大時，所有內容緩存到<span>OS</span>或<span>SQL</span>伺服器後，將僅僅或多或少地更慢。在數據變得太大不能緩存後，將逐漸變得更慢，直到應用程式只能進行磁盤搜索<span>(</span>以<span>log<i>N</i></span>增加<span>)</span>。為了避免這個問題，隨數據增加而增加
			鍵高速緩衝區大小。對於<span >MyISAM</span>資料表<span>,
			</span>由<span >key_buffer_size</span>系統變數控制
			鍵高速緩衝區大小。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-speed"></a>
			7.2.3.&nbsp;SELECT查詢的速度</h3></div></div></div><a class="indexterm" name="id2802441"></a><a class="indexterm" name="id2802450"></a>
			<p>
			總的來說，要想使一個較慢速<span>SELECT 
			... WHERE</span>更快，應首先檢查是否能增加一個索引。不同資料表之間的引用通常通過索引來完成。您可以使用<span>EXPLAIN</span>語句來確定<span>SELECT</span>語句使用哪些索引。參見<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5節，「MySQL如何使用索引」</a>和<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1節，「EXPLAIN語法（獲取關於SELECT的訊息）<code class="literal"></code>」</a>。</p>
			<p>
			下面是一些加速對<span>MyISAM</span>資料表的查詢的一般建議：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>為了幫助<strong><span>MySQL</span></strong>更好地最佳化查詢，在一個裝載數據後的資料表上運行<span >ANALYZE 
			TABLE</span>或<strong><span>myisamchk 
			--analyze</span></strong>。這樣為每一個索引更新指出有相同值的行的平均行數的值（當然，如果只有一個索引，這總是<span>1</span>。）<span>MySQL</span>使用該方法來決定當您聯接兩個基於非常量資料表達式的資料表時選擇哪個索引。您可以使用<span >SHOW 
			INDEX FROM <i>tbl_name</i></span>並檢查<span>Cardinality</span>值來檢查資料表分析結果。<strong><span>myisamchk 
			--</span><span>description 
			--verbose</span></strong>可以顯示索引分佈訊息。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要想根據一個索引排序一個索引和數據，使用<strong><span>myisamchk 
			--sort-index --sort-records=1</span></strong>（如果您想要在索引<span>1</span>上排序）。如果只有一個索引，想要根據該索引的次序讀取所有的記錄，這是使查詢更快的一個好方法。但是請注意，第一次對一個大資料表按照這種方法排序時將花很長時間！</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="where-optimizations"></a>
			7.2.4.&nbsp;MySQL怎樣最佳化WHERE子句<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2802573"></a><a class="indexterm" name="id2802582"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			該節討論為處理<span>WHERE</span>子句而進行的最佳化。例子中使用了<span>SELECT</span>語句，但相同的最佳化也適用<span>DELETE</span>和<span>UPDATE</span>語句中的<span>WHERE</span>子句。</p>
			<p>
			請注意對<span>MySQL</span>最佳化器的工作在不斷進行中，因此該節並不完善。<span>MySQL</span>執行了大量的最佳化，本文中所列的並不詳盡。</p>
			<p>
			下面列出了<span>MySQL</span>執行的部分最佳化：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>去除不必要的括號：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;((a AND b) AND c OR (((a AND b) AND (c AND d))))</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; (a AND b AND c) OR (a AND b AND c AND d)</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>常量重疊：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;(a&lt;b AND b=c) AND a=5</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; b&gt;5 AND b=c AND a=5</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>去除常量條件<span>(</span>由於常量重疊需要<span>)</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;(B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>-&gt; B=5 OR B=6</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>索引使用的常數資料表達式僅計算一次。</p>
			<ul type="disc">
				<li>對於<span >MyISAM</span>和<span >HEAP</span>資料表，在一個單個資料表上的沒有一個<span>WHERE</span>的<span>COUNT(*)</span>直接從資料表中檢索訊息。當僅使用一個資料表時，對<span>NOT 
				NULL</span>資料表達式也這樣做。</li>
				<li>無效常數資料表達式的早期檢測。<strong><span style="
     ">MySQL</span></strong>快速檢測某些<span>SELECT</span>語句是不可能的並且不返回行。</li>
				<li>如果不使用<span>GROUP 
				BY</span>或分組函數<span>(</span><span>COUNT()</span>、<span>MIN()</span>……<span>)</span>，<span>HAVING</span>與<span>WHERE</span>合併。</li>
				<li>對於聯接內的每個資料表，構造一個更簡單的<span>WHERE</span>以便更快地對資料表進行<span>WHERE</span>計算並且也盡快跳過記錄。</li>
				<li>所有常數的資料表在查詢中比其它資料表先讀出。常數資料表為：
 				<ul type="circle">
					<li>空資料表或只有<span>1</span>行的資料表。</li>
					<li>與在一個<span >PRIMARY 
					KEY</span>或<span >UNIQUE</span>索引的<span>WHERE</span>子句一起使用的資料表，這裡所有的索引部分使用常數資料表達式並且索引部分被定義為<span>NOT 
					NULL</span>。 </li>
				</ul>
				</li>
			</ul>
			<p>下列的所有資料表用作常數資料表： </p>
			<pre ><span>mysql&gt; SELECT * FROM t WHERE primary_key=1;</span></pre>
			<pre ><span>mysql&gt; SELECT * FROM t1,t2</span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE t1.primary_key=1 AND t2.primary_key=t1.id;</span></pre>
			<ul type="disc">
				<li>嘗試所有可能性便可以找到資料表聯接的最好聯接組合。如果所有在<span>ORDER 
				BY</span>和<span>GROUP 
				BY</span>的列來自同一個資料表，那麼當聯接時，該資料表首先被選中。</li>
				<li>如果有一個<span>ORDER 
				BY</span>子句和不同的<span>GROUP 
				BY</span>子句，或如果<span>ORDER 
				BY</span>或<span>GROUP 
				BY</span>包含聯接隊列中的第一個資料表之外的其它資料表的列，則建立一個臨時資料表。</li>
				<li>如果使用<span>SQL_SMALL_RESULT</span>，<strong><span>MySQL</span></strong>使用內存中的一個臨時資料表。</li>
				<li>
				每個資料表的索引被查詢，並且使用最好的索引，除非最佳化器認為使用資料表掃瞄更有效。是否使用掃瞄取決於是否最好的索引跨越超過<span>30%</span>的資料表。最佳化器更加複雜，其估計基於其它因素，例如資料表大小、行數和<span>I/O</span>塊大小，因此固定比例不再決定選擇使用索引還是掃瞄。</li>
				<li>在一些情況下，<strong><span style="font-weight:
     normal">MySQL</span></strong>能從索引中讀出行，甚至不查詢數據檔案。如果索引使用的所有列是數值類，那麼只使用索引樹來進行查詢。</li>
				<li>輸出每個記錄前，跳過不匹配<span>HAVING</span>子句的行。</li>
			</ul>
			<p>
			下面是一些快速查詢的例子：</p>
			<pre><span>SELECT COUNT(*) FROM </span><span><i><span>tbl_name</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT MIN(</span><span><i><span>key_part1</span></i></span><span>),MAX(</span><span><i><span>key_part1</span></i></span><span>) FROM </span><span><i><span>tbl_name</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT MAX(</span><span><i><span>key_part2</span></i></span><span>) FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>constant</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span>,... LIMIT 10;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span> DESC, </span><span><i><span>key_part2</span></i></span><span> DESC, ... LIMIT 10;</span></pre>
			<p>
			下列查詢僅使用索引樹就可以解決<span>(</span>假設索引的列為數值型<span>)</span>：</p>
			<pre><span>SELECT </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>val</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT COUNT(*) FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>val1</span></i></span><span> AND </span><span><i><span>key_part2</span></i></span><span>=</span><span><i><span>val2</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT </span><span><i><span>key_part2</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span><span> GROUP BY </span><span><i><span>key_part1</span></i></span><span>;</span></pre>
			<p>
			下列查詢使用索引按排序順序檢索行，不用另外的排序：</p>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span>,</span><span><i><span>key_part2</span></i></span><span>,... ;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT ... FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ORDER BY </span><span><i><span>key_part1</span></i></span><span> DESC, </span><span><i><span>key_part2</span></i></span><span> DESC, ... ;</span></pre>
			<h3 class="title"><a name="range-optimization"></a>
			7.2.5.&nbsp;範圍最佳化</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#range-access-single-part">
				7.2.5.1. 單元素索引的範圍訪問方法</a></span></dt><dt><span class="section"><a href="optimization.html#range-access-multi-part">
				7.2.5.2. 多元素索引的範圍訪問方法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
				<p>
				<span >range</span>訪問方法使用單一索引來搜索包含在一個或幾個索引值距離內的資料表記錄的子集。可以用於單部分或多元素索引。後面的章節將詳細描述如何從<span>WHERE</span>子句提取區間。</p>
				<h4 class="title"><a name="range-access-single-part"></a>
				7.2.5.1.&nbsp;單元素索引的範圍訪問方法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				對於單元素索引，可以用<span>WHERE</span>子句中的相應條件很方便地資料表示索引值區間，因此我們稱為<em><span>範圍條件</span></em>而不是「區間」。</p>
				<p>
				單元素索引範圍條件的定義如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>BTREE</span>和<span>HASH</span>索引，當使用<span>=</span>、<span>&lt;=&gt;</span>、<span>IN</span>、<span>IS 
				NULL</span>或者<span>IS 
				NOT NULL</span>操作符時，關鍵元素與常量值的比較關係對應一個範圍條件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>BTREE</span>索引，當使用<span>&gt;</span>、<span>&lt;</span>、<span>&gt;=</span>、<span>&lt;=</span>、<span>BETWEEN</span>、<span>!=</span>或者<span>&lt;&gt;</span>，或者<span><span>LIKE
				</span><span>&#39;<i>pattern</i>&#39;</span></span><span>(</span>其中 
				 
				<span >&#39;<i>pattern</i>&#39;</span>不以通配符開始<span>)</span>操作符時，關鍵元素與常量值的比較關係對應一個範圍條件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於所有類型的索引，多個範圍條件結合<span>OR</span>或<span>AND</span>則產生一個範圍條件。</p>
				<p>
				前面描述的「<span class="quote">常</span>量值」系指：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查詢字串中的常量</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>同一聯接中的<span>const</span>或<span >system</span>資料表中的列</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>無關聯子查詢的結果</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>完全從前面類型的子資料表達式組成的資料表達式</p>
				<p>
				下面是一些<span>WHERE</span>子句中有範圍條件的查詢的例子：</p>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> &gt; 1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;AND </span><span><i><span>key_col</span></i></span><span> &lt; 10;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> = 1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;OR </span><span><i><span>key_col</span></i></span><span> IN (15,18,20);</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM t1 </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;ab%&#39; </span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;OR </span><span><i><span>key_col</span></i></span><span> BETWEEN &#39;bar&#39; AND &#39;foo&#39;;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				請注意在常量傳播階段部分非常量值可以轉換為常數。</p>
				<p>
				<span>MySQL</span>嘗試為每個可能的索引從<span>WHERE</span>子句提取範圍條件。在提取過程中，不能用於構成範圍條件的條件被放棄，產生重疊範圍的條件組合到一起，並且產生空範圍的條件被刪除。</p>
				<p>
				例如，考慮下面的語句，其中<span >key1</span>是有索引的列，<span>nonkey</span>沒有索引：</p>
				<pre><span>SELECT * FROM t1 WHERE</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR key1 LIKE &#39;%b&#39;)) OR</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;bar&#39; AND nonkey = 4) OR</span></pre>
				<pre><span>&nbsp;&nbsp; (key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;);</span></pre>
				<p>
				<span >key1</span>的提取過程如下：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>用原始<span>WHERE</span>子句開始：</p>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span>(key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR key1 LIKE &#39;%b&#39;)) 
				OR</span></p>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>
				&nbsp;</span><span>(key1 &lt; &#39;bar&#39; AND nonkey = 4) OR</span></p>
				<p>
				<span>4.<span>&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>
				&nbsp;</span><span>(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span></p>
				<p>
				<span>5.<span>&nbsp;&nbsp;&nbsp;
				</span></span>刪除<span>nonkey 
				= 4</span>和<span>key1 
				LIKE &#39;%b&#39;</span>，因為它們不能用於範圍掃瞄。刪除它們的正確途徑是用<span>TRUE</span>替換它們，以便進行範圍掃瞄時不會丟失匹配的記錄。用<span>TRUE</span>替換它們後，可以得到：</p>
				<pre><span>6.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;abc&#39; AND (key1 LIKE &#39;abcde%&#39; OR TRUE)) OR</span></pre>
				<pre><span>7.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;bar&#39; AND TRUE) OR</span></pre>
				<pre><span>8.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span></pre>
				<p>
				<span>9.<span>&nbsp;&nbsp;&nbsp;
				</span></span>取消總是為<span>true</span>或<span>false</span>的條件：</p>
				<p >
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				(key1 LIKE &#39;abcde%&#39; OR TRUE)</span>總是<span>true</span></p>
				<p >
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</span>總是<span>false
				</span></p>
				<p>
				用常量替換這些條件，我們得到：</p>
				<pre ><span>(key1 &lt; &#39;abc&#39; AND TRUE) OR (key1 &lt; &#39;bar&#39; AND TRUE) OR (FALSE)</span></pre>
				<p>
				刪除不必要的<span>TRUE</span>和<span>FALSE</span>常量，我們得到</p>
				<pre ><span>(key1 &lt; &#39;abc&#39;) OR (key1 &lt; &#39;bar&#39;)</span></pre>
				<p>
				<span>10.</span>將重疊區間組合成一個產生用於範圍掃瞄的最終條件：</p>
				<pre><span>11.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(key1 &lt; &#39;bar&#39;)</span></pre>
				<p>
				<span>總的來說<span>(</span>如前面的例子所述<span>)</span>，用於範圍掃瞄的條件比</span><span  >WHERE</span><span>子句限制少。<span>MySQL</span>再執行檢查以過濾掉滿足範圍條件但不完全滿足</span><span  >WHERE</span><span>子句的行。</span></p>
				<p><span>範圍條件提取算法可以處理嵌套的任意深度的</span><span  >AND</span><span >/</span><span  >OR</span><span>結構，並且其輸出不依賴條件在</span><span  >WHERE</span><span>子句中出現的順序。</span></p>
				<h4 class="title"><a name="range-access-multi-part"></a>
				7.2.5.2.&nbsp;多元素索引的範圍訪問方法</h4></div></div></div>
				<p>
				多元素索引的範圍條件是單元素索引的範圍條件的延伸。多元素索引的範圍條件將索引記錄限制到一個或幾個關鍵元組內。使用索引的順序，通過一系列關鍵元組來定義關鍵元組區間。</p>
				<p>
				例如，考慮定義為<span >key1(<i>key_part1</i>,
				<i>key_part2</i>, <i>key_part3</i>)</span>的多元素索引，以及下面的按關鍵字順序所列的關鍵元組：</p>
				<pre><span><i><span>key_part1</span></i></span><span>&nbsp; </span><span><i><span>key_part2</span></i></span><span>&nbsp; </span><span><i><span>key_part3</span></i></span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;xyz&#39;</span></pre>
				<pre><span>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;foo&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;xyz&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;abc&#39;</span></pre>
				<pre><span>&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;aaa&#39;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				條件<span><i><span>key_part1</span></i><span> 
				= 1</span></span>定義了下面的範圍：</p>
				<pre><span>(1</span>，<span>-inf</span>，<span>-inf) &lt;= (</span><span><i><span>key_part1</span></i></span>，<span><i><span>key_part2</span></i></span>，<span><i><span>key_part3</span></i></span><span>) &lt; (1</span>，<span>+inf</span>，<span>+inf)</span></pre>
				<p>
				範圍包括前面數據集中的第<span>4</span>、<span>5</span>和<span>6</span>個元組，可以用於範圍訪問方法。</p>
				<p>
				通過對比，條件<i><span>key_part3</span></i><span> = 
				&#39;abc&#39;</span>不定義單一的區間，不能用於範圍訪問方法。</p>
				<p>
				下面更加詳細地描述了範圍條件如何用於多元素索引中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>HASH</span>索引，可以使用包含相同值的每個區間。這說明區間只能由下面形式的條件產生：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span><i><span>key_part1</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>const1</span></i></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>AND </span><span><i><span>key_part2</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>const2</span></i></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>AND ...</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>AND </span><span><i><span>key_partN</span></i></span><span> </span><span><i><span>cmp</span></i></span><span> </span><span><i><span>constN</span></i></span><span>;</span></pre>
				<p>
				這裡，<span><i><span>const1</span></i></span>，<span><i><span>const2</span></i></span>，<span>...</span>為常量，<span><i><span>cmp</span></i></span>是<span><span>=</span><span>、<span>&lt;=&gt;</span></span></span>或者<span>IS 
				NULL</span>比較操作符之一，條件包括所有索引部分。<span>(</span>也就是說，有<span><i><span>N</span></i></span><span>
				</span>個條件，每一個對應<span><i><span>N</span></i></span><span>-</span>元素索引的每個部分）<span>。</span></p>
				<p>
				關於常量的定義，參見<a href="optimization.html#range-access-single-part" title="7.2.5.1. Range Access Method for Single-Part Indexes">7.2.5.1節，「單元素索引的範圍訪問方法」</a>。</p>
				<p>
				例如，下面為三元素<span>HASH</span>索引的範圍條件：</p>
				<pre ><i><span >key_part1</span></i><span > = 1 AND </span><i><span >key_part2</span></i><span > IS NULL AND </span><i><span >key_part3</span></i><span > = &#39;foo&#39;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於<span>BTREE</span>索引，區間可以對結合<span>AND</span>的條件有用，其中每個條件用一個常量值通過<span><span>=</span><span>、<span>&lt;=&gt;</span>、<span>IS 
				NULL</span>、<span>&gt;</span>、<span>&lt;</span>、<span>&gt;=</span>、<span>&lt;=</span>、<span>!=</span>、<span>&lt;&gt;</span>、<span>BETWEEN</span></span></span>或者<span >LIKE 
				&#39;<i>pattern</i>&#39;</span><span> (</span>其中<span>&#39;<i>pattern</i>&#39;</span>不以通配符開頭<span>)</span>比較一個關鍵元素。區間可以足夠長以確定一個包含所有匹配條件<span>(</span>或如果使用<span>&lt;&gt;</span>或<span>!=</span>，為兩個區間<span>)</span>的記錄的單一的關鍵元組。例如，對於條件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp; </span><i><span >key_part1</span></i><span > = &#39;foo&#39; AND </span><i><span >key_part2</span></i><span > &gt;= 10 AND </span><i><span >key_part3</span></i><span > &gt; 10</span></pre>
				<p>
				單一區間為：</p>
				<pre ><span>(&#39;foo&#39;</span>，<span>10</span>，<span>10)</span></pre>
				<pre ><span>&nbsp;&nbsp; &lt; (</span><span><i><span>key_part1</span></i></span>，<span><i><span>key_part2</span></i></span>，<span><i><span>key_part3</span></i></span><span>)</span></pre>
				<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; (&#39;foo&#39;</span>，<span>+inf</span>，<span>+inf)</span></pre>
				<p>
				建立的區間可以比原條件包含更多的記錄。例如，前面的區間包括值<span><span>(&#39;foo&#39;</span><span>，<span>11</span>，<span>0)</span></span></span>，不滿足原條件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果包含區間內的一系列記錄的條件結合使用<span>OR</span>，則形成包括一系列包含在區間並集的記錄的一個條件。如果條件結合使用了<span>AND</span>，則形成包括一系列包含在區間交集內的記錄的一個條件。例如，對於兩部分索引的條件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >key_part1</span></i><span > = 1 AND </span><i><span >key_part2</span></i><span > &lt; 2)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >OR (</span><i><span >key_part1</span></i><span > &gt; 5)</span></pre>
				<p>
				區間為：</p>
				<p>
				<span>(1, -inf) &lt; (<i>key_part1</i>, <i>key_part2</i>) 
				&lt; (1, 2)</span></p>
				<p>
				<span>(5, -inf) &lt; (<i>key_part1</i>, <i>key_part2</i>)</span></p>
				<p>
				在該例子中，第<span>1</span>行的區間左側的約束使用了一個關鍵元素，右側約束使用了兩個關鍵元素。第<span>2</span>行的區間只使用了一個關鍵元素。<span>EXPLAIN</span>輸出的<span>key_len</span>列資料表示所使用關鍵字前綴的最大長度。</p>
				<p>
				在某些情況中，<span>key_len</span>可以資料表示使用的關鍵元素，但可能不是您所期望的。假定<i><span>key_part1</span></i>和<span><i><span>key_part2</span></i></span>可以為<span>NULL</span>。則<span>key_len</span>列顯示下面條件的兩個關鍵元素的長度：</p>
				<pre ><span><i><span>key_part1</span></i></span><span> &gt;= 1 AND </span><span><i><span>key_part2</span></i></span><span> &lt; 2</span></pre>
				<p>
				但實際上，該條件可以變換為：</p>
				<pre ><i><span >key_part1</span></i><span > &gt;= 1 AND </span><i><span >key_part2</span></i><span > IS NOT NULL</span></pre>
				<p> <a href="optimization.html#range-access-single-part" title="7.2.5.1. Range Access Method for Single-Part Indexes">
				7.2.5.1節，「單元素索引的範圍訪問方法」</a>描述了如何進行最佳化以結合或刪除單元素索引範圍條件的區間。多元素索引範圍條件的區間的步驟類似。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-merge-optimization"></a>
			7.2.6.&nbsp;索引合併最佳化</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#index-merge-intersection">
				7.2.6.1. 索引合併交集訪問算法</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-union">
				7.2.6.2. 索引合併並集訪問算法</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-sort-union">
				7.2.6.3. 索引合併排序並集訪問算法</a></span></dt></dl></div><a class="indexterm" name="id2804075"></a><a class="indexterm" name="id2804084"></a><a class="indexterm" name="id2804091"></a><div class="section"><div class="titlepage"><div><div>
				<p>
				<em><span>索引合併</span></em>方法用於通過<span>range</span>掃瞄搜索行並將結果合成一個。合併會產生並集、交集或者正在進行的掃瞄的交集的並集。</p>
				<p>
				在<span>EXPLAIN</span>輸出中，該方法資料表現為<span>type</span>列內的<span>index_merge</span>。在這種情況下，<span>key</span>列包含一列使用的索引，<span>key_len</span>包含這些索引的最長的關鍵元素。</p>
				<p>
				例如：</p>
				<p><span>SELECT * FROM <i>tbl_name</i> 
				WHERE <i>key_part1</i> = 10 OR <i>key_part2</i> = 20;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM <i>tbl_name</i></span></p>
				<p><span>&nbsp;&nbsp;&nbsp; WHERE (<i>key_part1</i> 
				= 10 OR <i>key_part2</i> = 20) AND <i>non_key_part</i>=30;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM t1, t2</span></p>
				<p><span>&nbsp; &nbsp;&nbsp;WHERE (t1.<i>key1<span style="font-style:normal"> 
				IN (1,2) OR t1.</span>key2</i> LIKE &#39;<i>value</i>%&#39;)</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; AND t2.<i>key1</i>=t1.<i>some_col</i>;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM t1, t2</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; WHERE t1.<i>key1</i>=1</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; AND (t2.<i>key1</i>=t1.<i>some_col</i> 
				OR t2.<i>key2</i>=t1.<i>some_col2</i>);</span></p>
				<p>
				<span>&nbsp;</span></p>
				<p>
				索引合併方法有幾種訪問算法<span> (</span>參見<span>EXPLAIN</span>輸出的<span>Extra</span>字段<span>)</span>：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>交集</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>聯合</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>排序並集</p>
				<p>
				後面幾節更加詳細地描述了這些方法。</p>
				<p>
				<strong><span>註釋：</span></strong>索引合併最佳化算法具有以下幾個已知問題：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果可以對某些關鍵字進行範圍掃瞄，則不考慮索引合併。例如，下面的查詢：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;</span></pre>
				<p>
				對於該查詢，可以有兩個方案：</p>
				<p >
				<span>1.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>(goodkey1 &lt; 10 OR goodkey2 &lt; 20)</span>條件進行索引合併掃瞄。</p>
				<p >
				<span>2.<span>&nbsp;&nbsp;&nbsp;
				</span></span>使用<span>badkey 
				&lt; 30</span>條件進行範圍掃瞄。</p>
				<p>
				然而，最佳化器只考慮第<span>2</span>個方案。如果這不是您想要的，您可以通過使用<span>IGNORE 
				INDEX</span>或<span>FORCE INDEX</span>讓最佳化器考慮<span>index_merge</span>。下面的查詢使用索引合併執行：</p>
				<p>
				<span>SELECT * FROM t1 FORCE INDEX(goodkey1,goodkey2)</span></p>
				<p>
				<span>WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND 
				badkey &lt; 30;</span></p>
				<p>
				<span>&nbsp;</span></p>
				<p>
				<span>SELECT * FROM t1 IGNORE INDEX(badkey)</span></p>
				<p>
				<span>WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND 
				badkey &lt; 30;</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果查詢有一個複雜的<span>WHERE</span>子句，有較深的<span>AND/OR</span>嵌套關係，<span>MySQL</span>不選擇該優選方案，通過下面的識別法則嘗試分佈各條件：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >x</span></i><span > AND </span><i><span >y</span></i><span >) OR </span><i><span >z</span></i><span > = (</span><i><span >x</span></i><span > OR </span><i><span >z</span></i><span >) AND (</span><i><span >y</span></i><span > OR </span><i><span >z</span></i><span >)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >(</span><i><span >x</span></i><span > OR </span><i><span >y</span></i><span >) AND </span><i><span >z</span></i><span > = (</span><i><span >x</span></i><span > AND </span><i><span >z</span></i><span >) OR (</span><i><span >y</span></i><span > AND </span><i><span >z</span></i><span >)</span></pre>
				<p>
				<span>index_merge</span>訪問方法的不同變數之間的選擇和其它訪問方法基於各適用選項的成本估計。</p>
				<h4 class="title"><a name="index-merge-intersection"></a>
				7.2.6.1.&nbsp;索引合併交集訪問算法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				該訪問算法可以用於當<span >WHERE</span>子句結合<span >AND</span>被轉換為不同的關鍵字的幾個範圍條件，每個條件為下面之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以這種形式，即索引有確切的<span><i><span>N</span></i></span>部分<span>(</span>即包括了所有索引部分<span>)</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><i><span >key_part1</span></i><span >=</span><i><span >const1</span></i><span > AND </span><i><span >key_part2</span></i><span >=</span><i><span >const2</span></i><span > ... AND </span><i><span >key_partN</span></i><span >=</span><i><span >constN</span></i></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>任何<span>InnoDB</span>或<span>BDB</span>資料表的主鍵的範圍條件。</p>
				<p>
				下面是一些例子：</p>
				<p><span>SELECT * FROM <i>
				innodb_table</i> WHERE <i>primary_key</i> &lt; 10 AND <i>key_col1</i>=20;</span></p>
				<p><span>&nbsp;</span></p>
				<p><span>SELECT * FROM <i>tbl_name</i></span></p>
				<p><span>WHERE (<i>key1_part1</i>=1 
				AND <i>key1_part2</i>=2) AND <i>key2</i>=2;</span></p>
				<p>
				索引合併交集算法同時對所有使用的索引進行掃瞄，並產生從合併的索引掃瞄接收的行序列的交集。</p>
				<p>
				如果使用的索引包括查詢中使用的所有列，所有資料表記錄均不搜索，並且在這種情況下<span>EXPLAIN</span>的輸出包含<span >Extra</span>字段中的<span>Using 
				index</span>。下面是一個此類查詢的例子：</p>
				<pre><span>SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;</span></pre>
				<p>
				如果使用的索引未包括查詢中使用的所有列，只有滿足所有使用的關鍵字的範圍條件才搜索所有記錄。</p>
				<p>如果某個合併條件是<span>InnoDB</span>或<span>BDB</span>資料表的主鍵的一個條件，不用於記錄查詢，但用於過濾使用其它條件搜索的記錄。</p>
				<h4 class="title"><a name="index-merge-union"></a>
				7.2.6.2.&nbsp;索引合併並集訪問算法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				該算法的適用標準類似於索引合併方法交集算法的標準。算法可以用於當<span >WHERE</span>子句結合<span >OR</span>被轉換為不同的關鍵字的幾個範圍條件的時候，每個條件為下面之一：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以這種形式，即索引有確切的<span><i><span>N</span></i></span>部分<span>(</span>即包括了所有索引部分<span>)</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>key_part1</span></i></span><span>=</span><span><i><span>const1</span></i></span><span> AND </span><span><i><span>key_part2</span></i></span><span>=</span><span><i><span>const2</span></i></span><span> ... AND </span><span><i><span>key_partN</span></i></span><span>=</span><span><i><span>constN</span></i></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>任何<span>InnoDB</span>或<span>BDB</span>資料表的主鍵的範圍條件。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>索引合併方法交集算法適用的一個條件。</p>
				<p>
				下面是一些例子：</p>
				<pre><span>SELECT * FROM t1 WHERE </span><span><i><span>key1</span></i></span><span>=1 OR </span><span><i><span>key2</span></i></span><span>=2 OR </span><span><i><span>key3</span></i></span><span>=3;</span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>SELECT * FROM </span><span><i><span>innodb_table</span></i></span><span> WHERE (</span><span><i><span>key1</span></i></span><span>=1 AND </span><span><i><span>key2</span></i></span><span>=2) OR</span></pre>
				<pre><span>&nbsp; (</span><span><i><span>key3</span></i></span><span>=&#39;foo&#39; AND </span><span><i><span>key4</span></i></span><span>=&#39;bar&#39;) AND </span><span><i><span>key5</span></i></span><span>=5;</span></pre>
				<h4 class="title"><a name="index-merge-sort-union"></a>
				7.2.6.3.&nbsp;索引合併排序並集訪問算法</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			該訪問算法可以用於當<span >WHERE</span>子句結合<span >OR</span>被轉換為不同的關鍵字的幾個範圍條件，但索引合併方法聯合算法並不適用的時候。</p>
			<p>
			下面是一些例子：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col1</span></i></span><span> &lt; 10 OR </span><span><i><span>key_col2</span></i></span><span> &lt; 20;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; WHERE (</span><span><i><span>key_col1</span></i></span><span> &gt; 10 OR </span><span><i><span>key_col2</span></i></span><span> = 20) AND </span><span><i><span>nonkey_col</span></i></span><span>=30;</span></pre>
			<p>
			排序聯合算法和聯合算法的區別是排序聯合算法必須先索取所有記錄的行<span>ID</span>，然後在返回記錄前對它們進行排序。</p>
			<h3 class="title"><a name="is-null-optimization"></a>
			7.2.7.&nbsp;MySQL如何最佳化IS NULL<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2804804"></a><a class="indexterm" name="id2804813"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>MySQL</span>可以對可以結合<span><i><span>col_name</span></i></span><span>
			</span>
			<span>=</span><span>
			</span><span><i>
			<span>constant_value</span></i></span>使用的<span><i><span>col_name</span></i></span><span>
			</span>
			<span>IS NULL</span>進行相同的最佳化。例如，<span>MySQL</span>可以使用索引和範圍用<span>IS 
			NULL</span>搜索<span>NULL</span>。</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> &lt;=&gt; NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>const1</span></i></span><span> OR </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>const2</span></i></span><span> OR </span><span><i><span>key_col</span></i></span><span> IS NULL;</span></pre>
			<p>
			如果<span>WHERE</span>子句包括聲明為<span>NOT 
			NULL</span>的列的<span><i><span>col_name</span></i></span><span>
			</span>
			<span>IS NULL</span>條件，資料表達式則最佳化。當列會產生<span>NULL</span>時，不會進行最佳化；例如，如果來自<span>LEFT 
			JOIN</span>右側的資料表。</p>
			<p>
			<span>MySQL</span>也可以最佳化組合<span><i><span>col_name</span></i><span> 
			= <i>expr</i> AND <i>col_name</i> IS NULL</span></span>，這是解決子查詢的一種常用形式。當使用最佳化時<span>EXPLAIN</span>顯示<span>ref_or_null</span>。</p>
			<p>
			該最佳化可以為任何關鍵元素處理<span>IS 
			NULL</span>。</p>
			<p>
			下面是一些最佳化的查詢例子，假定資料表<span>t2</span>的列<span>a</span>和<span>b</span>有一個索引：</p>
			<pre><span>SELECT * FROM t1 WHERE t1.a=</span><span><i><span>expr</span></i></span><span> OR t1.a IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; OR (t1.a=t2.a AND t2.a IS NULL AND ...);</span></pre>
			<p>
			<span>ref_or_null</span>首先讀取參考關鍵字，然後單獨搜索<span>NULL</span>關鍵字的行。</p>
			<p>
			請注意該最佳化只可以處理一個<span>IS 
			NULL</span>。在後面的查詢中，<span>MySQL</span>只對資料表達式<span><span>(</span><span>t1.a=t2.a 
			AND t2.a IS NULL</span><span>)</span></span>使用關鍵字查詢，不能使用<span>b</span>的關鍵元素：</p>
			<pre><span>SELECT * FROM t1, t2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; WHERE (t1.a=t2.a AND t2.a IS NULL)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; OR (t1.b=t2.b AND t2.b IS NULL);</span></pre>
			<h3 class="title"><a name="distinct-optimization"></a>
			7.2.8.&nbsp;MySQL如何最佳化DISTINCT<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2805038"></a><a class="indexterm" name="id2805047"></a>
			<p>
			在許多情況下結合<span>ORDER 
			BY</span>的<span>DISTINCT</span>需要一個臨時資料表。</p>
			<p>
			請注意因為<span>DISTINCT</span>可能使用<span>GROUP 
			BY</span>，必須清楚<span>MySQL</span>如何使用所選定列的一部分的<span>ORDER 
			BY</span>或<span>HAVING</span>子句中的列。參見<a href="functions.html#group-by-hidden-fields" title="12.10.3. GROUP BY with Hidden Fields">12.10.3節，「具有隱含字段的GROUP 
		BY」</a>。</p>
			<p>
			在大多數情況下，<span>DISTINCT</span>子句可以視為<span>GROUP 
			BY</span>的特殊情況。例如，下面的兩個查詢是等效的：</p>
			<pre><span>SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 &gt; </span><span><i><span>const</span></i></span><span>;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT c1, c2, c3 FROM t1 WHERE c1 &gt; </span><span><i><span>const</span></i></span><span> GROUP BY c1, c2, c3;</span></pre>
			<p>
			由於這個等效性，適用於<span>GROUP 
			BY</span>查詢的最佳化也適用於有<span>DISTINCT</span>子句的查詢。這樣，關於<span>DISTINCT</span>查詢的最佳化的更詳細的情況，參見<a href="optimization.html#group-by-optimization" title="7.2.13. How MySQL Optimizes GROUP BY">7.2.13節，「MySQL如何最佳化GROUP BY<code class="literal"></code>」</a>。</p>
			<p>
			結合<span>LIMIT
			<i>row_count</i></span>和<span>DISTINCT</span>後，<span>MySQL</span>發現唯一的<span><i><span>row_count</span></i></span>行後立即停止。</p>
			<p>
			如果不使用查詢中命名的所有資料表的列，<span>MySQL</span>發現第<span>1</span>個匹配後立即停止掃瞄未使用的資料表。在下面的情況中，假定<span>t1</span>在<span>t2</span>之前使用<span>(</span>可以用<span>EXPLAIN</span>檢查<span>)</span>，發現<span>t2</span>中的第<span>1</span>行後，<span>MySQL</span>不再<span>(</span>為<span>t1</span>中的任何行<span>)</span>讀<span>t2</span>：</p>
			<pre><span>SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;</span></pre>
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="left-join-optimization"></a>
			7.2.9.&nbsp;MySQL如何最佳化LEFT JOIN和RIGHT JOIN</h3></div></div></div><a class="indexterm" name="id2805216"></a><a class="indexterm" name="id2805224"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			在<span>MySQL</span>中，<span><i><span>A</span></i><span> 
			LEFT JOIN <i>B</i> join_condition</span></span>執行過程如下：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>根據資料表<span><i><span>A</span></i></span>和<span><i><span>A</span></i></span>依賴的所有資料表設置資料表<span>B</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>根據<span>LEFT 
			JOIN</span>條件中使用的所有資料表<span>(</span>除了<span><i><span>B</span></i></span><span>)</span>設置資料表<span><i><span>A</span></i></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>LEFT JOIN</span>條件用於確定如何從資料表<span><i><span>B</span></i></span>搜索行。<span>(</span>換句話說，不使用<span>WHERE</span>子句中的任何條件）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>可以對所有標準聯接進行最佳化，只是只有從它所依賴的所有資料表讀取的資料表例外。如果出現循環依賴關係，<span>MySQL</span>提示出現一個錯誤。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>進行所有標準<span>WHERE</span>最佳化。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span><i><span>A</span></i></span>中有一行匹配<span>WHERE</span>子句，但<span><i><span>B</span></i></span>中沒有一行匹配<span>ON</span>條件，則生成另一個<span><i><span>B</span></i></span>行，其中所有列設置為<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果使用<span>LEFT 
			JOIN</span>找出在某些資料表中不存在的行，並且進行了下面的測試：<span>WHERE</span>部分的<span><i><span>col_name</span></i><span> 
			IS NULL</span></span>，其中<span><i><span>col_name</span></i></span>是一個聲明為 
			<span>NOT NULL</span>的列，<span>MySQL</span>找到匹配<span>LEFT 
			JOIN</span>條件的一個行後停止<span>(</span>為具體的關鍵字組合<span>)</span>搜索其它行。</p>
			<p>
			<span>RIGHT JOIN</span>的執行類似<span>LEFT 
			JOIN</span>，只是資料表的角色反過來。</p>
			<p>
			聯接最佳化器計算資料表應聯接的順序。<span>LEFT 
			JOIN</span>和<span>STRAIGHT_JOIN</span>強制的資料表讀順序可以幫助聯接最佳化器更快地工作，因為檢查的資料表交換更少。請注意這說明如果執行下面類型的查詢，<span>MySQL</span>進行全掃瞄<span >b</span>，因為<span>LEFT 
			JOIN</span>強制它在<span>d</span>之前讀取：</p>
			<pre><span>SELECT *</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE b.key=d.key;</span></pre>
			<p>
			在這種情況下修復時用<span>a</span>的相反順序，<span>b</span>列於<span >FROM</span>子句中：</p>
			<pre><span>SELECT *</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE b.key=d.key;</span></pre>
			<p>
			<span>MySQL</span>可以進行下面的<span>LEFT 
			JOIN</span>最佳化：如果對於產生的<span>NULL</span>行，<span>WHERE</span>條件總為假，<span>LEFT 
			JOIN</span>變為普通聯接。</p>
			<p>
			例如，在下面的查詢中如果<span >t2.column1</span>為<span>NULL</span>，<span>WHERE</span><span>
			</span>子句將為<span>false</span>：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;</span></pre>
			<p>
			因此，可以安全地將查詢轉換為普通聯接：</p>
			<pre><span>SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;</span></pre>
			<p>這樣可以更快，因為如果可以使查詢更佳，<span>MySQL</span>可以在資料表<span>t1</span>之前使用資料表<span>t2</span>。為了強制使用資料表順序，使用<span>STRAIGHT_JOIN</span>。</p>
			<h3 class="title"><a name="nested-joins"></a>
			7.2.10.&nbsp;MySQL如何最佳化嵌套Join</h3></div></div></div>
			<p>
			資料表示聯接的語法允許嵌套聯接。下面的討論引用了<a href="sql-syntax.html#join" title="13.2.7.1. JOIN Syntax">13.2.7.1節，「JOIN語法」</a>中描述的聯接語法。</p>
			<p>
			同<span>SQL</span>標準比較，<span><i><span>table_factor</span></i></span>語法已經延伸了。後者只接受<span><i><span>table_reference</span></i></span>，而不是括號內所列的。</p>
			<p>
			<span><i>
			<span>table_reference</span></i></span>項列資料表內的每個逗號等價於內部聯接，這是一個保留延伸名。例如：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3, t4)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
			<p>
			等價於：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
			<p>
			在<span>MySQL</span>中，<span>CROSS 
			JOIN</span>語法上等價於<span >INNER 
			JOIN</span><span> (</span>它們可以彼此代替。在標準<span>SQL</span>中，它們不等價。<span >INNER 
			JOIN</span>結合<span>ON</span>子句使用；<span>CROSS 
			JOIN</span><span> </span>用於其它地方。</p>
			<p>
			總的來說，在只包含內部聯接操作的聯接資料表達式中可以忽略括號。刪除括號並將操作組合到左側後，聯接資料表達式：</p>
			<pre><span>t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span></pre>
			<pre><span>&nbsp;&nbsp; ON t1.a=t2.a</span></pre>
			<p>
			轉換為資料表達式：</p>
			<pre><span>(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ON t2.b=t3.b OR t2.b IS NULL</span></pre>
			<p>
			但是這兩個資料表達式不等效。要說明這點，假定資料表<span>t1</span>、<span>t2</span>和<span>t3</span>有下面的狀態：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表<span>t1</span>包含行<span>{1}</span>、<span>{2}</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表<span>t2</span>包含行<span>{1,101}</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表<span>t3</span>包含行<span>{101}</span></p>
			<p>
			在這種情況下，第<span>1</span>個資料表達式返回包括行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,NULL}</span>的結果，第<span>2</span>個資料表達式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,101}</span>：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>LEFT JOIN</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>ON t1.a=t2.a;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL | NULL |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>LEFT JOIN t3</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>ON t2.b=t3.b OR t2.b IS NULL;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL |&nbsp; 101 |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<p>
			在下面的例子中，外面的聯接操作結合內部聯接操作使用：</p>
			<pre><span>t1 LEFT JOIN (t2</span>，<span>t3) ON t1.a=t2.a</span></pre>
			<p>
			該資料表達式不能轉換為下面的資料表達式：</p>
			<pre><span>t1 LEFT JOIN t2 ON t1.a=t2.a</span>，<span>t3.</span></pre>
			<p>
			對於給定的資料表狀態，第<span>1</span>個資料表達式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,NULL}</span>，第<span>2</span>個資料表達式返回行<span>{1,1,101,101}</span>、<span>{2,NULL,NULL,101}</span>：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a &nbsp;&nbsp;&nbsp;| a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL | NULL |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; </span><span><b><span>SELECT *</span></b></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; </span><span><b><span>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</span></b></span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp; | a&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; | b&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp; 101 |&nbsp; 101 |</span></pre>
			<pre><span>|&nbsp;&nbsp;&nbsp; 2 | NULL | NULL |&nbsp; 101 |</span></pre>
			<pre><span>+------+------+------+------+</span></pre>
			<p>
			因此，如果我們忽略聯接資料表達式中的括號連同外面的聯接操作符，我們會改變原資料表達式的結果。</p>
			<p>
			更確切地說，我們不能忽視左外聯接操作的右操作數和右聯接操作的左操作數中的括號。換句話說，我們不能忽視外聯接操作中的內資料表達式中的括號。可以忽視其它操作數中的括號<span>(</span>外部資料表的操作數<span>)</span>。</p>
			<p>
			對於任何資料表<span><span>t1</span><span>、<span>t2</span>、<span>t3</span></span></span>和屬性<span>t2.b</span>和<span>t3.b</span>的任何條件<span>P</span>，下面的資料表達式：</p>
			<pre><span>(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)</span></pre>
			<p>
			等價於資料表達式 </p>
			<pre><span>t1</span>，<span>t2 LEFT JOIN t3 ON P(t2.b,t3.b)</span></pre>
			<p>
			如果聯接資料表達式<span>(</span><span><i><span>join_table</span></i></span><span>)</span>中的聯接操作的執行順序不是從左到右，我們則應討論嵌套的聯接。這樣，下面的查詢：</p>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a</span></pre>
			<pre><span>&nbsp; WHERE t1.a &gt; 1</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a</span></pre>
			<pre><span>&nbsp; WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1</span></pre>
			<p>
			聯接資料表：</p>
			<pre><span>t2 LEFT JOIN t3 ON t2.b=t3.b</span></pre>
			<pre><span>t2, t3</span></pre>
			<p>
			認為是嵌套的。第<span>1</span>個查詢結合左聯接操作則形成嵌套的聯接，而在第二個查詢中結合內聯接操作形成嵌套聯接。</p>
			<p>
			在第<span>1</span>個查詢中，括號可以忽略：聯接資料表達式的語法結構與聯接操作的執行順序相同。但對於第<span>2</span>個查詢，括號不能省略，儘管如果沒有括號，這裡的聯接資料表達式解釋不清楚。<span>(</span>在外部延伸語法中，需要第<span>2</span>個查詢的<span><span>(t2</span><span>，<span>t3)</span></span></span>的括號，儘管從理論上對查詢分析時不需要括號：這些查詢的語法結構將仍然不清楚，因為<span>LEFT 
			JOIN</span>和<span>ON</span>將充當資料表達式<span>(t2,t3)</span>的左、右界定符的角色<span>)</span>。</p>
			<p>
			前面的例子說明了這些點：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於只包含內聯接<span>(</span>而非外聯接<span>)</span>的聯接資料表達式，可以刪除括號。您可以移除括號並從左到右評估<span>(</span>或實際上，您可以按任何順序評估資料表<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>總的來說，對外聯接卻不是這樣。去除括號可能會更改結果。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>總的來說，對外聯接和內聯接的結合，也不是這樣。去除括號可能會更改結果。</p>
			<p>
			含嵌套外聯接的查詢按含內聯接的查詢的相同的管道方式執行。更確切地說，利用了嵌套環聯接算法。讓我們回憶嵌套環聯接執行查詢時採用什麼算法。</p>
			<p>
			假定我們有一個如下形式的資料表<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>的聯接查詢：</p>
			<pre><span>SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN T3 ON P2(T2,T3)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3).</span></pre>
			<p>
			這裡，<span>P1(T1,T2)</span>和<span>P2(T3,T3)</span>是一些聯接條件<span>(</span>資料表達式<span>)</span>，其中<span>P(t1,t2,t3)</span>是資料表<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>的列的一個條件。</p>
			<p>
			嵌套環聯接算法將按下面的方式執行該查詢：</p>
			<p>
			<span>&nbsp;</span></p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p >
			符號<span>t1||t2||t3</span>資料表示「<span class="quote">連接行</span><span>t1</span><span class="quote">、</span><span>t2</span><span class="quote">和</span><span>t3</span><span class="quote">的列組成的行</span>」。在下面的一些例子中，出現行名的<span>NULL</span>資料表示<span>NULL</span>用於行的每個列。例如，<span>t1||t2||NULL</span>資料表示「<span class="quote">連接行</span><span>t1</span><span class="quote">和</span><span>t2</span><span class="quote">的列以及</span><span>t3</span><span class="quote">的每個列的</span><span>NULL</span><span class="quote">組成的行</span>」。</p>
			<p>
			現在讓我們考慮帶嵌套的外聯接的查詢：</p>
			<pre><span>SELECT * FROM T1 LEFT JOIN</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 ON P2(T2,T3))</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON P1(T1,T2)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3)</span>。</pre>
			<p>
			對於該查詢我們修改嵌套環模式可以得到：</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; BOOL f2:=FALSE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f2=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF (!f2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			總的來說，對於外聯接操作中的第一個內資料表的嵌套環，引入了一個標誌，在環之前關閉並且在環之後打開。如果對於外部資料表的當前行，如果匹配資料表示內操作數的資料表，則標誌打開。如果在循環結尾處標誌仍然關閉，則對於外部資料表的當前行，沒有發現匹配。在這種情況下，對於內資料表的列，應使用<span>NULL</span>值補充行。結果行被傳遞到輸出進行最終檢查或傳遞到下一個嵌套環，但只能在行滿足所有嵌入式外聯接的聯接條件時。</p>
			<p>
			在我們的例子中，嵌入了下面資料表達式資料表示的外聯接資料表：</p>
			<pre><span>(T2 LEFT JOIN T3 ON P2(T2,T3))</span></pre>
			<p>
			請注意對於有內聯接的查詢，最佳化器可以選擇不同的嵌套環順序，例如：</p>
			<pre><span>FOR each row t3 in T3 {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P2(t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t1 in T1 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			對於有外聯接的查詢，最佳化器可以只選擇這樣的順序：外資料表的環優先於內資料表的環。這樣，對於有外聯接的查詢，只可能有一種嵌套順序。在下面的查詢中，最佳化器將評估兩個不同的嵌套：</p>
			<pre><span>SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)</span></pre>
			<pre><span>&nbsp; WHERE P(T1,T2,T3)</span></pre>
			<p>
			嵌套為：</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t1,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1:=TRUE</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			和</p>
			<pre><span>FOR each row t1 in T1 {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t3 in T3 such that P2(t1,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t2 in T2 such that P1(t1,t2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1:=TRUE</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF P(t1,NULL,NULL) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			在兩個嵌套中，必須在外環中處理<span>T1</span>，因為它用於外聯接中。<span>T2</span>和<span>T3</span>用於內聯接中，因此聯接必須在內環中處理。但是，因為該聯接是一個內聯接，<span>T2</span>和<span>T3</span>可以以任何順序處理。</p>
			<p>
			當討論內聯接嵌套環的算法時，我們忽略了部分詳情，可能對查詢執行的性能的影響會很大。我們沒有提及所謂的「下推」條件。假定可以用連接公式資料表示我們的<span>WHERE</span>條件<span>P(T1,T2,T3)</span>：</p>
			<pre><span>P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3)</span><span>。</span></pre>
			<p>
			在這種情況下，<span>MySQL</span>實際使用了下面的嵌套環方案來執行帶內聯接得到查詢：</p>
			<pre><span>FOR each row t1 in T1 such that C1(t1) {</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)&nbsp; {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF P(t1,t2,t3) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			您會看見每個連接 
			<span>C1(T1)</span>，<span>C2(T2)</span>，<span>C3(T3)</span>被從最內部的環內推出到可以對它進行評估的最外的環中。如果<span>C1(T1)</span>是一個限制性很強的條件，下推條件可以大大降低從資料表<span>T1</span>傳遞到內環的行數。結果是查詢大大加速。</p>
			<p>
			對於有外聯接的查詢，只有查出外資料表的當前的行可以匹配內資料表後，才可以檢查<span>WHERE</span>條件。這樣，對內嵌套環下推的條件不能直接用於帶外聯接的查詢。這裡我們必須引入有條件下推前提，由遇到匹配後打開的標誌保護。</p>
			<p>
			對於帶下面的外聯接的例子</p>
			<pre><span>P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)</span></pre>
			<p>
			使用受保護的下推條件的嵌套環方案看起來應為：</p>
			<pre><span>FOR each row t1 in T1 such that C1(t1) {</span></pre>
			<pre><span>&nbsp; BOOL f1:=FALSE;</span></pre>
			<pre><span>&nbsp; FOR each row t2 in T2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; such that P1(t1,t2) AND (f1?C2(t2):TRUE) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; BOOL f2:=FALSE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FOR each row t3 in T3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;t:=t1||t2||t3; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f2=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; IF (!f2) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||t2||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=TRUE;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; }</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>&nbsp; IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t:=t1||NULL||NULL; OUTPUT t;</span></pre>
			<pre><span>&nbsp; }</span></pre>
			<pre><span>}</span></pre>
			<p>
			總的來說，可以從聯接條件（例如<span>P1(T1,T2)</span>和<span>P(T2,T3)</span>）提取下推前提。在這種情況下，下推前提也受一個標誌保護，防止檢查由相應外聯接操作所產生的<span>NULL</span><span>-</span>補充的行的斷言。</p>
			<p>請注意如果從判斷式的<span>WHERE</span>條件推導出，根據從一個內資料表到相同嵌套聯接的另一個資料表的關鍵字進行的訪問被禁止。<span>(</span>在這種情況下，我們可以使用有條件關鍵字訪問，但是該技術還未用於<span>MySQL 
			5.1</span>中）<span>。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="outer-join-simplification"></a>
			7.2.11.&nbsp;MySQL如何簡化外部聯合</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			在許多情況下，一個查詢的<span >FROM</span>子句的資料表的資料表達式可以簡化。</p>
			<p>
			在分析階段，帶右外聯接操作的查詢被轉換為只包含左聯接操作的等效查詢。總的來說，根據以下原則進行轉換：</p>
			<pre><span>(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =</span></pre>
			<pre><span>(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)</span></pre>
			<p>
			所有<span >T1 INNER JOIN T2 ON 
			P(T1,T2)</span>形式的內聯接資料表達式被替換為<span>T1,T2</span>、<span><span>P(T1,T2)</span><span>，</span></span>並根據<span>WHERE</span>條件<span>(</span>或嵌入連接的聯接條件，如果有<span>)</span>聯接為一個連接。</p>
			<p>
			當最佳化器為用外聯接操作的聯接查詢評估方案時，它只考慮在訪問內資料表之前訪問外資料表的操作的方案。最佳化器選項受到限制，因為只有這樣的方案允許我們用嵌套環機制執行帶外聯接操作的查詢。</p>
			<p>
			假定我們有一個下列形式的查詢：</p>
			<p><span>SELECT * T1 LEFT JOIN T2 ON 
			P1(T1,T2)</span></p>
			<p><span>&nbsp; WHERE P(T1,T2) AND R(T2)</span></p>
			<p>
			<span>R(T2)</span>大大減少了資料表<span>T2</span>中匹配的行數。如果我們這樣執行查詢，最佳化器將不會有其它選擇，只能在訪問資料表<span>T2</span>之前訪問資料表<span>T1</span>，從而導致執行方案非常低。</p>
			<p>
			幸運的是，如果<span>WHERE</span>條件拒絕<span>null</span>，<span>MySQL</span>可以將此類查詢轉換為沒有外聯接操作的查詢。如果為該操作構建的<span>NULL</span>補充的行評估為<span>FALSE</span>或<span>UNKNOWN</span>，則該條件稱為對於某個外聯接操作拒絕<span>null</span>。</p>
			<p>
			因此，對於該外聯接：</p>
			<pre><span>T1 LEFT JOIN T2 ON T1.A=T2.A</span></pre>
			<p>
			類似下面的條件為拒絕<span>null</span>：</p>
			<pre><span>T2.B IS NOT NULL,</span></pre>
			<pre><span>T2.B &gt; 3,</span></pre>
			<pre><span>T2.C &lt;= T1.C,</span></pre>
			<pre><span>T2.B &lt; 2 OR T2.C &gt; 1</span></pre>
			<p>
			類似下面的條件不為拒絕<span>null</span>：</p>
			<pre><span>T2.B IS NULL,</span></pre>
			<pre><span>T1.B &lt; 3 OR T2.B IS NOT NULL,</span></pre>
			<pre><span>T1.B &lt; 3 OR T2.B &gt; 3</span></pre>
			<p>
			檢查一個外聯接操作的條件是否拒絕<span>null</span>的總原則很簡單。以下情況下為拒絕<span>null</span>的條件：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>形式為<span>A 
			IS NOT NULL</span>，其中<span>A</span>是任何內資料表的一個屬性</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>包含內資料表引用的判斷式，當某個參量為<span>NULL</span>時評估為<span>UNKNOWN</span></p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>包含用於連接的拒絕<span>null</span>的條件的聯合</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>拒絕<span>null</span>的條件的邏輯和</span></p>
			<p>
			一個條件可以對於一個查詢中的一個外聯接操作為拒絕<span>null</span>的而對於另一個不為拒絕<span>null</span>的。在下面的查詢中：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN T3 
			ON T3.B=T1.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			<span>WHERE</span>條件對於第<span>2</span>個外聯接操作為拒絕<span>null</span>的但對於第<span>1</span>個不為拒絕<span>null</span>的。</p>
			<p>
			如果<span>WHERE</span>條件對於一個查詢中的一個外聯接操作為拒絕<span>null</span>的，外聯接操作被一個內聯接操作代替。</p>
			<p>
			例如，前面的查詢被下面的查詢代替：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INNER JOIN T3 
			ON T3.B=T1.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			對於原來的查詢，最佳化器將評估只與一個訪問順序<span><span>T1</span><span>、<span>T2</span>、<span>T3</span></span></span>兼容的方案。在替換的查詢中，還考慮了訪問順序<span><span>T3</span><span>、<span>T1</span>、<span>T2</span>。</span></span></p>
			<p>
			一個外聯接操作的轉化可以觸發另一個的轉化。這樣，查詢：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN T3 
			ON T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			將首先轉換為查詢：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN T2 
			ON T2.A=T1.A</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN T3 
			ON T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			該查詢等效於查詢：</p>
			<p><span>SELECT * FROM (T1 LEFT JOIN T2 
			ON T2.A=T1.A), T3</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0 AND T3.B=T2.B</span></p>
			<p>
			現在剩餘的外聯接操作也可以被一個內聯接替換，因為條件<span>T3.B=T2.B</span>為拒絕<span>null</span>的，我們可以得到一個根本沒有外聯接的查詢：</p>
			<p><span>SELECT * FROM (T1 INNER JOIN T2 
			ON T2.A=T1.A), T3</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0 AND T3.B=T2.B</span></p>
			<p>
			有時我們可以成功替換嵌入的外聯接操作，但不能轉換嵌入的外聯接。下面的查詢：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 
			ON T3.B=T2.B)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span></p>
			<p>
			被轉換為：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 INNER JOIN T3 
			ON T3.B=T2.B)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span>，</p>
			<p>
			只能重新寫為仍然包含嵌入式外聯接操作的形式：</p>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2,T3)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (T2.A=T1.A AND 
			T3.B=T2.B)</span></p>
			<p><span>&nbsp; WHERE T3.C &gt; 0</span>。</p>
			<p>
			如果試圖轉換一個查詢中的嵌入式外聯接操作，我們必須考慮嵌入式外聯接的聯接條件和<span>WHERE</span>條件。在下面的查詢中：</p>
			<pre><span>SELECT * FROM T1 LEFT JOIN</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2 LEFT JOIN T3 ON T3.B=T2.B)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A AND T3.C=T1.C</span></pre>
			<pre><span>&nbsp; WHERE T3.D &gt; 0 OR T1.D &gt; 0</span></pre>
			<pre><span  >WHERE</span><span>條件對於嵌入式外聯接不為拒絕<span>null</span>的，但嵌入式外聯接</span><span >T2.A=T1.A AND T3.C=T1.C</span><span>的聯接條件為拒絕<span>null</span>的</span>。<span>因此該查詢可以轉換為</span>：</pre>
			<p><span>SELECT * FROM T1 LEFT JOIN</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (T2, T3)</span></p>
			<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON T2.A=T1.A AND 
			T3.C=T1.C AND T3.B=T2.B</span></p>
			<p><span>&nbsp; WHERE T3.D &gt; 0 OR T1.D &gt; 0</span></p>
			<h3 class="title"><a name="order-by-optimization"></a>
			7.2.12.&nbsp;MySQL如何最佳化ORDER BY<code class="literal"></code></h3></div></div></div>
			<p>
			在某些情況中，<span>MySQL</span>可以使用一個索引來滿足<span>ORDER 
			BY</span>子句，而不需要額外的排序。</p>
			<p>
			即使<span>ORDER 
			BY</span>不確切匹配索引，只要<span>WHERE</span>子句中的所有未使用的索引部分和所有額外的<span>ORDER 
			BY </span>列為常數，就可以使用索引。下面的查詢使用索引來解決<span>ORDER BY</span>部分：</p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i>,<i>key_part2</i>,... 
			;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; WHERE <i>key_part1</i>=<i>constant</i>
			</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part2</i>;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1 </span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i> 
			DESC, <i>key_part2</i> DESC;</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; </span></p>
			<p><span>SELECT * FROM t1</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; WHERE <i>key_part1</i>=1
			</span></p>
			<p><span>&nbsp;&nbsp;&nbsp; ORDER BY <i>key_part1</i> 
			DESC, <i>key_part2</i> DESC;</span></p>
			<p>
			在某些情況下，<span>MySQL</span><em><span>不能</span></em>使用索引來解決<span>ORDER 
			BY</span>，儘管它仍然使用索引來找到匹配<span>WHERE</span>子句的行。這些情況包括：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對不同的關鍵字使用<span>ORDER 
			BY</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 ORDER BY </span><i><span >key1</span></i><span >, </span><i><span >key2</span><span>；</span></i></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對關鍵字的非連續元素使用<span>ORDER 
			BY</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 WHERE </span><i><span >key2</span></i><span >=</span><i><span >constant</span></i><span > ORDER BY </span><i><span >key_part2</span></i>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>混合<span>ASC</span>和<span>DESC</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 ORDER BY </span><i><span >key_part1</span></i><span > DESC, </span><i><span >key_part2</span></i><span > ASC</span>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用於查詢行的關鍵字與<span>ORDER BY</span>中所使用的不相同：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1 WHERE </span><i><span >key2</span></i><span >=</span><i><span >constant</span></i><span > ORDER BY </span><i><span >key1</span></i>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您正聯接許多資料表，並且<span>ORDER BY</span>中的列並不是全部來自第<span>1</span>個用於搜索行的非常量資料表。<span>(</span>這是<span>EXPLAIN</span>輸出中的沒有<span>const</span>聯接類型的第<span>1</span>個資料表）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有不同的<span>ORDER 
			BY</span>和<span>GROUP 
			BY</span>資料表達式。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用的資料表索引的類型不能按順序保存行。例如，對於<span>HEAP</span>資料表的<span>HASH</span>索引情況即如此。</p>
			<p>
			通過<span>EXPLAIN 
			SELECT ...ORDER BY</span>，可以檢查<span>MySQL</span>是否可以使用索引來解決查詢。如果<span>Extra</span>列內有<span>Using 
			filesort</span>，則不能解決查詢。參見<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1節，「EXPLAIN語法（獲取關於SELECT的訊息）<code class="literal"></code>」</a>。</p>
			<p>
			檔案排序最佳化不僅用於記錄排序關鍵字和行的位置，並且還記錄查詢需要的列。這樣可以避免兩次讀取行。檔案排序算法的工作像這樣：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>讀行匹配<span>WHERE</span>子句的行，如前面所示。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>對於每個行，記錄構成排序關鍵字和行位置的一系列值，並且記錄查詢需要的列。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>根據排序關鍵字排序元組</p>
			<p>
			<span>4.<span>&nbsp;&nbsp;&nbsp;
			</span></span>按排序的順序檢索行，但直接從排序的元組讀取需要的列，而不是再一次訪問資料表。</p>
			<p>
			該算法比以前版本的<span>Mysql</span>有很大的改進。</p>
			<p>
			為了避免速度變慢，該最佳化只用於排序元組中的<span>extra</span>列的總大小不超過<span>max_length_for_sort_data</span>系統變數值的時候。<span>(</span>將該變數設置得太高的的跡像是將看到硬盤活動太頻繁而<span>CPU</span>活動較低）<span>。
			</span></p>
			<p>
			如果想要增加<span>ORDER BY</span>的速度，首先看是否可以讓<span>MySQL</span>使用索引而不是額外的排序階段。如果不能，可以嘗試下面的策略：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>增加<span>sort_buffer_size</span>變數的大小。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>增加<span>read_</span><span>rnd_buffer_size</span>變數的大小。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>更改<span>tmpdir</span>指向具有大量空閒空間的專用檔案系統。該選項接受幾個使用<span>round-robin(</span>循環<span>)</span>模式的路徑。在<span>Unix</span>中路徑應用冒號<span>(</span>『<span>:</span>』<span>)</span>區間開，在<span>Windows</span>、<span>NetWare</span>和<span>OS/2</span>中用分號<span>(</span>『<span>；</span>』<span>)</span>。可以使用該特性將負載均分到幾個目錄中。<em><span>註釋：</span></em>路徑應為位於不同<em><span>物理</span></em>硬盤上的檔案系統的目錄，而不是同一硬盤的不同的分區。</p>
			<p>
			預設情況下，<span>MySQL</span>排序所有<span><span>GROUP 
			BY <i>col1</i></span><span>，<i><span>col2</span></i>，<span>...</span></span></span>查詢的方法如同在查詢中指定<span>ORDER 
			BY</span><span><span>
			<i>col1</i></span><span>，<i><span>col2</span></i>，<span>...</span></span></span>。如果顯式包括一個包含相同的列的<span>ORDER 
			BY</span>子句，<span>MySQL</span>可以毫不減速地對它進行最佳化，儘管仍然進行排序。如果查詢包括<span>GROUP 
			BY</span>但您想要避免排序結果的消耗，您可以指定<span>ORDER BY</span><span> 
			NULL</span>禁止排序。例如：</p>
			<p><span>INSERT INTO foo</span></p>
			<p><span>SELECT a, COUNT(*) FROM bar 
			GROUP BY a ORDER BY NULL;</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-by-optimization"></a>
			7.2.13.&nbsp;MySQL如何最佳化GROUP BY<code class="literal"></code></h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#loose-index-scan">
				7.2.13.1. 鬆散索引掃瞄</a></span></dt><dt><span class="section"><a href="optimization.html#tight-index-scan">
				7.2.13.2. 緊湊索引掃瞄</a></span></dt></dl></div><a class="indexterm" name="id2807303"></a><a class="indexterm" name="id2807312"></a>
			<p>
			滿足<span>GROUP 
			BY</span>子句的最一般的方法是掃瞄整個資料表並建立一個新的臨時資料表，資料表中每個組的所有行應為連續的，然後使用該臨時資料表來找到組並應用累積函數<span>(</span>如果有<span>)</span>。在某些情況中，<span>MySQL</span>能夠做得更好，通過索引訪問而不用建立臨時資料表。</p>
			<p>
			為<span>GROUP 
			BY</span>使用索引的最重要的前提條件是 所有<span>GROUP 
			BY</span>列引用同一索引的屬性，並且索引按順序保存其關鍵字<span>(</span>例如，這是<span>B-</span>樹索引，而不是<span>HASH</span>索引<span>)</span>。是否用索引訪問來代替臨時資料表的使用還取決於在查詢中使用了哪部分索引、為該部分指定的條件，以及選擇的累積函數。</p>
			<p>
			有兩種方法通過索引訪問執行<span>GROUP 
			BY</span>查詢，如下面的章節所描述。在第<span>1</span>個方法中，組合操作結合所有範圍判斷式使用<span>(</span>如果有<span>)</span>。第<span>2</span>個方法首先執行範圍掃瞄，然後組合結果元組。</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="loose-index-scan"></a>
							7.2.13.1.&nbsp;鬆散索引掃瞄</h4></div></div></div>
				<p>
				使用索引時最有效的途徑是直接搜索組域。通過該訪問方法，<span>MySQL</span>使用某些關鍵字排序的索引類型<span>(</span>例如，<span>B-</span>樹<span>)</span>的屬性。該屬性允許使用 
				索引中的搜尋組而不需要考慮滿足所有<span>WHERE</span>條件的索引中的所有關鍵字。既然該訪問方法只考慮索引中的關鍵字的一小部分，它被稱為<em><span>鬆散索引掃瞄</span></em>。如果沒有<span>WHERE</span>子句，
				鬆散索引掃瞄讀取的關鍵字數量與組數量一樣多，可以比所有關鍵字數小得多。如果<span>WHERE</span>子句包含範圍判斷式<span>(</span>關於<span>range</span>聯接類型的討論參見<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1節，「EXPLAIN語法（獲取關於SELECT的訊息）<code class="literal"></code>」</a><span>)</span>，
				鬆散索引掃瞄搜尋滿足範圍條件的每個組的第<span>1</span>個關鍵字，並且再次讀取盡可能最少數量的關鍵字。在下面的條件下是可以的：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查詢針對一個單資料表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>GROUP BY</span>包括索引的第<span>1</span>個連續部分<span>(</span>如果對於<span>GROUP 
				BY</span>，查詢有一個<span>DISTINCT</span>子句，則所有顯式屬性指向索引開頭<span>)</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>只使用累積函數<span>(</span>如果有<span>)</span><span>MIN()</span>和<span>MAX()</span>，並且它們均指向相同的列。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>索引的任何其它部分（除了那些來自查詢中引用的<span>GROUP 
				BY</span>）必須為常數<span>(</span>也就是說，必須按常量數量來引用它們<span>)</span>，但<span>MIN()</span>或<span>MAX()</span><span>
				</span>函數的參數例外。</p>
				<p>
				此類查詢的<span>EXPLAIN</span>輸出顯示<span>Extra</span>列的<span>Using 
				indexforgroup-by</span>。</p>
				<p>
				下面的查詢提供該類的幾個例子，假定資料表<span>t1(c1,c2,c3,c4)</span>有一個索引<span><span>idx(c1</span><span>，<span>c2</span>，<span>c3)</span></span></span>：</p>
				<p><span>SELECT c1, c2 FROM t1 GROUP 
				BY c1, c2;</span></p>
				<p><span>SELECT DISTINCT c1, c2 FROM 
				t1;</span></p>
				<p><span>SELECT c1, MIN(c2) FROM t1 
				GROUP BY c1;</span></p>
				<p><span>SELECT c1, c2 FROM t1 WHERE 
				c1 &lt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT MAX(c3), MIN(c3), 
				c1, c2 FROM t1 WHERE c2 &gt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT c2 FROM t1 WHERE c1 
				&lt; <i>const</i> GROUP BY c1, c2;</span></p>
				<p><span>SELECT c1, c2 FROM t1 WHERE 
				c3 = <i>const</i> GROUP BY c1, c2</span>；</p>
				<p>
				由於上述原因，不能用該快速選擇方法執行下面的查詢：</p>
				<p>
				<span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>除了<span>MIN()</span>或<span><span>MAX()</span><span>，</span></span>還有其它累積函數，例如：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1, SUM(c2) FROM t1 GROUP BY c1;</span></pre>
				<p>
				<span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>GROUP BY</span>子句中的域不引用索引開頭，如下所示：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1,c2 FROM t1 GROUP BY c2, c3;</span></pre>
				<p>
				<span>3.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查詢引用了<span>GROUP 
				BY</span>部分後面的關鍵字的一部分，並且沒有等於常量的等式，例如：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1,c3 FROM t1 GROUP BY c1, c2</span>；</pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="tight-index-scan"></a>
				7.2.13.2.&nbsp;緊湊索引掃瞄</h4></div></div></div>
				<p>緊湊式索引掃瞄可以為索引掃瞄或一個範圍索引掃瞄，取決於查詢條件。</p>
				<p>如果不滿足鬆散索引掃瞄條件，<span >GROUP 
				BY</span>查詢仍然可以不用建立臨時資料表。如果<span >WHERE</span>子句中有範圍條件，該方法只讀取滿足這些條件的關鍵字。否則，進行索引掃瞄。該方法讀取由<span >WHERE</span>子句定義的每個範圍的所有關鍵字，或沒有範圍條件式掃瞄整個索引，我們將它定義為緊湊式索引掃瞄。請注意對於緊湊式索引掃瞄，只有找到了滿足範圍條件的所有關鍵字後才進行組合操作。</p>
				<p>要想讓該方法工作，對於引用<span >GROUP 
				BY</span>關鍵字元素的前面、中間關鍵字元素的查詢中的所有列，有一個常量等式條件即足夠了。等式條件中的常量填充了搜索關鍵字中的「差距」，可以形成完整的索引前綴。這些索引前綴可以用於索引搜尋。如果需要排序<span >GROUP 
				BY</span>結果，並且能夠形成索引前綴的搜索關鍵字，<span>MySQL</span>還可以避免額外的排序操作，因為使用有順序的索引的前綴進行搜索已經按順序檢索到了所有關鍵字。</p>
				<p>上述的第一種方法不適合下面的查詢，但第<span>2</span>種索引訪問方法可以工作<span>(</span>假定我們已經提及了資料表<span >t1</span>的索引<span >idx</span><span>)</span>：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				GROUP BY</span>中有一個差距，但已經由條件<span >c2 
				= &#39;a&#39;</span>覆蓋。</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1</span>，<span>c2</span>，<span>c3 FROM t1 WHERE c2 = &#39;a&#39; GROUP BY c1</span>，<span>c3;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span >
				GROUP BY</span>不以關鍵字的第<span>1</span>個元素開始，但是有一個條件提供該元素的常量：</p>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; SELECT c1</span>，<span>c2</span>，<span>c3 FROM t1 WHERE c1 = &#39;a&#39; GROUP BY c2</span>，<span>c3;</span></pre>
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="limit-optimization"></a>
			7.2.14.&nbsp;MySQL如何最佳化LIMIT<code class="literal"></code></h3></div></div></div><a class="indexterm" name="id2807761"></a><a class="indexterm" name="id2807770"></a>
			<p>
			在一些情況中，當您使用<span>LIMIT <i>row_count</i></span>而不使用<span>HAVING</span>時，<strong><span>MySQL</span></strong>將以不同方式處理查詢。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您用<span>LIMIT</span>只選擇一些行，當<strong><span>MySQL</span><span>選擇</span></strong>做完整的資料表掃瞄時，它將在一些情況下使用索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LIMIT <i>row_count</i></span>與<span>ORDER 
			BY</span>，<strong><span>MySQL</span></strong>一旦找到了排序結果的第一個<i><span>row_count</span></i>行，將結束排序而不是排序整個資料表。如果使用索引，將很快。如果必須進行檔案排序（<span>filesort</span>），必須選擇所有匹配查詢沒有<span>LIMIT</span>子句的行，並且在確定已經找到第<span>1</span>個<span><i><span>row_count</span></i></span>行前，必須對它們的大部分進行排序。在任何一種情況下，一旦找到了行，則不需要再排序結果的其它部分，並且<span>MySQL</span>不再進行排序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當結合<span>LIMIT <i>row_count</i></span>和<span>DISTINCT</span>時，<strong><span style="font-family:
細明體;">MySQL</span></strong>一旦找到<i><span>row_count</span></i>個唯一的行，它將停止。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情況下，<span>GROUP 
			BY</span>能通過順序讀取鍵<span>(</span>或在鍵上做排序<span>)</span>來解決，然後計算摘要直到關鍵字的值改變。在這種情況下，<span>LIMIT
			<i>row_count</i></span>將不計算任何不必要的<span>GROUP 
			BY</span>值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只要<span>MySQL</span>已經發送了需要的行數到客戶，它將放棄查詢，除非您正使用<span>SQL_CALC_FOUND_ROWS</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LIMIT 
			0</span>將總是快速返回一個空集合。這對檢查查詢的有效性是有用的。當使用<span>MySQL 
			API</span>時，它也可以用來得到結果列的列類型。<span>(</span>該技巧在<span>MySQL 
			Monitor</span>中不工作，只顯示<span>Empty set</span>；應使用<span>SHOW 
			COLUMNS</span>或<span>DESCRIBE</span>）<span>。
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當伺服器使用臨時資料表來進行查詢時，使用<span>LIMIT
			<i>row_count</i></span>子句來計算需要多少空間。</p>
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title"><a name="how-to-avoid-table-scan"></a>7.2.15.&nbsp;如何避免資料表掃瞄</h3>
					</div></div></div><a class="indexterm" name="id2807970"></a>
			<p>
			<span>EXPLAIN</span>的輸出顯示了當<span>MySQL</span>使用資料表掃瞄來解決查詢時使用的所有類型列。這通常在如下條件下發生：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表很小，掃瞄資料表比搜尋關鍵字速度快。這對於少於<span>10</span>行並且行較短的資料表比較普遍。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>ON</span>或<span>WHERE</span>子句中沒有適用的索引列的約束。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>正用常量值比較索引列，並且<span>MySQL</span>已經計算到<span>(</span>基於索引樹<span>)</span>常數覆蓋了資料表的很大部分並且資料表掃瞄將會比較快。參見<a href="optimization.html#where-optimizations" title="7.2.4. How MySQL Optimizes WHERE Clauses">7.2.4節，「MySQL怎樣最佳化WHERE子句<code class="literal"></code>」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您正通過另一個列使用一個低的集的勢的關鍵字<span>(</span>許多行匹配關鍵字<span>)</span>。在這種情況下，<span>MySQL</span>假設通過使用關鍵字它可能會進行許多關鍵字搜尋，資料表掃瞄將會更快。</p>
			<p>
			對於小資料表，資料表掃瞄通常合適。對於大資料表，嘗試下面的技巧以避免最佳化器錯選了資料表掃瞄：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>ANALYZE TABLE <i>tbl_name</i></span>為掃瞄的資料表更新關鍵字分佈。參見<a href="sql-syntax.html#analyze-table" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1節，「ANALYZE 
			TABLE語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對掃瞄的資料表使用<span>FORCE</span><span>
			</span><span>INDEX</span>告知<span>MySQL</span>，相對於使用給定的索引資料表掃瞄將非常耗時。參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >SELECT * FROM t1, t2 FORCE INDEX (</span><i><span >index_for_column</span></i><span >)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE t1.</span><span><i><span>col_name</span></i></span><span>=t2.</span><span><i><span>col_name</span></i></span>；</pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>--max-seeks-for-key=1000</span>選項啟動<strong><span>mysqld</span></strong>或使用<span>SET 
			max_seeks_for_key=1000</span>告知最佳化器假設關鍵字掃瞄不會超過<span>1,000</span>次關鍵字搜索。參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert-speed"></a>
			7.2.16.&nbsp;INSERT語句的速度</h3></div></div></div><a class="indexterm" name="id2808156"></a><a class="indexterm" name="id2808165"></a><a class="indexterm" name="id2808175"></a>
			<p>
			<span>插入一個記錄需要的時間由下列因素組成</span><span>，其中的數字資料表示大約比例：</span></p>
			<ul type="disc">
				<li>
				連接：<span>(3)</span></li>
				<li>
				發送查詢給伺服器：<span>(2)</span></li>
				<li>
				分析查詢：<span>(2)</span></li>
				<li>
				插入記錄：（<span>1x</span>記錄大小）</li>
				<li>
				插入索引：（<span>1x</span>索引）</li>
				<li>
				關閉：<span>(1)</span></li>
			</ul>
			<p>
			<span>這不考慮打開資料表的初始開銷，每個並發運行的查詢打開</span><span>。</span></p>
			<p>
			<span>資料表的大小以<span>log<i>N</i> 
			(B</span>樹<span>)</span>的速度減慢索引的插入。</span></p>
			<p>
			加快插入的一些方法：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果同時從同一個客戶端插入很多行，使用含多個<span>VALUE</span>的<span>INSERT</span>語句同時插入幾行。這比使用單行<span>INSERT</span>語句快<span>(</span>在某些情況下快幾倍<span>)</span>。如果您正向一個非空資料表新增數據，可以調節<span>bulk_insert_buffer_size</span>變數，使數據插入更快。參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您從不同的客戶端插入很多行，能通過<span>INSERT 
			DELAYED</span>語句加快速度。參見<a href="sql-syntax.html#insert" title="13.2.4. INSERT Syntax">13.2.4節，「INSERT語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>MyISAM</span>，如果在資料表中沒有刪除的行，能在<span>SELECT</span>語句正在運行的同時插入行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當從一個文本檔案裝載一個資料表時，使用<span>LOAD 
			DATA INFILE</span>。這通常比使用很多<span>INSERT</span>語句快<span>20</span>倍。參見<a href="sql-syntax.html#load-data" title="13.2.5. LOAD DATA INFILE Syntax">13.2.5節，「LOAD 
			DATA INFILE語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當資料表有很多索引時，有可能要多做些工作使得<span>LOAD 
			DATA INFILE</span>更快些。使用下列過程：</p>
			<ul type="disc">
				<ol start="1" type="1">
					<li>
					有選擇地用<span>CREATE 
					TABLE</span>建立資料表。</li>
					<li>
					執行<span>FLUSH 
					TABLES</span>語句或命令<strong><span>mysqladmin 
					flush-tables</span></strong>。</li>
					<li>
					使用<b><span>myisamchk --keys-used=0 -rq <i>
					/path/to/db/tbl_name</i></span></b>。這將從資料表中取消所有索引的使用。</li>
					<li>
					用<span>LOAD DATA 
					INFILE</span>把數據插入到資料表中，因為不更新任何索引，因此很快。</li>
					<li>
					如果只想在以後讀取資料表，使用<strong><span>myisampack</span></strong>壓縮它。參見<a href="storage-engines.html#compressed-format" title="15.1.3.3. Compressed Table Characteristics">15.1.3.3節，「壓縮資料表特性」</a>。</li>
					<li>
					用<strong><span>myisamchk -r 
					-q </span></strong><span><b><i>
					<span>/path/to/db/tbl_name</span></i></b></span>重新建立索引。這將在寫入磁盤前在內存中建立索引樹，並且它更快，因為避免了大量磁盤搜索。結果索引樹也被完美地平衡。</li>
					<li>
					執行<span>FLUSH TABLES</span>語句或<strong><span>mysqladmin 
					flush-tables</span></strong>命令。</li>
				</ol>
			</ul>
			<p>
			請注意如果插入一個空<span>MyISAM</span>資料表，<span>LOAD 
			DATA INFILE</span>也可以執行前面的最佳化；主要不同處是可以讓<strong><span>myisamchk</span></strong>為建立索引分配更多的臨時內存，比執行<span>LOAD 
			DATA INFILE</span>語句時為伺服器重新建立索引分配得要多。</p>
			<p>
			也可以使用<span>ALTER TABLE <i>tbl_name</i> DISABLE KEYS</span>代替<b><span>myisamchk 
			--keys-used=0 -rq <i>/path/to/db/tbl_name</i></span></b>，使用<span>ALTER 
			TABLE <i>tbl_name</i> ENABLE KEYS</span>代替<strong><span>myisamchk 
			-r -q </span></strong><span><b><i>
			<span>/path/to/db/tbl_name</span></i></b></span>。使用這種方式，還可以跳過<span>FLUSH 
			TABLES</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>鎖定資料表可以加速用多個語句執行的<span>INSERT</span>操作：</p>
			<ul style=" margin-bottom: 0cm" type="disc">
				<li><span>LOCK TABLES a WRITE;</span></li>
				<li><span>INSERT INTO a VALUES 
				(1,23),(2,34),(4,33);</span></li>
				<li><span>INSERT INTO a VALUES 
				(8,26),(6,29);</span></li>
				<li><span>UNLOCK TABLES;</span></li>
			</ul>
			<p>
			這樣性能會提高，因為索引緩存區僅在所有<span>INSERT</span>語句完成後刷新到磁盤上一次。一般有多少<span>INSERT</span>語句即有多少索引緩存區刷新。如果能用一個語句插入所有的行，就不需要鎖定。</p>
			<p>
			對於事務資料表，應使用<span>BEGIN</span>和<span>COMMIT</span>代替<span>LOCK 
			TABLES</span>來加快插入。</p>
			<p>
			鎖定也將降低多連接測試的整體時間，儘管因為它們等候鎖定最大等待時間將上升。例如：</p>
			<p><span>
			Connection 1 does 1000 inserts</span></p>
			<p><span>
			Connections 2, 3, and 4 do 1 insert</span></p>
			<p><span>
			Connection 5 does 1000 inserts</span></p>
			<p>
			如果不使用鎖定，<span>2</span>、<span>3</span>和<span>4</span>將在<span>1</span>和<span>5</span>前完成。如果使用鎖定，<span>2</span>、<span>3</span>和<span>4</span>將可能不在<span>1</span>或<span>5</span>前完成，但是整體時間應該快大約<span>40%</span>。</p>
			<p>
			<span>INSERT</span>、<span>UPDATE</span>和<span>DELETE</span>操作在<strong><span>MySQL</span></strong>中是很快的，通過為在一行中多於大約<span>5</span>次連續不斷地插入或更新的操作加鎖，可以獲得更好的整體性能。如果在一行中進行多次插入，可以執行<span>LOCK 
			TABLES</span>，隨後立即執行<span>UNLOCK 
			TABLES</span><span>(</span>大約每<span>1000</span>行<span>)</span>以允許其它的線程訪問資料表。這也會獲得好的性能。</p>
			<p>
			<span>INSERT</span>裝載數據比<span>LOAD 
			DATA INFILE</span>要慢得多，即使是使用上述的策略。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>為了對<span>LOAD 
			DATA INFILE</span>和<span>INSERT</span>在<span>MyISAM</span>資料表得到更快的速度，通過增加<span>key_</span><span>buffer_size</span>系統變數來擴大
			鍵高速緩衝區。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
			<div class="itemizedlist">&nbsp;</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="update-speed"></a>
			7.2.17.&nbsp;UPDATE語句的速度</h3></div></div></div>
		<p>
		更新查詢的最佳化同<span>SELECT</span>查詢一樣，需要額外的寫開銷。寫速度依賴於更新的數據大小和更新的索引的數量。沒有更改的索引不被更新。</p>
		<p>
		使更改更快的另一個方法是推遲更改然後在一行內進行多次更新。如果鎖定資料表，同時做多個更新比一次做一個快得多。</p>
		<p>
		請注意對使用動態記錄格式的<span>MyISAM</span>資料表，更新一個較長總長的記錄可能會切分記錄。如果經常這樣該，偶爾使用<span>OPTIMIZE 
		TABLE</span>很重要。參見<a href="sql-syntax.html#optimize-table" title="13.5.2.5. OPTIMIZE TABLE Syntax">13.5.2.5節，「OPTIMIZE 
		TABLE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete-speed"></a>
			7.2.18.&nbsp;DELETE語句的速度</h3></div></div></div>
			<p>
			刪除一個記錄的時間與索引數量確切成正比。為了更快速地刪除記錄，可以增加鍵高速緩衝的大小。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
			<p>
			如果想要刪除一個資料表的所有行，使用<span>TRUNCATE TABLE <i>tbl_name</i>
			</span>而不要用<span>DELETE FROM <i>tbl_name</i></span>。參見<a href="sql-syntax.html#truncate" title="13.2.9. TRUNCATE Syntax">13.2.9節，「TRUNCATE語法」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tips"></a>
			7.2.19.&nbsp;其它最佳化技巧</h3></div></div></div><a class="indexterm" name="id2808794"></a><a class="indexterm" name="id2808805"></a>
			<p>
			該節列出了提高查詢速度的各種技巧：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用持久的連接資料庫以避免連接開銷。如果不能使用持久的連接並且您正啟動許多新的與資料庫的連接，可能要更改<span>thread_cache_size</span>變數的值。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>總是檢查所有查詢確實使用已經在資料表中建立了的索引。在<strong><span>MySQL</span></strong>中，可以用<span>EXPLAIN</span>命令做到。參見<a href="optimization.html#explain" title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1節，「EXPLAIN語法（獲取關於SELECT的訊息）<code class="literal"></code>」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>嘗試避免在頻繁更新的資料表上執行複雜的<span>SELECT</span>查詢，以避免與鎖定資料表有關的由於讀、寫衝突發生的問題。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於沒有刪除的行的<span>MyISAM</span>資料表，可以在另一個查詢正從資料表中讀取的同時在末尾插入行。如果這很重要，應考慮按照避免刪除行的方式使用資料表。另一個可能性是在刪除大量行後運行<span>OPTIMIZE 
			TABLE</span>。參見<a href="storage-engines.html#myisam-storage-engine" title="15.1. The MyISAM Storage Engine">15.1節，「MyISAM儲存引擎」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要修復任何<span>ARCHIVE</span>資料表可以發生的壓縮問題，可以執行<span>OPTIMIZE 
			TABLE</span>。參見<a href="storage-engines.html#archive-storage-engine" title="15.8. The ARCHIVE Storage Engine">15.8節，「ARCHIVE儲存引擎」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您主要按<span><i><span>expr1</span></i><span>，<i><span>expr2</span></i>，<span>...</span></span></span>順序檢索行，使用<span >ALTER 
			TABLE ... ORDER BY <i>expr1</i>, <i>expr2</i>, ...</span>。對資料表大量更改後使用該選項，可以獲得更好的性能。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情況下，使得基於來自其它資料表的列的訊息引入一個「 
			哈希」的列有意義。如果該列較短並且有合理的唯一值，它可以比在許多列上的一個大索引快些。在<strong><span>MySQL</span></strong>中，很容易使用這個額外列：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>hash_col</span></i></span><span>=MD5(CONCAT(</span><span><i><span>col1</span></i></span><span>,</span><span><i><span>col2</span></i></span><span>))</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;AND </span><span><i><span>col1</span></i></span><span>=&#39;</span><span><i><span>constant</span></i></span><span>&#39; AND </span><span><i><span>col2</span></i></span><span>=&#39;</span><span><i><span>constant</span></i></span><span>&#39;;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於頻繁更改的<span >MyISAM</span>資料表，應試圖避免所有變長列<span>(</span><span>VARCHAR</span>、<span>BLOB</span>和<span>TEXT</span><span>)</span>。如果資料表包括單一的變長列則使用動態記錄格式。參見<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>儲存引擎和資料表類型</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			只是因為行太大，將一張資料表分割為不同的資料表一般沒有什麼用處。為了訪問行，最大的性能衝擊是磁盤搜索以找到行的第一個字節。在找到數據後，大多數新型磁盤對大多數應用程式來說足夠快，能讀入整個行。確實有必要分割的唯一情形是如果它是使用動態記錄格式使之變為固定的記錄大小的<span >MyISAM</span>資料表<span>(</span>見上述<span>)</span>，或如果您需要很頻繁地掃瞄資料表而不需要大多數列。參見<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>儲存引擎和資料表類型</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			如果您需要很經常地計算結果，例如基於來自很多行的訊息的計數，引入一個新資料表並實時更新計數器可能更好一些。下面形式的更新會更快一些：</p>
			<pre><span>UPDATE </span><span><i><span>tbl_name</span></i></span><span> SET </span><span><i><span>count_col</span></i></span><span>=</span><span><i><span>count_col</span></i></span><span>+1 WHERE </span><span><i><span>key_col</span></i></span><span>=</span><span><i><span>constant</span></i></span><span>;</span></pre>
			<p>
			當您使用象<span >MyISAM</span>那樣的只有資料表級鎖定的<strong><span>MySQL</span><span>儲存引擎</span></strong><span>(</span>多重讀<span>/</span>單個寫<span>)</span>時，這確實很重要。這也給大多數資料庫較好的性能，因為行鎖定管理器在這種情況下有較少的事情要做。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			如果您需要從大的記錄檔案資料表中收集統計訊息，使用總結性的資料表而不是掃瞄整個資料表。維護總結應該比嘗試做「實時」統計要快些。當有變化時從日誌重新生成新的總結資料表比改變運行的應用<span>(</span>取決於業務決策<span>)</span>要快得多。</p>
			<ul type="disc">
				<li>
				如果可能，應該將報告分類為「實時」或「統計」，這裡統計報告所需的數據僅僅基於從實際數據定期產生的總結資料表中產生。</li>
				<li>充分利用列有預設值的事實。只有當插入的值不同於預設值時，才明確地插入值。這減少<span>MySQL</span>需要做的語法分析從而提高插入速度。</li>
				<li>
				<span>在一些情況下，包裝並儲存數據到一個<span>BLOB</span>列中是很方便的。在這種情況下，必須在您的應用中增加額外的代碼來打包<span>/</span>解包訊息，但是這種方法可以在某些階段節省很多訪問。當有不符合行和列資料表結構的數據時，這很實用。</span></li>
				<li><span>
				在一般情況下，應該嘗試以非冗余方式<span>(</span>查看資料庫理論中的<i>第三正則形式</i><span>)</span>保</span>存數據，但是為了獲得更快的速度，可以複製訊息或建立總結資料表。</li>
				<li>儲存過程或<span>UDF(</span>用戶定義函數<span>)</span>可能是獲得更好性能的一個好方法，詳細訊息參見<a href="stored-procedures.html">第20章：</a><a href="stored-procedures.html" title="Chapter 20. Stored Procedures and Functions"><i>儲存程式和函數</i></a>和<a href="extending-mysql.html#adding-functions" title="27.2. Adding New Functions to MySQL">27.2節，「為MySQL新增新函數」</a>。 </li>
				<li>總是能通過在應用程式中緩存查詢<span>/</span>答案並嘗試同時執行很多插入<span>/</span>更新來獲得一些好處。如果資料庫支援鎖定資料表<span>(</span>象<strong><span>MySQL</span></strong>和<span>Oracle)</span>，這應該有助於確保索引緩存只在所有更新後刷新一次。還可以利用<span>MySQL</span>的查詢緩存來獲得類似的結果；參見<a href="database-administration.html#query-cache" title="5.13. The MySQL Query Cache">5.13節，「MySQL查詢高速緩衝」</a>。</li>
				<li>當不需要知道何時寫入數據時，使用<span >INSERT 
				DELAYED</span>。這樣可以加快處理，因為很多記錄可以通過一次磁盤寫入被寫入。</li>
				<li>當您想要讓選擇顯得更重要時，使用<span>INSERT 
				/*! LOW_PRIORITY */</span>。</li>
				<li>使用<span >INSERT 
				LOW_PRIORITY</span>來取得插入隊列的檢索，也就是即使有另一個客戶等待寫入也要執行<span >SELECT</span>。</li>
				<li>使用多行<span>INSERT</span>語句通過一個<span>SQL</span>命令來儲存很多行<span>(</span>許多<span>SQL</span>伺服器支援它，包括<span>MySQL</span><span>)</span>。</li>
				<li>使用<span>LOAD 
				DATA INFILE</span>裝載較大數量的數據。這比使用<span >INSERT</span>要快得多。</li>
				<li>使用<span>AUTO_INCREMENT</span>列構成唯一值。</li>
				<li>當<span >MyISAM</span>使用動態資料表格式時，偶爾使用<span>OPTIMIZE 
				TABLE</span>可以避免碎片。參見<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3節，「MyISAM資料表的儲存格式」</a>。</li>
				<li>可能時使用<span >MEMORY</span>資料表以得到更快的速度。<span><a  href="../../../澶┼渤/2006.1/1/IT/IT/wwn/manual_Server.html#Table_types"><span>參見</span></a></span><a href="storage-engines.html#memory-storage-engine" title="15.4. The MEMORY (HEAP) Storage Engine">15.4節，「MEMORY (HEAP)儲存引擎」</a>。</li>
				<li>在<span>Web</span>伺服器中，圖像和其它二進制資產應該作為檔案儲存。也就是僅在資料庫中儲存的本檔案的引用而不是檔案本身。大多數<span>Web</span>伺服器在緩存檔案方面比資料庫內容要好得多，因此使用檔案一般要快得多。</li>
				<li>對經常訪問的不重要數據<span>(</span>如為沒有在<span>Web
				</span>瀏覽器中啟用<span>cookie</span>的用戶最後顯示的標語的相關訊息<span>)</span>使用內存資料表。在許多<span>Web</span>應用程式環境中也可以使用用戶會話來處理可變狀態數據。</li>
				<li>
				在不同資料表中具有相同訊息的列應該被聲明為相同的並有相同的名字。嘗試使名字簡單化。例如，在<span >customer</span>資料表中使用<span>name</span>而不是<span>customer_name</span>。為了使名字能移植到其它<span>SQL</span>伺服器，應該使名字短於<span>18</span>個字元。</li>
				<li>如果確實需要很高的速度，應該研究一下不同<span>SQL</span>伺服器支援的數據儲存的低層接口！例如直接訪問<strong><span>MySQL</span></strong><span>
				</span><span>MyISAM</span>儲存引擎，比起使用<span>SQL</span>接口，速度可以提高<span>2-5</span>倍。為了能實現，數據必須與應用程式在同一台伺服器上，並且通常只應該被一個程序訪問<span>(</span>因為外部檔案鎖定確實很慢<span>)</span>。通過在<strong><span>MySQL</span></strong>伺服器中引進低層<span>MyISAM</span>命令能消除以上問題<span>(</span>如果需要，這可能是獲得更好性能的一個簡單的方法<span>)</span>。通過精心設計資料庫接口，應該能相當容易地支援這類最佳化。</li>
				<li>如果正使用數字數據，在許多情況下，從一個資料庫訪問訊息<span>(</span>使用實時連接<span>)</span>比訪問一個文本檔案快些。這是因為資料庫中的訊息比文本檔案更緊湊，因此這將涉及更少的磁盤訪問。還可以在應用程式中節省代碼，因為不須分析文本檔案來找出行和列的邊界。</li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			通過複製可以提高某些操作的性能。可以在複製伺服器中分佈客戶的檢索以均分負載。為了防止備份時主伺服器變慢，可以使用一個從伺服器來備份。參見<a href="replication.html">第6章：</a><a href="replication.html" title="Chapter 6. Replication in MySQL"><i>MySQL中的複製</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<span>DELAY_KEY_WRITE=1</span>選項聲明<span>MyISAM</span>資料表可以使索引更新更快，因為在資料表關閉之前它們不刷新到硬盤上。不利之處是當資料表打開時如果殺掉伺服器，應確保用<span>--myisam-recover</span>選項運行伺服器保證沒有問題，或者在重啟伺服器之前運行<strong><span>myisamchk</span></strong>。<span>(</span>然而，即使在這種情況下，應通過使用<span>DELAY_KEY_WRITE</span>保證不丟失數據，因為關鍵字訊息總是可以從數據行產生）<span>。</span></p>
			<div class="itemizedlist">&nbsp;</div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="locking-issues"></a>
		7.3.&nbsp;鎖定事宜</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#internal-locking">
			7.3.1. 鎖定方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">
			7.3.2. 資料表鎖定事宜</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-locking"></a>
			7.3.1.&nbsp;鎖定方法</h3></div></div></div><a class="indexterm" name="id2809544"></a><a class="indexterm" name="id2809550"></a><a class="indexterm" name="id2809557"></a><a class="indexterm" name="id2809567"></a><a class="indexterm" name="id2809574"></a><a class="indexterm" name="id2809581"></a><a class="indexterm" name="id2809588"></a><a class="indexterm" name="id2809598"></a><a class="indexterm" name="id2809608"></a></div><div class="section"><div class="titlepage"><div><div>
		<p>
		<span>MySQL 5.1</span>支援對<span>MyISAM</span>和<span>MEMORY</span>資料表進行資料表級鎖定，對<span>BDB</span>資料表進行頁級鎖定，對<span>InnoDB</span>資料表進行行級鎖定。</p>
		<p>
		在許多情況下，可以根據培訓猜測應用程式使用哪類鎖定類型最好，但一般很難說出某個給出的鎖類型就比另一個好。一切取決於應用程式，應用程式的不同部分可能需要不同的鎖類型。</p>
		<p>
		為了確定是否想要使用行級鎖定的儲存引擎，應看看應用程式做什麼並且混合使用什麼樣的選擇和更新語句。例如，大多數<span>Web</span>應用程式執行許多選擇，而很少進行刪除，只對關鍵字的值進行更新，並且只插入少量具體的資料表。基本<span>MySQL
		</span>
		<span>MyISAM</span>設置已經調節得很好。</p>
		<p>
		在<span>MySQL</span>中對於使用資料表級鎖定的儲存引擎，資料表鎖定時不會死鎖的。這通過總是在一個查詢開始時立即請求所有必要的鎖定並且總是以同樣的順序鎖定資料表來管理。</p>
		<p>
		對<span>WRITE</span>，<strong><span style="font-family:
細明體;">MySQL</span></strong>使用的資料表鎖定方法原理如下：</p>
		<ul type="disc">
			<li>
			如果在資料表上沒有鎖，在它上面放一個寫鎖。</li>
			<li>
			否則，把鎖定請求放在寫鎖定隊列中。</li>
		</ul>
		<p>
		對<span>READ</span>，<strong><span style="
">MySQL</span></strong>使用的鎖定方法原理如下：</p>
		<ul type="disc">
			<li>
			如果在資料表上沒有寫鎖定，把一個讀鎖定放在它上面。</li>
			<li>
			否則，把鎖請求放在讀鎖定隊列中。</li>
		</ul>
		<p>
		當一個鎖定被釋放時，鎖定可被寫鎖定隊列中的線程得到，然後是讀鎖定隊列中的線程。</p>
		<p>
		這意味著，如果您在一個資料表上有許多更新，<span>SELECT</span>語句將等待直到沒有更多的更新。</p>
		<p>
		可以通過檢查<span>table_locks_waited</span>和<span>table_locks_immediate</span>狀態變數來分析系統上的資料表鎖定爭奪：</p>
		<p><span>mysql&gt; <b>SHOW STATUS LIKE 
		&#39;Table%&#39;;</b></span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p><span>| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;&nbsp; |</span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p><span>| Table_locks_immediate | 1151552 |</span></p>
		<p><span>| Table_locks_waited&nbsp;&nbsp;&nbsp; | 15324&nbsp;&nbsp; |</span></p>
		<p><span>+-----------------------+---------+</span></p>
		<p>
		如果<span>INSERT</span>語句不衝突，可以自由為<span>MyISAM</span>資料表混合併行的<span>INSERT</span>和<span>SELECT</span>語句而不需要鎖定。也就是說，您可以在其它客戶正讀取<span>MyISAM</span>資料表的時候插入行。如果數據檔案中間不包含空閒塊，不會發生衝突，因為在這種情況下，記錄總是插入在數據檔案的尾部。<span>(</span>從資料表的中部刪除或更新的行可能導致空洞）<span>。</span>如果有空洞，當所有空洞填入新的數據時，並行的插入能夠重新自動啟用。</p>
		<p>
		如果不能同時插入，為了在一個資料表中進行多次<span>INSERT</span>和<span>SELECT</span>操作，可以在臨時資料表中插入行並且立即用臨時資料表中的記錄更新真正的資料表。</p>
		<p>
		這可用下列代碼做到：</p>
		<p><span>mysql&gt; <b>LOCK TABLES real_table 
		WRITE, insert_table WRITE;</b></span></p>
		<p><span>mysql&gt; <b>INSERT INTO real_table 
		SELECT * FROM insert_table;</b></span></p>
		<p><span>mysql&gt; <b>TRUNCATE TABLE 
		insert_table;</b></span></p>
		<p><span>mysql&gt; <b>UNLOCK TABLES;</b></span></p>
		<pre><span>&nbsp;</span></pre>
		<p>
		<span>
		InnoDB</span>使用行鎖定，<span>BDB</span>使用頁鎖定。對於這兩種儲存引擎，都可能存在死鎖。這是因為，在<span>SQL</span>語句處理期間，<span>InnoDB</span>自動獲得行鎖定和<span>BDB</span>獲得頁鎖定，而不是在事務啟動時獲得。</p>
		<p>
		行級鎖定的優點：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>當在許多線程中訪問不同的行時只存在少量鎖定衝突。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>回滾時只有少量的更改。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以長時間鎖定單一的行。</p>
		<p>
		行級鎖定的缺點：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>比頁級或資料表級鎖定佔用更多的內存。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>當在資料表的大部分中使用時，比頁級或資料表級鎖定速度慢，因為您必須獲取更多的鎖。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果您在大部分數據上經常進行<span>GROUP 
		BY</span>操作或者必須經常掃瞄整個資料表，比其它鎖定明顯慢很多。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>用高級別鎖定，通過支援不同的類型鎖定，您也可以很容易地調節應用程式，因為其鎖成本小於行級鎖定。</p>
		<p>
		在以下情況下，資料表鎖定優先於頁級或行級鎖定：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>資料表的大部分語句用於讀取。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>對嚴格的關鍵字進行讀取和更新，您可以更新或刪除可以用單一的讀取的關鍵字來提取的一行：</p>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >UPDATE </span><i><span >tbl_name</span></i><span > SET </span><i><span >column</span></i><span >=</span><i><span >value</span></i><span > WHERE </span><i><span >unique_key_col</span></i><span >=</span><i><span >key_value</span></i><span >;</span></pre>
		<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span >DELETE FROM </span><i><span >tbl_name</span></i><span > WHERE </span><i><span >unique_key_col</span></i><span >=</span><i><span >key_value</span></i><span >;</span></pre>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>
		<span>SELECT</span><span>
		</span>結合併行的<span>INSERT</span>語句，並且只有很少的<span>UPDATE</span>或<span>DELETE</span>語句。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>在整個資料表上有許多掃瞄或<span>GROUP 
		BY</span>操作，沒有任何寫操作。</p>
		<p>
		不同於行級或頁級鎖定的選項：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>版本<span>(</span>例如，為並行的插入在<span>MySQL</span>中使用的技術<span>)</span>，其中可以一個寫操作，同時有許多讀取操作。這說明資料庫或資料表支援數據依賴的不同視圖，取決於訪問何時開始。其它共同的術語是「<span class="quote">時間跟蹤</span>」、「<span class="quote">寫複製</span>」或者「按需<span class="quote">複製</span>」。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>按需複製在許多情況下優先於頁級或行級鎖定。然而，在最壞的情況下，它可能比使用常規鎖定使用更多的內存。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>除了行級鎖定外，您可以使用應用程式級鎖定，例如在<span>MySQL</span>中使用<span>GET_LOCK()</span>和<span>RELEASE_LOCK()</span>。這些是建議性鎖定，它們只能在運行良好的應用程式中工作。</p>
		<h3 class="title"><a name="table-locking"></a>
			7.3.2.&nbsp;資料表鎖定事宜</h3></div></div></div><a class="indexterm" name="id2810105"></a>
		<p>
		為達到最高鎖定速度，除<span>InnoDB</span>和<span>BDB</span>之外，對所有儲存引擎，<span>MySQL</span>使用資料表鎖定<span>(</span>而不是頁、行或者列鎖定<span>)</span>。</p>
		<p>
		對於<span>InnoDB</span>和<span>BDB</span>資料表，如果您用<span>LOCK 
		TABLES</span>顯式鎖定資料表，<span>MySQL</span>只使用資料表鎖定。對於這些資料表類型，我們建議您根本不要使用<span>LOCK 
		TABLES</span>，因為<span>InnoDB</span>使用自動行級鎖定而<span>BDB</span>使用頁級鎖定來保證事務隔離。</p>
		<p>
		對於大資料表，對於大多數應用程式，資料表鎖定比行鎖定更好，但存在部分問題。</p>
		<p>
		資料表鎖定使許多線程同時從一個資料表中進行讀取操作，但如果一個線程想要對資料表進行寫操作，它必須首先獲得獨佔訪問。更新期間，所有其它想要訪問該資料表的線程必須等待直到更新完成。</p>
		<p>
		資料表更新通常情況認為比資料表檢索更重要，因此給予它們更高的優先級。這應確保更新一個資料表的活動不能「<span class="quote">餓死</span>」，即使該資料表上有很繁重的<span>SELECT</span>活動。</p>
		<p>
		資料表鎖定在這種情況下會造成問題，例如當線程正等待，因為硬盤已滿並且線上程可以處理之前必須有空閒空間。在這種情況下，所有想要訪問出現問題的資料表的線程也被設置成等待狀態，直到有更多的硬盤空間可用。</p>
		<p>
		資料表鎖定在下面的情況下也存在問題：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>一個客戶發出長時間運行的查詢。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>然後，另一個客戶對同一個資料表進行更新。該客戶必須等待直到<span>SELECT</span>完成。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>另一個客戶對同一個資料表上發出了另一個<span>SELECT</span>語句。因為<span>UPDATE</span>比<span>SELECT</span>優先級高，該<span>SELECT</span>語句等待<span>UPDATE</span>完成，並且等待第<span>1</span>個<span>SELECT</span>完成。</p>
		<p>
		下面描述了一些方法來避免或減少資料表鎖定造成的競爭：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>試圖使<span>SELECT</span>語句運行得更快。您可能必須建立一些摘要<span>(summary)</span>資料表做到這點。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>用<span>--low-priority-updates</span>啟動<span><b><span>mysqld</span></b></span>。這將給所有更新<span>(</span>修改<span>)</span>一個資料表的語句以比<span>SELECT</span>語句低的優先級。在這種情況下，在先前情形的第<span>2</span>個<span>SELECT</span>語句將在<span>UPDATE</span>語句前執行，而不需要等候第<span>1</span>個<span>SELECT</span>完成。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以使用<span>SET LOW_PRIORITY_UPDATES=1</span>語句指定具體連接中的所有更新應使用低優先級。參見<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3節，「SET語法」</a></p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以用<span>LOW_PRIORITY</span>屬性給與一個特定的<span>INSERT</span>、<span>UPDATE</span>或<span>DELETE</span>語句較低優先級。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以用<span>HIGH_PRIORITY</span>屬性給與一個特定的<span>SELECT</span>語句較高優先級。參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>為<strong><span style="font-family:
細明體;">max_write_lock_count</span></strong>系統變數指定一個低值來啟動<span><b><span>mysqld</span></b></span>來強制<span>MySQL</span>在具體數量的插入完成後臨時提高所有等待一個資料表的<span>SELECT</span>語句的優先級。這樣允許在一定數量的<span>WRITE</span>鎖定後給出<span>READ</span>鎖定。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果您有關於<span>INSERT</span>結合<span>SELECT</span>的問題，切換到使用新的<span>MyISAM</span>資料表，因為它們支援並發的<span>SELECT</span>和<span>INSERT</span>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果您對同一個資料表混合插入和刪除，<span>INSERT DELAYED</span>將會有很大的幫助。參見<a href="sql-syntax.html#insert-delayed" title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2節，「INSERT 
			DELAYED語法」</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果您對同一個資料表混合使用<span>SELECT</span>和<span>DELETE</span>語句出現問題，<span>DELETE</span>的<span>LIMIT</span>選項可以有所幫助。參見<a href="sql-syntax.html#delete" title="13.2.1. DELETE Syntax">13.2.1節，「DELETE語法」</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>對<span>SELECT</span>語句使用<span>SQL_BUFFER_RESULT</span>可以幫助使資料表鎖定時間變短。參見<a href="sql-syntax.html#select" title="13.2.7. SELECT Syntax">13.2.7節，「SELECT語法」</a>。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以更改<span>mysys/thr_lock.c</span>中的鎖代碼以使用單一的隊列。在這種情況下，寫鎖定和讀鎖定將具有相同的優先級，對一些應用程式會有幫助。</p>
		<p>
		這裡是一些<span>MySQL</span>中資料表鎖定相關的技巧：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果不混合更新與需要在同一個資料表中檢查許多行的選擇，可以進行並行操作。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>可以使用<span>LOCK 
		TABLES</span>來提高速度，因為在一個鎖定中進行許多更新比沒有鎖定的更新要快得多。將資料表中的內容切分為幾個資料表也可以有所幫助。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果在<span>MySQL</span>中資料表鎖定時遇到速度問題，可以將您的資料表轉換為<span>InnoDB</span>或<span>BDB</span>資料表來提高性能。參見<a href="storage-engines.html#innodb" title="15.2. The InnoDB Storage Engine">15.2節，「InnoDB儲存引擎」</a>和<a href="storage-engines.html#bdb-storage-engine" title="15.5. The BDB (BerkeleyDB) Storage Engine">15.5節，「BDB (BerkeleyDB)儲存引擎」</a>。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="optimizing-database-structure"></a>
		7.4.&nbsp;最佳化資料庫結構</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design">
			7.4.1. 設計選擇</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">
			7.4.2. 使您的數據盡可能小</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">
			7.4.3. 列索引</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">
			7.4.4. 多列索引</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">
			7.4.5. MySQL如何使用索引</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">
			7.4.6. MyISAM鍵高速緩衝</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. 
			MyISAM索引統計集合</a></span></dt><dt><span class="section"><a href="optimization.html#open-tables">
			7.4.8. MySQL如何計算打開的資料表</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">
			7.4.9. MySQL如何打開和關閉資料表</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">
			7.4.10. 在同一個資料庫中建立多個資料表的問題</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="design"></a>
			7.4.1.&nbsp;設計選擇</h3></div></div></div><a class="indexterm" name="id2810606"></a><a class="indexterm" name="id2810616"></a><a class="indexterm" name="id2810623"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			<span>MySQL</span>將行數據和索引數據保存在不同的檔案中。許多<span>(</span>幾乎所有<span>)</span>其它資料庫將行數據和索引數據混合保存在用一個檔案中。我們認為<span>MySQL
			</span>選擇對廣範圍的現代系統更好一些。</p>
			<p>
			保存行數據的另一種方式是將每個列的訊息保存在單獨的區域<span>(</span>例如<span>SDBM</span>和<span>Focus)</span>。這樣會對每個訪問多個列的查詢造成性能問題。因為當訪問多個列時退化得很快，我們認為該模型對一般資料庫不合適。</p>
			<p>
			更常見的情形是索引和數據保存在一起<span>(</span>例如<span>Oracle/Sybase)</span>。在這種情況下，您可以在索引的葉級頁找到行的訊息。該佈局比較好的事情是在許多情況下，根據索引緩存得怎樣，可以保存一個硬盤讀取。該佈局的不利之處資料表現在：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>資料表掃瞄要慢得多，因為您必須通讀索引以獲得數據。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您不能只使用資料表來檢索查詢的數據。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您需要使用更多的空間，因為您必須從節點複製索引<span>(</span>您不能保存節點上的行<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>刪除要經過一段時間後才退化資料表<span>(</span>因為刪除時通常不會更新節點上的索引<span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只緩存索引數據會更加困難。</p>
			<h3 class="title"><a name="data-size"></a>
			7.4.2.&nbsp;使您的數據盡可能小</h3></div></div></div><a class="indexterm" name="id2810729"></a><a class="indexterm" name="id2810739"></a><a class="indexterm" name="id2810749"></a><a class="indexterm" name="id2810760"></a><a class="indexterm" name="id2810770"></a>
			<p>
			最基本的最佳化之一是使資料表在磁盤上佔據的空間盡可能小。這能給出巨大的改進，因為磁盤讀入較快，並且在查詢執行過程中小資料表的內容被處理時佔用較少的主儲存器。如果在更小的列上做索引，索引也佔據較少的資源。</p>
			<p>
			<span>MySQL</span>支援許多不同的儲存引擎<span>(</span>資料表類型<span>)</span>和行格式。對於每個資料表，可以確定使用哪個儲存引擎和索引方法。為應用程式選擇合適的資料表格式可以大大提高性能。參見<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>儲存引擎和資料表類型</i></a>。</p>
			<p>
			可以使用下面的技術可以使資料表的性能更好並且使儲存空間最小：</p>
			<ul type="disc">
				<li>盡可能地使用最有效<span>(</span>最小<span>)</span>的數據類型。<strong><span>MySQL</span></strong>有很多節省磁盤空間和內存的專業化類型。</li>
				<li>盡可能使用較小的整數類型使資料表更小。例如，<span>MEDIUMINT</span>經常比<span>INT</span>好一些，因為<span>MEDIUMINT</span>列使用的空間要少<span>25%</span>。</li>
				<li>如果可能，聲明列為<span>NOT 
				NULL</span>。它使任何事情更快而且每列可以節省一位。注意如果在應用程式中確實需要<span>NULL</span>，應該毫無疑問使用它，只是避免
				預設地在所有列上有它。</li>
				<li>對於<span >MyISAM</span>資料表，如果沒有任何變長列<span>(</span><span>VARCHAR</span>、<span>TEXT</span>或<span>BLOB</span>列<span>)</span>，使用固定尺寸的記錄格式。這比較快但是不幸地可能會浪費一些空間。參見<a href="storage-engines.html#myisam-table-formats" title="15.1.3. MyISAM Table Storage Formats">15.1.3節，「MyISAM資料表的儲存格式」</a>。即使您已經用<span >CREATE</span>選項讓<span>VARCHAR</span>列<span >ROW_FORMAT=fixed</span>，也可以提示想使用固定長度的行。</li>
				<li>在<span>MySQL/InnoDB</span>中，<span>InnoDB</span>資料表使用更緊湊的儲存格式。在以前版本的<span>MySQL</span>中，<span>InnoDB</span>記錄包含一些冗余訊息，例如列數目和每個列的長度，即使對於固定大小的列。預設情況，建立的資料表為緊湊格式<span>(ROW_FORMAT=COMPACT)</span>。如果想要降級舊版本的<span>MySQL/InnoDB</span>，可以用<span>ROW_FORMAT=REDUNDANT</span>要求舊的格式。</li>
				<li>緊湊<span>的<span>InnoDB</span>格式也改變了包含<span>UTF-8</span>數據的</span><span  >CHAR</span><span>列的保存方式。在</span><span  >ROW_FORMAT=REDUNDANT</span><span>格式中</span><span>，</span><span >UTF-8
				</span>
				<span  >
				CHAR(<i>n</i>)</span><span>佔用<span>3*</span></span><span><i><span  >n</span></i></span><span>字節</span><span>，</span><span>假</span>定<span>UTF-8</span>編碼的字元的最大長度是<span>3</span>字節。許多語言可以主要用單字節<span>UTF-8</span>字元來編寫，固定的儲存長度通常會浪費空間。通過根據需要剝離尾部的空格，<span>ROW_FORMAT=COMPACT</span>格式為這些列分配可變數量的<span>n..3*n</span>字節。最小儲存長度按順序保存為<span>n</span>字節，以在典型情況下幫助更新。</li>
				<li>每張資料表的主索引應該盡可能短。這使一行的識別容易而有效。</li>
				<li>
				只建立您確實需要的索引。索引對檢索有好處，但是當您需要快速儲存東西時就變得糟糕。如果主要通過搜索列的組合來存取一個資料表，對它們做一個索引。第一個索引部分應該是最常用的列。如果從資料表中選擇時總是使用許多列，應該首先以更多的副本使用列以獲得更好的索引壓縮。</li>
				<li>如果很可能一個索引在頭幾個字元上有唯一的前綴，僅僅索引該前綴比較好。<strong><span>MySQL</span></strong>支援對一個字元列的最左邊部分建立一個索引<span>(</span>參見<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4節，「CREATE 
			INDEX語法」</a><span>)</span>。更短的索引會更快，不僅因為它們占較少的磁盤空間，而且因為它們將在索引緩存中提供更多的訪問，因此磁盤搜索更少。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</li>
			</ul>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情形下，將一個經常被掃瞄的資料表分割為<span>2</span>個資料表是有益的。特別是如果它是一個動態格式的資料表，並且可能使用一個掃瞄資料表時能用來找出相關行的較小靜態格式的資料表。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="indexes"></a>
			7.4.3.&nbsp;列索引</h3></div></div></div><a class="indexterm" name="id2811058"></a><a class="indexterm" name="id2811068"></a><a class="indexterm" name="id2811078"></a>
			<p>
			所有<span>MySQL</span>列類型可以被索引。對相關列使用索引是提高<span>SELECT</span>操作性能的最佳途徑。</p>
			<p>
			根據儲存引擎定義每個資料表的最大索引數和最大索引長度。參見<a href="storage-engines.html">第15章：</a><a href="storage-engines.html" title="Chapter 15. Storage Engines and Table Types"><i>儲存引擎和資料表類型</i></a>。所有儲存引擎支援每個資料表至少<span>16</span>個索引，總索引長度至少為<span>256</span>字節。大多數儲存引擎有更高的限制。</p>
			<p>
			在索引定義中用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>語法，您可以建立一個只使用<span>CHAR</span>或<span>VARCHAR</span>列的第<span>1</span>個<span><i><span>length</span></i></span>字元的索引。按這種方式只索引列值的前綴可以使索引檔案小得多。</p>
			<p>
			<span>MyISAM</span>和<span>InnoDB</span>儲存引擎還支援對<span>BLOB</span>和<span>TEXT</span>列的索引。當索引一個<span>BLOB</span>或<span>TEXT</span>列時，您<em><span>必須</span></em>為索引指定前綴長度。例如：</p>
			<pre><span>CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));</span></pre>
			<p>
			在<span>MySQL 5.1</span>中，對於<span >MyISAM</span>和<span>InnoDB</span>資料表，前綴可以達到<span>1000</span>字節長。請注意前綴的限制應以字節為單位進行測量，而<span>CREATE 
			TABLE</span>語句中的前綴長度解釋為字元數。<em><span>當為使用多字節字元編碼的列指定前綴長度時一定要加以考慮</span></em>。</p>
			<p>
			還可以建立<span>FULLTEXT</span>索引。該索引可以用於全文搜索。只有<span>MyISAM</span>儲存引擎支援<span>FULLTEXT</span>索引，並且只為<span>CHAR</span>、<span>VARCHAR</span>和<span>TEXT</span>列。索引總是對整個列進行，不支援局部<span>(</span>前綴<span>)</span>索引。詳情參見<a href="functions.html#fulltext-search" title="12.7. Full-Text Search Functions">12.7節，「全文搜索功能」</a>。</p>
			<p>
			也可以為空間列類型建立索引。只有<span>MyISAM</span>儲存引擎支援空間類型。空間索引使用<span>R-</span>樹。</p>
			<p>預設情況<span >MEMORY</span><span>(</span><span >HEAP</span><span>)</span>儲存引擎使用<span>hash</span>索引，但也支援<span>B-</span>樹索引。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="multiple-column-indexes"></a>
			7.4.4.&nbsp;多列索引</h3></div></div></div><a class="indexterm" name="id2811319"></a><a class="indexterm" name="id2811326"></a><a class="indexterm" name="id2811336"></a>
			<p>
			<span>MySQL</span>可以為多個列建立索引。一個索引可以包括<span>15</span>個列。對於某些列類型，可以索引列的前綴<span>(</span>參見<a href="optimization.html#indexes" title="7.4.3. Column Indexes">7.4.3節，「列索引」</a><span>)</span>。</p>
			<p>
			多列索引可以視為包含通過連接索引列的值而建立的值的排序的數組。</p>
			<p>
			<span>MySQL</span>按這樣的方式使用多列索引：當您在<span>WHERE</span>子句中為索引的第<span>1</span>個列指定已知的數量時，查詢很快，即使您沒有指定其它列的值。</p>
			<p>
			假定資料表具有下面的結構：</p>
			<pre><span>CREATE TABLE test (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; last_name CHAR(30) NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; first_name CHAR(30) NOT NULL,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PRIMARY KEY (id),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; INDEX name (last_name,first_name)</span></pre>
			<pre><span>);</span></pre>
			<p>
			<span >name</span>索引是一個對<span>last_name</span>和<span >first_name</span>的索引。索引可以用於為<span>last_name</span>，或者為<span>last_name</span>和<span>first_name</span>在已知範圍內指定值的查詢。因此，<span >name</span>索引用於下面的查詢：</p>
			<pre><span>SELECT * FROM test WHERE last_name=&#39;Widenius&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39; AND first_name=&#39;Michael&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND (first_name=&#39;Michael&#39; OR first_name=&#39;Monty&#39;);</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; AND first_name &gt;=&#39;M&#39; AND first_name &lt; &#39;N&#39;;</span></pre>
			<p>
			然而，<span >name</span>索引<em><span>不</span></em>用於下面的查詢：</p>
			<pre><span>SELECT * FROM test WHERE first_name=&#39;Michael&#39;;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM test</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; WHERE last_name=&#39;Widenius&#39; OR first_name=&#39;Michael&#39;;</span></pre>
			<p><span>MySQL</span>使用索引提高查詢性能的方式將在<a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">7.4.5節，「MySQL如何使用索引」</a>中討論。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-indexes"></a>
			7.4.5.&nbsp;MySQL如何使用索引</h3></div></div></div><a class="indexterm" name="id2811470"></a>
			<p>
			索引用於快速找出在某個列中有一特定值的行。不使用索引，<span>MySQL</span>必須從第<span>1</span>條記錄開始然後讀完整個資料表直到找出相關的行。資料表越大，花費的時間越多。如果資料表中查詢的列有一個索引，<span>MySQL</span>能快速到達一個位置去搜尋到數據檔案的中間，沒有必要看所有數據。如果一個資料表有<span>1000</span>行，這比順序讀取至少快<span>100</span>倍。注意如果您需要訪問大部分行，順序讀取要快得多，因為此時我們避免磁盤搜索。</p>
			<p>
			大多數<span>MySQL</span>索引<span>(</span><span >PRIMARY 
			KEY</span>、<span><span>UNIQUE</span>、<span>INDEX</span></span>和<span >FULLTEXT</span><span>)</span>在<span>B</span>樹中儲存。只是空間列類型的索引使用<span>R-</span>樹，並且<span >MEMORY</span>資料表還支援<span>hash</span>索引。</p>
			<p>
			字串自動地壓縮前綴和結尾空格。參見<a href="sql-syntax.html#create-index" title="13.1.4. CREATE INDEX Syntax">13.1.4節，「CREATE 
		INDEX語法」</a>。</p>
			<p>
			總的來說，按後面的討論使用索引。本節最後描述<span>hash</span>索引<span>(</span>用於<span >MEMORY</span>資料表<span>)</span>的特徵。</p>
			<p>
			索引用於下面的操作：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>快速找出匹配一個<span>WHERE</span>子句的行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>刪除行。如果可以在多個索引中進行選擇，<span>MySQL</span>通常使用找到最少行的索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當執行聯接時，從其它資料表檢索行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對具體有索引的列<span><i><span>key_col</span></i></span>找出<span>MAX()</span>或<span>MIN()</span>值。由預處理器進行最佳化，檢查是否對索引中在<span>key_</span><span><i><span>col</span></i></span>之前發生所有關鍵字元素使用了<span >WHERE
			<i>key_part_#</i> = <i>constant</i></span>。在這種情況下，<span>MySQL</span>為每個<span>MIN()</span>或<span>MAX()</span>資料表達式執行一次關鍵字搜尋，並用常數替換它。如果所有資料表達式替換為常量，查詢立即返回。例如：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT MIN(</span><span><i><span>key_part2</span></i></span><span>),MAX(</span><span><i><span>key_part2</span></i></span><span>)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_part1</span></i></span><span>=10;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果對一個可用關鍵字的最左面的前綴進行了排序或分組<span>(</span>例如，<span>ORDER 
			BY key_part_1,key_part_2</span><span>)</span>，排序或分組一個資料表。如果所有關鍵字元素後面有<span>DESC</span>，關鍵字以倒序被讀取。參見<a href="optimization.html#order-by-optimization" title="7.2.12. How MySQL Optimizes ORDER BY">7.2.12節，「MySQL如何最佳化ORDER BY<code class="literal"></code>」</a>。</p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一些情況中，可以對一個查詢進行最佳化以便不用查詢數據行即可以檢索值。<span>如果查詢只使用來自某個資料表的數字型並且構成某些關鍵字的最左面前綴的列，為了更快，可以從索引樹檢索出值。</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT </span><span><i><span>key_part3</span></i></span><span> FROM </span><span><i><span>tbl_name</span></i></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;WHERE </span><span><i><span>key_part1</span></i></span><span>=1</span></pre>
			<p>
			假定您執行下面的<span>SELECT</span>語句：</p>
			<pre><span>mysql&gt; </span><span><b><span>SELECT * FROM <i>tbl_name</i> WHERE col1=val1 AND col2=val2;</span></b></span></pre>
			<p>
			如果<span>col1</span>和<span>col2</span>上存在一個多列索引，可以直接取出相應行。如果<span>col1</span>和<span>col2</span>上存在單列索引，最佳化器試圖通過決定哪個索引將找到更少的行來找出更具限制性的索引並且使用該索引取行。</p>
			<p>
			如果資料表有一個多列索引，最佳化器可以使用最左面的索引前綴來找出行。例如，如果有一個<span>3</span>列索引<span>(col1,col2,col3)</span>，則已經對<span>(col1)</span>、<span>(col1,col2)</span>和<span>(col1,col2,col3)</span>上的搜索進行了索引。</p>
			<p>
			如果列不構成索引最左面的前綴，<strong><span>MySQL</span></strong>不能使用局部索引。假定有下面顯示的<span>SELECT</span>語句。</p>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col1=val1;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col1=val1 AND col2=val2;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col2=val2;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE col2=val2 AND col3=val3;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			如果<span><span> 
			(col1</span><span>，<span>col2</span>，<span>col3)</span></span></span>有一個索引，只有前<span>2</span>個查詢使用索引。第<span>3</span>個和第<span>4</span>個查詢確實包括索引的列，但<span>(col2)</span>和<span><span>(col2</span><span>，<span>col3)</span></span></span>不是 
			<span>
			<span>(col1</span><span>，<span>col2</span>，<span>col3)</span></span></span>的最左邊的前綴。</p>
			<p>
			也可以在資料表達式通過<span><span>=</span><span>、<span>&gt;</span>、<span>&gt;=</span>、<span>&lt;</span>、<span>&lt;=</span></span></span>或者<span>BETWEEN</span>操作符使用<span>B-</span>樹索引進行列比較。如果<span>LIKE</span>的參數是一個不以通配符開頭的常量字串，索引也可以用於<span>LIKE</span>比較。例如，下面的<span>SELECT</span>語句使用索引：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;Patrick%&#39;;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;Pat%_ck%&#39;;</span></pre>
			<p>
			在第<span>1</span>個語句中，只考慮帶<span>&#39;Patrick&#39; 
			&lt;=key_<i>col</i> &lt; &#39;Patricl&#39;</span>的行。在第<span>2</span>個語句中，只考慮帶<span>&#39;Pat&#39; 
			&lt;=key_<i>col</i> &lt; &#39;Pau&#39;</span>的行。</p>
			<p>
			下面的<span>SELECT</span>語句不使用索引：</p>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE &#39;%Patrick%&#39;;</span></pre>
			<pre><span>SELECT * FROM </span><span><i><span>tbl_name</span></i></span><span> WHERE </span><span><i><span>key_col</span></i></span><span> LIKE </span><span><i><span>other_col</span></i></span><span>;</span></pre>
			<p>
			在第一條語句中，<span>LIKE</span>值以一個通配符字元開始。在第二條語句中，<span>LIKE</span>值不是一個常數。</p>
			<p>
			如果使用<span >... LIKE &#39;%<i>string</i>%&#39;</span>並且<span><i><span>string</span></i></span>超過<span>3</span>個字元，<span>MySQL</span>使用<em><span>Turbo 
			Boyer-Moore</span><span>算法</span></em>初始化字串的模式然後使用該模式來更快地進行搜索。</p>
			<p>
			如果<span><i><span>col_name</span></i></span>被索引，使用<span><i><span>col_name</span></i><span> 
			IS NULL</span></span>的搜索將使用索引。</p>
			<p>
			任何不跨越<span>WHERE</span>子句中的所有<span >AND</span>級的索引不用於最佳化查詢。換句話說，為了能夠使用索引，必須在每個<span >AND</span>組中使用索引前綴。</p>
			<p>
			下面的<span>WHERE</span>子句使用索引：</p>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=1 AND </span><span><i><span>index_part2</span></i></span><span>=2 AND </span><span><i><span>other_column</span></i></span><span>=3</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* </span><span><i><span>index</span></i></span><span> = 1 OR </span><span><i><span>index</span></i></span><span> = 2 */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index</span></i></span><span>=1 OR A=10 AND </span><span><i><span>index</span></i></span><span>=2</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* optimized like &quot;</span><span><i><span>index_part1</span></i></span><span>=&#39;hello&#39;&quot; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=&#39;hello&#39; AND </span><span><i><span>index_part3</span></i></span><span>=5</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* Can use index on </span><span><i><span>index1</span></i></span><span> but not on </span><span><i><span>index2</span></i></span><span> or </span><span><i><span>index3</span></i></span><span> */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index1</span></i></span><span>=1 AND </span><span><i><span>index2</span></i></span><span>=2 OR </span><span><i><span>index1</span></i></span><span>=3 AND </span><span><i><span>index3</span></i></span><span>=3;</span></pre>
			<p>
			下面的<span>WHERE</span>子句不使用索引：</p>
			<pre><span>&nbsp;&nbsp;&nbsp; /* </span><span><i><span>index_part1</span></i></span><span> is not used */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part2</span></i></span><span>=1 AND </span><span><i><span>index_part3</span></i></span><span>=2</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /*&nbsp; Index is not used in both parts of the WHERE clause&nbsp; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index</span></i></span><span>=1 OR A=10</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; /* No index spans all rows&nbsp; */</span></pre>
			<pre><span>... WHERE </span><span><i><span>index_part1</span></i></span><span>=1 OR </span><span><i><span>index_part2</span></i></span><span>=10</span></pre>
			<p>
			有時<span>MySQL</span>不使用索引，即使有可用的索引。一種情形是當最佳化器估計到使用索引將需要<span>MySQL</span>訪問資料表中的大部分行時。<span>(</span>在這種情況下，資料表掃瞄可能會更快些，因為需要的搜索要少）<span>。</span>然而，如果此類查詢使用<span>LIMIT</span>只搜索部分行，<span>MySQL</span>則使用索引，因為它可以更快地找到幾行並在結果中返回。</p>
			<p>
			<span>Hash</span>索引還有一些其它特徵：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>它們只用於使用<span>=</span>或<span>&lt;=&gt;</span>操作符的等式比較<span>(</span>但<em><span>很快</span></em><span>)</span>。它們用於比較
			操作符，例如發現範圍值的<span>&lt;</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>最佳化器不能使用<span>hash</span>索引來加速<span>ORDER 
			BY</span>操作。<span>(</span>該類索引不能用來按順序搜索下一個條目）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MySQL</span>不能確定在兩個值之間大約有多少行<span>(</span>這被範圍最佳化器用來確定使用哪個索引<span>)</span>。如果您將一個<span>MyISAM</span>資料表改為<span>hash-</span>索引的<span >MEMORY</span>資料表，會影響一些查詢。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只能使用整個關鍵字來搜索一行。<span>(</span>用<span>B-</span>樹索引，任何關鍵字的最左面的前綴可用來找到行）<span>。</span></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-key-cache"></a>
			7.4.6.&nbsp;MyISAM鍵高速緩衝</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#shared-key-cache">
				7.4.6.1. 共享鍵高速緩衝訪問</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">
				7.4.6.2. 多鍵高速緩衝</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">
				7.4.6.3. 中點插入策略</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">
				7.4.6.4. 索引預加載</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">
				7.4.6.5. 鍵高速緩衝塊大小</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">
				7.4.6.6. 重構鍵高速緩衝</a></span></dt></dl></div><a class="indexterm" name="id2812335"></a><a class="indexterm" name="id2812342"></a>
			<p>
			為了使硬盤<span>I/O</span>最小化，<span>MyISAM</span>儲存引擎使用一個被許多資料庫管理系統使用的策略。它使用一個緩存機制將經常訪問的資料表鎖在內存中：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於索引塊，維護一個稱之為<i>鍵高速<em><span>緩衝</span></em></i><span>(</span>或<em><span>鍵高速緩衝區</span></em><span>)</span>的特殊結構。該結構包含大量塊緩存區，其中放置了最常用的索引塊。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於數據塊，<span>MySQL</span>不使用特殊緩存。而使用原生的作業系統檔案系統的緩存。</p>
			<p>
			本節首先描述了<span>MyISAM</span>鍵高速緩衝的基本操作。然後討論了提高
			鍵高速緩衝性能並使您更好地控制緩存操作的最新的更改：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>多個線程可以並行訪問緩存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>可以設置多個鍵高速緩衝，並將資料表索引指定給具體緩存。</p>
			<p>
			可以使用<span>key_</span><span>buffer_size</span>系統變數控制
			鍵高速緩衝的大小。如果該變數設置為零，不使用鍵高速緩衝。如果<span>key_buffer_size</span>值太小不能分配最小數量的塊緩存區<span>(8)</span>，也不使用
			鍵高速緩衝。</p>
			<p>
			如果鍵高速緩衝不工作，只使用作業系統提供的原生檔案系統緩存區訪問索引檔案。<span>(</span>換句話說，使用與資料表數據塊相同的策略資料表來訪問索引塊）<span>。
			</span></p>
			<p>
			索引塊是一個連續的訪問<span>MyISAM</span>索引檔案的單位。通常一個索引塊的大小等於索引<span>B-</span>樹節點的大小。<span>(</span>在硬盤上使用<span>B-</span>樹數據結構資料表示索引。樹底部的節點為葉子節點。葉子節點上面的節點為非葉子節點）<span>。</span></p>
			<p>
			鍵高速緩衝結構中的所有塊緩存區大小相同。該大小可以等於、大於或小於資料表索引塊的大小。通常這兩個值中的一個是另一個的幾倍。</p>
			<p>
			當必須訪問資料表索引塊中的數據時，伺服器首先檢查是否它可以用於鍵高速緩衝中的某些塊緩存區。如果適用，伺服器訪問鍵高速緩衝中的數據而不是硬盤上的數據。也就是說，從緩存讀取或寫入緩存，而不是從硬盤讀寫。否則，伺服器選擇一個包含一個不同的資料表索引塊的緩存塊緩存區，並用需要的資料表索引塊的拷貝替換那裡的數據。一旦新的索引塊位於緩存中，可以訪問索引數據。</p>
			<p>
			如果用於替換的塊已經被修改了，塊被視為「髒了」。在這種情況下，在替換前，其內容被刷新到它來自的資料表索引。</p>
			<p>通常伺服器遵從<em><span>LRU(</span><span>最近最少使用</span><span>)</span></em>策略：當選擇一個塊用於替換時，它選擇最近最少使用的索引塊。為了使該選擇更容易，
			鍵高速緩衝模塊維護所有使用的塊的專門隊列<span>(<em><span>LRU</span></em></span><em><span>鏈</span></em><span>)</span>。當訪問塊時，它被放到隊列最後。當塊需要替換時，隊列開頭的塊是最近最少使用的塊，並成為第<span>1</span>個候選者。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="shared-key-cache"></a>
				7.4.6.1.&nbsp;共享鍵高速緩衝訪問</h4></div></div></div>
				<p>
				在以下條件下，線程可以同時訪問鍵高速緩衝緩存區：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>沒有被更新的緩存區可以被多個線程訪問。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>正被更新的緩存區讓需要使用它的線程等待直到更新完成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>多個線程可以發起請求替換緩存塊，只要它們不彼此干擾<span>(</span>也就是說，只要它們需要不同的索引塊，並且使不同的緩存塊被替換<span>)</span>。</p>
				<p>
				對鍵高速緩衝的共享訪問允許伺服器大大提高吞吐量。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="multiple-key-caches"></a>
							7.4.6.2.&nbsp;多鍵高速緩衝</h4></div></div></div>
				<p>
				對鍵高速緩衝的共享訪問可以提高性能但不能完全消除線程之間的竟爭。它們仍然競爭對鍵高速緩衝緩存區的訪問進行管理的控制結構。為了進一步降低
				鍵高速緩衝訪問竟爭，<span>MySQL 
				5.1</span>還提供了多個鍵高速緩衝，允許您為不同的鍵高速緩衝分配不同的資料表索引。</p>
				<p>
				有多個鍵高速緩衝時，當為給定的<span>MyISAM</span>資料表處理查詢時，伺服器必須知道使用哪個緩存。預設情況，所有<span>MyISAM</span>資料表索引被緩存到預設
				鍵高速緩衝中。要想為具體鍵高速緩衝分配資料表索引，應使用<span>CACHE 
				INDEX</span>語句<span>(</span>參見<a href="sql-syntax.html#cache-index" title="13.5.5.1. CACHE INDEX Syntax">13.5.5.1節，「CACHE 
			INDEX語法」</a><span>)</span>。</p>
				<p>
				例如，下面的語句將資料表<span>t1</span>、<span>t2</span>和<span>t3</span>的索引分配給名為<span >hot_cache</span>的
				鍵高速緩衝：</p>
				<pre><span>mysql&gt; </span><span><b><span>CACHE INDEX t1, t2, t3 IN hot_cache;</span></b></span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t3 | assign_to_keycache | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------------+----------+----------+</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				可以用<span>SET 
				GLOBAL</span>參數設置語句或使用伺服器啟動選項設置在<span>CACHE 
				INDEX</span>語句中引用的鍵高速緩衝的大小來建立鍵高速緩衝。例如：</p>
				<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL keycache1.key_buffer_size=128*1024;</span></b></span></pre>
				<p>
				要想刪除鍵高速緩衝，將其大小設置為零：</p>
				<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL keycache1.key_buffer_size=0;</span></b></span></pre>
				<p>
				請注意不能刪除預設鍵高速緩衝。刪除預設鍵高速緩衝的嘗試將被忽略：</p>
				<pre><span>mysql&gt; </span><span><b><span>set global key_buffer_size = 0;</span></b></span></pre>
				<pre><span>&nbsp;</span></pre>
				<pre><span>mysql&gt; </span><span><b><span>show variables like &#39;key_buffer_size&#39;;</span></b></span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>| Variable_name&nbsp;&nbsp; | Value&nbsp;&nbsp; |</span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>| key_buffer_size | 8384512 |</span></pre>
				<pre><span>+-----------------+---------+</span></pre>
				<pre><span>&nbsp;</span></pre>
				<p>
				鍵高速緩衝變數是結構式系統變數，有一個名和組件。對於<span >keycache1.key_buffer_size</span>，<span >keycache1</span>是緩存變數名，<span>key_buffer_size</span>是緩存組件。關於引用結構式
				鍵高速緩衝系統變數所使用的語法的描述，參見<a href="language-structure.html#structured-system-variables" title="9.4.1. Structured System Variables">9.4.1節，「結構式系統變數」</a></p>
				<p>
				預設情況下，資料表索引被分配給伺服器啟動時建立的主要<span>(</span>預設<span>)</span>鍵高速緩衝。當
				鍵高速緩衝被刪除後，所有分配給它的索引被重新分配給預設鍵高速緩衝。</p>
				<p>
				對於一個忙的伺服器，我們建議採用使用三個鍵高速緩衝的策略：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>佔用為所有鍵高速緩衝分配的空間的<span>20%</span>的「熱」鍵高速緩衝。該緩存用於頻繁用於搜索但沒有更新的資料表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>佔用為所有鍵高速緩衝分配的空間的<span>20%</span>的「冷」鍵高速緩衝。該緩存用於中等大小、大量修改的資料表，例如臨時資料表。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>佔用鍵高速緩衝空間的<span>20%</span>的「溫」鍵高速緩衝。使用它作為預設
				鍵高速緩衝，預設情況被所有其它資料表使用。</p>
				<p>
				使用<span>3</span>個鍵高速緩衝有好處的一個原因是對一個鍵高速緩衝結構的訪問不會阻擋對其它的訪問。訪問分配給一個緩存的資料表的查詢不會與訪問分配給其它緩存的資料表的查詢競爭。由於其它原因也會提高性能：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				熱緩存只用於檢索查詢，因此其內容決不會被修改。結果是，無論何時需要從硬盤上拉入索引塊，選擇用於替換的緩存塊的內容不需要先刷新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>對於分配給熱緩存的索引，如果沒有查詢需要索引掃瞄，很有可能對應索引<span>B-</span>樹的非葉子節點的索引塊仍然在緩存中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				當更新的節點位於緩存中並且不需要先從硬盤讀入時，為臨時資料表頻繁執行的更新操作會執行得更快。如果臨時資料表的索引的大小可以與冷鍵高速緩衝相比較，很可能更新的節點位於緩存中。</p>
				<p>
				<span>CACHE INDEX</span>在一個資料表和
				鍵高速緩衝之間建立一種聯繫，但每次伺服器重啟時該聯繫被丟失。如果您想要每次伺服器重啟時該聯繫生效，一個發辦法是使用選項檔案：包括配置
				鍵高速緩衝的變數設定值，和一個<span >init-file</span>選項用來命名包含待執行的<span>CACHE 
				INDEX</span>語句的一個檔案。例如：</p>
				<pre><span>key_buffer_size = 4G</span></pre>
				<pre><span>hot_cache.key_buffer_size = 2G</span></pre>
				<pre><span>cold_cache.key_buffer_size = 2G</span></pre>
				<pre><span>init_file=/path/to/data-directory/mysqld_init.sql</span></pre>
				<p>
				每次伺服器啟動時執行<span >mysqld_init.sql</span>中的語句。該檔案每行應包含一個<span>SQL</span>語句。下面的例子分配幾個資料表，分別對應<span >hot_cache</span>和<span >cold_cache</span>：</p>
				<pre><span>CACHE INDEX a.t1, a.t2, b.t3 IN hot_cache</span></pre>
				<pre><span>CACHE INDEX a.t4, b.t5, b.t6 IN cold_cache</span></pre>
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="midpoint-insertion"></a>
				7.4.6.3.&nbsp;中點插入策略</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				預設情況，鍵高速緩衝管理系統採用<span>LRU</span>策略選擇要收回的鍵高速緩衝塊，但它也支援更複雜的方法，稱之為「<span class="quote">中點插入策略</span>」。</p>
				<p>
				當使用中點插入策略時，<span>LRU</span>鏈被分為兩個部分：一條熱子鏈和一條溫子鏈。兩部分之間的劃分點不固定，但
				鍵高速緩衝管理系統關注溫部分不「<span class="quote">太短</span>」，總是包含至少<span >key_cache_division_limit</span>比例的
				鍵高速緩衝塊。<span>key_cache_division_limit</span>是結構式
				鍵高速緩衝變數的一個組件，因此其值是一個可以根據每個緩存進行設置的參數。</p>
				<p>
				當一個索引塊從資料表中讀入鍵高速緩衝，它被放入溫子鏈的末端。經過一定量的訪問後<span>(</span>訪問塊<span>)</span>，它被提升給熱子鏈。目前，需要用來提升一個塊<span>(3)</span>的訪問次數與所有索引塊的相同。</p>
				<p>
				提升到熱子鏈的塊被放到子鏈的末端。塊然後在該子鏈中循環。如果塊在子鏈的開頭停留足夠長的時間，它被降到溫鏈。該時間由鍵高速緩衝<span>key_cache</span><span>_age_threshold</span>組件的值確定。</p>
				<p>
				對於包含<span><i><span>N</span></i></span>個塊的
				鍵高速緩衝，閾值資料表示，熱子鏈開頭的沒有在最後<span><i><span>N</span></i><span> 
				*key_cache_age_threshold/100</span></span>次訪問中被訪問的塊將被移動到溫子鏈開頭。該塊然後變為第<span>1</span>個擠出的候選者，因為替換的塊總是來自溫子鏈的開頭。</p>
				<p>
				中點插入策略允許您將更有價值的塊總是在緩存中。如果您想使用簡單的<span>LRU</span>策略，使<span>key_cache_division_limit</span>值保持其預設值<span>100</span>。</p>
				<p>
				若執行的查詢要求索引掃瞄有效推出所有索引塊對應有數值的高級<span>B-</span>樹節點的緩存，中點插入策略可以幫助提高性能。要想避免，必須使用中點插入策略，而<span>key_cache_division_limit</span>設置為遠小於<span>100</span>。然後在索引掃瞄操作過程中，有數值的經常訪問的節點被保留在熱子鏈中。</p>
				<h4 class="title"><a name="index-preloading"></a>7.4.6.4.&nbsp;索引預加載</h4></div></div></div>
				<p>
				如果鍵高速緩衝內有足夠的塊以容納整個索引的塊，或者至少容納對應其非葉節點的塊，則在使用前，預裝含索引塊的鍵高速緩衝很有意義。預裝可以以更有效的方式將資料表索引塊放入
				鍵高速緩衝緩存區中：通過順序地從硬盤讀取索引塊。</p>
				<p>
				不進行預裝，塊仍然根據查詢需要放入鍵高速緩衝中。儘管塊將仍然在緩存中（因為有足夠的緩存區保存它們），它們以隨機方式從硬盤上索取，而不是以順序方式。</p>
				<p>
				要想將索引預裝到緩存中，使用<span >LOAD 
				INDEX INTO CACHE</span>語句。例如，下面的語句可以預裝資料表<span>t1</span>和<span>t2</span>索引的節點<span>(</span>索引塊<span>)</span>：</p>
				<pre><span>mysql&gt; </span><span><b><span>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</span></b></span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| Table&nbsp;&nbsp; | Op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Msg_type | Msg_text |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<pre><span>| test.t1 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>| test.t2 | preload_keys | status&nbsp;&nbsp; | OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+---------+--------------+----------+----------+</span></pre>
				<p>
				<span >IGNORE LEAVES</span>修改器只允許預裝索引非葉節點所用的塊。這樣，上述的語句預裝<span>t1</span>中的所有索引塊，但只預裝<span>t2</span>中的非葉節點對應的塊。</p>
				<p>如果已經使用<span>CACHE 
				INDEX</span>語句為一個索引分配了一個鍵高速緩衝，預裝可以將索引塊放入該緩存。否則，索引被裝入預設鍵高速緩衝。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-block-size"></a>
				7.4.6.5.&nbsp;鍵高速緩衝塊大小</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<p>
				可以使用<span>key_cache_block_size</span>變數為具體的
				鍵高速緩衝指定塊緩存區的大小。這樣允許為索引檔案調節<span>I/O</span>操作的性能。</p>
				<p>
				當讀緩存區的大小等於原生作業系統<span>I/O</span>緩存區的大小時，可以獲得<span>I/O</span>操作的最佳性能。但是將關鍵字節點的大小設置為等於<span>I/O</span>緩存區的大小並不總是能保證最佳整體性能。當讀取大的葉節點時，伺服器讀入大量的不需要的數據，結果防止讀入其它葉子的節點。</p>
				<p>
				目前，您不能控制資料表內索引塊的大小。該大小由伺服器在建立<span>.MYI</span>索引檔案時設置，取決於資料表定義中索引的關鍵字大小。在大多數情況下，它被設置為與<span>I/O</span>緩存區大小相等。</p>
				<h4 class="title"><a name="key-cache-restructuring"></a>
				7.4.6.6.&nbsp;重構鍵高速緩衝</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			<p>
			鍵高速緩衝可以通過更新其參數值隨時重新構建。例如：</p>
			<pre><span>mysql&gt; </span><span><b><span>SET GLOBAL cold_cache</span><span>。<span>key_buffer_size=4*1024*1024</span>；</span></b></span></pre>
			<p>
			如果您為<span>key_</span><span>buffer_size</span>或<span>key_cache_block_size</span>鍵高速緩衝組件分配的值與組件當前的值不同，伺服器將毀掉緩存的舊結構並根據新值建立一個新的。如果緩存包含任何髒的塊，伺服器在銷毀前將它們保存到硬盤上並重新建立緩存。如果您設置其它
			鍵高速緩衝參數，則不會發生重新構建。</p>
			<p>
			當重新構建鍵高速緩衝時，伺服器首先將任何髒緩存區的內容刷新到硬盤上。之後，緩存內容不再需要。然而，重新構建並不阻塞需要使用分配給緩存的索引的查詢。相反，伺服器使用原生檔案系統緩存直接訪問資料表索引。檔案系統緩存不如使用
			鍵高速緩衝有效，因此儘管查詢可以執行，但速度會減慢。緩存被重新構建後，它又可以緩存分配給它的索引了，並且索引不再使用檔案系統緩存。</p>
			<h3 class="title"><a name="myisam-index-statistics"></a>7.4.7. MyISAM索引統計集合</h3></div></div></div>
			<p>
			儲存引擎搜集最佳化器使用的資料表的統計訊息。資料表統計基於數數值組，其中數數值組是一系列有相同的關鍵字前綴值的記錄。對於最佳化器，重要的統計即為數數值組的平均大小。</p>
			<p>
			<span>MySQL</span>用下述方式使用平均數數值組：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>估計必須為每個<span>ref</span>訪問讀取多少行</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>估計部分聯接將產生多少行；也就是說，下述形式的操作將產生的行數：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp; </span><span>(...) JOIN </span><span><i><span>tbl_name</span></i></span><span> ON </span><span><i><span>tbl_name</span></i></span><span>.</span><span><i><span>key</span></i></span><span> = </span><span><i><span>expr</span></i></span></pre>
			<p>
			隨著索引的平均數數值組大小的增加，索引將更沒有用，因為每個搜尋的平均行數增加：為了讓索引有利於最佳化目的，最好是每個索引值對應資料表內的少量行數。當某個給定的索引值產生較多行時，索引更加沒有用，<span>MySQL</span>更不可能使用它。</p>
			<p>
			平均數數值組大小與資料表的集的勢相關，即數數值組的數目。<span>SHOW 
			INDEX</span>語句顯示集的勢值（基於<span><i><span>N</span></i></span><span>/</span><span><i><span>S</span></i></span>），其中<span><i><span>N</span></i></span>是資料表內的記錄數，<span><i><span>S</span></i></span>是平均數數值組大小。該比例產生資料表內數數值組的大約數。</p>
			<p>
			對於基於<span>&lt;=&gt;</span>比較
			操作符的聯接，<span>NULL</span>並不視為與任何其它值不同：<span>NULL 
			&lt;=&gt; NULL</span>，正如對於其它<span><i><span>N</span></i></span><span>
			</span>，<span><i><span>N</span></i><span> 
			&lt;=&gt; <i>N</i></span></span>。</p>
			<p>
			然而，對於基於<span>=</span>操作符的聯接，<span>NULL</span>與非<span>NULL</span>值不同：當<span><i><span>expr1</span></i></span>或<span><i><span>expr2</span></i></span><span>(</span>或兩者<span>)</span>為<span>NULL</span>時，<span><i><span>expr1</span></i><span> 
			= <i>expr2</i></span></span>不為真。這樣影響比較形式<span><i><span>tbl_name.key</span></i><span> 
			= <i>expr</i></span></span>的<span>ref</span>訪問：如果<span><i><span>expr</span></i></span>當前的值為<span>NULL</span>，<span>MySQL</span>不會訪問資料表，因為比較不能為真。</p>
			<p>
			<span>對於<span>=</span></span>比較，資料表內有多少<span>NULL</span>值並不重要。為了最佳化目的，相關值為非<span>NULL</span>數值組的平均大小。然而，<span>MySQL</span>目前不允許搜集或使用該平均大小。</p>
			<p>
			<span>對於<span>MyISAM</span>資料表，您可以使用</span><span  >myisam_stats_method</span><span>系統變數部分控制資料表統計訊息的搜集。該變數有兩個可能的不同值，如下所示：</span></p>
			<p>
			<span  >
			·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>當</span><span  >myisam_stats_method</span><span>為</span><span  >nulls_equal</span><span>時，所有</span><span  >NULL</span><span>值被視為相等的<span>(</span>也就是說，它們都形成一個數值組<span>)</span>。</span></p>
			<p>
			<span>如果</span><span  >NULL</span><span>數值組大小遠大於平均非</span><span  >NULL</span><span>數值組大小，該方法向上傾斜平均數數值組大小。這樣使索引對於最佳化器來說比它實際為搜尋非</span><span  >NULL</span><span>值的聯接更加沒有用。結果是，</span><span  >nulls_equal</span><span>方法會使最佳化器進行</span><span  >ref</span><span>訪問時本應使用索引而沒有使用。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當<span>myisam_stats_method</span>為<span>nulls_unequal</span>時，<span>NULL</span>值不視為相同。相反，每個<span>NULL</span>值形成一個單獨的數值組，大小為<span>1</span>。</p>
			<p>
			如果您有許多<span>NULL</span>值，該方法向下傾斜平均數數值組大小。如果平均非<span>NULL</span>數值組較大，統計大小為<span>1</span>的每個組的<span>NULL</span>值會使最佳化器過高估計搜尋非<span>NULL</span>值的聯接的索引值。結果是，當其它方法會更好時，<span>nulls_unequal</span>方法會使最佳化器為<span>ref</span>搜尋使用該索引。</p>
			<p>
			如果您要使用許多使用<span>&lt;=&gt;</span>而不是<span>=</span>的聯接，在比較過程中<span>NULL</span>值並不特殊，一個<span>NULL</span>等於另一個<span>NULL</span>。在這種情況下，<span>nulls_equal</span>是合適的統計方法。</p>
			<p>
			<span>myisam_stats_method</span>系統變數有全局和會話值。設置全局值會影響<span>MyISAM</span><span>
			</span>為所有<span>MyISAM</span>資料表的統計的搜集。設置會話值只影響當前客戶連接的統計的搜集。這說明您可以強制用給定的方法重新生成資料表的統計的搜集，而不需要因為設置<span>myisam_stats_method</span>的會話值而影響其它客戶。</p>
			<p>
			可以使用下面任一方法來重新生成資料表的統計訊息：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>設置<span>myisam_stats_method</span>，然後執行<span>CHECK 
			TABLE</span>語句</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>執行<strong><span>myisamchk 
			--stats_method=method_name --analyze</span></strong></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>更改資料表，使其統計訊息不為最新<span>(</span>例如，插入一行然後刪除它<span>)</span>，然後設置<span>myisam_stats_method</span>並執行<span>ANALYZE 
			TABLE</span>語句</p>
			<p>
			使用<span>myisam_stats_method</span>的一些警告：</p>
			<p>
			您可以強制顯式搜集資料表的統計訊息，如上所述。然而，<span>MySQL</span>也可以自動搜集統計訊息。例如，如果在為資料表執行語句的過程中，一些語句修改了資料表，<span>MySQL</span>可以搜集統計訊息。<span>(</span>例如，大批插入或刪除，或者執行<span>ALTER 
			TABLE</span>語句時可能發生）<span>。</span>如果發生，使用<span>myisam_stats_method</span>此時所有的值搜集統計訊息。這樣，如果您使用一個方法搜集統計訊息，但當後面自動搜集一個資料表的統計訊息時<span>myisam_stats_method</span>被設置為另一個方法，將使用其它方法。</p>
			<p>
			對於給定的<span>MyISAM</span>資料表，還不能說出使用哪個方法來產生統計訊息。</p>
			<p>
			<span>myisam_stats_method</span>只適合<span>MyISAM</span>資料表。其它儲存引擎只有一個方法來搜集資料表的統計訊息。通常它接近於<span>nulls_equal</span>方法。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="open-tables"></a>
			7.4.8.&nbsp;MySQL如何計算打開的資料表</h3></div></div></div><a class="indexterm" name="id2813747"></a><a class="indexterm" name="id2813757"></a>
			<p>
			當運行<strong><span>mysqladmin status</span></strong>時，將看見像這樣的一些東西：</p>
			<pre><span>Uptime: 426 Running threads: 1 Questions: 11082</span></pre>
			<pre><span>Reloads: 1 Open tables: 12</span></pre>
			<pre><span>&nbsp;</span></pre>
			<p>
			如果您僅有<span>6</span>個資料表，<span >Open 
			tables</span>值為<span>12</span>可能有點令人困惑。</p>
			<p>
			<strong>
			<span>
			MySQL</span></strong>是多線程的，因此許多客戶可以同時在同一個資料表上進行查詢。為了使多個客戶線程在同一個資料表上有不同狀態的問題減到最小，資料表被每個並發程序獨立地打開。這樣需要額外的內存但一般會提高性能。對於<span>MyISAM</span>資料表，數據檔案需要為每個打開資料表的客戶提供一個額外的檔案描述符。<span>(</span>索引檔案描述符在所有線程之間共享<span>)</span>。</p>
			<p>
			下一節中提供了該主題的更多的訊息。參見<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9節，「MySQL如何打開和關閉資料表」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-cache"></a>
			7.4.9.&nbsp;MySQL如何打開和關閉資料表</h3></div></div></div><a class="indexterm" name="id2813823"></a><a class="indexterm" name="id2813832"></a><a class="indexterm" name="id2813842"></a><a class="indexterm" name="id2813853"></a><a class="indexterm" name="id2813863"></a><a class="indexterm" name="id2813873"></a>
			<p>
			<span>table_cache</span>、<span>max_connections</span>和<span>max_tmp_tables</span>系統變數影響伺服器保持打開的檔案的最大數量。如果您增加這些值其中的一個或兩個，會遇到作業系統為每個程序打開檔案描述符的數量強加的限制。許多作業系統允許您增加打開的檔案的限制，儘管該方法隨系統的不同而不同。查閱作業系統文檔以確定是否可以增加限制以及如何操作。</p>
			<p>
			<span>table_cache</span>與<span>max_connections</span>有關。例如，對於<span>200</span>個並行運行的連接，應該讓資料表的緩存至少有<span><span>200 
			* </span><i><span>N</span></i></span>，這裡<span><i><span>N</span></i></span>是可以執行的查詢的一個聯接中資料表的最大數量。還需要為臨時資料表和檔案保留一些額外的檔案描述符。</p>
			<p>
			確保作業系統可以處理<span>table_cache</span>設置所指的打開的檔案描述符的數目。如果<span>table_cache</span><span>is</span>設得太高，<span>MySQL</span>可能為檔案描述符耗盡資源並拒絕連接，不能執行查詢，並且很不可靠。還必須考慮到<span>MyISAM</span>儲存引擎需要為每個打開的資料表提供兩個檔案描述符。可以在<strong><span>mysqld_safe</span></strong>中使用<span>--open-files-limit</span>啟動選項來增加<span>MySQL</span>適用的檔案描述符的數量。參見<a href="problems.html#not-enough-file-handles" title="A.2.17. File Not Found">A.2.17節，「檔案未找到」</a>。</p>
			<p>
			打開資料表的緩存可以保持在<span>table_cache</span>條。
			預設為<span>64</span>；可以用<strong><span>mysqld</span></strong>的<span >--table_cache</span>選項來更改。請注意<span> 
			MySQL</span>可以臨時打開更多的 資料表以執行查詢。</p>
			<p>
			在下面的條件下，未使用的資料表將被關閉並從資料表緩存中移出：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當緩存滿了並且一個線程試圖打開一個不在緩存中的資料表時。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當緩存包含超過<span>table_cache</span>個條目，並且緩存中的資料表不再被任何線程使用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當資料表刷新操作發生。當執行<span>FLUSH 
			TABLES</span>語句或執行<strong><span  style="font-family:
細明體">mysqladmin flush-tables</span></strong>或<strong><span>mysqladmin 
			refresh</span></strong>命令時會發生。</p>
			<p>
			當資料表緩存滿時，伺服器使用下列過程找到一個緩存入口來使用：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當前未使用的資料表被釋放，以最近最少使用順序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果緩存滿了並且沒有資料表可以釋放，但是一個新資料表需要打開，緩存必須臨時被擴大。</p>
			<p>
			如果緩存處於一個臨時擴大狀態並且一個資料表從在用變為不在用狀態，它被關閉並從緩存中釋放。</p>
			<p>
			對每個並發訪問打開一個資料表。這意味著，如果<span>2</span>個線程訪問同一個資料表或在同一個查詢中訪問資料表兩次<span>(</span>例如，將資料表連接為自身時<span>)</span>，資料表需要被打開兩次。每個並行的打開要求在資料表緩存中有一個條目。任何資料表的第一次打開占<span>2</span>個檔案描述符：一個用於數據檔案另一個用於索引檔案。資料表的每一次額外使用僅佔一個數據檔案的檔案描述符。索引檔案描述符在所有線程之間共享。</p>
			<p>
			如果您正用<span>HANDLER
			<i>tbl_name</i> OPEN</span>語句打開一個資料表，將為該線程專門分配一個資料表。該資料表不被其它線程共享，只有線程使用<span >HANDLER
			<i>tbl_name</i> CLOSE</span>或線程終止後才被關閉。資料表關閉後，被拉回資料表緩存中<span>(</span>如果緩存不滿<span>)</span>。參見<a href="sql-syntax.html#handler" title="13.2.3. HANDLER Syntax">13.2.3節，「HANDLER語法」</a>。</p>
			<p>
			可以通過檢查<strong><span  style="font-family:
細明體">mysqld</span></strong>的狀態變數<span>Opened_tables</span>確定資料表緩存是否太小：</p>
			<pre><span>mysql&gt; </span><span><b><span>SHOW STATUS LIKE &#39;Opened_tables&#39;;</span></b></span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<pre><span>| Variable_name | Value |</span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<pre><span>| Opened_tables | 2741&nbsp; |</span></pre>
			<pre><span>+---------------+-------+</span></pre>
			<p>如果值很大，即使您沒有發出許多<span>FLUSH 
			TABLES</span>語句，也應增加資料表緩存的大小。參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>和<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4節，「伺服器狀態變數」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-many-tables"></a>
			7.4.10.&nbsp;在同一個資料庫中建立多個資料表的問題</h3></div></div></div><a class="indexterm" name="id2814177"></a></div></div><div class="section"><div class="titlepage"><div><div>
		如果在同一個資料庫目錄中有許多<span>MyISAM</span>資料表，打開、關閉和建立操作將會很慢。如果對許多不同的資料表執行<span>SELECT</span>語句，當資料表緩存滿時，將有一點開銷，因為對每個必須打開的資料表，另外一個必須被關閉。可以通過使資料表緩存更大些來減少這個開銷。<h2 class="title"><a name="optimizing-the-server"></a>
		7.5.&nbsp;最佳化MySQL伺服器</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#system">
			7.5.1. 系統因素和啟動參數的調節</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">
			7.5.2. 調節伺服器參數</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">
			7.5.3. 控制查詢最佳化器的性能</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">
			7.5.4. 編譯和連結怎樣影響MySQL的速度</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">
			7.5.5. MySQL如何使用內存</a></span></dt><dt><span class="section"><a href="optimization.html#dns">
			7.5.6. MySQL如何使用DNS</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="system"></a>
			7.5.1.&nbsp;系統因素和啟動參數的調節</h3></div></div></div><a class="indexterm" name="id2814234"></a><a class="indexterm" name="id2814245"></a><a class="indexterm" name="id2814251"></a>
			<p>
			我們從系統級因素開始，因為必須盡早地進行部分決策以獲得較大性能。在其它情況下，快速瀏覽該節就足夠了。但是，瞭解一下更改該層次的參數能夠獲得多少性能提高是很有意義的。</p>
			<p>
			使用的作業系統很重要。為了更好地使用多<span>CPU</span>機器，應使用<span>Solaris(</span>因為其線程工作得很好<span>)</span>或<span>Linux(</span>因為<span>2.4</span>和以後的內核有很好的<span>SMP</span>支援<span>)</span>。請注意預設情況舊的<span>Linux</span>內核有一個<span>2GB</span>的檔案大小限制。如果有這樣的一個內核並且需要檔案大於<span>2GB</span>，應得到<span>ext2</span>檔案系統的大檔案支援<span>(LFS)</span>補丁。其它檔案系統例如<span>ReiserFS</span>和<span>XFS</span>沒有此<span>2GB</span>限制。</p>
			<p>
			將<span>MySQL</span>用於生產前，我們建議您在想用的平台上對它進行測試。</p>
			<p>
			其它技巧：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果有足夠的<span>RAM</span>，可以移除所有的交換設備。有些作業系統即使有自由內存也使用交換設備。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>--skip-external-locking</span><span> 
			MySQL</span>選項以避免外部鎖定。該選項預設開啟。</p>
			<p>
			請注意只要您只運行一個伺服器，<span>--skip-external-locking</span>選項不影響<span>MySQL</span>的功能。只要記住運行<strong><span>myisamchk</span></strong>之前關閉伺服器<span>(</span>或鎖定並刷新相關資料表<span>)</span>。在一些系統上該選項是強制的，因為在任何情況下外部鎖定均不工作。</p>
			<p>
			不能使用<span>--skip-external-locking</span>的唯一情況是對相同的數據運行多個<span>MySQL</span>伺服器<span>(</span>非客戶<span>)</span>的情況，或者如果沒有事先告訴伺服器刷新並鎖定一個資料表即運行<strong><span>myisamchk</span></strong>來檢查<span>(</span>非修復<span>)</span>該資料表。請注意一般不建議使用多個<span>MySQL</span>伺服器來並行訪問相同的數據，除了使用<span>MySQL 
			Cluster</span>時。</p>
			<p>
			即使使用<span>--skip-external-locking</span>，仍然可以使用<span>LOCK 
			TABLES</span>和<span>UNLOCK 
			TABLES</span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-parameters"></a>
			7.5.2.&nbsp;調節伺服器參數</h3></div></div></div><a class="indexterm" name="id2814396"></a><a class="indexterm" name="id2814406"></a><a class="indexterm" name="id2814418"></a><a class="indexterm" name="id2814431"></a>
			<p>
			可以用這個命令得到<strong><span>mysqld</span></strong>伺服器
			預設緩存區的大小：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqld --verbose --help</span></b></span></pre>
			<p>這個命令生成所有<span><b><span>mysqld</span></b></span>選項和可配置變數的列資料表。輸出包括
			預設值並且看上去像這樣：</p>
			<pre><span>help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>abort-slave-event-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>allow-suspicious-udfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>auto-increment-increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>auto-increment-offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>automatic-sp-privileges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>basedir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/</span></pre>
			<pre><span>bdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>bind-address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>character-set-client-handshake&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>character-set-server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;latin1</span></pre>
			<pre><span>character-sets-dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/share/mysql/charsets/</span></pre>
			<pre><span>chroot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>collation-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1_swedish_ci</span></pre>
			<pre><span>completion-type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>concurrent-insert&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>console&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>datadir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/</span></pre>
			<pre><span>default-character-set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1</span></pre>
			<pre><span>default-collation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latin1_swedish_ci</span></pre>
			<pre><span>default-time-zone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>disconnect-slave-event-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>enable-locking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>enable-pstack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>engine-condition-pushdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>external-locking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>gdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>large-pages&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>init-connect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>init-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>init-slave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_checksums&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;TRUE</span></pre>
			<pre><span>innodb_data_home_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_doublewrite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_fast_shutdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_file_per_table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>innodb_flush_log_at_trx_commit&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_flush_method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_locks_unsafe_for_binlog&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>innodb_log_arch_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_log_group_home_dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>innodb_max_dirty_pages_pct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90</span></pre>
			<pre><span>innodb_max_purge_lag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_status_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>innodb_table_locks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>innodb_support_xa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>language&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/share/mysql/english</span></pre>
			<pre><span>local-infile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/home/jon/bin/mysql/var/master1.log</span></pre>
			<pre><span>log-bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/master1</span></pre>
			<pre><span>log-bin-index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-bin-trust-routine-creators&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/master1.err</span></pre>
			<pre><span>log-isam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myisam.log</span></pre>
			<pre><span>log-queries-not-using-indexes&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-short-format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slave-updates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slow-admin-statements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>log-slow-queries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-tc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc.log</span></pre>
			<pre><span>log-tc-size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24576</span></pre>
			<pre><span>log-update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>log-warnings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>low-priority-updates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>master-connect-retry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60</span></pre>
			<pre><span>master-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-info-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; master.info</span></pre>
			<pre><span>master-password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>master-retry-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 86400</span></pre>
			<pre><span>master-ssl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>master-ssl-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-capath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-cipher&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-ssl-key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>master-user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test</span></pre>
			<pre><span>max-binlog-dump-events&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>memlock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>myisam-recover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFF</span></pre>
			<pre><span>ndbcluster&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>ndb-connectstring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>ndb-mgmd-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>ndb-nodeid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ndb-autoincrement-prefetch-sz&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>ndb-distibution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEYHASH</span></pre>
			<pre><span>ndb-force-send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb_force_send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-use-exact-count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb_use_exact_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-shm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>ndb-optimized-node-selection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-cache-check-time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ndb-index-stat-enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>ndb-index-stat-cache-entries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>ndb-index-stat-update-freq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-alter-table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-passwords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>old-style-user-limits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>pid-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /home/jon/bin/mysql/var/hostname.pid1</span></pre>
			<pre><span>port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>relay-log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>relay-log-index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>relay-log-info-file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relay-log.info</span></pre>
			<pre><span>replicate-same-server-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>report-host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>report-password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>report-port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3306</span></pre>
			<pre><span>report-user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>rpl-recovery-rank&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>safe-user-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>secure-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>server-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>show-slave-auth-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>skip-grant-tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>skip-slave-start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE</span></pre>
			<pre><span>slave-load-tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /tmp/</span></pre>
			<pre><span>socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /tmp/mysql.sock</span></pre>
			<pre><span>sporadic-binlog-dump-fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>sql-mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFF</span></pre>
			<pre><span>symbolic-links&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>tc-heuristic-recover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(No default value)</span></pre>
			<pre><span>temp-pool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>timed_mutexes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>tmpdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>use-symbolic-links&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>verbose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>warnings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></pre>
			<pre><span>back_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768</span></pre>
			<pre><span>bulk_insert_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>connect_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</span></pre>
			<pre><span>date_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>datetime_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>default_week_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>delayed_insert_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>delayed_insert_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>delayed_queue_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000</span></pre>
			<pre><span>expire_logs_days&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>flush_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>ft_max_word_len&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84</span></pre>
			<pre><span>ft_min_word_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>ft_query_expansion_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>ft_stopword_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>group_concat_max_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>innodb_additional_mem_pool_size&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>innodb_autoextend_increment&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;8</span></pre>
			<pre><span>innodb_buffer_pool_awe_mem_mb&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_buffer_pool_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>innodb_concurrency_tickets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 500</span></pre>
			<pre><span>innodb_file_io_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>innodb_force_recovery&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_lock_wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>innodb_log_buffer_size&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1048576</span></pre>
			<pre><span>innodb_log_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5242880</span></pre>
			<pre><span>innodb_log_files_in_group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span></pre>
			<pre><span>innodb_mirrored_log_groups&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>innodb_open_files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>innodb_sync_spin_loops&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>innodb_thread_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>innodb_commit_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>innodb_thread_sleep_delay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10000</span></pre>
			<pre><span>interactive_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28800</span></pre>
			<pre><span>join_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>key_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388600</span></pre>
			<pre><span>key_cache_age_threshold&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</span></pre>
			<pre><span>key_cache_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;1024</span></pre>
			<pre><span>key_cache_division_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>long_query_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>lower_case_table_names&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_allowed_packet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>max_binlog_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_binlog_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1073741824</span></pre>
			<pre><span>max_connect_errors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>max_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100</span></pre>
			<pre><span>max_delayed_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</span></pre>
			<pre><span>max_error_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64</span></pre>
			<pre><span>max_heap_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16777216</span></pre>
			<pre><span>max_join_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_length_for_sort_data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>max_relay_log_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_seeks_for_key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>max_sort_length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>max_tmp_tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32</span></pre>
			<pre><span>max_user_connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>max_write_lock_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</span></pre>
			<pre><span>multi_range_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256</span></pre>
			<pre><span>myisam_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</span></pre>
			<pre><span>myisam_data_pointer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6</span></pre>
			<pre><span>myisam_max_extra_sort_file_size&nbsp;&nbsp; 2147483648</span></pre>
			<pre><span>myisam_max_sort_file_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2147483647</span></pre>
			<pre><span>myisam_repair_threads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>myisam_sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8388608</span></pre>
			<pre><span>myisam_stats_method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nulls_unequal</span></pre>
			<pre><span>net_buffer_length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16384</span></pre>
			<pre><span>net_read_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30</span></pre>
			<pre><span>net_retry_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>net_write_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60</span></pre>
			<pre><span>open_files_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;0</span></pre>
			<pre><span>optimizer_prune_level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>optimizer_search_depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 62</span></pre>
			<pre><span>preload_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768</span></pre>
			<pre><span>query_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>query_cache_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1048576</span></pre>
			<pre><span>query_cache_min_res_unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096</span></pre>
			<pre><span>query_cache_size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0</span></pre>
			<pre><span>query_cache_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>query_cache_wlock_invalidate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>query_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>range_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048</span></pre>
			<pre><span>read_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>read_only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>read_rnd_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 262144</span></pre>
			<pre><span>div_precision_increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span></pre>
			<pre><span>record_buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131072</span></pre>
			<pre><span>relay_log_purge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>relay_log_space_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>slave_compressed_protocol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE</span></pre>
			<pre><span>slave_net_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3600</span></pre>
			<pre><span>slave_transaction_retries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>slow_launch_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span></pre>
			<pre><span>sort_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2097144</span></pre>
			<pre><span>sync-binlog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-frm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE</span></pre>
			<pre><span>sync-replication&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-replication-slave-id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>sync-replication-timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>table_cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64</span></pre>
			<pre><span>table_lock_wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50</span></pre>
			<pre><span>thread_cache_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</span></pre>
			<pre><span>thread_concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</span></pre>
			<pre><span>thread_stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 196608</span></pre>
			<pre><span>time_format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (No default value)</span></pre>
			<pre><span>tmp_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33554432</span></pre>
			<pre><span>transaction_alloc_block_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</span></pre>
			<pre><span>transaction_prealloc_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096</span></pre>
			<pre><span>updatable_views_with_limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></pre>
			<pre><span>wait_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28800</span></pre>
			<p>
			如果有一個<span><b><span>mysqld</span></b></span>伺服器正在運行，通過連接它並執行這個命令，可以看到實際上使用的變數的值：</p>
			<pre><span>mysql&gt; </span><span><b><span>SHOW VARIABLES;</span></b></span></pre>
			<p>
			還可以通過下面的語句看到運行伺服器的統計和狀態指標：</p>
			<pre><span>mysql&gt;SHOW STATUS</span><span >；</span></pre>
			<p>
			使用<strong><span>mysqladmin</span></strong>還可以獲得系統變數和狀態訊息：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqladmin variables</span></b></span></pre>
			<pre><span>shell&gt; </span><span><b><span>mysqladmin extended-status</span></b></span></pre>
			<p>
			關於所有系統和狀態變數的完全描述參見<a href="database-administration.html#server-system-variables" title="5.3.3. Server System Variables">5.3.3節，「伺服器系統變數」</a>和<a href="database-administration.html#server-status-variables" title="5.3.4. Server Status Variables">5.3.4節，「伺服器狀態變數」</a>。</p>
			<p>
			<span>MySQL</span>使用完全可以升級的算法，因此通常運行時可以用很少的內存。然而，通常情況若給<span>MySQL</span>更多的內存性能會更好。</p>
			<p>
			當調節<span>MySQL</span>伺服器時，要配置的兩個最重要的變數是<span>key_</span><span>buffer_size</span>和<span>table_cache</span>。在試圖更改其它變數前您應先確信已經適當地配置了這些變數。</p>
			<p>
			下面的例子顯示了部分典型的不同的運行時配置的變數值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果至少有<span>256MB</span>內存和許多資料表，想要在中等數量的客戶時獲得最大性能，應使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=64M --table_cache=256 \</span></b></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><b><span>--sort_buffer_size=4M --read_buffer_size=1M &amp;</span></b></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果只有<span>128MB</span>內存和少量資料表，但仍然要進行大量的排序，可以使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M</span></b></span></pre>
			<p>
			如果有許多並行連接，交換問題會發生，除非<strong><span>mysqld</span></strong>已經配置成為每個連接分配很少的內存。如果有足夠的內存用於所有連接，<strong><span>mysqld</span></strong>會執行得更好。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於少量內存和大量連接，應使用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \</span></b></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><b><span>--read_buffer_size=100K &amp;</span></b></span></pre>
			<p>
			或甚至為：</p>
			<pre ><span>shell&gt; </span><span><b><span>mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \</span></b></span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>--table_cache=32 --read_buffer_size=8K \</span></b></span></pre>
			<pre ><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><b><span>--net_buffer_length=1K &amp;</span></b></span></pre>
			<p>
			如果正對遠遠大於可用內存的資料表執行<span>GROUP 
			BY</span>或<span>ORDER 
			BY</span>操作，應增加<span>read_</span><span>rnd_buffer_size</span>的值以加速排序操作後面的行讀取。</p>
			<p>
			如果已經安裝了<span>MySQL</span>，<span>support-files</span>目錄包含一些不同的<span>my.cnf</span>示範檔案：<span><span>my-huge.cnf</span><span>、<span>my-</span>大<span>.cnf</span>、<span>my-medium.cnf</span></span></span>和<span>my-small.cnf</span>。可以使用這些檔案來最佳化系統。</p>
			<p>
			請注意如果在命令行中為<strong><span>mysqld</span></strong>或<strong><span>mysqld_safe</span></strong>指定一個選項，它只在該次伺服器使用中保持有效。要想每次伺服器運行時使用該選項，將它放在選項檔案中。</p>
			<p>
			要想看參數更改的效果，應執行：</p>
			<pre><span>shell&gt; </span><span><b><span>mysqld --key_buffer_size=32M --verbose ---help</span></b></span></pre>
			<p>
			變數值列於輸出的最後。確保<span>--verbose</span>和<span>---help</span>選項在最後。否則，在命令行中列於它們後面的選項的效果不會反映到輸出中。</p>
			<p>關於調節<span>InnoDB</span>儲存引擎的訊息，參見<a href="storage-engines.html#innodb-tuning" title="15.2.11. InnoDB Performance Tuning Tips">15.2.11節，「InnoDB性能調節提示」</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-optimizer"></a>
			7.5.3.&nbsp;控制查詢最佳化器的性能</h3></div></div></div><a class="indexterm" name="id2815057"></a>
			<p>
			查詢最佳化器的任務是發現執行<span>SQL</span>查詢的最佳方案。因為「<span class="quote">好</span>」方案和「<span class="quote">壞</span>」方案之間的性能差別會巨大<span>(</span>也就是說，秒相對於小時或甚至天<span>)</span>，大多數查詢最佳化器，包括<span>MySQL</span>的查詢最佳化器，總或多或少地在所有可能的查詢評估方案中搜索最佳方案。對於聯接查詢，<span>MySQL</span>最佳化器所調查的可能的方案數隨查詢中所引用的資料表的數目呈指數增長。對於小數量的資料表<span>(</span>典型小於<span>7-10)</span>，這不是一個問題。然而，當提交的查詢更大時，查詢最佳化所花的時間會很容易地成為伺服器性能的主要瓶頸。</p>
			<p>
			查詢最佳化的一個更加靈活的方法是允許用戶控制最佳化器詳盡地搜索最佳查詢評估方案。一般思想是最佳化器調查的方案越少，它編譯一個查詢所花費的時間越少。另一方面，因為最佳化器跳過了一些方案，它可能錯過一個最佳方案。</p>
			<p>
			最佳化器關於方案數量評估的行為可以通過兩個系統變數來控制：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>optimizer_prune_level</span>變數告訴最佳化器根據對每個資料表訪問的行數的估計跳過某些方案。我們的試驗顯示該類「<span class="quote">有根據的猜測</span>」很少錯過最佳方案，並且可以大大降低查詢編輯次數。這就是為什麼預設情況該選項為<span>on(</span><span>optimizer_prune_level</span><span>=1)</span>。然而，如果您認為最佳化器錯過了一個更好的查詢方案，則該選項可以關閉<span>(</span><span>optimizer_prune_level</span><span>=0)</span>，風險是查詢編輯花費的時間更長。請注意即使使用該啟發，最佳化器仍然可以探測呈指數數目的方案。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			<span>optimizer_search_depth</span>變數告訴最佳化器對於每個未完成的「未來的」方案，應查看多深，以評估是否應對它進一步擴大。<span>optimizer_search_depth</span>值較小會使查詢編輯次數大大減小。例如，如果<span>optimizer_search_depth</span>接近於查詢中資料表的數量，對<span>12</span>、<span>13</span>或更多資料表的查詢很可能需要幾小時甚至幾天的時間來編譯。同時，如果用<span>optimizer_search_depth</span>等於<span>3</span>或<span>4</span>編輯，對於同一個查詢，編譯器編譯時間可以少於<span>1</span>分鐘。如果不能確定合理的<span>optimizer_search_depth</span>值，該變數可以設置為<span>0</span>，告訴最佳化器自動確定該值。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="compile-and-link-options"></a>
			7.5.4.&nbsp;編譯和連結怎樣影響MySQL的速度</h3></div></div></div><a class="indexterm" name="id2815202"></a><a class="indexterm" name="id2815212"></a><a class="indexterm" name="id2815222"></a><a class="indexterm" name="id2815232"></a></div><div class="section"><div class="titlepage"><div><div>
			<p>
			下列大多數測試是在<span>Linux</span>上並用<strong><span>MySQL</span></strong>基準進行的，但是它們能對其它作業系統和工作負載給出一些指示。</p>
			<p>
			當您用<span>-static</span>連結時，可以得到最快的可執行檔案。</p>
			<p>
			在<span>Linux</span>上，最好用<strong><span>pgcc</span></strong>和<span >-O3</span>編譯伺服器。為了用這些選項編譯<tt ><span>「sql_yacc.cc」</span></tt>，需要大約<span>200M</span>內存，因為<strong><span>gcc</span></strong>或<strong><span>pgcc</span></strong>需要大量的內存使所有函數嵌入（<span>inline</span>）。在配置<strong><span>MySQL</span></strong>時，也應該設定<span>CXX=gcc</span>以避免包括<span>libstdc++</span>庫<span>(</span>它不需要<span>)</span>。請注意對於某些版本的<strong><span>pgcc</span></strong>，生成的二進制只能運行在真<span>Pentium</span>處理器上，即使您使用編譯器選項說明您想讓最終的代碼在所有<span>x586-</span>類處理器上工作<span>(</span>例如<span>AMD)</span>。</p>
			<p>
			只通過使用一個較好的編譯器或較好的編譯器選項，在應用中能得到<span>10-30%</span>的加速。如果您自己編譯<span>SQL</span>伺服器，這特別重要！</p>
			<p>
			當我們測試<span>Cygnus CodeFusion</span>或<span>Fujitsu</span>編譯器時，二者均還沒足夠不出錯來讓<span>MySQL</span>啟用最佳化進行編譯。</p>
			<p>
			標準<span>MySQL</span>二進制分發編譯為支援所有字元編碼。當您自己編譯<span>MySQL</span>時，應只包括將使用的字元編碼的支援。通過<strong><span>configure</span></strong>的<span>--with-charset</span>選項來控制。</p>
			<p>
			這裡是我們做過的一些測量資料表：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<strong><span>pgcc</span></strong>並用<span>-O6</span>編譯，<strong><span>mysqld</span></strong>伺服器比用<strong><span>gcc</span></strong><span> 
			2.95.2</span>快<span>11%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您動態地連結<span>(</span>沒有<span>-static</span><span>)</span>，在<span>Linux</span>中結果慢了<span>13%</span>。注意您仍能在客戶應用程式中使用動態連結<span>MySQL</span>庫。只有伺服器對性能是關鍵的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您用<span>strip 
			mysqld</span>剝離<strong><span>mysqld</span></strong>二進制，生成的二進制可以快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於在同一主機上運行的客戶與伺服器之間的連接，如果您使用<span>TCP/IP</span>而非<span>Unix</span>套接字檔案進行連接，結果慢<span>7.5%</span>。<span>(</span>在<span>Unix</span>中，如果您連接<span>localhost</span>主機，<span>MySQL</span>預設使用一個套接字檔案）<span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於從客戶到伺服器的<span>TCP/IP</span>連接，從另一台主機連接一台遠程伺服器要比連接同一主機上的伺服器慢<span>8-11%</span>，即使通過<span>100Mb/s</span>以太網進行連接。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當使用安全連接運行我們的基準測試時<span>(</span>所有數據用內部<span>SSL</span>支援進行加密<span>)</span>，性能比未加密連接慢<span>55%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您用<span>--with-debug=full</span>編譯，大多數查詢慢<span>20%</span>。部分查詢時間會很長；例如，<span>MySQL</span>基準的運行要慢<span>35%</span>。如果您使用<span>--with-debug</span><span>(</span>沒有<span>=full</span><span>)</span>，速度只下降<span>15%</span>。對於用<span>--with-debug=full</span>編譯的<strong><span>mysqld</span></strong>版本，可以用<span>--skip-safemalloc</span>選項啟動以便在運行時禁用內存檢查。執行速度則接近用<span>--with-debug</span>配置的時候。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Sun UltraSPARC-Iie</span>上，用<span>Forte 
			5.0</span>編譯的伺服器比用<strong><span>gcc</span></strong><span> 
			3.2</span>編譯的要快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Sun UltraSPARC-Iie</span>上，用<span>Forte 
			5.0</span>編譯的<span>32</span>位模式伺服器比<span>64</span>位模式伺服器要快<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>用<strong><span>gcc</span></strong><span> 
			2.95.2</span>編譯帶<span>-mcpu=v8 
			-Wa</span>的<span>UltraSPARC</span>，使用<span>-xarch=v8plusa</span>選項性能會提高<span>4%</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Solaris 2.5.1</span>上，在單個處理器上<span>MIT-pthreads</span>比帶原生線程的<span>Solaris</span>慢<span>8-12%</span>。如果有更大的負載<span>/cpus</span>，差別應該更大。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Linux-x86</span>上使用<strong><span>gcc</span></strong>編譯而不用幀指針<span>(</span><span >-fomit-frame-pointer</span><span> 
			or </span><span >-fomit-frame-pointer 
			-ffixed-ebp</span><span>)</span>，可以使<strong><span>mysqld</span></strong>快<span>1-4%</span>。</p>
			<p><span>MySQL AB</span>提供的<span>Linux</span>上的二進制<span>MySQL</span>分發一般用<strong><span>pgcc</span></strong>編譯。我們必須返回到常規<strong><span>gcc</span></strong>，因為<strong><span>pgcc</span></strong>中有一個<span>bug</span>，使生成的二進制不能在<span>AMD</span>上運行。我們將繼續使用<strong><span>gcc</span></strong>直到該<span>bug</span>被解決。同時，如果您有一個非<span>AMD</span>機，您可以用<strong><span>pgcc</span></strong>編譯構建一個更快的二進制。標準<span>MySQL 
			Linux</span>二進制是通過靜態連結，以使它更快並且更加易於移植。</p>
			<h3 class="title"><a name="memory-use"></a>
			7.5.5.&nbsp;MySQL如何使用內存</h3></div></div></div><a class="indexterm" name="id2815594"></a>
			<p>下面的列資料表中列出了<strong><span  style="font-family:
細明體">mysqld</span></strong>伺服器使用內存的一些方法。在適用的地方，給出了內存相關的系統變數名：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>鍵緩存<span>(</span>變數<span >key_buffer_size</span><span>)</span>被所有線程共享；伺服器使用的其它緩存則根據需要分配。參見<a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">7.5.2節，「調節伺服器參數」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>每個連接使用具體線程的空間：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>堆棧<span>(</span>預設<span>64KB</span>，變數<span >thread_stack</span><span>)</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>連接緩存區<span>(</span>變數<span >net_buffer_length</span><span>)</span></p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>結果緩存區<span>(</span>變數<span >net_buffer_length</span><span>)</span></p>
			<p>連接緩存區和結果緩存區可以根據需要動態擴充到<span >max_allowed_packet</span>。當某個查詢運行時，也為當前查詢字串分配內存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有線程共享相同的基本內存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有壓縮<span >MyISAM</span>資料表映射到內存。這是因為<span>4GB</span>的<span>32</span>位內存空間不足以容納大多數大資料表。當<span>64</span>位地址空間的系統變得越來越普遍後，我們可以增加常規的內存映射支援。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對資料表進行順序掃瞄的請求將分配一個<em><span>緩存區</span></em><span>(</span>變數<span >read_buffer_size</span><span>)</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當按任意順序讀取行時<span>(</span>例如，按照排序順序<span>)</span>，將分配一個隨機讀 
			<em><span>緩存區</span></em><span>(</span>變數<span >read_rnd_buffer_size</span><span>)</span>以避免硬盤搜索。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有聯合在一個令牌內完成，並且大多數聯合甚至可以不用臨時資料表即可以完成。大多數臨時資料表是基於內存的<span>(</span><span >HEAP</span><span>)</span>資料表。具有大的記錄長度的臨時資料表<span> 
			(</span>所有列的長度的和<span>)</span>或包含<span >BLOB</span>列的資料表儲存在硬盤上。</p>
			<p>如果某個內部<span>heap</span>（堆積）資料表大小超過<span >tmp_table_size</span>，<span>MySQL</span>可以根據需要自動將內存中的<span>heap</span>資料表改為基於硬盤的<span >MyISAM</span>資料表。還可以通過設置<strong><span>mysqld</span></strong>的<span >tmp_table_size</span>選項來增加臨時資料表的大小，或設置客戶程式中的<span>SQL</span>選項<span >SQL_BIG_TABLE</span>。參見<a href="sql-syntax.html#set-option" title="13.5.3. SET Syntax">13.5.3節，「SET語法」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>進行排序的大多數請求將分配一個排序緩存區，並根據結果集的大小為兩個臨時檔案分配零。參見<a href="problems.html#temporary-files" title="A.4.4. Where MySQL Stores Temporary Files">A.4.4節，「MySQL將臨時檔案儲存在哪裡」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			幾乎所有解析和計算在局部內存中完成。小項目不需要內存，因此避免了普通的慢內存分配和釋放。只為不期望的大字串分配內存；使用函數<span >malloc()</span>和<span >free()</span>來完成。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於每個打開的<span >MyISAM</span>資料表，索引檔案打開一次；數據檔案為每個並行運行的線程打開一次。對於每個並行線程，將分配一個資料表結構、一個每個列的列結構和大小為<span >3 
			* <i>N</i></span>的緩存區<span>(</span>其中<span><i><span>N</span></i></span>是最大行的長度，而不是計算<span >BLOB</span>列<span>)</span>。一個<span >BLOB</span>列需要<span>5</span>至<span>8</span>個字節加上<span >BLOB</span>數據的長度。<span >MyISAM</span><span>
			</span>儲存引擎維護一個額外的行緩存區供內部應用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>對於每個具有<span >BLOB</span>列的資料表，將對緩存區進行動態擴大以讀入大的<span >BLOB</span><span>
			</span>值。如果您掃瞄一個資料表，則分配一個與最大的<span >BLOB</span>值一樣大的緩存區。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有使用的資料表的句柄結構保存在高速緩存中並以<span>FIFO</span>管理。預設情況，高速緩存有<span>64</span>個入口。如果某個資料表同時被兩個運行的線程使用，高速緩存則為該提供兩個入口。參見<a href="optimization.html#table-cache" title="7.4.9. How MySQL Opens and Closes Tables">7.4.9節，「MySQL如何打開和關閉資料表」</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>當並行執行的線程結束時，<span >FLUSH 
			TABLE</span>語句或<strong><span>mysqladmin 
			flush-table</span></strong>命令可以立即關閉所有不使用的資料表並將所有使用中的資料表標記為已經關閉。這樣可以有效釋放大多數使用中的內存。<span >FLUSH 
			TABLE</span>在關閉所有資料表之前不返回結果。</p>
			<p><span>ps</span>和其它系統狀態程式可以報導<span>mysqld</span>使用很多內存。這可以是在不同的內存地址上的線程棧造成的。例如，<span>Solaris</span>版本的<span>ps</span>將棧間未用的內存算作已用的內存。您可以通過用<span>swap 
			-s</span>檢查可用交換區來驗證它。我們用商業內存漏洞探查器測試了<span>mysqld</span>，因此應該有沒有內存漏洞。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dns"></a>
			7.5.6.&nbsp;MySQL如何使用DNS</h3></div></div></div><a class="indexterm" name="id2815983"></a><a class="indexterm" name="id2815989"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<p>
		當新的客戶連接<strong><span  style="font-family:
細明體">mysqld</span></strong>時，<strong><span>mysqld</span></strong>建立一個新的線程來處理請求。該線程先檢查是否主機名在主機名緩存中。如果不在，線程試圖解析主機名：</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果作業系統支援線程安全<span><span>gethostbyaddr_r</span><span> 
		()</span></span>和<span><span>gethostbyname_r</span><span>()</span></span>使用，線程使用它們來執行主機名解析。</p>
		<p>
		<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</span></span>如果作業系統不支援線程安全使用，線程鎖定一個互斥體並使用<span >gethostbyaddr()</span>和<span >gethostbyname()</span>。在這種情況下，在第<span>1</span>個線程解鎖互斥體前，沒有其它線程可以解析不在主機名緩存中的主機名。</p>
		<p>
		您可以用<span >--skip-name-resolve</span>選項啟動<strong><span>mysqld</span></strong>來禁用<span>DNS</span>主機名搜尋。然而，在這種情況下，您只可以使用<span>MySQL</span>中的授權資料表中的<span>IP</span>號。</p>
		<p>
		如果您有一個很慢的<span>DNS</span>和許多主機，您可以通過用<span >--skip-name-resolve</span>禁用<span>DNS</span>搜尋或增加<span>HOST_CACHE_SIZE</span>定義<span>(</span>預設值：<span>128)</span>並重新編譯<strong><span>mysqld</span></strong>來提高性能。</p>
		<p>
		您可以用<span >--skip-host-cache</span>選項啟動伺服器來禁用主機名緩存。要想清除主機名緩存，執行<span >FLUSH 
		HOSTS</span>語句或執行<strong><span  style="font-family:
細明體">mysqladmin flush-hosts</span></strong>命令。</p>
		<p>
		如果您想要完全禁止<span>TCP/IP</span>連接，用<span >--skip-networking</span>選項啟動<strong><span>mysqld</span></strong>。</p>
		<h2 class="title"><a name="disk-issues"></a>
		7.6.&nbsp;磁盤事宜</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links">
			7.6.1. 使用符號連結</a></span></dt>
			<dd>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
			磁盤搜索是巨大的性能瓶頸。當數據量變得非常大以致於緩存性能變得不可能有效時，該問題變得更加明顯。對於大資料庫，其中您或多或少地隨機訪問數據，您可以確信對讀取操作需要至少一次硬盤搜索，寫操作需要多次硬盤搜索。要想使該問題最小化，應使用搜索次數較少的磁盤。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>通過連結檔案到不同的磁盤或對硬盤分段來增加可用磁盤錠數量（因此降低搜索成本）：</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>使用符號連結</p>
			<p>
			這說明，對於<span>M</span><span>yISAM</span>資料表，您符號連結索引檔案和<span>/</span>或數據檔案，從它們數據目錄內的通常位置到另一個硬盤（也可以被條紋化）。這將使搜索和讀次數達到最好，假定硬盤不再為其它目的使用。參見<a href="optimization.html#symbolic-links" title="7.6.1. Using Symbolic Links">7.6.1節，「使用符號連結」</a>。</p>
			<p >
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分條</p>
			<p>
			分條意味著您有許多磁盤，將第<span>1</span>個塊放到第<span>1</span>個硬盤，第<span>2</span>個塊放到第<span>2</span>個磁盤，並且第<span><i><span>N</span></i></span>塊在（<i><span>N</span></i><span> 
			mod number_of_disks</span>）磁盤上等等。這意味著如果正常數據大小小於分條大小（或完全匹配），能夠得到最佳性能。分條完全取決於作業系統和分條大小，因此用不同的條紋大小對應用程式進行基準測試。參見<a href="optimization.html#custom-benchmarks" title="7.1.5. Using Your Own Benchmarks">7.1.5節，「使用自己的基準」</a>。</p>
			<p>
			分條的不同速度完全依賴於參數。依賴於怎樣設置條紋參數和硬盤數量，可以根據不同數量級別得到不同的標準。您必須進行選擇以便最佳化隨機或順序存取。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>為了高可靠性您可能想使用<span>RAID 0+1</span>（條紋加鏡像），但在這種情況下，需要<span>2*N</span>塊磁盤來保持<span>N</span>個磁盤的數據。如果您肯為它花錢，這可能是最好的選項。然而，您可能還必須投資一部分資金到卷管理軟件中以便有效地管理它。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一個較好的選擇是根據數據類型的重要性程度改變<span>RAID</span>級別。例如，保存可以在<span>RAID 
			0</span>硬盤上重新生成的不太重要的數據，但保存 真正重要數據（例如主機訊息和日誌）到<span>RAID 
			0+1</span>或<span>RAID N</span>硬盤。如果您有許多寫操作，<span>RAID 
			N</span>可能會存在問題，因為需要時間來更新校驗位。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>Linux</span>上，通過配置磁盤接口時使用<span>hdparm</span>，您可以獲得更多的性能。（在一般負載下達到<span>100%</span>並不困難。）下面的<span>hdparm</span>選項 
			應該非常適用於<span>MySQL</span>，並且可能適用於許多其它應用程式：</p>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp; hdparm -m 16 -d 1</span></pre>
			<p>
			請注意，當使用該命令時，性能和可靠性依賴於硬件，因此我們強烈建議，使用<span>hdparm</span>後<span>，</span>完全測試您的系統。為獲取更多詳細訊息，請查閱<span>hdparm</span>手冊幫助頁。如果<span>hdparm</span>使用的不好，會導致檔案系統破壞，因此試驗之前請做好每個備份<span>!
			</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>也可以設置資料庫使用的檔案系統參數：</p>
			<p>
			如果不需要知道檔案最後一次訪問的時間（這對資料庫伺服器並沒有實際的用途），可以用<span>-o 
			noatime</span>選項安裝檔案系統。這將跳過對檔案系統中的節點的最後一次訪問時間的更新，從而能夠避免一些硬盤搜索。</p>
			<p>
			在許多作業系統中，用<span>-o 
			async</span>選項安裝，可以將檔案系統設置為異步更新。如果電腦相當穩定，這應該給予您更高的性能而不需要犧牲太多的可靠性。（該標誌是<span>Linux</span>中預設開啟。）</dd>
			</dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="symbolic-links"></a>
			7.6.1.&nbsp;使用符號連結</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">7.6.1.1. 
				在Unix上使用針對資料庫的符號連結</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">7.6.1.2. 
				在Unix平台上使用資料表的符號連結<br>
				</a><a href="optimization.html#windows-symbolic-links">7.6.1.3. 
				在Windows平台上使用關於資料庫的符號連結</a></span></dt></dl></div><a class="indexterm" name="id2816368"></a><a class="indexterm" name="id2816374"></a><div class="section"><div class="titlepage"><div><div>
				<p>
				您可以將資料表和資料庫從資料庫目錄移動到其它的位置並且用指向新位置的符號連結進行替換。您可能需要這樣作，例如，移動資料庫到一個有更多空閒空間的檔案系統中或通過將資料表分散到不同的磁盤上以增加系統的訪問速度。</p>
				<p>
				推薦的方法值需要將資料庫通過符號連結指到不同的磁盤。符號連結資料表僅作為是最後的辦法。</p>
				<h4 class="title"><a name="symbolic-links-to-databases"></a>7.6.1.1. 在Unix上使用針對資料庫的符號連結</h4></div></div></div><a class="indexterm" name="id2816411"></a>
				<p>
				在<span>Unix</span>中，符號連結一個資料庫的方法是，首先在一些有空閒空間的硬盤上建立一個目錄，然後從<span>MySQL</span>數據目錄中建立它的一個符號連結。</p>
				<pre><span>shell&gt; </span><b><span >mkdir /dr1/databases/test</span></b></pre>
				<pre><span>shell&gt; </span><b><span >ln -s /dr1/databases/test <i>/path/to/datadir</i></span></b></pre>
				<p>
				<span>MySQL</span>不支援連結一個目錄到多個資料庫。用一個符號連結替換一個資料庫目錄，只要您不在資料庫之間製作符號連結。假定您有一個資料庫<span>db1</span>在<span>MySQL</span>數據目錄下，然後生成一個符號連結<span>db2</span>指向 
				<span>db1</span>：</p>
				<pre><span>shell&gt; </span><b><span >cd <i>/path/to/datadir</i></span></b></pre>
				<pre><span>shell&gt; </span><span><b><span>ln -s db1 db2</span></b></span></pre>
				<p>
				對於<span>db1</span>中的任何資料表<span>tbl_a</span>，在<span>db2</span>也出現並且還是資料表<span>tbl_a</span>。如果一個客戶更新<span>db1.tbl_a</span>並且另一個客戶更新<span>db2.tbl_a</span>，可能會出現問題。</p>
				<p>
				然而，如果您真的需要這樣做，可以通過改變源檔案<span>mysys/my_symlink.c</span>來實現，在該檔案中您應搜尋下面的語句：</p>
				<p><span>if (!(MyFlags &amp; 
				MY_RESOLVE_LINK) ||</span></p>
				<p><span>&nbsp;&nbsp;&nbsp; (!lstat(filename,&amp;stat_buff) 
				&amp;&amp; S_ISLNK(stat_buff.st_mode)))</span></p>
				<p>
				將該語句修改為：</p>
				<p><span>if (1)</span></p>
				<p>
				請注意，對於所有的<span>Windows</span>伺服器，預設啟用符號連結支援。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-tables"></a>7.6.1.2. 在Unix平台上使用資料表的符號連結<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2816545"></a>
				<p>
				您不應在沒有完全可操作的<span>realpath()</span>使用的系統中對資料表進行符號連結。（<span>Linux</span>和<span>Solaris</span>支援<span>realpath()</span><span>)</span>。可以通過發出一個<span>SHOW 
				VARIABLES LIKE &#39;have_symlink&#39;</span>語句，檢查系統是否支援符號連結。</p>
				<p>
				只有<span>M</span><span>yISAM</span>資料表完全支援符號連結。對於其它資料表類型，如果試圖在作業系統中的檔案上用前面的任何語句使用符號連結，可能會出現奇怪的問題。</p>
				<p>
				對於<span>M</span><span>yISAM</span>資料表的符號連結的處理如下：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				在數據目錄指，一定會有資料表定義檔案、數據檔案和索引檔案。數據檔案和索引檔案可以移到別處和在數據目錄中符號連結替代。資料表定義檔案不能進行符號連結替換。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>可以分別通過符號連結將數據檔案和索引檔案指到不同的目錄。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果<strong><span>mysqld</span></strong>沒有運行，符號連結可以從伺服器命令行使用<span>ln 
				-s</span>手動完成。同樣，通過使用<span>DATA DIRECTORY</span>和<span>INDEX 
				DIRECTORY</span>選項建立資料表，您可以指示運行的<span>MySQL</span>伺服器執行符號連結。參見<a href="sql-syntax.html#create-table" title="13.1.5. CREATE TABLE Syntax">13.1.5節，「CREATE 
				TABLE語法」</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>
				myisamchk</span></strong>不用數據檔案或索引檔案替換符號連結。它直接工作在符號連結指向的檔案。任何臨時檔案建立在數據檔案或索引檔案所處的目錄中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><strong><span>註釋：</span></strong>當您刪掉一個資料表時，如果該資料表使用了符號連結，<em><span>符號連結和該符號連結指向的檔案都被刪除掉</span></em>。這就是您不應以系統<span>root</span>用戶運行<strong><span>mysqld</span></strong>或允許系統用戶對<span>MySQL</span>資料庫目錄有寫訪問權限的原因。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果您用<span>ALTER TABLE ... RENAME</span>重命名一個資料表並且不將資料表移到另一個資料庫，資料庫目錄中的符號連結被重新命名為一個新名字並且數據檔案和索引檔案也相應地重新命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果您用<span>ALTER TABLE ... RENAME</span>移動一個資料表到另一個資料庫，資料表移動到另一個資料庫目錄。舊的符號連結和其所指向的檔案被刪除。換句話說，新資料表不再被連結。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果不使用符號連結，您應對<strong><span>mysqld</span></strong>使用<span>--skip-symbolic-links</span>選項以確保沒有人能夠使用<strong><span>mysqld</span></strong>來刪除或重新命名數據目錄之外的檔案。</p>
				<p>
				資料表符號連結還不支援以下操作：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ALTER TABLE</span>忽略<span>DATA 
				DIRECTORY </span>和<span>INDEX DIRECTORY</span>資料表選項。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>BACKUP TABLE </span>和<span>RESTORE 
				TABLE</span>不考慮符號連結。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>.frm</span>檔案必須<em><span>絕不能是一個符號</span></em>連結（如前面所述，只有數據和索引檔案可以是符號連結）。如果試圖這樣做（例如，生成符號連結）會產生不正確的結果。假定您在<span>MySQL</span>數據目錄下有一個資料庫<span>db1</span>，該資料庫有一個資料表<span>tbl1</span>，並且在<span>db1</span>目錄中您製作了一個符號連結<span>tbl2</span>指向<span>tbl1</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><b><span >cd <i>/path/to/datadir</i>/db1</span></b></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.frm tbl2.frm</span></b></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.MYD tbl2.MYD</span></b></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>shell&gt; </span><span><b><span>ln -s tbl1.MYI tbl2.MYI</span></b></span></pre>
				<p>
				如果一個線程讀取<span>db1.tbl1</span>同時另一個線程更新 
				<span>db1.tbl2</span>會發生問題：</p>
				<p >
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>查詢緩存將變為「傻瓜」<span> (</span>它沒有辦法知道<span>tbl1</span>是否被更新，因此它返回過時的結果<span>)</span>。</p>
				<p >
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				<span>tbl2</span>上的<span>ALTER</span>語句也會失敗。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="windows-symbolic-links"></a>7.6.1.3. 在Windows平台上使用關於資料庫的符號連結</h4></div></div></div><a class="indexterm" name="id2816953"></a><a class="indexterm" name="id2816959"></a><a class="indexterm" name="id2816966"></a></div></div></div></div><div>
<p>
<span>Windows</span>的<strong><span>mysqld-max</span></strong>和<span>mysql-max-nt</span>伺服器使用<span>-DUSE_SYMDIR</span>選項編譯成。允許您放置資料庫目錄到一個不同的硬盤，通過設置一個符號連結指向它。這類似於<span>Unix</span>中的符號連結，儘管設置連結的過程不同。</p>
<p>
符號連結預設為啟用。如果您不需要，使用<span>skip-symbolic-links</span>選項來禁用它：</p>
<pre><span>[mysqld]</span></pre>
<p><span>skip-symbolic-links</span></p>
<p>
在<span>Windows</span>中，通過在數據目錄中建立一個檔案，該檔案包含目標目錄的路徑，您可以為<span>MySQL</span>資料庫建立一個符號連結。該檔案應該被命名為<span>db_name.sym</span>，其中<span><i><span>db_name</span></i></span>是資料庫名。</p>
<p>
假定<span>MySQ</span>數據目錄是<span>C:\mysql\data</span>並且您想要資料庫<span>foo</span>放置在<span>D:\data\foo</span>。設置一個符號連結如下所示：</p>
<p>
<span>1.<span>&nbsp;&nbsp;&nbsp;
</span></span>確保<span>D:\data\foo</span>目錄存在，如果必要建立它。如果您在數據目錄內有一個命名為<span>foo</span>的資料庫目錄，您應移動它到<span>D:\data</span>目錄。否則，符號連結無效。為避免出現問題，當您移動資料庫目錄時伺服器不應該運行。</p>
<p>
<span>2.<span>&nbsp;&nbsp;&nbsp;
</span></span>建立一個文本檔案<span>C:\mysql\data\foo.sym</span>，該本文檔案包含路徑名<span>D:\data\foo\</span>。</p>
<p>此後，資料庫<span>foo</span>建立的所有資料表將建立在<span>D:\data\foo</span>檔案中。<em><span>請注意，如果在<span>MySQL</span>數據目錄中存在同名的資料庫目錄，不能使用符號連結</span></em>。</p>
<hr><p>
      這是MySQL參考手冊的翻譯版本，關於MySQL參考手冊，<span class="GramE">請訪問</span><a target="_top"  href="http://dev.mysql.com/doc/mysql/en">dev.mysql.com</a>。 
		原始參考手冊為英文版，與英文版參考手冊相比，本翻譯版可能不是最新的。</p></div>
</body></html>
