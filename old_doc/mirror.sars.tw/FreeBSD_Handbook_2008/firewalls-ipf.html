<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org" />
<title>IPFILTER (IPF) 防火牆</title>
<meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.79" />
<link rel="HOME" title="FreeBSD 使用手冊" href="index.html" />
<link rel="UP" title="防火牆" href="firewalls.html" />
<link rel="PREVIOUS" title="OpenBSD 封包過濾器 (Packet Filter, PF)及 ALTQ"
href="firewalls-pf.html" />
<link rel="NEXT" title="IPFW" href="firewalls-ipfw.html" />
<link rel="STYLESHEET" type="text/css" href="docbook.css" />
<meta http-equiv="Content-Type" content="text/html; charset=Big5" />
</head>
<body class="SECT1" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#840084"
alink="#0000FF">
<div class="NAVHEADER">
<table summary="Header navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<th colspan="3" align="center">FreeBSD 使用手冊</th>
</tr>

<tr>
<td width="10%" align="left" valign="bottom"><a href="firewalls-pf.html"
accesskey="P">Prev</a></td>
<td width="80%" align="center" valign="bottom">Chapter 28 防火牆</td>
<td width="10%" align="right" valign="bottom"><a href="firewalls-ipfw.html"
accesskey="N">Next</a></td>
</tr>
</table>

<hr align="LEFT" width="100%" />
</div>

<div class="SECT1">
<h1 class="SECT1"><a id="FIREWALLS-IPF" name="FIREWALLS-IPF">28.5 IPFILTER (IPF)
防火牆</a></h1>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> 此一節的內容仍在陸續補充、更新，所以本節內容可能並未完全符合現況。</p>
</blockquote>
</div>

<p>IPFILTER 的作者為 Darren Reed。IPFILTER 並非得綁某特定作業系統才行： 它是個跨 OS
平台的 open source 應用程式，且已被移植到 FreeBSD、NetBSD、OpenBSD、<span
class="TRADEMARK">SunOS</span>&#8482;、HP/UX 以及 <span
class="TRADEMARK">Solaris</span>&#8482; 這些作業系統上。此外，IPFILTER
的支援、維護也相當積極，也有定期釋出的更新版。</p>

<p>IPFILTER is based on a kernel-side firewall and <acronym class="ACRONYM">NAT</acronym>
mechanism that can be controlled and monitored by userland interface programs. The
firewall rules can be set or deleted with the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipf</span>(8)</span></a> utility. The
<acronym class="ACRONYM">NAT</acronym> rules can be set or deleted with the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipnat</span>(1)</span></a> utility. The
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipfstat</span>(8)</span></a> utility can
print run-time statistics for the kernel parts of IPFILTER. The <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipmon&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipmon</span>(8)</span></a> program can
log IPFILTER actions to the system log files.</p>

<p>IPF was originally written using a rule processing logic of 「the last matching rule
wins」 and used only stateless type of rules. Over time IPF has been enhanced to include
a 「quick」 option and a stateful 「keep state」 option which drastically modernized the
rules processing logic. IPF's official documentation covers the legacy rule coding
parameters and the legacy rule file processing logic. The modernized functions are only
included as additional options, completely understating their benefits in producing a far
superior secure firewall.</p>

<p>The instructions contained in this section are based on using rules that contain the
「quick」 option and the stateful 「keep state」 option. This is the basic framework for
coding an inclusive firewall rule set.</p>

<p>An inclusive firewall only allows packets matching the rules to pass through. This way
you can control what services can originate behind the firewall destined for the public
Internet and also control the services which can originate from the public Internet
accessing your private network. Everything else is blocked and logged by default design.
Inclusive firewalls are much, much more secure than exclusive firewall rule sets and is
the only rule set type covered herein.</p>

<p>For detailed explanation of the legacy rules processing method see: <a
href="http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1"
target="_top">http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1</a> and <a
href="http://coombs.anu.edu.au/~avalon/ip-filter.html"
target="_top">http://coombs.anu.edu.au/~avalon/ip-filter.html</a>.</p>

<p>IPF 的 FAQ 位於 <a href="http://www.phildev.net/ipf/index.html"
target="_top">http://www.phildev.net/ipf/index.html</a>.</p>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37558" name="AEN37558">28.5.1 啟用 IPF</a></h2>

<p>IPF is included in the basic FreeBSD install as a separate run time loadable module.
The system will dynamically load the IPF kernel loadable module when the rc.conf
statement <tt class="LITERAL">ipfilter_enable="YES"</tt> is used. The loadable module was
created with logging enabled and the <tt class="LITERAL">default pass all</tt> options.
You do not need to compile IPF into the FreeBSD kernel just to change the default to <tt
class="LITERAL">block all</tt>, you can do that by just coding a block all rule at the
end of your rule set.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37567" name="AEN37567">28.5.2 kernel 選項</a></h2>

<p>在編譯 FreeBSD kernel 時，並不必完全加入下列的選項來啟用 IPF。
在這裡只是要列出給你參考的一些資訊而已。 將 IPF 編譯入 kernel 中，會導致無法使用 kernel
的動態載入模組。</p>

<p>Sample kernel config IPF option statements are in the <tt
class="FILENAME">/usr/src/sys/conf/NOTES</tt> kernel source (<tt
class="FILENAME">/usr/src/sys/<tt class="REPLACEABLE"><i>arch</i></tt>/conf/LINT</tt> for
FreeBSD&nbsp;4.X) and are reproduced here:</p>

<pre class="PROGRAMLISTING">
options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK
</pre>

<p><tt class="LITERAL">options IPFILTER</tt> enables support for the 「IPFILTER」
firewall.</p>

<p><tt class="LITERAL">options IPFILTER_LOG</tt> enables the option to have IPF log
traffic by writing to the <tt class="DEVICENAME">ipl</tt> packet logging pseudo——device
for every rule that has the <tt class="LITERAL">log</tt> keyword.</p>

<p><tt class="LITERAL">options IPFILTER_DEFAULT_BLOCK</tt> changes the default behavior
so any packet not matching a firewall <tt class="LITERAL">pass</tt> rule gets
blocked.</p>

<p>These settings will take effect only after you have built and installed a kernel with
them set.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37597" name="AEN37597">28.5.3 可用的 rc.conf 選項</a></h2>

<p>須在 <tt class="FILENAME">/etc/rc.conf</tt> 內加入下列內容，以便在開機時就會啟用
IPF：</p>

<pre class="PROGRAMLISTING">
ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # IPF 防火牆規則設定檔
ipmon_enable="YES"                # 啟用 IP 監控記錄
ipmon_flags="-Ds"                 # D = 使用服務程序 (daemon) 啟動
                                  # s = 使用 syslog 記錄
                                  # v = 記錄於 tcp window, ack, seq
                                  # n = 將 IP 及 port 對應至名稱中
</pre>

<p>If you have a LAN behind this firewall that uses the reserved private IP address
ranges, then you need to add the following to enable <acronym
class="ACRONYM">NAT</acronym> functionality:</p>

<pre class="PROGRAMLISTING">
gateway_enable="YES"              # 啟用 LAN Gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat
</pre>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37605" name="AEN37605">28.5.4 IPF</a></h2>

<p>The ipf command is used to load your rules file. Normally you create a file containing
your custom rules and use this command to replace in mass the currently running firewall
internal rules:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">ipf -Fa -f /etc/ipf.rules</kbd>
</pre>

<p><code class="OPTION">-Fa</code> means flush all internal rules tables.</p>

<p><code class="OPTION">-f</code> means this is the file to read for the rules to
load.</p>

<p>This gives you the ability to make changes to your custom rules file, run the above
IPF command, and thus update the running firewall with a fresh copy of all the rules
without having to reboot the system. This method is very convenient for testing new rules
as the procedure can be executed as many times as needed.</p>

<p>See the <a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipf</span>(8)</span></a> manual page for
details on the other flags available with this command.</p>

<p>The <a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipf</span>(8)</span></a> command expects
the rules file to be a standard text file. It will not accept a rules file written as a
script with symbolic substitution.</p>

<p>There is a way to build IPF rules that utilizes the power of script symbolic
substitution. For more information, see <a
href="firewalls-ipf.html#FIREWALLS-IPF-RULES-SCRIPT">Section 28.5.9</a>.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37629" name="AEN37629">28.5.5 IPFSTAT</a></h2>

<p>The default behavior of <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipfstat</span>(8)</span></a> is to
retrieve and display the totals of the accumulated statistics gathered as a result of
applying the user coded rules against packets going in and out of the firewall since it
was last started, or since the last time the accumulators were reset to zero by the <tt
class="COMMAND">ipf -Z</tt> command.</p>

<p>See the <a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipfstat</span>(8)</span></a> manual page
for details.</p>

<p>The default <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipfstat</span>(8)</span></a> command
output will look something like this:</p>

<pre class="SCREEN">
input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 <acronym class="ACRONYM">TCP</acronym> RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 <acronym class="ACRONYM">TCP</acronym> cksum fails(in): 0 (out): 0
 Packet log flags set: (0)
</pre>

<p>When supplied with either <code class="OPTION">-i</code> for inbound or <code
class="OPTION">-o</code> for outbound, it will retrieve and display the appropriate list
of filter rules currently installed and in use by the kernel.</p>

<p><tt class="COMMAND">ipfstat -in</tt> displays the inbound internal rules table with
rule number.</p>

<p><tt class="COMMAND">ipfstat -on</tt> displays the outbound internal rules table with
the rule number.</p>

<p>The output will look something like this:</p>

<pre class="SCREEN">
@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state
</pre>

<p><tt class="COMMAND">ipfstat -ih</tt> displays the inbound internal rules table,
prefixing each rule with a count of how many times the rule was matched.</p>

<p><tt class="COMMAND">ipfstat -oh</tt> displays the outbound internal rules table,
prefixing each rule with a count of how many times the rule was matched.</p>

<p>The output will look something like this:</p>

<pre class="SCREEN">
2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state
</pre>

<p>One of the most important functions of the <tt class="COMMAND">ipfstat</tt> command is
the <code class="OPTION">-t</code> flag which displays the state table in a way similar
to the way <a href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">top</span>(1)</span></a> shows the
FreeBSD running process table. When your firewall is under attack this function gives you
the ability to identify, drill down to, and see the attacking packets. The optional
sub-flags give the ability to select the destination or source IP, port, or protocol that
you want to monitor in real time. See the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipfstat</span>(8)</span></a> manual page
for details.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37677" name="AEN37677">28.5.6 IPMON</a></h2>

<p>In order for <tt class="COMMAND">ipmon</tt> to work properly, the kernel option
IPFILTER_LOG must be turned on. This command has two different modes that it can be used
in. Native mode is the default mode when you type the command on the command line without
the <code class="OPTION">-D</code> flag.</p>

<p>Daemon mode is for when you want to have a continuous system log file available so
that you can review logging of past events. This is how FreeBSD and IPFILTER are
configured to work together. FreeBSD has a built in facility to automatically rotate
system logs. That is why outputting the log information to syslogd is better than the
default of outputting to a regular file. In the default <tt class="FILENAME">rc.conf</tt>
file you see the ipmon_flags statement uses the <code class="OPTION">-Ds</code>
flags:</p>

<pre class="PROGRAMLISTING">
ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names
</pre>

<p>The benefits of logging are obvious. It provides the ability to review, after the
fact, information such as which packets had been dropped, what addresses they came from
and where they were going. These all give you a significant edge in tracking down
attackers.</p>

<p>Even with the logging facility enabled, IPF will not generate any rule logging on its
own. The firewall administrator decides what rules in the rule set he wants to log and
adds the log keyword to those rules. Normally only deny rules are logged.</p>

<p>It is very customary to include a default deny everything rule with the log keyword
included as your last rule in the rule set. This way you get to see all the packets that
did not match any of the rules in the rule set.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37695" name="AEN37695">28.5.7 IPMON Logging</a></h2>

<p><b class="APPLICATION">Syslogd</b> uses its own special method for segregation of log
data. It uses special groupings called 「facility」 and “level”. IPMON in <code
class="OPTION">-Ds</code> mode uses <tt class="LITERAL">security</tt> (<tt
class="LITERAL">local0</tt> in 4.X) as the 「facility」 name. All IPMON logged data goes
to <tt class="LITERAL">security</tt> (<tt class="LITERAL">local0</tt> in 4.X). The
following levels can be used to further segregate the logged data if desired:</p>

<pre class="SCREEN">
LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short
</pre>

<p>To setup IPFILTER to log all data to <tt class="FILENAME">/var/log/ipfilter.log</tt>,
you will need to create the file. The following command will do that:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">touch /var/log/ipfilter.log</kbd>
</pre>

<p>The syslog function is controlled by definition statements in the <tt
class="FILENAME">/etc/syslog.conf</tt> file. The <tt class="FILENAME">syslog.conf</tt>
file offers considerable flexibility in how syslog will deal with system messages issued
by software applications like IPF.</p>

<p>Add the following statement to <tt class="FILENAME">/etc/syslog.conf</tt> for
FreeBSD&nbsp;5.X and later:</p>

<pre class="PROGRAMLISTING">
security.* /var/log/ipfilter.log
</pre>

<p>Or add the following statement to <tt class="FILENAME">/etc/syslog.conf</tt> for
FreeBSD&nbsp;4.X:</p>

<pre class="PROGRAMLISTING">
local0.* /var/log/ipfilter.log
</pre>

<p>The <tt class="LITERAL">security.*</tt> (<tt class="LITERAL">local0</tt> for 4.X)
means to write all the logged messages to the coded file location.</p>

<p>To activate the changes to <tt class="FILENAME">/etc/syslog.conf</tt> you can reboot
or bump the syslog task into re-reading <tt class="FILENAME">/etc/syslog.conf</tt> by
running <tt class="COMMAND">/etc/rc.d/syslogd reload</tt> (<tt class="COMMAND">killall
-HUP syslogd</tt> in FreeBSD 4.X).</p>

<p>Do not forget to change <tt class="FILENAME">/etc/newsyslog.conf</tt> to rotate the
new log you just created above.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37730" name="AEN37730">28.5.8 The Format of Logged
Messages</a></h2>

<p>Messages generated by <tt class="COMMAND">ipmon</tt> consist of data fields separated
by white space. Fields common to all messages are:</p>

<ol type="1">
<li>
<p>The date of packet receipt.</p>
</li>

<li>
<p>The time of packet receipt. This is in the form HH:MM:SS.F, for hours, minutes,
seconds, and fractions of a second (which can be several digits long).</p>
</li>

<li>
<p>The name of the interface the packet was processed on, e.g. <tt
class="DEVICENAME">dc0</tt>.</p>
</li>

<li>
<p>The group and rule number of the rule, e.g. <tt class="LITERAL">@0:17</tt>.</p>
</li>
</ol>

<p>These can be viewed with <tt class="COMMAND">ipfstat -in</tt>.</p>

<ol type="1">
<li>
<p>The action: p for passed, b for blocked, S for a short packet, n did not match any
rules, L for a log rule. The order of precedence in showing flags is: S, p, b, n, L. A
capital P or B means that the packet has been logged due to a global logging setting, not
a particular rule.</p>
</li>

<li>
<p>The addresses. This is actually three fields: the source address and port (separated
by a comma), the -&gt; symbol, and the destination address and port. 209.53.17.22,80
-&gt; 198.73.220.17,1722.</p>
</li>

<li>
<p><tt class="LITERAL">PR</tt> followed by the protocol name or number, e.g. PR tcp.</p>
</li>

<li>
<p><tt class="LITERAL">len</tt> followed by the header length and total length of the
packet, e.g. len 20 40.</p>
</li>
</ol>

<p>If the packet is a <acronym class="ACRONYM">TCP</acronym> packet, there will be an
additional field starting with a hyphen followed by letters corresponding to any flags
that were set. See the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipmon&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipmon</span>(8)</span></a> manual page
for a list of letters and their flags.</p>

<p>If the packet is an ICMP packet, there will be two fields at the end, the first always
being 「ICMP」, and the next being the ICMP message and sub-message type, separated by a
slash, e.g. ICMP 3/3 for a port unreachable message.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="FIREWALLS-IPF-RULES-SCRIPT"
name="FIREWALLS-IPF-RULES-SCRIPT">28.5.9 Building the Rule Script with Symbolic
Substitution</a></h2>

<p>Some experienced IPF users create a file containing the rules and code them in a
manner compatible with running them as a script with symbolic substitution. The major
benefit of doing this is that you only have to change the value associated with the
symbolic name and when the script is run all the rules containing the symbolic name will
have the value substituted in the rules. Being a script, you can use symbolic
substitution to code frequently used values and substitute them in multiple rules. You
will see this in the following example.</p>

<p>The script syntax used here is compatible with the sh, csh, and tcsh shells.</p>

<p>Symbolic substitution fields are prefixed with a dollar sign: <tt
class="LITERAL">$</tt>.</p>

<p>Symbolic fields do not have the $ prefix.</p>

<p>The value to populate the symbolic field must be enclosed with double quotes (<tt
class="LITERAL">"</tt>).</p>

<p>Start your rule file with something like this:</p>

<pre class="PROGRAMLISTING">
############# IPF 規則命令稿的開始  ########################

oif="dc0"            # 對外網路裝置的名稱
odns="192.0.2.11"    # ISP 的 DNS 伺服器 IP 位址
myip="192.0.2.7"     # 從我的 ISP 提供的靜態 IP
ks="keep state"
fks="flags S keep state"

# You can choose between building /etc/ipf.rules file
# from this script or running this script "as is".
#
# Uncomment only one line and comment out another.
#
# 1) This can be used for building /etc/ipf.rules:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) This can be used to run script "as is":
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Allow out access to my ISP's Domain name server.
pass out quick on $oif proto tcp from any to $odns port = 53 $fks
pass out quick on $oif proto udp from any to $odns port = 53 $ks

# Allow out non-secure standard www function
pass out quick on $oif proto tcp from $myip to any port = 80 $fks

# Allow out secure www function https over TLS SSL
pass out quick on $oif proto tcp from $myip to any port = 443 $fks
EOF
################## End of IPF rules script ########################
</pre>

<p>That is all there is to it. The rules are not important in this example; how the
symbolic substitution fields are populated and used are. If the above example was in a
file named <tt class="FILENAME">/etc/ipf.rules.script</tt>, you could reload these rules
by entering the following command:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">sh /etc/ipf.rules.script</kbd>
</pre>

<p>There is one problem with using a rules file with embedded symbolics: IPF does not
understand symbolic substitution, and cannot read such scripts directly.</p>

<p>This script can be used in one of two ways:</p>

<ul>
<li>
<p>Uncomment the line that begins with <tt class="LITERAL">cat</tt>, and comment out the
line that begins with <tt class="LITERAL">/sbin/ipf</tt>. Place <tt
class="LITERAL">ipfilter_enable="YES"</tt> into <tt class="FILENAME">/etc/rc.conf</tt> as
usual, and run script once after each modification to create or update <tt
class="FILENAME">/etc/ipf.rules</tt>.</p>
</li>

<li>
<p>Disable IPFILTER in system startup scripts by adding <tt
class="LITERAL">ipfilter_enable="NO"</tt> (this is default value) into <tt
class="FILENAME">/etc/rc.conf</tt> file.</p>

<p>Add a script like the following to your <tt class="FILENAME">/usr/local/etc/rc.d/</tt>
startup directory. The script should have an obvious name like <tt
class="FILENAME">ipf.loadrules.sh</tt>. The <tt class="FILENAME">.sh</tt> extension is
mandatory.</p>

<pre class="PROGRAMLISTING">
#!/bin/sh
sh /etc/ipf.rules.script
</pre>

<p>The permissions on this script file must be read, write, execute for owner <tt
class="USERNAME">root</tt>.</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd
class="USERINPUT">chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</kbd>
</pre>
</li>
</ul>

<p>從現在起，當系統開機時就會載入你所設的 IPF 規則。</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37805" name="AEN37805">28.5.10 IPF 規則</a></h2>

<p>A rule set is a group of ipf rules coded to pass or block packets based on the values
contained in the packet. The bi-directional exchange of packets between hosts comprises a
session conversation. The firewall rule set processes the packet two times, once on its
arrival from the public Internet host and again as it leaves for its return trip back to
the public Internet host. Each TCP/IP service (i.e. telnet, www, mail, etc.) is
predefined by its protocol, source and destination IP address, or the source and
destination port number. This is the basic selection criteria used to create rules which
will pass or block services.</p>

<p>IPF was originally written using a rules processing logic of 「the last matching rule
wins」 and used only stateless rules. Over time IPF has been enhanced to include a
「quick」 option and a stateful 「keep state」 option which drastically modernized the
rule processing logic.</p>

<p>The instructions contained in this section are based on using rules that contain the
「quick」 option and the stateful 「keep state」 option. This is the basic framework for
coding an inclusive firewall rule set.</p>

<p>An inclusive firewall only allows services matching the rules through. This way you
can control what services can originate behind the firewall destined for the public
Internet and also control the services which can originate from the public Internet
accessing your private network. Everything else is blocked and logged by default design.
Inclusive firewalls are much, much securer than exclusive firewall rule sets and is the
only rule set type covered herein.</p>

<div class="WARNING">
<blockquote class="WARNING">
<p><b>Warning:</b> When working with the firewall rules, be <span class="emphasis"><b
class="EMPHASIS">very careful</b></span>. Some configurations <span class="emphasis"><b
class="EMPHASIS">will lock you out</b></span> of the server. To be on the safe side, you
may wish to consider performing the initial firewall configuration from the local console
rather than doing it remotely e.g. via <b class="APPLICATION">ssh</b>.</p>
</blockquote>
</div>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37819" name="AEN37819">28.5.11 Rule Syntax</a></h2>

<p>The rule syntax presented here has been simplified to only address the modern stateful
rule context and 「first matching rule wins」 logic. For the complete legacy rule syntax
description see the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipf</span>(8)</span></a> manual
page.</p>

<p>A <tt class="LITERAL">#</tt> character is used to mark the start of a comment and may
appear at the end of a rule line or on its own line. Blank lines are ignored.</p>

<p>Rules contain keywords. These keywords have to be coded in a specific order from left
to right on the line. Keywords are identified in bold type. Some keywords have
sub-options which may be keywords themselves and also include more sub-options. Each of
the headings in the below syntax has a bold section header which expands on the
content.</p>

<p><tt class="REPLACEABLE"><i>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO
SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG STATEFUL</i></tt></p>

<p><tt class="REPLACEABLE"><i>ACTION</i></tt> = block | pass</p>

<p><tt class="REPLACEABLE"><i>IN-OUT</i></tt> = in | out</p>

<p><tt class="REPLACEABLE"><i>OPTIONS</i></tt> = log | quick | on interface-name</p>

<p><tt class="REPLACEABLE"><i>SELECTION</i></tt> = proto value | source/destination IP |
port = number | flags flag-value</p>

<p><tt class="REPLACEABLE"><i>PROTO</i></tt> = tcp/udp | udp | tcp | icmp</p>

<p><tt class="REPLACEABLE"><i>SRC_ADD,DST_ADDR</i></tt> = all | from object to object</p>

<p><tt class="REPLACEABLE"><i>OBJECT</i></tt> = IP address | any</p>

<p><tt class="REPLACEABLE"><i>PORT_NUM</i></tt> = port number</p>

<p><tt class="REPLACEABLE"><i>TCP_FLAG</i></tt> = S</p>

<p><tt class="REPLACEABLE"><i>STATEFUL</i></tt> = keep state</p>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37853" name="AEN37853">28.5.11.1 ACTION</a></h3>

<p>The action indicates what to do with the packet if it matches the rest of the filter
rule. Each rule <span class="emphasis"><b class="EMPHASIS">must</b></span> have a action.
The following actions are recognized:</p>

<p><tt class="LITERAL">block</tt> indicates that the packet should be dropped if the
selection parameters match the packet.</p>

<p><tt class="LITERAL">pass</tt> indicates that the packet should exit the firewall if
the selection parameters match the packet.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37861" name="AEN37861">28.5.11.2 IN-OUT</a></h3>

<p>A mandatory requirement is that each filter rule explicitly state which side of the
I/O it is to be used on. The next keyword must be either in or out and one or the other
has to be coded or the rule will not pass syntax checks.</p>

<p><tt class="LITERAL">in</tt> means this rule is being applied against an inbound packet
which has just been received on the interface facing the public Internet.</p>

<p><tt class="LITERAL">out</tt> means this rule is being applied against an outbound
packet destined for the interface facing the public Internet.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37868" name="AEN37868">28.5.11.3 OPTIONS</a></h3>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> These options must be used in the order shown here.</p>
</blockquote>
</div>

<p><tt class="LITERAL">log</tt> indicates that the packet header will be written to the
<tt class="DEVICENAME">ipl</tt> log (as described in the LOGGING section below) if the
selection parameters match the packet.</p>

<p><tt class="LITERAL">quick</tt> indicates that if the selection parameters match the
packet, this rule will be the last rule checked, allowing a 「short-circuit」 path to
avoid processing any following rules for this packet. This option is a mandatory
requirement for the modernized rules processing logic.</p>

<p><tt class="LITERAL">on</tt> indicates the interface name to be incorporated into the
selection parameters. Interface names are as displayed by <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ifconfig</span>(8)</span></a>. Using
this option, the rule will only match if the packet is going through that interface in
the specified direction (in/out). This option is a mandatory requirement for the
modernized rules processing logic.</p>

<p>When a packet is logged, the headers of the packet are written to the IPL packet
logging pseudo-device. Immediately following the log keyword, the following qualifiers
may be used (in this order):</p>

<p><tt class="LITERAL">body</tt> indicates that the first 128 bytes of the packet
contents will be logged after the headers.</p>

<p><tt class="LITERAL">first</tt> If the <tt class="LITERAL">log</tt> keyword is being
used in conjunction with a 「keep state」 option, it is recommended that this option is
also applied so that only the triggering packet is logged and not every packet which
thereafter matches the 「keep state」 information.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37888" name="AEN37888">28.5.11.4 SELECTION</a></h3>

<p>The keywords described in this section are used to describe attributes of the packet
to be interrogated when determining whether rules match or not. There is a keyword
subject, and it has sub-option keywords, one of which has to be selected. The following
general-purpose attributes are provided for matching, and must be used in this order:</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37891" name="AEN37891">28.5.11.5 PROTO</a></h3>

<p><tt class="LITERAL">proto</tt> is the subject keyword and must be coded along with one
of its corresponding keyword sub-option values. The value allows a specific protocol to
be matched against. This option is a mandatory requirement for the modernized rules
processing logic.</p>

<p><tt class="LITERAL">tcp/udp | udp | tcp | icmp</tt> or any protocol names found in <tt
class="FILENAME">/etc/protocols</tt> are recognized and may be used. The special protocol
keyword <tt class="LITERAL">tcp/udp</tt> may be used to match either a <acronym
class="ACRONYM">TCP</acronym> or a UDP packet, and has been added as a convenience to
save duplication of otherwise identical rules.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37900" name="AEN37900">28.5.11.6 SRC_ADDR/DST_ADDR</a></h3>

<p>The <tt class="LITERAL">all</tt> keyword is essentially a synonym for 「from any to
any」 with no other match parameters.</p>

<p><tt class="LITERAL">from src to dst</tt>: the from and to keywords are used to match
against IP addresses. Rules must specify BOTH source and destination parameters. <tt
class="LITERAL">any</tt> is a special keyword that matches any IP address. Examples of
use: 「from any to any」 or 「from 0.0.0.0/0 to any」 or “from any to 0.0.0.0/0」 or
「from 0.0.0.0 to any” or 「from any to 0.0.0.0」.</p>

<p>IP addresses may be specified as a dotted IP address numeric form/mask-length, or as
single dotted IP address numeric form.</p>

<p>There is no way to match ranges of IP addresses which do not express themselves easily
as mask-length. See this web page for help on writing mask-length: <a
href="http://jodies.de/ipcalc" target="_top">http://jodies.de/ipcalc</a>.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37911" name="AEN37911">28.5.11.7 PORT</a></h3>

<p>If a port match is included, for either or both of source and destination, then it is
only applied to <acronym class="ACRONYM">TCP</acronym> and UDP packets. When composing
port comparisons, either the service name from <tt class="FILENAME">/etc/services</tt> or
an integer port number may be used. When the port appears as part of the from object, it
matches the source port number; when it appears as part of the to object, it matches the
destination port number. The use of the port option with the <tt class="LITERAL">to</tt>
object is a mandatory requirement for the modernized rules processing logic. Example of
use: 「from any to any port = 80」</p>

<p>Port comparisons may be done in a number of forms, with a number of comparison
operators, or port ranges may be specified.</p>

<p>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | "eq" | "ne" | "lt" | "gt" |
"le" | "ge".</p>

<p>To specify port ranges, port "&lt;&gt;" | "&gt;&lt;"</p>

<div class="WARNING">
<blockquote class="WARNING">
<p><b>Warning:</b> Following the source and destination matching parameters, the
following two parameters are mandatory requirements for the modernized rules processing
logic.</p>
</blockquote>
</div>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37922" name="AEN37922">28.5.11.8 <acronym
class="ACRONYM">TCP</acronym>_FLAG</a></h3>

<p>Flags are only effective for <acronym class="ACRONYM">TCP</acronym> filtering. The
letters represents one of the possible flags that can be interrogated in the <acronym
class="ACRONYM">TCP</acronym> packet header.</p>

<p>The modernized rules processing logic uses the <tt class="LITERAL">flags S</tt>
parameter to identify the tcp session start request.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN37930" name="AEN37930">28.5.11.9 STATEFUL</a></h3>

<p><tt class="LITERAL">keep state</tt> indicates that on a pass rule, any packets that
match the rules selection parameters should activate the stateful filtering facility.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> This option is a mandatory requirement for the modernized rules
processing logic.</p>
</blockquote>
</div>
</div>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37936" name="AEN37936">28.5.12 Stateful Filtering</a></h2>

<p>Stateful filtering treats traffic as a bi-directional exchange of packets comprising a
session conversation. When activated, keep-state dynamically generates internal rules for
each anticipated packet being exchanged during the bi-directional session conversation.
It has the interrogation abilities to determine if the session conversation between the
originating sender and the destination are following the valid procedure of
bi-directional packet exchange. Any packets that do not properly fit the session
conversation template are automatically rejected as impostors.</p>

<p>Keep state will also allow ICMP packets related to a <acronym
class="ACRONYM">TCP</acronym> or UDP session through. So if you get ICMP type 3 code 4 in
response to some web surfing allowed out by a keep state rule, they will be automatically
allowed in. Any packet that IPF can be certain is part of an active session, even if it
is a different protocol, will be let in.</p>

<p>What happens is:</p>

<p>Packets destined to go out the interface connected to the public Internet are first
checked against the dynamic state table, if the packet matches the next expected packet
comprising in a active session conversation, then it exits the firewall and the state of
the session conversation flow is updated in the dynamic state table, the remaining
packets get checked against the outbound rule set.</p>

<p>Packets coming in to the interface connected to the public Internet are first checked
against the dynamic state table, if the packet matches the next expected packet
comprising a active session conversation, then it exits the firewall and the state of the
session conversation flow is updated in the dynamic state table, the remaining packets
get checked against the inbound rule set.</p>

<p>When the conversation completes it is removed from the dynamic state table.</p>

<p>Stateful filtering allows you to focus on blocking/passing new sessions. If the new
session is passed, all its subsequent packets will be allowed through automatically and
any impostors automatically rejected. If a new session is blocked, none of its subsequent
packets will be allowed through. Stateful filtering has technically advanced
interrogation abilities capable of defending against the flood of different attack
methods currently employed by attackers.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37949" name="AEN37949">28.5.13 Inclusive Rule Set
Example</a></h2>

<p>The following rule set is an example of how to code a very secure inclusive type of
firewall. An inclusive firewall only allows services matching pass rules through and
blocks all other by default. All firewalls have at the minimum two interfaces which have
to have rules to allow the firewall to function.</p>

<p>All <span class="TRADEMARK">UNIX</span>&reg; flavored systems including FreeBSD are
designed to use interface <tt class="DEVICENAME">lo0</tt> and IP address <tt
class="HOSTID">127.0.0.1</tt> for internal communication within the operating system. The
firewall rules must contain rules to allow free unmolested movement of these special
internally used packets.</p>

<p>The interface which faces the public Internet is the one where you place your rules to
authorize and control access out to the public Internet and access requests arriving from
the public Internet. This can be your user PPP <tt class="DEVICENAME">tun0</tt> interface
or your NIC that is connected to your DSL or cable modem.</p>

<p>In cases where one or more NICs are cabled to private LANs behind the firewall, those
interfaces must have a rule coded to allow free unmolested movement of packets
originating from those LAN interfaces.</p>

<p>The rules should be first organized into three major sections: all the free unmolested
interfaces, the public interface outbound, and the public interface inbound.</p>

<p>The rules in each of the public interface sections should have the most frequently
matched rules placed before less commonly matched rules, with the last rule in the
section blocking and logging all packets on that interface and direction.</p>

<p>The Outbound section in the following rule set only contains 'pass' rules which
contain selection values that uniquely identify the service that is authorized for public
Internet access. All the rules have the 'quick', 'on', 'proto', 'port', and 'keep state'
option coded. The 'proto tcp' rules have the 'flag' option included to identify the
session start request as the triggering packet to activate the stateful facility.</p>

<p>The Inbound section has all the blocking of undesirable packets first, for two
different reasons. The first is that these things being blocked may be part of an
otherwise valid packet which may be allowed in by the later authorized service rules. The
second reason is that by having a rule that explicitly blocks selected packets that I
receive on an infrequent basis and that I do not want to see in the log, they will not be
caught by the last rule in the section which blocks and logs all packets which have
fallen through the rules. The last rule in the section which blocks and logs all packets
is how you create the legal evidence needed to prosecute the people who are attacking
your system.</p>

<p>Another thing you should take note of, is there is no response returned for any of the
undesirable stuff, their packets just get dropped and vanish. This way the attacker has
no knowledge if his packets have reached your system. The less the attackers can learn
about your system, the more time they must invest before actually doing something bad.
The inbound 'nmap OS fingerprint' attempts rule I log the first occurrence because this
is something a attacker would do.</p>

<p>Any time you see log messages on a rule with 'log first'. You should do an <tt
class="COMMAND">ipfstat -hio</tt> command to see the number of times the rule has been
matched so you know if you are being flooded, i.e. under attack.</p>

<p>When you log packets with port numbers you do not recognize, look it up in <tt
class="FILENAME">/etc/services</tt> or go to <a
href="http://www.securitystats.com/tools/portsearch.php"
target="_top">http://www.securitystats.com/tools/portsearch.php</a> and do a port number
lookup to find what the purpose of that port number is.</p>

<p>Check out this link for port numbers used by Trojans <a
href="http://www.simovits.com/trojans/trojans.html"
target="_top">http://www.simovits.com/trojans/trojans.html</a>.</p>

<p>The following rule set is a complete very secure 'inclusive' type of firewall rule set
that I have used on my system. You can not go wrong using this rule set for your own.
Just comment out any pass rules for services that you do not want to authorize.</p>

<p>If you see messages in your log that you want to stop seeing just add a block rule in
the inbound section.</p>

<p>You have to change the <tt class="DEVICENAME">dc0</tt> interface name in every rule to
the interface name of the Nic card that connects your system to the public Internet. For
user PPP it would be <tt class="DEVICENAME">tun0</tt>.</p>

<p>Add the following statements to <tt class="FILENAME">/etc/ipf.rules</tt>:</p>

<pre class="PROGRAMLISTING">
#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the
# firewall on the private network
# or from this gateway server destine for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym
class="ACRONYM">NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out non-secure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FBSD CVSUP function
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois for LAN PC to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule enforces the block all by default logic.
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Interrogate packets originating from the public Internet
# destine for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it's the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence stops a .denial of service. attack targeted
# at filling up your log file space.
# This rule enforces the block all by default logic.
block in log first quick on dc0 all
################### End of rules file #####################################
</pre>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN37980" name="AEN37980">28.5.14 <acronym
class="ACRONYM">NAT</acronym></a></h2>

<p><acronym class="ACRONYM">NAT</acronym> stands for Network Address Translation. To
those familiar with <span class="TRADEMARK">Linux</span>&reg;, this concept is called IP
Masquerading; <acronym class="ACRONYM">NAT</acronym> and IP Masquerading are the same
thing. One of the many things the IPF <acronym class="ACRONYM">NAT</acronym> function
enables is the ability to have a private Local Area Network (LAN) behind the firewall
sharing a single ISP assigned IP address on the public Internet.</p>

<p>You may ask why would someone want to do this. ISPs normally assign a dynamic IP
address to their non-commercial users. Dynamic means that the IP address can be different
each time you dial in and log on to your ISP, or for cable and DSL modem users when you
power off and then power on your modems you can get assigned a different IP address. This
IP address is how you are known to the public Internet.</p>

<p>Now lets say you have five PCs at home and each one needs Internet access. You would
have to pay your ISP for an individual Internet account for each PC and have five phone
lines.</p>

<p>With <acronym class="ACRONYM">NAT</acronym> you only need a single account with your
ISP, then cable your other four PCs to a switch and the switch to the NIC in your FreeBSD
system which is going to service your LAN as a gateway. <acronym
class="ACRONYM">NAT</acronym> will automatically translate the private LAN IP address for
each separate PC on the LAN to the single public IP address as it exits the firewall
bound for the public Internet. It also does the reverse translation for returning
packets.</p>

<p><acronym class="ACRONYM">NAT</acronym> is most often accomplished without the
approval, or knowledge, of your ISP and in most cases is grounds for your ISP terminating
your account if found out. Commercial users pay a lot more for their Internet connection
and usually get assigned a block of static IP address which never change. The ISP also
expects and consents to their Commercial customers using <acronym
class="ACRONYM">NAT</acronym> for their internal private LANs.</p>

<p>There is a special range of IP addresses reserved for <acronym
class="ACRONYM">NAT</acronym>ed private LAN IP address. According to RFC 1918, you can
use the following IP ranges for private nets which will never be routed directly to the
public Internet:</p>

<div class="INFORMALTABLE"><a id="AEN38006" name="AEN38006"></a>
<table border="0" frame="void" width="100%" class="CALSTABLE">
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td>Start IP <tt class="HOSTID">10.0.0.0</tt></td>
<td>-</td>
<td>Ending IP <tt class="HOSTID">10.255.255.255</tt></td>
</tr>

<tr>
<td>Start IP <tt class="HOSTID">172.16.0.0</tt></td>
<td>-</td>
<td>Ending IP <tt class="HOSTID">172.31.255.255</tt></td>
</tr>

<tr>
<td>Start IP <tt class="HOSTID">192.168.0.0</tt></td>
<td>-</td>
<td>Ending IP <tt class="HOSTID">192.168.255.255</tt></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38030" name="AEN38030">28.5.15 IP<acronym
class="ACRONYM">NAT</acronym></a></h2>

<p><acronym class="ACRONYM">NAT</acronym> rules are loaded by using the <tt
class="COMMAND">ipnat</tt> command. Typically the <acronym class="ACRONYM">NAT</acronym>
rules are stored in <tt class="FILENAME">/etc/ipnat.rules</tt>. See <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=1"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipnat</span>(1)</span></a> for
details.</p>

<p>When changing the <acronym class="ACRONYM">NAT</acronym> rules after <acronym
class="ACRONYM">NAT</acronym> has been started, make your changes to the file containing
the NAT rules, then run ipnat command with the <code class="OPTION">-CF</code> flags to
delete the internal in use <acronym class="ACRONYM">NAT</acronym> rules and flush the
contents of the translation table of all active entries.</p>

<p>To reload the <acronym class="ACRONYM">NAT</acronym> rules issue a command like
this:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">ipnat -CF -f /etc/ipnat.rules</kbd>
</pre>

<p>To display some statistics about your <acronym class="ACRONYM">NAT</acronym>, use this
command:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">ipnat -s</kbd>
</pre>

<p>To list the <acronym class="ACRONYM">NAT</acronym> table's current mappings, use this
command:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">ipnat -l</kbd>
</pre>

<p>To turn verbose mode on, and display information relating to rule processing and
active rules/table entries:</p>

<pre class="SCREEN">
<samp class="PROMPT">#</samp> <kbd class="USERINPUT">ipnat -v</kbd>
</pre>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38071" name="AEN38071">28.5.16 IP<acronym
class="ACRONYM">NAT</acronym> Rules</a></h2>

<p><acronym class="ACRONYM">NAT</acronym> rules are very flexible and can accomplish many
different things to fit the needs of commercial and home users.</p>

<p>The rule syntax presented here has been simplified to what is most commonly used in a
non-commercial environment. For a complete rule syntax description see the <a
href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=5"><span
class="CITEREFENTRY"><span class="REFENTRYTITLE">ipnat</span>(5)</span></a> manual
page.</p>

<p>The syntax for a <acronym class="ACRONYM">NAT</acronym> rule looks something like
this:</p>

<pre class="PROGRAMLISTING">
map <tt class="REPLACEABLE"><i>IF</i></tt> <tt
class="REPLACEABLE"><i>LAN_IP_RANGE</i></tt> -&gt; <tt
class="REPLACEABLE"><i>PUBLIC_ADDRESS</i></tt>
</pre>

<p>The keyword <tt class="LITERAL">map</tt> starts the rule.</p>

<p>Replace <tt class="REPLACEABLE"><i>IF</i></tt> with the external interface.</p>

<p>The <tt class="REPLACEABLE"><i>LAN_IP_RANGE</i></tt> is what your internal clients use
for IP Addressing, usually this is something like <tt
class="HOSTID">192.168.1.0/24</tt>.</p>

<p>The <tt class="REPLACEABLE"><i>PUBLIC_ADDRESS</i></tt> can either be the external IP
address or the special keyword <tt class="LITERAL">0/32</tt>, which means to use the IP
address assigned to <tt class="REPLACEABLE"><i>IF</i></tt>.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38097" name="AEN38097">28.5.17 How <acronym
class="ACRONYM">NAT</acronym> works</a></h2>

<p>A packet arrives at the firewall from the LAN with a public destination. It passes
through the outbound filter rules, <acronym class="ACRONYM">NAT</acronym> gets his turn
at the packet and applies its rules top down, first matching rule wins. <acronym
class="ACRONYM">NAT</acronym> tests each of its rules against the packets interface name
and source IP address. When a packets interface name matches a <acronym
class="ACRONYM">NAT</acronym> rule then the [source IP address, i.e. private LAN IP
address] of the packet is checked to see if it falls within the IP address range
specified to the left of the arrow symbol on the <acronym class="ACRONYM">NAT</acronym>
rule. On a match the packet has its source IP address rewritten with the public IP
address obtained by the <tt class="LITERAL">0/32</tt> keyword. <acronym
class="ACRONYM">NAT</acronym> posts a entry in its internal <acronym
class="ACRONYM">NAT</acronym> table so when the packet returns from the public Internet
it can be mapped back to its original private IP address and then passed to the filter
rules for processing.</p>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38108" name="AEN38108">28.5.18 Enabling IP<acronym
class="ACRONYM">NAT</acronym></a></h2>

<p>To enable IP<acronym class="ACRONYM">NAT</acronym> add these statements to <tt
class="FILENAME">/etc/rc.conf</tt>.</p>

<p>To enable your machine to route traffic between interfaces:</p>

<pre class="PROGRAMLISTING">
gateway_enable="YES"
</pre>

<p>To start IP<acronym class="ACRONYM">NAT</acronym> automatically each time:</p>

<pre class="PROGRAMLISTING">
ipnat_enable="YES"
</pre>

<p>To specify where to load the IP<acronym class="ACRONYM">NAT</acronym> rules from:</p>

<pre class="PROGRAMLISTING">
ipnat_rules="/etc/ipnat.rules"
</pre>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38122" name="AEN38122">28.5.19 <acronym
class="ACRONYM">NAT</acronym> for a very large LAN</a></h2>

<p>For networks that have large numbers of PC's on the LAN or networks with more than a
single LAN, the process of funneling all those private IP addresses into a single public
IP address becomes a resource problem that may cause problems with the same port numbers
being used many times across many <acronym class="ACRONYM">NAT</acronym>ed LAN PC's,
causing collisions. There are two ways to relieve this resource problem.</p>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN38127" name="AEN38127">28.5.19.1 Assigning Ports to
Use</a></h3>

<p>A normal NAT rule would look like:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 0/32
</pre>

<p>In the above rule the packet's source port is unchanged as the packet passes through
IP<acronym class="ACRONYM">NAT</acronym>. By adding the portmap keyword you can tell
IP<acronym class="ACRONYM">NAT</acronym> to only use source ports in a range. For example
the following rule will tell IP<acronym class="ACRONYM">NAT</acronym> to modify the
source port to be within that range:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000
</pre>

<p>Additionally we can make things even easier by using the <tt class="LITERAL">auto</tt>
keyword to tell IP<acronym class="ACRONYM">NAT</acronym> to determine by itself which
ports are available to use:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto
</pre>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN38140" name="AEN38140">28.5.19.2 Using a pool of public
addresses</a></h3>

<p>In very large LANs there comes a point where there are just too many LAN addresses to
fit into a single public address. By changing the following rule:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 204.134.75.1
</pre>

<p>Currently this rule maps all connections through <tt class="HOSTID">204.134.75.1</tt>.
This can be changed to specify a range:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 204.134.75.1-10
</pre>

<p>Or a subnet using CIDR notation such as:</p>

<pre class="PROGRAMLISTING">
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24
</pre>
</div>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38149" name="AEN38149">28.5.20 Port Redirection</a></h2>

<p>A very common practice is to have a web server, email server, database server and DNS
server each segregated to a different PC on the LAN. In this case the traffic from these
servers still have to be <acronym class="ACRONYM">NAT</acronym>ed, but there has to be
some way to direct the inbound traffic to the correct LAN PCs. IP<acronym
class="ACRONYM">NAT</acronym> has the redirection facilities of <acronym
class="ACRONYM">NAT</acronym> to solve this problem. Lets say you have your web server on
LAN address <tt class="HOSTID">10.0.10.25</tt> and your single public IP address is <tt
class="HOSTID">20.20.20.5</tt> you would code the rule like this:</p>

<pre class="PROGRAMLISTING">
rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80
</pre>

<p>or:</p>

<pre class="PROGRAMLISTING">
rdr dc0 0/32 port 80 -&gt; 10.0.10.25 port 80
</pre>

<p>or for a LAN DNS Server on LAN address of <tt class="HOSTID">10.0.10.33</tt> that
needs to receive public DNS requests:</p>

<pre class="PROGRAMLISTING">
rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp
</pre>
</div>

<div class="SECT2">
<h2 class="SECT2"><a id="AEN38163" name="AEN38163">28.5.21 FTP and <acronym
class="ACRONYM">NAT</acronym></a></h2>

<p>FTP is a dinosaur left over from the time before the Internet as it is known today,
when research universities were leased lined together and FTP was used to share files
among research Scientists. This was a time when data security was not a consideration.
Over the years the FTP protocol became buried into the backbone of the emerging Internet
and its username and password being sent in clear text was never changed to address new
security concerns. FTP has two flavors, it can run in active mode or passive mode. The
difference is in how the data channel is acquired. Passive mode is more secure as the
data channel is acquired be the ordinal ftp session requester. For a real good
explanation of FTP and the different modes see <a
href="http://www.slacksite.com/other/ftp.html"
target="_top">http://www.slacksite.com/other/ftp.html</a>.</p>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN38168" name="AEN38168">28.5.21.1 IP<acronym
class="ACRONYM">NAT</acronym> Rules</a></h3>

<p>IP<acronym class="ACRONYM">NAT</acronym> has a special built in FTP proxy option which
can be specified on the <acronym class="ACRONYM">NAT</acronym> map rule. It can monitor
all outbound packet traffic for FTP active or passive start session requests and
dynamically create temporary filter rules containing only the port number really in use
for the data channel. This eliminates the security risk FTP normally exposes the firewall
to from having large ranges of high order port numbers open.</p>

<p>This rule will handle all the traffic for the internal LAN:</p>

<pre class="PROGRAMLISTING">
map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
</pre>

<p>This rule handles the FTP traffic from the gateway:</p>

<pre class="PROGRAMLISTING">
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
</pre>

<p>This rule handles all non-FTP traffic from the internal LAN:</p>

<pre class="PROGRAMLISTING">
map dc0 10.0.10.0/29 -&gt; 0/32
</pre>

<p>The FTP map rule goes before our regular map rule. All packets are tested against the
first rule from the top. Matches on interface name, then private LAN source IP address,
and then is it a FTP packet. If all that matches then the special FTP proxy creates temp
filter rules to let the FTP session packets pass in and out, in addition to also <acronym
class="ACRONYM">NAT</acronym>ing the FTP packets. All LAN packets that are not FTP do not
match the first rule and fall through to the third rule and are tested, matching on
interface and source IP, then are <acronym class="ACRONYM">NAT</acronym>ed.</p>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN38183" name="AEN38183">28.5.21.2 IP<acronym
class="ACRONYM">NAT</acronym> FTP Filter Rules</a></h3>

<p>Only one filter rule is needed for FTP if the <acronym class="ACRONYM">NAT</acronym>
FTP proxy is used.</p>

<p>Without the FTP Proxy you will need the following three rules:</p>

<pre class="PROGRAMLISTING">
# Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state
</pre>
</div>

<div class="SECT3">
<h3 class="SECT3"><a id="AEN38190" name="AEN38190">28.5.21.3 FTP <acronym
class="ACRONYM">NAT</acronym> Proxy Bug</a></h3>

<p>As of FreeBSD 4.9 which includes IPFILTER version 3.4.31 the FTP proxy works as
documented during the FTP session until the session is told to close. When the close
happens packets returning from the remote FTP server are blocked and logged coming in on
port 21. The <acronym class="ACRONYM">NAT</acronym> FTP/proxy appears to remove its temp
rules prematurely, before receiving the response from the remote FTP server acknowledging
the close. A problem report was posted to the IPF mailing list.</p>

<p>The solution is to add a filter rule to get rid of these unwanted log messages or do
nothing and ignore FTP inbound error messages in your log. Most people do not use
outbound FTP too often.</p>

<pre class="PROGRAMLISTING">
block in quick on rl0 proto tcp from any to any port = 21
</pre>
</div>
</div>
</div>

<div class="NAVFOOTER">
<hr align="LEFT" width="100%" />
<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="firewalls-pf.html"
accesskey="P">Prev</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Home</a></td>
<td width="33%" align="right" valign="top"><a href="firewalls-ipfw.html"
accesskey="N">Next</a></td>
</tr>

<tr>
<td width="33%" align="left" valign="top">OpenBSD 封包過濾器 (Packet Filter, PF)及
<acronym class="ACRONYM">ALTQ</acronym></td>
<td width="34%" align="center" valign="top"><a href="firewalls.html"
accesskey="U">Up</a></td>
<td width="33%" align="right" valign="top">IPFW</td>
</tr>
</table>
</div>

<p align="center"><small>本文及其他文件，可由此下載：<a
href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p>

<p align="center"><small>若有 FreeBSD 方面疑問，請先閱讀 <a
href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
&#60;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&#62;。<br />
關於本文件的問題，請洽詢 &#60;<a
href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&#62;。</small></p>
</body>
</html>

