

<!-- Vignette StoryServer 4 Sat Mar 11 15:43:24 2000 --> 
<style type=text/css>
<!--
p,div {font-size:12pt; line-height:14pt; font-family:宋體;}
.p1{font-size:12pt;font-family:宋體;}
.p2{font-size:12pt;font-family:宋體;line-height:14pt;}
.p3{font-size:14.8px;font-family:宋體;}
.p4{font-size:14.8px;font-family:宋體;line-height:14pt;}
.p5{font-size:1pt}
a:hover{color:red;}
a.t1:visited{color:red;}
-->
</style>
<title>FreeBSD使用大全</title></head>

<body bgcolor="#FFFFFF" text="#000000" link="#383098" vlink="#336699" alink="#FF0000" topmargin="0">
<!-- Vignette StoryServer 4 Thu Mar 23 10:01:54 2000 --> <!-- Vignette StoryServer 4 Thu Mar 23 15:34:35 2000 --> 

<!--開始：新聞內容-->
<TABLE WIDTH=750 BORDER=0 CELLSPACING=0 CELLPADDING=0>

<tr valign=top>



<TD  valign=top>
<CENTER><FONT COLOR=#000066 size=5><B>FreeBSD連載(16)：設備檔案</B><br></FONT></CENTER>

<HR  ALIGN="center" SIZE=1>
<CENTER><FONT FACE="Arial" SIZE=2> 1999年11月18日 16:37 </FONT><FONT COLOR="#990000" SIZE=2>王波</FONT></CENTER><p>

<h1 align=center>設備檔案</h1>

<p>　　對於每種硬體設備，系統核心有相應的設備驅動程序負責對它的處理。而在Unix中，使用設備檔案的方式來表示
硬體設備，每種設備驅動程序都被抽象為設備檔案的形式，這樣就給應用程序一個一致的檔案界面，方便應用程序和操作系統
之間的通信。所有的設備檔案都放置在/dev目錄下。
</p>

<pre>
<P>$ ls -l /dev/rfd0 /dev/fd0</P>

<P>brw-r-----  9 root operator 2, 0 Nov 12 13:32 /dev/fd0</P>

<P>crw-r-----  9 root operator 9, 0 Nov 12 13:32 /dev/rfd0</P>
</pre>

<p>　　在上面的列表中可以看到原來顯示檔案大小的地方，現在改為顯示兩個用逗號分隔的數字。這是系統用來表示設備的
兩個重要的序號，第一個為主設備號（major number），用來表示設備使用的硬體驅動程序在系統中的序號﹔第
二個為從設備號（minor number），硬體驅動程序使用它來區分不同的設備和判斷如何進行處理。FreeBSD
下主設備號用8位表示，而從設備號用24位來表示。事實上設備檔案的名字並不重要，重要的是這兩個設備號，操作系統
使用它確定硬體驅動程序，並與硬體驅動程序進行通信。
</p>

<ul><h2><P><LI>磁碟和塊設備檔案</LI></P></h2></ul>

<p>　　在Unix下將設備分為兩種，塊設備和字符設備，其中塊設備主要用於隨機存取的目的，磁碟為這一類設備的代表
，而字符設備用於順序存取的目的，例如磁帶或終端設備。</p>

<p>　　磁碟設備的命名方式在前一章中提到過，磁碟設備由磁碟名、磁碟的序號、分區的序號、以及FreeBSD子分區
的序號來表示，例如在設備wd0s1a中，wd為驅動程序，此後為設備序號，0表示為這個驅動程序的第一個設備，Unix
習慣上從0開始計數，第三部分的分區序號為s1，注意這裡為第一個分區，因為s1是從1開始向下排列的，與一般Unix
的習慣不同，這是因為分區的概念是一個DOS概念，因此這裡也使用與DOS相對應的順序，最後一個a為FreeBSD
子分區的順序，每個UFS基本分區可以有8個子分區，這8個分區按照習慣用於不同的目的，例如wd0s1a用於
根檔案系統，wd0s1b用做交換分區，使用wd0s1c表示整個硬碟分區wd0s1。因此可以將fd0c用於對整個
軟碟fd0進行存取，wcd0c用於對整個光碟wcd0進行存取等。</p>

<p>　　傳統名字，例如wd0a，可以用於表示第一個UFS分區上的a子分區，如wd0s1a。一般一個硬碟上只有一
個UFS分區，因此可以直接使用傳統名字標識磁碟分區。</p>

<p>　　在使用ls命令列表時，系統使用c（character）標識一個字符設備檔案，使用b（block）標識塊
設備檔案。
</p>
<pre>
<P>$ ls -l /dev/*wd0s1</P>
<P>crw-r----- 1 root operator 3, 131072 Oct 31 19:59 /dev/rwd0s1</P>
<P>brw-r----- 1 root operator 0, 131072 Oct 31 19:59 /dev/wd0s1</P>
</pre>

<p>　　雖然硬碟設備為塊設備，用於隨機存取的目的。但它也可以被順序存取，這種方式稱為raw方式。使用raw方式
存取硬碟，就需要一個對應的字符類型的設備檔案，對應wd0s1硬碟設備的字符類型硬碟設備為rwd0s1，設備名中
第一個字母使用r表示對硬碟的raw方式順序存取。</p>

<p>　　由於設備檔案就代表了整個設備，就可以使用FreeBSD的標準命令以raw方式直接操作設備檔案，從而直接
訪問硬體設備。利用這種方式，能完成很多有用的工作，但是這種方式也非常危險，例如對硬碟設備檔案的操作失誤會破壞整
個硬碟的數據。幸好大部分直接訪問設備的操作都為讀取相應數據的操作，而不需要寫入磁碟設備。</p>

<p>　　當某個設備不可使用，則其對應的設備檔案也不能正常訪問，因此直接訪問設備檔案可以判斷對應的設備是否真正正
常。例如，判斷連接到第一個串口，ttyd0上的滑鼠是否正常工作，使用命令 “cat &lt;/dev/ttyd
0” 來查看ttyd0上的輸入數據，如果連接的有滑鼠且工作正常，那麼在移動滑鼠的同時螢幕上就會顯示出接收到的雜
亂數據。如果沒有反應，說明滑鼠工作不正確。但這也可能是其他程序接管了這個設備，例如系統運行了moused。如果
moused控制了滑鼠端口，那麼 “cat &lt; /dev/sysmouse” 會給出答案。</p>

<p>　　cat或其他命令，沒有控制具體接收到數據的多少，更有效的系統工具是dd，它能精確輸入輸出一定數量的數據
。例如：# dd if=/dev/rwd0 of=mbr count=1 bs=512</p>

<p>　　這將以512字節為單位，讀取硬碟wd0上一個單位的數據，保存到名字為mbr的檔案中，通常這是硬碟wd0
上的主引導扇區。
</p>

<ul><h2><P><LI>終端設備</LI></P></h2></ul>

<p>　　終端設備檔案為標識用戶與系統連接的終端設備的設備檔案，這是一種典型的字符設備檔案。普通的終端一般使用串
口和主機相連接，系統使用終端檔案來描述這個連接的終端。通常第一個串口連接的設備為ttyd0（標準個人電腦第一
個串口連接的常常是滑鼠），第二個串口為ttyd1，依次類推。</p>

<p>　　如果用戶是使用telnet或其他遠程登錄的方式，那麼系統使用一個偽設備檔案與用戶的偽終端相對應，這些偽
終端設備檔案為ttyp0到ttysv，ttyP0到ttySv。這樣就能支持相當多用戶同時登錄系統。</p>

<p>　　Unix是多用戶、多任務系統，但是個人電腦僅僅有一個螢幕，熟練Unix用戶喜歡同時進行幾個工作，例如
在一邊下載檔案，一邊進行編程等，對於直接使用控制台的FreeBSD用戶來講，FreeBSD提供的虛擬終端能完美
的解決這個問題。</p>

<p>　　對於在控制台上的虛擬終端，對應的終端設備檔案為ttyv0、ttyv1、ttyv3等，與鍵碟上的12個功
能鍵相對應。控制台設備被系統用來輸出很多必要的信息，包括各種登錄信息等對系統安全非常相關的信息。由於在控制台上
操作就是在個人電腦前面操作，因此通常在控制台上能完成許多在其他終端上不能完成的操作，例如：使用Ctrl+Alt+Del
重起系統等。為了保証系統安全，必須限制對控制台的物理訪問。</p>

<p>　　對於不在控制台的用戶，就需要額外的應用程序的支持，在X終端上能使用X Window系統開出多個視窗，每
個視窗對應一個偽終端。在字符終端上，也可以通過應用程序screen打開幾個偽終端，但這需要安裝相應的軟體。這些
偽終端都使用ttyp0等偽設備檔案。</p>

<p>　　與終端相關的另一個問題為不同的終端設備分為不同的終端類型，這是因為雖然終端是字符型設備，但又要求它能夠
具備更複雜的功能，例如進行全螢幕操作等。這樣就要求終端設備能接受和識別一些控制字符，而不同的終端設備具備不同的
控制字符。登錄用戶可以使用TERM環境變量來告訴應用程序目前使用的終端類型，常用的終端類型有vt100，ansi
等，FreeBSD控制台的終端類型為cons25，但是其他Unix中一般不識別這個類型，因此如果在FreeBSD
上通過telnet等連接到其他Unix上之後，應該改變TERM變量的值為ansi。</p>

<p>　　在FreeBSD中，終端類別對應的控制字符使用termcap的方法定義，而System V中使用ter
minfo的方式。所有的終端類型記錄在/usr/share/misc/termcap檔案中，並定義這些終端對應
的控制字符。</p>

<p>　　登錄到系統之後，將有一個終端設備檔案與用戶的這個登錄過程相聯繫。這個終端設備檔案在控制台上登錄時可能是
/dev/ttyv0，如果從網路上遠程登錄可能是/dev/ttyp0，但無論是那種情況，系統總使用/dev/t
ty來代表用戶目前使用的終端，直接訪問/dev/tty將對目前的終端進行直接操作。</p>

<p>　　除了這些與設備相聯繫的設備檔案之外，還有一些特殊的設備檔案。例如/dev/zero檔案代表一個永遠輸出
0的設備檔案，使用它作輸入可以得到全為空的檔案。因此可用來創建新檔案和以覆蓋的方式清除舊檔案。下面使用dd命令
將從zero設備中創建一個10K大小（bs決定每次讀寫1024字節，count定義讀寫次數為10次），但內容全
為0的檔案。
</p>

<p>　　# dd if=/dev/zero of=file count=10 bs=1024</p>

<p>　　10+0 records in</p>

<p>　　10+0 records out</p>

<p>　　10240 bytes transferred in 0.001408 secs (7267903 b
ytes/sec)</p>

<p>　　另一個特殊設備檔案為/dev/null，永遠無法寫滿，寫入的內容被系統立即丟棄。如果不想看到程序的輸出
，可以使用它作輸出。</p>

<p>　　# make world &gt; /dev/null</p>

<p>　　去除了螢幕輸出，使整個程序執行過程非常平靜。
</p>

<ul><h2><P><LI>設備檔案的創建</LI></P></h2></ul>

<p>　　通常情況下，安裝系統時已經創建了常用的設備檔案，可以直接訪問這些設備檔案來訪問設備。但在用戶重新定制內
核，並添加了新硬體驅動程序之後，新驅動程序對應的設備檔案就可能不存在。在FreeBSD中，最常見的例子就是在內
核中增加聲卡的驅動程序時，就需要創建相應設備檔案。</p>

<p>　　創建設備檔案可以使用/dev目錄下的shell程序MAKEDEV來完成，首先進入/dev目錄，然後再執
行MAKEDEV。</p>

<p>　　# cd /dev</p>

<p>　　# ./MAKEDEV snd0</p>

<p>　　MAKEDEV將使用設備名作參數創建設備檔案，同時也創建這個設備檔案依賴的其他相關設備檔案。MAKEDEV
的參數，並不一定為創建的設備檔案名。例如建立 “MAKEDEV vty8” 將建立ttyv0到ttyv7共
8個設備檔案，使用 “MAKEDEV wd1s1a” 命令，將建立wd1、wd1s1、wd1s2等，以及wd1s1a、wd1s1b
等設備檔案。也可以使用all做MAKEDEV的參數，這將首先清除/dev目錄下的所有設備文
件，然後MAKEDEV創建所有預設的設備檔案。一般情況下這將創建足夠多的設備檔案，其中的大部分設備檔案在具體的
系統中不會用得到。</p>

<p>　　如果對一個系統中沒有（或者核心沒有探測到）的設備對應的設備檔案進行操作，則系統返回Device not configured
的錯誤信息。</p>

<p>　　MAKEDEV將使用mknod和對應設備的正確參數，包括字符或塊設備、主設備號和從設備號來建立相應的設
備檔案。管理員也可以直接使用mknod創建設備檔案，但這就必須將這些設備參數統統指定正確才行。因此除非對系統中
的硬體驅動程序特別熟悉，一般不直接使用mknod來創建設備檔案。
</p>



<BR>

</TD>
</TR></TABLE>


</BODY>
</HTML>
