<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 5. Objective-C Instances</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt01.html" />
    <link rel="prev" href="ch04.html" />
    <link rel="next" href="pt02.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="pt02.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 4. Objective-C Classes </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Part II. IDE</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id5"></a>Chapter 5. Objective-C Instances</h2>
          </div>
        </div>
      </div>
      <p>Instances are the heart of the action in an Objective-C program. Most of the methods you’ll define when creating your own classes will be instance methods; most of the messages you’ll send in your code will call instance methods. This chapter describes how instances come into existence and how they work.</p>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_how_instances_are_created"></a>How Instances Are Created</h2>
            </div>
          </div>
        </div>
        <p>Your class objects are created for you automatically as your program starts up, but instances must be created deliberately as the program runs. The entire question of where instances come from is thus crucial. Ultimately, every instance comes into existence in just one way: someone deliberately asks a class to instantiate itself. But there are three different ways in which this can occur: ready-made instances, instantiation from scratch, and nib-based instantiation.<a id="idm441656106464" class="indexterm"></a>
<a id="idm441656105216" class="indexterm"></a><a id="idm441656104352" class="indexterm"></a>
<a id="idm441656103360" class="indexterm"></a>
<a id="idm441656102112" class="indexterm"></a></p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_ready_made_instances"></a>Ready-Made Instances</h3>
              </div>
            </div>
          </div>
          <p>One way to create an instance is indirectly, by calling code that does the instantiation for you. You can think of an instance obtained in this indirect manner as a “ready-made instance.” (That’s my made-up phrase, not an official technical term.) Consider this simple code:</p>
          <pre class="screen">NSString* s2 = [s uppercaseString];</pre>
          <p>The documentation for the NSString instance method <code class="literal">uppercaseString</code> says that it returns “a string with each character from the receiver changed to its corresponding uppercase value.” In other words, you send the <code class="literal">uppercaseString</code> message to an NSString, and you get back a <span class="emphasis"><em>different</em></span>, newly created NSString. After that line of code, <code class="literal">s2</code> points to an NSString instance that didn’t exist beforehand.</p>
          <p>The NSString produced by the <code class="literal">uppercaseString</code> method is a ready-made NSString instance. Your code didn’t say anything about instantiation; it just sent the <code class="literal">uppercaseString</code> message. But clearly <span class="emphasis"><em>someone</em></span> said something about instantiation, because instantiation took place; this is a newly minted NSString instance. That someone is presumably some code inside the NSString class. But we don’t have to worry about the details. We are guaranteed of receiving a complete brand spanking new ready-to-roll NSString, and that’s all we care about.</p>
          <p>Similarly, any class factory method instantiates the class and dispenses the resulting instance as a ready-made instance. So, for example, the NSString class method <code class="literal">stringWithContentsOfFile:encoding:error:</code> reads a file and produces an NSString representing its contents. All the work of instantiation has been done for you. You just accept the resulting string and away you go.</p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>A Cocoa class factory method is likely to have its return value typed as <code class="literal">id</code>. As I mentioned in <a class="xref" href="ch03.html">Chapter 3</a>, this can lead to trouble if you mistakenly assign the resulting instance where a different class of object is expected; the compiler doesn’t complain (because <code class="literal">id</code> is the universal donor) but you can mysteriously crash later when the wrong message is sent to the instance.<a id="idm441656089152" class="indexterm"></a>
<a id="idm441656087904" class="indexterm"></a></p>
          </div>
          <p>Not every method that returns an instance returns a new instance, of course. For example, this is how you ask an array (an NSArray) for its last element:</p>
          <pre class="screen">id last = [myArray lastObject];</pre>
          <p>The NSArray <code class="literal">myArray</code> didn’t <span class="emphasis"><em>create</em></span> the object that it hands you. That object already existed; <code class="literal">myArray</code> was merely containing it, as it were — it was holding the object, pointing to it. Now it’s sharing that object with you, that’s all.</p>
          <p>Similarly, many classes dispense one particular object. For example, your app has exactly one instance of the UIApplication class (we call this the <span class="emphasis"><em>singleton</em></span> UIApplication instance);<a id="idm441656082912" class="indexterm"></a> to access it, you send the <code class="literal">sharedApplication</code> class method to the UIApplication class:<a id="idm441656081312" class="indexterm"></a>
<a id="idm441656080064" class="indexterm"></a></p>
          <pre class="screen">UIApplication* theApp = [UIApplication sharedApplication];</pre>
          <p>This singleton instance existed before you asked for it; indeed, it existed before any code of yours could possibly run. You don’t care how it was brought into being; all you care is that you can get hold of it when you want it. I’ll talk more about globally available singleton objects of this kind in <a class="xref" href="ch13.html">Chapter 13</a>.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_instantiation_from_scratch"></a>Instantiation from Scratch</h3>
              </div>
            </div>
          </div>
          <p>The alternative to requesting a ready-made instance is to tell a class, yourself, directly, to instantiate itself. There is basically one way to do this: you send a class the <code class="literal">alloc</code> message.<a id="idm441656074832" class="indexterm"></a> The <code class="literal">alloc</code> class method is implemented by the NSObject class, the root class from which all other classes inherit. It causes memory to be set aside for the instance so that an instance pointer can point to it. (Management of that memory is a separate issue, discussed in <a class="xref" href="ch12.html">Chapter 12</a>.)</p>
          <p>You must never, never, <span class="emphasis"><em>never</em></span> call <code class="literal">alloc</code> by itself. You must <span class="emphasis"><em>immediately</em></span> call another method, an instance method that <span class="emphasis"><em>initializes</em></span> the newly created instance, placing it into a known valid state so that it can be sent other messages. Such a method is called an <span class="emphasis"><em>initializer</em></span>.<a id="idm441656069808" class="indexterm"></a> Moreover, an initializer returns an instance — usually the same instance, initialized. Therefore you can, and always should, call <code class="literal">alloc</code> and the initializer in the same line of code. The minimal initializer is <code class="literal">init</code>. So the basic pattern, known informally as “alloc-init,” looks like <a class="xref" href="ch05.html#EXallocinit">Example 5.1</a>.</p>
          <div class="example">
            <a id="EXallocinit"></a>
            <p class="title">Example 5.1. The basic pattern for instantiation from scratch</p>
            <div class="example-contents">
              <pre class="screen">SomeClass* aVariable = [[SomeClass alloc] init];</pre>
            </div>
          </div>
          <br class="example-break" />
          <p>You cannot instantiate from scratch if you do not also know how to initialize, so we turn immediately to a discussion of initialization.</p>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="_initialization"></a>Initialization</h4>
                </div>
              </div>
            </div>
            <p>Every class defines or inherits at least one initializer. This is an instance method; the instance has just been created, by calling <code class="literal">alloc</code> on the class, and it is to this newly minted instance that the initializer message must be sent. An initialization message must be sent to an instance immediately after that instance is created by means of the <code class="literal">alloc</code> message, and it must not be sent to an instance at any other time.<a id="idm441656061504" class="indexterm"></a>
<a id="idm441656060256" class="indexterm"></a></p>
            <p>The basic initialization pattern, as shown in <a class="xref" href="ch05.html#EXallocinit">Example 5.1</a>, is to nest the <code class="literal">alloc</code> call in the initialization call, assigning the result of the <span class="emphasis"><em>initialization</em></span> (not the <code class="literal">alloc</code>!) to a variable. One reason for this is that if something goes wrong and the instance can’t be created or initialized, the initializer will return nil; therefore it’s important to capture the result of the initializer and treat that, not the result of <code class="literal">alloc</code>, as the pointer to the instance.</p>
            <p>To help you identify initializers, all initializers are named in a conventional manner. The convention is that all initializers, and only initializers, begin with the word <code class="literal">init</code>. The ultimate bare-bones initializer is called simply <code class="literal">init</code>, and takes no parameters. Other initializers do take parameters, and usually begin with the phrase <code class="literal">initWith</code> followed by descriptions of their parameters. For example, the NSArray class documentation lists these methods:<a id="idm441656052816" class="indexterm"></a></p>
            <pre class="screen">– initWithArray:
– initWithArray:copyItems:
– initWithContentsOfFile:
– initWithContentsOfURL:
– initWithObjects:
– initWithObjects:count:</pre>
            <p>Let’s try a real example. A particularly easy and generally useful initializer for NSArray is <code class="literal">initWithObjects:</code>. It takes a list of objects; the list must be terminated by nil. In <a class="xref" href="ch03.html">Chapter 3</a>, we illustrated this by creating an NSArray from three strings, by means of a class factory method that returned a ready-made instance:</p>
            <pre class="screen">NSArray* pep =
    [NSArray arrayWithObjects:@"Manny", @"Moe", @"Jack", nil];</pre>
            <p>Now we’ll do what amounts to exactly the same thing, except that we’ll create the instance ourselves, from scratch:</p>
            <pre class="screen">NSArray* pep =
    [[NSArray alloc] initWithObjects:@"Manny", @"Moe", @"Jack", nil];</pre>
            <p>In that particular case, there exist both a factory method and an initializer that work from the same set of data. Ultimately, it makes no difference which you use; given the same arguments, both approaches result in NSArray instances that are indistinguishable from one another. It will turn out in the discussion of memory management (<a class="xref" href="ch12.html">Chapter 12</a>) that there might be a reason to choose instantiation from scratch over ready-made instances (though not, perhaps, under ARC).</p>
            <p>In modern Objective-C, as I mentioned in <a class="xref" href="ch03.html">Chapter 3</a>, you are unlikely to call <code class="literal">arrayWithObjects:</code>, because there is now a convenient literal array syntax that calls it for you. For the same reason, you are unlikely to call <code class="literal">initWithObjects:</code>. So I’ll give another example. Suppose that, one way or another, you now have an array <code class="literal">pep</code> containing the three strings <code class="literal">@"Manny"</code>, <code class="literal">@"Moe"</code>, and <code class="literal">@"Jack"</code>, and that you want to instantiate a second array based on it and containing those same three strings. It is not sufficient to assign <code class="literal">pep</code> to another NSArray variable:</p>
            <pre class="screen">NSArray* pep2 = pep; // no, that isn't another array</pre>
            <p>Object references are pointers, and pointer assignment merely points two references at the same thing (<a class="xref" href="ch03.html">Chapter 3</a>). So <code class="literal">pep2</code> in that code isn’t a second array; it’s the same array, which isn’t what we said we wanted. To make a new array instance based on the first, we can call the class method <code class="literal">arrayWithArray:</code>, like this:</p>
            <pre class="screen">NSArray* pep2 = [NSArray arrayWithArray: pep];</pre>
            <p>Now <code class="literal">pep2</code> is a newly minted instance, separate from <code class="literal">pep</code>. It’s a ready-made instance, returned from a class factory method. To create the instance ourselves, from scratch, we call the corresponding initializer:</p>
            <pre class="screen">NSArray* pep2 = [[NSArray alloc] initWithArray: pep];</pre>
            <p>In looking through the documentation for an initializer, don’t forget to look upward through the class hierarchy. For example, the class documentation for UIWebView lists no initializers, but UIWebView inherits from UIView, and in UIView’s class documentation you’ll discover <code class="literal">initWithFrame:</code>. Moreover, the <code class="literal">init</code> method is defined as an instance method of the NSObject class, so every class inherits it and every newly minted instance can be sent the <code class="literal">init</code> message. Thus it is a given that if a class defines no initializers of its own, you can initialize an instance of it with <code class="literal">init</code>. For example, the UIResponder class documentation lists no initializers at all (and no factory methods). So to create a UIResponder instance from scratch, you’d call <code class="literal">alloc</code> and <code class="literal">init</code>.</p>
            <div class="note" style="margin-left: 0; margin-right: 10%;">
              <h3 class="title">Note</h3>
              <p>In just the single case where <code class="literal">init</code> is the initializer you want to call, you can collapse the successive calls to <code class="literal">alloc</code> and <code class="literal">init</code> into a call to <code class="literal">new</code>. In other words, <code class="literal">[MyClass new]</code> is a synonym for <code class="literal">[[MyClass alloc] init]</code>.<a id="idm441656024240" class="indexterm"></a> I used to avoid <code class="literal">new</code> as confusing, chiefly because it conceals the initialization that guarantees this is a proper instance (and, before ARC, the need for memory management). But recently I’ve reversed course; I now use <code class="literal">new</code> quite a bit, and I’ll use it freely in this book.</p>
            </div>
          </div>
          <div class="section">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="_the_designated_initializer"></a>The designated initializer</h4>
                </div>
              </div>
            </div>
            <p>If a class does define initializers, one of them may be described in the documentation as the <span class="emphasis"><em>designated initializer</em></span>. (There’s nothing about a method’s name that tells you it’s the designated initializer; you must peruse the documentation to find out.) For example, in the UIView class documentation, the <code class="literal">initWithFrame:</code> method is described as the designated initializer. A class that does not define a designated initializer inherits its designated initializer; the ultimate designated initializer, inherited by all classes without any other designated initializer anywhere in their superclass chain, is <code class="literal">init</code>.<a id="idm441656017776" class="indexterm"></a>
<a id="idm441656016528" class="indexterm"></a></p>
            <p>The designated initializer is the initializer on which any other initializers depend, in this class or any subclasses: ultimately, they <span class="emphasis"><em>must</em></span> call it. The designated initializer might have the most parameters, allowing the most instance variables to be set explicitly, with the other initializers supplying default values for some instance variables, for convenience. Or it might just be the most basic form of initialization. But in any case, it is a bottleneck through which all other initializers pass. Here are some examples:</p>
            <div class="itemizedlist">
              <ul class="itemizedlist" type="disc">
                <li class="listitem">
The NSDate class documentation says that <code class="literal">initWithTimeIntervalSinceReferenceDate:</code> is the designated initializer, and that <code class="literal">initWithTimeIntervalSinceNow:</code> calls it.
</li>
                <li class="listitem">
The UIView class documentation says that <code class="literal">initWithFrame:</code> is the designated initializer. UIView contains no other initializers, but some of its subclasses do. UIWebView, a UIView subclass, has no initializer, so <code class="literal">initWithFrame:</code> is its inherited designated initializer. UIImageView, a UIView subclass, has initializers such as <code class="literal">initWithImage:</code>, but none of them is a designated initializer; so <code class="literal">initWithFrame:</code> is its inherited designated initializer as well, and <code class="literal">initWithImage:</code> must call <code class="literal">initWithFrame:</code>.
</li>
              </ul>
            </div>
            <p>Moreover, a class that implements a designated initializer will override the designated initializer inherited from its superclass. The idea is typically that even the inherited designated initializer, if called, will be overridden so as to call this class’s designated initializer. For example, UIView overrides the inherited <code class="literal">init</code> to call its own designated initializer, <code class="literal">initWithFrame</code>:, with a value of <code class="literal">(CGRect){{0, 0}, {0, 0}}</code>.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="SECnibbasedinstantiation"></a>Nib-Based Instantiation</h3>
              </div>
            </div>
          </div>
          <p>The third means of instantiation is through a nib file (or storyboard file). A nib file is where Xcode lets you “draw” parts of the user interface. Most Xcode projects will include at least one nib file, which will be built into the app bundle, and will then be loaded as the app runs. A nib file consists, in a sense, of the names of classes along with instructions for instantiating and initializing them. When the app runs and a nib file is loaded, those instructions are carried out — those classes <span class="emphasis"><em>are</em></span> instantiated and initialized.<a id="idm441656002336" class="indexterm"></a>
<a id="idm441656001088" class="indexterm"></a><a id="idm441656000224" class="indexterm"></a>
<a id="idm441655998976" class="indexterm"></a>
<a id="idm441655997984" class="indexterm"></a></p>
          <p>For example, suppose you’d like the user to be presented with a view containing a button whose title is “Howdy.” Xcode lets you arrange this graphically by editing a nib file: you drag a button from the Object library into the view, place it at a certain position in the view, and then set its title to “Howdy” (<a class="xref" href="ch05.html#FIGdraggingButtonEarlier">Figure 5.1</a>). In effect, you create a drawing of what you want the view and its contents to look like.</p>
          <div class="figure">
            <a id="FIGdraggingButtonEarlier"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0501.png" alt="figs/pios_0501.png" />
              </div>
            </div>
            <p class="title">Figure 5.1. Dragging a button into a view</p>
          </div>
          <br class="figure-break" />
          <p>When the app runs, the nib file loads, and that drawing is turned into reality. To do this, the drawing is treated as a set of instructions for instantiating objects. The button that you dragged into the view is treated as a representative of the UIButton class. The UIButton class is told to instantiate itself, and that instance is then initialized, giving it the same position you gave it in the drawing (the instance’s <code class="literal">frame</code>), the same title you gave it in the drawing (the instance’s <code class="literal">title</code>), and putting it into the window. In effect, the loading of your nib file is equivalent to this code (assuming that <code class="literal">view</code> is a reference to the view object):</p>
          <pre class="screen">UIButton* b =
    [UIButton buttonWithType:UIButtonTypeRoundedRect]; // instantiate
[b setTitle:@"Howdy!" forState:UIControlStateNormal];  // set up title
[b setFrame: CGRectMake(100,100,100,35)];              // set up frame
[view addSubview:b];                                   // place button in view</pre>
          <p>The fact that nib files are a source of instances, and that those instances are brought into existence as the nib file is loaded, is a source of confusion to beginners. I’ll discuss nib files and how they are used to generate instances in much more detail in <a class="xref" href="ch07.html">Chapter 7</a>.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_polymorphism"></a>Polymorphism</h2>
            </div>
          </div>
        </div>
        <p>The compiler, even in the world of static typing, is perfectly happy for you to supply a subclass instance where a superclass type is declared. To see this, let’s start with the first line of the previous example:<a id="idm441655984512" class="indexterm"></a>
<a id="idm441655983264" class="indexterm"></a><a id="idm441655982400" class="indexterm"></a>
<a id="idm441655981152" class="indexterm"></a>
<a id="idxpoly" class="indexterm"></a></p>
        <pre class="screen">UIButton* b = [UIButton buttonWithType:UIButtonTypeRoundedRect];</pre>
        <p>UIButton is a subclass of UIControl, which is a subclass of UIView. So it would be perfectly legal and acceptable to say this:</p>
        <pre class="screen">UIButton* b = [UIButton buttonWithType:UIButtonTypeRoundedRect];
UIView* v = b;</pre>
        <p>The variable <code class="literal">b</code> is a UIButton instance, but I’m assigning it to a variable declared as a UIView. That’s legal and acceptable because UIView is an ancestor (up the superclass chain) of UIButton. Putting it another way, I’m behaving as if a UIButton were a UIView, and the compiler accepts this because a UIButton <span class="emphasis"><em>is</em></span> a UIView.</p>
        <p>What’s important when the app runs, however, is not the declared class of a variable, but the actual class of the object to which that variable points. Even if I assign the UIButton instance <code class="literal">b</code> to a UIView variable <code class="literal">v</code>, the object to which the variable <code class="literal">v</code> points is still a UIButton. So I can send it messages appropriate to a UIButton. For example:</p>
        <pre class="screen">UIButton* b = [UIButton buttonWithType:UIButtonTypeRoundedRect];
UIView* v = b;
[v setTitle:@"Howdy!" forState:UIControlStateNormal];</pre>
        <p>That code will cause the compiler to complain, because UIView doesn’t implement <code class="literal">setTitle:forState:</code>; under ARC, in fact, that code won’t even compile. So I’ll calm the compiler’s fears by typecasting:<a id="idm441655970416" class="indexterm"></a><a id="idm441655969552" class="indexterm"></a></p>
        <pre class="screen">UIButton* b = [UIButton buttonWithType:UIButtonTypeRoundedRect];
UIView* v = b;
[(UIButton*)v setTitle:@"Howdy!" forState:UIControlStateNormal];</pre>
        <p>The typecast calms the compiler’s fears, but the important thing is what happens when the program runs. What happens is that this code works just fine! It works fine not because I typecast <code class="literal">v</code> to a UIButton (typecasting doesn’t magically convert anything to anything else; it’s just a hint to the compiler), but because <code class="literal">v</code> really <span class="emphasis"><em>is</em></span> a UIButton. So when the message <code class="literal">setTitle:forState:</code> arrives at the object pointed to by <code class="literal">v</code>, everything is fine. If <code class="literal">v</code> had been a UIView but <span class="emphasis"><em>not</em></span> a UIButton, on the other hand, the program would have crashed at that instant.</p>
        <p>An object, then, responds to a message sent to it on the basis of what it really is, not on the basis of anything said about what it is — and what it really is cannot be known until the program actually runs and the message is actually sent to that object.</p>
        <p>Now let’s turn the tables. We called a UIButton a UIView and sent it a UIButton message. Now we’re going to call a UIButton a UIButton and send it a UIView message.</p>
        <p>What an object really is depends not just upon its class but also upon that class’s inheritance. A message is acceptable even if an object’s own class doesn’t implement a corresponding method, provided that the method is implemented somewhere up the superclass chain. For example, returning again to the same code:</p>
        <pre class="screen">UIButton* b = [UIButton buttonWithType:UIButtonTypeRoundedRect];
[b setFrame: CGRectMake(100,100,100,35)];</pre>
        <p>This code works fine. But you won’t find <code class="literal">setFrame:</code> in the documentation for the UIButton class. That’s because you’re looking in the wrong place. A UIButton is a UIControl, and a UIControl is a UIView. To find out about <code class="literal">setFrame:</code>, look in the UIView class’s documentation. (Okay, it’s more complicated than that; you won’t find <code class="literal">setFrame:</code> there either. But you will find a term <code class="literal">frame</code> which is called a “property,” and this amounts to the same thing, as I’ll explain later in this chapter.) So the <code class="literal">setFrame:</code> message is sent to a UIButton, but it corresponds to a method defined on a UIView. Yet it works fine, because a UIButton <span class="emphasis"><em>is</em></span> a UIView.</p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tip</h3>
          <p>A common beginner mistake is to consult the documentation without following the superclass chain. If you want to know what you can say to a UIButton, don’t just look in the UIButton class documentation: also look in the UIControl class documentation, the UIView class documentation, and so on.<a id="idm441655953712" class="indexterm"></a>
<a id="idm441655952464" class="indexterm"></a></p>
        </div>
        <p>To sum up: we treated a UIButton object as a UIView, yet we were still able to send it a UIButton message. We treated a UIButton as a UIButton, yet we were still able to send it a UIView message. What matters when a message is sent to an object is not how the variable pointing to that object is declared but what class the object really is. What an object really is depends upon its class, along with that class’s inheritance from the superclass chain; these facts are innate to the object and are independent of how your code characterizes the variable pointing to the object. This independent maintenance of object type integrity is the basis of what is called <span class="emphasis"><em>polymorphism</em></span>.</p>
        <p>But it is not quite the whole of polymorphism. To understand the whole of polymorphism, we must go further into the dynamics of message sending.</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_keyword_self"></a>The Keyword self</h2>
            </div>
          </div>
        </div>
        <p>A common situation is that code in an instance method defined in a class must call another instance method defined within the same class. We have not yet discussed how to do this. A method is called by sending a message to an object; in this situation, what object would that be? The answer is supplied by a special keyword, <code class="literal">self</code>. Here’s a simple example:<a id="idm441655946816" class="indexterm"></a></p>
        <pre class="screen">@implementation MyClass

- (NSString*) greeting {
    return @"Goodnight, Gracie!";
}

- (NSString*) sayGoodnightGracie {
    return [self greeting];
}

@end</pre>
        <p>When the <code class="literal">sayGoodnightGracie</code> message is sent to a MyClass instance, the <code class="literal">sayGoodnightGracie</code> method runs. It sends the <code class="literal">greeting</code> message to <code class="literal">self</code>. As a result, the <code class="literal">greeting</code> instance method is called; it returns the string <code class="literal">@"Goodnight, Gracie!"</code>, and this same string is then returned from the <code class="literal">sayGoodnightGracie</code> method.</p>
        <p>The example seems straightforward enough, and it is. In real life, your code when you define a class will sometimes consist of a few public instance methods along with lots of other instance methods on which they rely. The instance methods within this class will be calling each other constantly. They do this by sending messages to <code class="literal">self</code>.</p>
        <p>Behind this simple example, though, is a subtle and important mechanism having to do with the real meaning of the keyword <code class="literal">self</code>. The keyword <code class="literal">self</code> does not actually mean “in the same class.” It’s an instance, after all, not a class. What instance? It’s this same instance. The same as what? The same instance to which the message was sent that resulted in the keyword <code class="literal">self</code> being encountered in the first place.</p>
        <p>So let’s consider in more detail what happens when we instantiate MyClass and send the <code class="literal">sayGoodnightGracie</code> message to that instance:</p>
        <pre class="screen">MyClass* thing = [MyClass new];
NSString* s = [thing sayGoodnightGracie];</pre>
        <p>We instantiate MyClass and assign the instance to a variable <code class="literal">thing</code>. We then send the <code class="literal">sayGoodnightGracie</code> message to <code class="literal">thing</code>, the instance we just created. The message arrives, and it turns out this instance is a MyClass. Sure enough, MyClass implements a <code class="literal">sayGoodnightGracie</code> instance method, and this method is called. As it runs, the keyword <code class="literal">self</code> is encountered. It means “the instance to which the original message was sent in the first place.” That, as it happens, is the instance pointed to by the variable <code class="literal">thing</code>. So now the <code class="literal">greeting</code> message is sent to that instance (<a class="xref" href="ch05.html#FIGself">Figure 5.2</a>).</p>
        <div class="figure">
          <a id="FIGself"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0502.png" alt="figs/pios_0502.png" />
            </div>
          </div>
          <p class="title">Figure 5.2. The meaning of self</p>
        </div>
        <br class="figure-break" />
        <p>This mechanism may seem rather elaborate, considering that the outcome is just what you’d intuitively expect. But the mechanism <span class="emphasis"><em>needs</em></span> to be elaborate in order to get the right outcome. This is particularly evident when superclasses are involved and a class overrides a method of its superclass. To illustrate, suppose we have a class Dog with an instance method <code class="literal">bark</code>. And suppose Dog also has an instance method <code class="literal">speak</code>, which simply calls <code class="literal">bark</code>. Now suppose we subclass Dog with a class Basenji, which overrides <code class="literal">bark</code> (because Basenjis can’t bark). What happens when we send the <code class="literal">speak</code> message to a Basenji instance, as in <a class="xref" href="ch05.html#EXbasenji">Example 5.2</a>?</p>
        <div class="example">
          <a id="EXbasenji"></a>
          <p class="title">Example 5.2. Polymorphism in action</p>
          <div class="example-contents">
            <pre class="screen">@implementation Dog

- (NSString*) bark {
    return @"Woof!";
}

- (NSString*) speak {
    return [self bark];
}

@end

@implementation Basenji : Dog

- (NSString*) bark {
    return @""; // empty string, Basenjis can't bark
}

@end

// So, in some other class:

Basenji* b = [Basenji new];
NSString* s = [b speak];</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>If the keyword <code class="literal">self</code> meant merely “the same class where this keyword appears,” then when we send the <code class="literal">speak</code> message to a Basenji instance, we would arrive at the implementation of <code class="literal">speak</code> in the Dog class (because that’s where <code class="literal">speak</code> is implemented), and the Dog class’s <code class="literal">bark</code> method would be called. This would be terrible, because it would make nonsense of the notion of overriding; we’d return <code class="literal">@"Woof!"</code>, which is wrong for a Basenji. But that is <span class="emphasis"><em>not</em></span> what the keyword <code class="literal">self</code> means. It has to do with the instance, not the class.</p>
        <p>So here’s what happens. The <code class="literal">speak</code> message is sent to our Basenji instance, <code class="literal">b</code>. The Basenji class doesn’t implement a <code class="literal">speak</code> method, so we look upward in the class hierarchy and discover that <code class="literal">speak</code> is implemented in the superclass, Dog. We call Dog’s instance method <code class="literal">speak</code>, the <code class="literal">speak</code> method runs, and the keyword <code class="literal">self</code> is encountered. It means “the instance to which the original message was sent in the first place.” That instance is still our Basenji instance <code class="literal">b</code>. So we send the <code class="literal">bark</code> message to the Basenji instance <code class="literal">b</code>. The Basenji class implements a <code class="literal">bark</code> instance method, so this method is found and called, and the empty string is returned (<a class="xref" href="ch05.html#FIGpoly">Figure 5.3</a>).</p>
        <div class="figure">
          <a id="FIGpoly"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0503.png" alt="figs/pios_0503.png" />
            </div>
          </div>
          <p class="title">Figure 5.3. Class inheritance, overriding, self, and polymorphism</p>
        </div>
        <br class="figure-break" />
        <p>Of course, if the Basenji class had <span class="emphasis"><em>not</em></span> overridden <code class="literal">bark</code>, then when the <code class="literal">bark</code> message was sent to the Basenji instance, we would have looked upward in the class hierarchy <span class="emphasis"><em>again</em></span> and found the <code class="literal">bark</code> method implemented in the Dog class and called that. Thus, thanks to the way the keyword <code class="literal">self</code> works, inheritance works correctly both when there is overriding and when there is not.</p>
        <p>If you understand that example, you understand polymorphism. The mechanism I’ve just described is crucial to polymorphism and is the basis of object-oriented programming. (Observe that I now speak of object-oriented programming, not just object-based programming as in <a class="xref" href="ch02.html">Chapter 2</a>. That’s because, in my view, the addition of polymorphism is what turns object-based programming into object-oriented programming.)<a id="idm441655895456" class="indexterm"></a>
<a id="idm441655894560" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_keyword_super"></a>The Keyword super</h2>
            </div>
          </div>
        </div>
        <p>Sometimes (quite often, in Cocoa programming) you want to override an inherited method but still access the overridden functionality. To do so, you’ll use the keyword <code class="literal">super</code>.<a id="idm441655891312" class="indexterm"></a> Like <code class="literal">self</code>, the keyword <code class="literal">super</code> is something you send a message to. But its meaning has nothing to do with “this instance” or any other instance. The keyword <code class="literal">super</code> is class-based, and it means: “Start the search for messages I receive in the superclass of this class” (where “this class” is the class where the keyword <code class="literal">super</code> appears).</p>
        <p>You can do anything you like with <code class="literal">super</code>, but its primary purpose, as I’ve already said, is to access overridden functionality — typically from within the very functionality that does the overriding, so as to get both the overridden functionality and some additional functionality.</p>
        <p>For example, suppose we define a class NoisyDog, a subclass of Dog. When told to bark, it barks twice:<a id="idm441655885776" class="indexterm"></a>
<a id="idm441655884528" class="indexterm"></a></p>
        <p></p>
        <pre class="screen">@implementation NoisyDog : Dog

- (NSString*) bark {
    return [NSString stringWithFormat: @"%@ %@", [super bark], [super bark]];
}

@end</pre>
        <p>That code calls <code class="literal">super</code>’s implementation of <code class="literal">bark</code>, twice; it assembles the two resulting strings into a single string with a space between, and returns that (using the <code class="literal">stringWithFormat:</code> method). Because Dog’s <code class="literal">bark</code> method returns <code class="literal">@"Woof!"</code>, NoisyDog’s <code class="literal">bark</code> method returns <code class="literal">@"Woof! Woof!"</code>. Notice that there is no circularity or recursion here: NoisyDog’s <code class="literal">bark</code> method will never call itself.</p>
        <p>A nice feature of this architecture is that by sending a message to the keyword <code class="literal">super</code>, rather than hard-coding <code class="literal">@"Woof!"</code> into NoisyDog’s <code class="literal">bark</code> method, we ensure maintainability: if Dog’s <code class="literal">bark</code> method is changed, the result of NoisyDog’s <code class="literal">bark</code> method will change to match. For example, if we later go back and change Dog’s <code class="literal">bark</code> method to return <code class="literal">@"Arf!"</code>, NoisyDog’s <code class="literal">bark</code> method will return <code class="literal">@"Arf! Arf!"</code> with no further change on our part.</p>
        <p>In real Cocoa programming, it will very often be Cocoa’s own methods that you’re overriding. For example, the UIViewController class, which is built into Cocoa, implements a method <code class="literal">viewDidAppear:</code>, defined as follows:</p>
        <pre class="screen">- (void)viewDidAppear:(BOOL)animated</pre>
        <p>The documentation says that UIViewController is a class for which you are very likely to define a subclass (so as to get all of UIViewController’s mighty powers — we’ll find out what they are in <a class="xref" href="ch19.html">Chapter 19</a> — along with your own custom behavior). The documentation proceeds to suggest that in your subclass of UIViewController you might want to override this method, but cautions that if you do, “you must call <code class="literal">super</code> at some point in your implementation.” The phrase “call <code class="literal">super</code>” is a kind of shorthand, meaning “pass on to <code class="literal">super</code> the very same call and arguments that were sent to you.” So your own implementation might look like this:<a id="idm441655864688" class="indexterm"></a></p>
        <pre class="screen">@implementation MyViewController : UIViewController
// ...
- (void) viewDidAppear: (BOOL) animated {
    [super viewDidAppear: animated];
    // ... do more stuff here ...
}</pre>
        <p>The result is that when <code class="literal">viewDidAppear:</code> is called in a MyViewController instance, we do both the standard stuff that its superclass UIViewController does in response to <code class="literal">viewDidAppear:</code> and the custom stuff pertaining to our own class MyViewController. In this particular case, we don’t even know exactly what the UIViewController stuff is, and we don’t care. When the documentation tells you to call <code class="literal">super</code> when overriding, call <code class="literal">super</code> when overriding!</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_instance_variables_and_accessors"></a>Instance Variables and Accessors</h2>
            </div>
          </div>
        </div>
        <p>In <a class="xref" href="ch03.html">Chapter 3</a>, I explained that one of the main reasons there are instances and not just classes is that instances can have instance variables. Instance variables, you remember, are declared when you define the class, and in <a class="xref" href="ch04.html">Chapter 4</a> I said that these declarations go into curly braces at the start of the class’s interface section or, in modern Objective-C, its implementation section. But the value of an instance variable differs for each instance.<a id="idm441655855984" class="indexterm"></a>
<a id="idm441655854736" class="indexterm"></a><a id="idm441655853872" class="indexterm"></a>
<a id="idm441655852624" class="indexterm"></a></p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>The term “instance variable” arises so often that it is often abbreviated to <span class="emphasis"><em>ivar</em></span>. I’ll use both terms indiscriminately from now on.
<a id="idm441655850768" class="indexterm"></a></p>
        </div>
        <p>Let’s write a class that uses an instance variable. Suppose we have a Dog class and we want every Dog instance to have a number, which should be an int. (For example, this number might correspond to the dog’s license number, or something like that.) In modern Objective-C, we would probably declare <code class="literal">number</code> in the implementation section for the Dog class, like this:</p>
        <pre class="screen">@implementation Dog {
    int number;
}
// method implementations go here
@end</pre>
        <p>(You might ask why, for this example, I don’t use instead the concept of giving the dog a name. The reason is that a name would be an NSString instance, which is an object; instance variables that are pointers to objects raise some additional issues I don’t want to discuss just now. But instance variables that are simple C data types raise no such issues. We’ll return to this matter in <a class="xref" href="ch12.html">Chapter 12</a>.)</p>
        <p>By default, instance variables are <span class="emphasis"><em>protected</em></span>, meaning that other classes (except for subclasses) can’t see them. So if, somewhere else, I instantiate a Dog, I won’t be able to access that Dog instance’s <code class="literal">number</code> instance variable. This is a deliberate feature of <span class="keep-together">Objective-C</span>; you can work around it if you like, but in general you should not. Instead, if you want to provide public access to an instance variable, write an accessor method and make the method declaration public.<a id="idm441655843648" class="indexterm"></a>
<a id="idm441655842400" class="indexterm"></a></p>
        <p>Within a class, on the other hand, that class’s own instance variables are global. Any Dog method can just use the variable name <code class="literal">number</code> and access this instance variable, just like any other variable. But code that does this can be confusing when you’re reading it; suddenly there’s a variable called <code class="literal">number</code> and you don’t understand what it is, because there’s no nearby declaration for it. So I often use a different notation, like this: <code class="literal">self-&gt;ivarName</code>. The “arrow” operator, formed by a minus sign and a greater-than sign, is called the <span class="emphasis"><em>structure pointer</em></span> operator, because of its original use in C (K&amp;R 6.2).<a id="idm441655837888" class="indexterm"></a>
<a id="idm441655836384" class="indexterm"></a>
<a id="idm441655835136" class="indexterm"></a><a id="idm441655834272" class="indexterm"></a>
<a id="idm441655832768" class="indexterm"></a>
<a id="idm441655831520" class="indexterm"></a></p>
        <p>So let’s write, in Dog’s implementation section, a method that allows setting a value for the <code class="literal">number</code> ivar:</p>
        <pre class="screen">- (void) setNumber: (int) n {
    self-&gt;number = n;
}</pre>
        <p>Of course, to make <code class="literal">setNumber:</code> public to any other class that imports Dog’s interface file, we must also declare it in Dog’s interface section:</p>
        <pre class="screen">@interface Dog : NSObject
- (void) setNumber: (int) n;
@end</pre>
        <p>We can now instantiate a Dog and assign that instance a number:</p>
        <pre class="screen">Dog* fido = [Dog new];
[fido setNumber: 42];</pre>
        <p>We can now set a Dog’s number, but we can’t get it (from outside that Dog instance). To correct this problem, we’ll write a second accessor method, one that allows for getting the value of the <code class="literal">number</code> ivar:</p>
        <pre class="screen">- (int) number {
    return self-&gt;number;
}</pre>
        <p>Again, we declare the <code class="literal">number</code> method in Dog’s interface section. Now we can both set and get a Dog instance’s <code class="literal">number</code>:</p>
        <pre class="screen">Dog* fido = [Dog new];
[fido setNumber: 42];
int n = [fido number];
// sure enough, n is now 42!</pre>
        <p>This architecture is very typical. Your class can have as many ivars as you like, but if you want them to be publicly accessible, you must provide accessor methods. Luckily, Objective-C 2.0 — which is what you’re using to program for iOS — provides a mechanism for generating accessor methods automatically (discussed in <a class="xref" href="ch12.html">Chapter 12</a>), so you won’t have to go through the tedium of writing them by hand every time you want to make an ivar publicly accessible. (Though, to be honest, I don’t see why you shouldn’t have to go through that tedium; before Objective-C 2.0, we all had to, so why shouldn’t you? We also had to clean the roads with our tongues on the way to school. And we liked it! You kids today, you don’t know what real programming is.)<a id="idm441655819600" class="indexterm"></a></p>
        <p>You’ve probably noticed that Dog now has both a <code class="literal">number</code> method and a <code class="literal">number</code> instance variable. This fact should not confuse you. It doesn’t confuse the compiler, because the method name and the instance variable name are used in completely different ways in code. If the compiler can tell the difference, so can you. Nevertheless, a convention that is becoming increasingly common, for reasons that I’ll explain in <a class="xref" href="ch12.html">Chapter 12</a>, is to begin ivar names with an underscore: <code class="literal">_number</code>, not <code class="literal">number</code>.<a id="idm441655813552" class="indexterm"></a>
<a id="idm441655812304" class="indexterm"></a> If we follow this convention and rename our ivar, we’ll also have to rewrite (but not rename) the methods that access it:</p>
        <pre class="screen">@implementation Dog {
    int _number;
}

- (void) setNumber: (int) n {
    self-&gt;_number = n;
}

- (int) number {
    return self-&gt;_number;
}

@end</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_key_value_coding"></a>Key–Value Coding</h2>
            </div>
          </div>
        </div>
        <p>Objective-C provides a means for translating from a string to an instance variable accessor, called <span class="emphasis"><em>key–value coding</em></span>.<a id="idm441655808144" class="indexterm"></a> Such translation is useful, for example, when the name of the desired instance variable will not be known until runtime. So instead of calling <code class="literal">[fido number]</code>, we might have a string <code class="literal">@"number"</code> that tells us what accessor to call. This string is the “key.” The key–value coding equivalent of calling a getter is <code class="literal">valueForKey:</code>; the equivalent of calling a setter is <code class="literal">setValue:forKey:</code>.</p>
        <p>Thus, for example, suppose we wish to get the value of the <code class="literal">number</code> instance variable from the <code class="literal">fido</code> instance. We can do this by sending <code class="literal">valueForKey:</code> to <code class="literal">fido</code>. However, even though the <code class="literal">number</code> instance variable is an int, the value returned by <code class="literal">valueForKey:</code> is an object — in this case, an NSNumber, the object equivalent of a number (see <a class="xref" href="ch10.html">Chapter 10</a>). If we want the actual int, NSNumber provides an instance method, <code class="literal">intValue</code>, that lets us extract it:</p>
        <pre class="screen">NSNumber* num = [fido valueForKey: @"number"];
int n = [num intValue];</pre>
        <p>Similarly, to use key–value coding to set the value of the <code class="literal">number</code> instance variable in the <code class="literal">fido</code> instance, we would say:</p>
        <pre class="screen">NSNumber* num = [NSNumber numberWithInt:42];
[fido setValue: num forKey: @"number"];</pre>
        <p>Before handing off the number 42 as the <code class="literal">value</code> argument in <code class="literal">setValue:forKey:</code>, we had to wrap it up as an object — in this case, an NSNumber object. Starting with LLVM compiler version 4.0 (Xcode 4.4), there’s a syntactic shorthand for doing that; just as we can create an NSString by wrapping text in a compiler directive <code class="literal">@"..."</code>, we can create an NSNumber by wrapping a numeric expression in a compiler directive <code class="literal">@(...)</code> — or, if the numeric expression is just a literal number, by preceding that literal number with <code class="literal">@</code>. So we can rewrite the previous example like this:<a id="idm441655791504" class="indexterm"></a>
<a id="idm441655790256" class="indexterm"></a></p>
        <pre class="screen">NSNumber* num = @42;
[fido setValue: num forKey: @"number"];</pre>
        <p>In real life, you’d probably omit the intermediate variable <code class="literal">num</code> and write the whole thing as a single line of code:</p>
        <pre class="screen">[fido setValue: @42 forKey: @"number"];</pre>
        <p>In these examples there is no advantage to using key–value coding over just calling the accessors. But suppose we had received the value <code class="literal">@"number"</code> in a variable (as the result of a method call, perhaps). Suppose that variable is called <code class="literal">something</code>. Then we could say:</p>
        <pre class="screen">id result = [fido valueForKey: something];</pre>
        <p>Thus we could access a different instance variable under different circumstances. This powerful flexibility is possible because Objective-C is such a dynamic language that a message to be sent to an object does not have to be formed until the program is already running.</p>
        <p>When you call <code class="literal">valueForKey:</code> or <code class="literal">setValue:forKey:</code>, the correct accessor method is called if there is one. Thus, when we use <code class="literal">@"number"</code> as the key, a <code class="literal">number</code> method and a <code class="literal">setNumber:</code> method are called if they exist. (This is one reason why your accessors should be properly named.) On the other hand, if there isn’t an accessor method, the instance variable is accessed directly. Such direct access violates the privacy of instance variables, so there’s a way to turn off this feature for a particular class if you don’t like it. (I’ll explain what it is, with more about key–value coding, in <a class="xref" href="ch12.html">Chapter 12</a>.)</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_properties"></a>Properties</h2>
            </div>
          </div>
        </div>
        <p>A <span class="emphasis"><em>property</em></span> is a syntactic feature of Objective-C 2.0 designed to provide an alternative to the standard syntax for calling an accessor method.<a id="idm441655776736" class="indexterm"></a><a id="idm441655775872" class="indexterm"></a> As syntactic sugar for formally calling a method, you can append the property name to an instance reference using dot-notation. You can use the resulting expression either on the left side of an equal sign (to call the corresponding setter) or elsewhere (to call the corresponding getter).<a id="idm441655774576" class="indexterm"></a> The name of the property relies, by default, on the accessor naming conventions.</p>
        <p>I’ll use the Dog class as an example. If the Dog class has a public getter method called <code class="literal">number</code> and a public setter method called <code class="literal">setNumber:</code>, then the Dog class also has a <code class="literal">number</code> property. This means that, instead of saying things like this:</p>
        <pre class="screen">[fido setNumber: 42];
int n = [fido number];</pre>
        <p>You can talk like this:</p>
        <pre class="screen">fido.number = 42;
int n = fido.number;</pre>
        <p>Your use of property syntax is entirely optional. The existence of a property is equivalent to the existence of the corresponding getter and setter methods, and you’re free to call those methods by either syntax. When you use property syntax in code, it is translated behind the scenes into a call to the corresponding getter or setter method, so it’s all the same if you call the corresponding getter or setter method explicitly. In the case of Dog, you can use <code class="literal">number</code> as a property, or you can call the getter and setter methods <code class="literal">number</code> and <code class="literal">setNumber:</code>.</p>
        <p>(Naturally, there are verbal quasi-religious wars on this topic, with one side claiming that property syntax is convenient and compact, and makes Objective-C more like other languages that use dot-notation, and the other side retorting that it does no such thing, because it is so limited. For example, property syntax opponents would argue, a UIScrollView has a <code class="literal">contentView</code> property, but when <span class="emphasis"><em>setting</em></span> it you are most likely to want to animate the scroll view at the same time, which you do by calling <code class="literal">setContentView:animated:</code>. That’s a kind of setter, but it takes two parameters; property syntax can’t express that, so we’re back to using an explicit method call, and property syntax has saved us nothing, and in fact is more likely to mislead us into forgetting to add the animation. Another objection to property notation is that the compiler restricts its use; for example, you can use a formal method call to send the <code class="literal">number</code> message to a Dog instance typed as an <code class="literal">id</code>, but you can’t append the <code class="literal">number</code> property with dot-notation to such an instance.)</p>
        <p>To use a property within the class that has that property, you must use <code class="literal">self</code> explicitly. So, for example:</p>
        <pre class="screen">self.number = 42;</pre>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Do not confuse a property with an instance variable. An expression like <code class="literal">self-&gt;number = n</code>, or even simply <code class="literal">number = n</code>, sets the instance variable directly (and is possible only within the class, because instance variables are protected by default). An expression like <code class="literal">fido.number</code> or <code class="literal">self.number</code> involves a property and is equivalent to calling a getter or setter method. That getter or setter method may access an instance variable, and that instance variable may even have the same name as the property, but that doesn’t make them the same thing.</p>
        </div>
        <p>Properties will be taken up again in <a class="xref" href="ch12.html">Chapter 12</a>, where it will turn out that they are much more powerful and interesting beasts than I’m suggesting here. But I’m telling you about properties now because they are so widely used in Cocoa and because you’ll encounter them so frequently in the documentation. For example, in <a class="xref" href="ch01.html">Chapter 1</a>, I talked about setting a UIView’s <code class="literal">autoresizingMask</code> property:</p>
        <pre class="screen">myView.autoresizingMask =
    UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleWidth;</pre>
        <p>How did I know I could talk that way? Because the UIView documentation says that UIView has an <code class="literal">autoresizingMask</code> property. Near the top of the documentation page, we see this line:</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <p><code class="literal">autoresizingMask</code> <span class="emphasis"><em>property</em></span></p>
          </blockquote>
        </div>
        <p>And further down, we get the details:</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <p>
              <span class="strong">
                <strong>autoresizingMask</strong>
              </span>
            </p>
            <p>An integer bit mask that determines how the receiver resizes itself when its superview’s bounds change.</p>
            <p>
              <code class="literal">@property(nonatomic) UIViewAutoresizing autoresizingMask</code>
            </p>
          </blockquote>
        </div>
        <p>That last line is a <span class="emphasis"><em>property declaration</em></span>. From the point of view of the UIView class’s client — in this case, that’s you — the property declaration is simply a shorthand, telling you that such a property exists, rather than bothering to tell you about the two accessor methods <code class="literal">autoresizingMask</code> and <code class="literal">setAutoresizingMask:</code>. (Never mind for now what <code class="literal">nonatomic</code> means.) That’s how I knew there was a setter <code class="literal">setAutoresizingMask:</code>. In my code, I used property syntax as a way of calling that setter method; alternatively, I could have called <code class="literal">setAutoresizingMask:</code> explicitly.</p>
        <p>Similarly, earlier in this chapter I called UIView’s <code class="literal">setFrame:</code> method, even though no such method is mentioned in the UIView documentation. What the UIView documentation does say is this:</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <p>
              <span class="strong">
                <strong>frame</strong>
              </span>
            </p>
            <p>The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.</p>
            <p>
              <code class="literal">@property(nonatomic) CGRect frame</code>
            </p>
          </blockquote>
        </div>
        <p>The documentation is telling me about the UIView property name <code class="literal">frame</code>, but that’s the same thing as telling me about the existence of UIView instance methods <code class="literal">frame</code> and <code class="literal">setFrame:</code>; I can use these methods either through the <code class="literal">frame</code> property and dot-notation or by calling them explicitly.</p>
        <p>Objective-C uses dot-notation for properties, and C uses dot-notation for structs; these can be chained. So, for example, UIView’s <code class="literal">frame</code> is a property whose value is a struct (a CGRect); thus, you can say <code class="literal">myView.frame.size.height</code>, where <code class="literal">frame</code> is a property that returns a struct, <code class="literal">size</code> is an element of that struct, and <code class="literal">height</code> is an element of <span class="emphasis"><em>that</em></span> struct. But there are limitations on this syntax; you cannot (for example) <span class="emphasis"><em>set</em></span> a frame’s height directly through a chain starting with the UIView, like this:<a id="idm441655735440" class="indexterm"></a>
<a id="idm441655729744" class="indexterm"></a></p>
        <pre class="screen">myView.frame.size.height = 36.0; // error, "Expression is not assignable"</pre>
        <p>Instead, if you want to change a component of a struct property, you must fetch the property value into a struct variable, change the struct variable’s value, and set the entire property value from the struct variable:<a id="idm441655727328" class="indexterm"></a></p>
        <pre class="screen">CGRect f = myView.frame;
f.size.height = 0;
myView.frame = f;</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_how_to_write_an_initializer"></a>How to Write an Initializer</h2>
            </div>
          </div>
        </div>
        <p>Now that you know about <code class="literal">self</code> and <code class="literal">super</code> and instance variables, we can return to a topic that I blithely skipped over earlier. I described how to initialize a newly minted instance by calling an initializer, and emphasized that you must always do so, but I said nothing about how to write an initializer in your own classes. You will wish to do so only when you want your class to provide a convenient initializer that goes beyond the functionality of the inherited initializers. Often your purpose will be to accept some parameters and use them to set the initial values of some instance variables.<a id="idm441655722720" class="indexterm"></a></p>
        <p>For example, in the case of a Dog with a number, let’s say we don’t want any Dog instances to come into existence without a number; every Dog <span class="emphasis"><em>must</em></span> have one. So having a value for its <code class="literal">number</code> ivar is a <span class="emphasis"><em>sine qua non</em></span> of a Dog being instantiated in the first place. An initializer publicizes this rule and helps to enforce it — especially if it is the class’s designated initializer. So let’s decide that this initializer will be Dog’s designated initializer.</p>
        <p>Moreover, let’s say that a Dog’s number should not be changed. Once the Dog has come into existence, along with a number, that number should remain attached to that Dog instance for as long as that Dog instance persists.</p>
        <p>So delete the <code class="literal">setNumber:</code> method and its declaration, thus destroying any ability of other classes to set a Dog instance’s <code class="literal">number</code> after it has been initialized. Instead, we’re going to set a Dog’s <code class="literal">number</code> as it is initialized, using a method we’ll declare like this:</p>
        <pre class="screen">- (id) initWithNumber: (int) n</pre>
        <p>Our return value is typed as <code class="literal">id</code>, not as a pointer to a Dog, even though in fact we will return a Dog object. This is a convention that we should obey. The name is conventional as well; as you know, the <code class="literal">init</code> beginning tells the world this is an initializer.</p>
        <p>Now I’m just going to show you the actual code for the initializer (<a class="xref" href="ch05.html#EXinitializer">Example 5.3</a>). Much of this code is conventional — a dance you are required to do. You should not question this dance: just do it. I’ll describe the meaning of the code, but I’m not going to try to justify all the parts of the convention.</p>
        <div class="example">
          <a id="EXinitializer"></a>
          <p class="title">Example 5.3. Conventional schema for an initializer</p>
          <div class="example-contents">
            <pre class="screen">- (id) initWithNumber: (int) n {
    self = [super init]; <a id="CO3-1"></a>❶ <a id="CO3-2"></a>❷
    if (self) {
        self-&gt;_number = n; <a id="CO3-3"></a>❸
    }
    return self; <a id="CO3-4"></a>❹
}</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>The parts of the convention are:</p>
        <div class="calloutlist">
          <table border="0" summary="Callout list">
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO3-1">❶</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
We send some sort of initialization message, calling a designated initializer. If the method we are writing is our class’s designated initializer, this message is sent to <code class="literal">super</code> and calls the superclass’s designated initializer. Otherwise, it is sent to <code class="literal">self</code> and calls either this class’s designated initializer or another initializer that calls this class’s designated initializer. In this case, the method we are writing is our class’s designated initializer, and the superclass’s designated initializer is <code class="literal">init</code>.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO3-2">❷</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
We capture the result of the initialization message to <code class="literal">super</code>, and assign that result to <code class="literal">self</code>. It comes as a surprise to many beginners (and not-so-beginners) that one can assign to <code class="literal">self</code> at all or that it would make sense to do so. But one can assign to <code class="literal">self</code> (because of how Objective-C messaging works behind the scenes), and it makes sense to do so because in certain cases the instance returned from the call to <code class="literal">super</code> might not be same as the <code class="literal">self</code> we started with.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO3-3">❸</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
If <code class="literal">self</code> is not nil, we initialize any instance variables we care to. This part of the code is typically the only part you’ll customize; the rest will be according to the pattern. Observe that I don’t use any setter methods (or properties); in initializing an instance variable not inherited from the superclass, you should assign directly to the instance variable.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO3-4">❹</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
We return <code class="literal">self</code>.
</p>
              </td>
            </tr>
          </table>
        </div>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>All instance variables are set to a form of zero by <code class="literal">alloc</code>. Therefore, any instance variables not initialized explicitly in an initializer remain 0. This means, among other things, that by default a BOOL instance variable is NO and an object reference instance variable is nil. It is common practice to take advantage of these defaults in your program; if the default values are satisfactory initial values, you won’t bother to set them in your designated initializer.</p>
        </div>
        <p>But we are not finished. Recall from earlier in this chapter that a class that defines a designated initializer should also override the inherited designated initializer (in this case, <code class="literal">init</code>). And you can see why: if we don’t, someone could say <code class="literal">[[Dog alloc] init]</code> (or <code class="literal">[Dog new]</code>) and create a dog without a number — the very thing our initializer is trying to prevent. Just for the sake of the example, I’ll make the overridden <code class="literal">init</code> assign a negative number as a signal that there’s a problem. Notice that we’re still obeying the rules: this initializer is not the designated initializer, so it calls this class’s designated initializer.</p>
        <pre class="screen">- (id) init {
    return [self initWithNumber: -9999];
}</pre>
        <p>Just to complete the story, here’s some code showing how we now would instantiate a Dog:
<a id="idm441655687760" class="indexterm"></a></p>
        <pre class="screen">Dog* fido = [[Dog alloc] initWithNumber:42];
int n = [fido number];
// n is now 42; our initialization worked!</pre>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="pt02.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 4. Objective-C Classes </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Part II. IDE</td>
        </tr>
      </table>
    </div>
  </body>
</html>
