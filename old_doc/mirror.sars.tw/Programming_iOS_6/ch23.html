<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 23. Text</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt05.html" />
    <link rel="prev" href="ch22.html" />
    <link rel="next" href="ch24.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch22.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt05.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch24.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 22. Popovers and Split Views </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 24. Web Views</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id23"></a>Chapter 23. Text</h2>
          </div>
        </div>
      </div>
      <p>The high-level text classes are NSString and NSAttributedString. Text can be displayed in various ways:
<a id="idxtext" class="indexterm"></a></p>
      <div class="variablelist">
        <dl>
          <dt>
            <span class="term">
UILabel
</span>
          </dt>
          <dd>
Displays text, possibly consisting of multiple lines; neither scrollable nor editable.
</dd>
          <dt>
            <span class="term">
UITextField
</span>
          </dt>
          <dd>
Displays a single line of editable text; may have a border, a background image, and overlay views at its right and left end.
</dd>
          <dt>
            <span class="term">
UITextView
</span>
          </dt>
          <dd>
Displays scrollable text, possibly editable; can use data detectors to display tappable links.
</dd>
          <dt>
            <span class="term">
UIWebView
</span>
          </dt>
          <dd>
A scrollable view displaying rendered HTML. A good way to show text that includes images and tappable links. Can also display various additional document types, such as PDF, RTF, and <span class="emphasis"><em>.doc</em></span>. Discussed in <a class="xref" href="ch24.html">Chapter 24</a>.<a id="idm441644763472" class="indexterm"></a>
</dd>
          <dt>
            <span class="term">
Drawing
</span>
          </dt>
          <dd>
            <p class="simpara">
There are three main ways to draw text directly:
</p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">
Core Graphics
</span>
                </dt>
                <dd>
Low-level methods for drawing text (not NSStrings). For drawing in general, see <a class="xref" href="ch15.html">Chapter 15</a>.
</dd>
                <dt>
                  <span class="term">
NSString and NSAttributedString
</span>
                </dt>
                <dd>
At a high level, the UIStringDrawing category on NSString and the NSStringDrawing category on NSAttributedString endow strings with the ability to draw themselves, along with metrics methods for learning the dimensions at which a given string will be drawn. Some examples have appeared already in <a class="xref" href="ch12.html">Chapter 12</a> and <a class="xref" href="ch20.html">Chapter 20</a>.<a id="idm441644755376" class="indexterm"></a>
<a id="idm441644754080" class="indexterm"></a>
</dd>
                <dt>
                  <span class="term">
Core Text
</span>
                </dt>
                <dd>
The underlying low-level technology behind <span class="emphasis"><em>all</em></span> string drawing on iOS. Also provides access to advanced font typographical features.
</dd>
              </dl>
            </div>
          </dd>
        </dl>
      </div>
      <div class="note" style="margin-left: 0; margin-right: 10%;">
        <h3 class="title">Note</h3>
        <p>An app can include fonts within its bundle; these will be loaded at launch time if the app lists them in its <span class="emphasis"><em>Info.plist</em></span> under the “Fonts provided by application” key (<code class="literal">UIAppFonts</code>). In this way, your app can use fonts not present by default on the device.<a id="idm441644748192" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_attributed_strings"></a>Attributed Strings</h2>
            </div>
          </div>
        </div>
        <p>Before iOS 6, controls such as UILabel and UITextView could display text only in a <span class="emphasis"><em>single</em></span> font and size. If you wanted styled text — that is, text consisting of multiple <a id="idm441644745136" class="indexterm"></a>style runs, with different font, size, color, and other text features in different parts of the text — you were largely out of luck. You could construct an NSAttributedString to express styled text, by dropping down to the lowest level, Core Text; but to display it in the interface you had to use a CATextLayer or have CoreText draw it, which was a lot of work. Workarounds included using a UIWebView or manipulating multiple UILabels. (For example, that’s how the TidBITS News app used to work, as shown in <a class="xref" href="ch19.html#FIGtbnews">Figure 19.1</a>; the bold headline and the smaller article summary are two different labels.) <span class="emphasis"><em>Editable</em></span> styled text was virtually impossible to achieve.
<a id="idm441644742320" class="indexterm"></a>
<a id="idm441644741296" class="indexterm"></a>
<a id="idm441644740224" class="indexterm"></a>
<a id="idxattributedstrings" class="indexterm"></a></p>
        <p>Starting in iOS 6, however, NSAttributedString is fully integrated. With it, you can draw styled text directly, or you can hand an attributed string to any built-in interface class that understands it, including UILabel, UITextView, and UIButton.<a id="idm441644737280" class="indexterm"></a>
<a id="idm441644736000" class="indexterm"></a></p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>In general, interface object methods and properties that accept attributed strings stand side by side with their pre-iOS 6 equivalents; the new ones tend to have “attributed” in their name. Thus, you don’t <span class="emphasis"><em>have</em></span> to use attributed strings. If a UILabel, for example, is to display text in a single font, size, color, and alignment, it might be easiest to use the pre-iOS 6 plain-old-NSString features of UILabel. If you do decide to use attributed strings with an interface object, it is best not to mix in any of the pre-iOS 6 settings; if you’re going to use an attributed string, let it do <span class="emphasis"><em>all</em></span> the work of dictating text style features.<a id="idm441644732544" class="indexterm"></a>
<a id="idm441644730976" class="indexterm"></a>
<a id="idm441644729664" class="indexterm"></a></p>
        </div>
        <p>An NSAttributedString consists of an NSString (its <code class="literal">string</code>) plus the attributes, applied in ranges. For example, if the string “one red word” is blue except for the word “red” which is red, and if these are the only changes over the course of the string, then there are three distinct style runs — everything before the word “red,” the word “red” itself, and everything after the word “red.” However, we can apply the attributes in two steps, first making the whole string blue, and then making the word “red” red, just as you would expect.</p>
        <p>The attributes are described in dictionaries. Each possible attribute has a predefined name, used as a key in these dictionaries:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">NSFontAttributeName</code>
</span>
            </dt>
            <dd>
A UIFont, including font family, style, and size.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSForegroundColorAttributeName</code>
</span>
            </dt>
            <dd>
The text color, a UIColor.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSBackgroundColorAttributeName</code>
</span>
            </dt>
            <dd>
The color <span class="emphasis"><em>behind</em></span> the text, a UIColor. You could use this to highlight a word, for example.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSLigatureAttributeName</code>
</span>
            </dt>
            <dd>
An NSNumber wrapping 0 or 1, expressing whether or not you want ligatures used.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSKernAttributeName</code>
</span>
            </dt>
            <dd>
An NSNumber wrapping the floating-point amount of kerning. A negative value brings a glyph closer to the following glyph; a positive value adds space between them. The special value <code class="literal">[NSNull null]</code> turns on inherent autokerning if the font supports it.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSStrikethroughStyleAttributeName</code>
</span>
            </dt>
            <dd>
An NSNumber wrapping 0 or 1.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSUnderlineStyleAttributeName</code>
</span>
            </dt>
            <dd>
An NSNumber wrapping 0 or 1.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSStrokeColorAttributeName</code>
</span>
            </dt>
            <dd>
The stroke color, a UIColor.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSStrokeWidthAttributeName</code>
</span>
            </dt>
            <dd>
An NSNumber wrapping a float. The stroke width is peculiarly coded. If it isn’t zero, it’s either a positive or negative float (wrapped in an NSNumber). If it’s positive, then the text glyphs are stroked but not filled, giving an outline effect, and the foreground color is used unless the stroke color is defined. If it’s negative, then its absolute value is the width of the stroke, and the glyphs are both filled (with the foreground color) and stroked (with the stroke color).
</dd>
            <dt>
              <span class="term">
<code class="literal">NSShadowAttributeName</code>
</span>
            </dt>
            <dd>
An <a id="idm441644701472" class="indexterm"></a>NSShadow object. An NSShadow is just a glorified struct (what Apple calls a “value object”), combining a <code class="literal">shadowOffset</code>, <code class="literal">shadowColor</code>, and <code class="literal">shadowBlurRadius</code>.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSParagraphStyleAttributeName</code>
</span>
            </dt>
            <dd>
              <p class="simpara">
An <a id="idm441644696560" class="indexterm"></a>NSParagraphStyle object. This is basically just a glorified struct, assembling text features that apply properly to paragraphs as a whole, not merely to characters, even if your string consists only of a single paragraph. Here are its most important properties:<a id="idm441644695504" class="indexterm"></a>
<a id="idm441644694208" class="indexterm"></a><a id="idm441644693312" class="indexterm"></a>
<a id="idm441644692016" class="indexterm"></a><a id="idm441644691120" class="indexterm"></a>
<a id="idm441644689824" class="indexterm"></a>
</p>
              <div class="itemizedlist">
                <ul class="itemizedlist" type="disc">
                  <li class="listitem">
                    <p class="simpara">
<code class="literal">alignment</code>
</p>
                    <div class="itemizedlist">
                      <ul class="itemizedlist" type="circle">
                        <li class="listitem">
<code class="literal">NSTextAlignmentLeft</code>
</li>
                        <li class="listitem">
<code class="literal">NSTextAlignmentCenter</code>
</li>
                        <li class="listitem">
<code class="literal">NSTextAlignmentRight</code>
</li>
                        <li class="listitem">
<code class="literal">NSTextAlignmentJustified</code> (a new facility in iOS 6)<a id="idm441644681408" class="indexterm"></a>
<a id="idm441644680096" class="indexterm"></a>
</li>
                        <li class="listitem">
<code class="literal">NSTextAlignmentNatural</code> (left-aligned or right-aligned depending on the writing direction)
</li>
                      </ul>
                    </div>
                  </li>
                  <li class="listitem">
                    <p class="simpara">
<code class="literal">lineBreakMode</code> (only the two <code class="literal">Wrapping</code> options wrap; the others draw a single line)
</p>
                    <div class="itemizedlist">
                      <ul class="itemizedlist" type="circle">
                        <li class="listitem">
<code class="literal">NSLineBreakByWordWrapping</code>
</li>
                        <li class="listitem">
<code class="literal">NSLineBreakByCharWrapping</code>
</li>
                        <li class="listitem">
<code class="literal">NSLineBreakByClipping</code>
</li>
                        <li class="listitem">
<code class="literal">NSLineBreakByTruncatingHead</code>
</li>
                        <li class="listitem">
<code class="literal">NSLineBreakByTruncatingTail</code>
</li>
                        <li class="listitem">
<code class="literal">NSLineBreakByTruncatingMiddle</code>
</li>
                      </ul>
                    </div>
                  </li>
                  <li class="listitem">
<code class="literal">firstLineHeadIndent</code>, <code class="literal">headIndent</code> (left margin), <code class="literal">tailIndent</code> (right margin)
</li>
                  <li class="listitem">
<code class="literal">lineHeightMultiple</code>, <code class="literal">maximumLineHeight</code>, <code class="literal">minimumLineHeight</code>
</li>
                  <li class="listitem">
<code class="literal">lineSpacing</code>
</li>
                  <li class="listitem">
<code class="literal">paragraphSpacing</code>, <code class="literal">paragraphSpacingBefore</code>
</li>
                  <li class="listitem">
<code class="literal">hyphenationFactor</code> (a float between 0 and 1)<a id="idm441644655776" class="indexterm"></a>
<a id="idm441644654448" class="indexterm"></a>
</li>
                </ul>
              </div>
            </dd>
          </dl>
        </div>
        <p>To construct an NSAttributedString, you can call <code class="literal">initWithString:attributes:</code> if the entire string has the same attributes; otherwise, you’ll use its mutable subclass NSMutableAttributedString, which lets you set attributes over a range. To construct an NSParagraphStyle, you’ll use its mutable subclass NSMutableParagraphStyle. (The properties of NSParagraphStyle itself are all read-only, for historical reasons.) It is sufficient to apply a paragraph style to the first character of a paragraph; to put it another way, the paragraph style of the first character of a paragraph dictates how the whole paragraph is rendered. Both NSAttributedString and NSParagraphStyle come with default values for all attributes, so you only have to set the attributes you care about.</p>
        <p>We now know enough for an example! I’ll generate the paragraph shown in <a class="xref" href="ch23.html#FIGgetty1">Figure 23.1</a>. This is a UILabel; its background is white, so you can see its bounds relative to the text. Two words are made extra-bold by stroking in a different color, and the whole paragraph is centered and indented from the edges of the label.</p>
        <div class="figure">
          <a id="FIGgetty1"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2301.png" alt="figs/pios_2301.png" />
            </div>
          </div>
          <p class="title">Figure 23.1. A label showing an attributed string</p>
        </div>
        <br class="figure-break" />
        <p>I start by dictating the entire string and the overall style of the text; then I apply the special style to the two stroked words:</p>
        <pre class="screen">NSString* s1 = @"The Gettysburg Address, as delivered on a certain occasion "
    @"(namely Thursday, November 19, 1863) by A. Lincoln";
NSMutableAttributedString* content =
    [[NSMutableAttributedString alloc]
     initWithString:s1
     attributes:
         @{
           NSFontAttributeName:
               [UIFont fontWithName:@"Arial-BoldMT" size:15],
           NSForegroundColorAttributeName:
               [UIColor colorWithRed:0.251 green:0.000 blue:0.502 alpha:1]
         }];
NSRange r = [s1 rangeOfString:@"Gettysburg Address"];
[content addAttributes:
    @{
      NSStrokeColorAttributeName:[UIColor redColor],
      NSStrokeWidthAttributeName: @-2.0
     } range:r];</pre>
        <p>Now I create the paragraph style and apply it to the first character. Note how the margins are dictated: the <code class="literal">tailIndent</code> is negative, to bring the right margin leftward, and the <code class="literal">firstLineHeadIndent</code> must be set separately, as the <code class="literal">headIndent</code> does not automatically apply to the first line:</p>
        <pre class="screen">NSMutableParagraphStyle* para = [NSMutableParagraphStyle new];
para.headIndent = 10;
para.firstLineHeadIndent = 10;
para.tailIndent = -10;
para.lineBreakMode = NSLineBreakByWordWrapping;
para.alignment = NSTextAlignmentCenter;
para.paragraphSpacing = 15;
[content addAttribute:NSParagraphStyleAttributeName
                value:para range:NSMakeRange(0,1)];</pre>
        <p>Now I’ll generate the string shown in <a class="xref" href="ch23.html#FIGgetty2">Figure 23.2</a>. Note the full justification, the automatic hyphenation, and the large initial cap kerned close to the following letter.</p>
        <div class="figure">
          <a id="FIGgetty2"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2302.png" alt="figs/pios_2302.png" />
            </div>
          </div>
          <p class="title">Figure 23.2. A label showing another attributed string</p>
        </div>
        <br class="figure-break" />
        <p>Once again, I start by styling the string as a whole; then I style the first letter. There’s an obvious but important difference between <code class="literal">setAttributes:</code> and <code class="literal">addAttributes:</code>:</p>
        <pre class="screen">NSString* s2 = @"Fourscore and seven years ago, our fathers brought forth "
    @"upon this continent a new nation, conceived in liberty and dedicated "
    @"to the proposition that all men are created equal.";
NSMutableAttributedString* content2 =
    [[NSMutableAttributedString alloc]
     initWithString:s2
     attributes:
         @{
           NSFontAttributeName:
               [UIFont fontWithName:@"HoeflerText-Black" size:16]
         }];
[content2 setAttributes:
    @{
      NSFontAttributeName:[UIFont fontWithName:@"HoeflerText-Black" size:24]
     } range:NSMakeRange(0,1)];
[content2 addAttributes:
    @{
      NSKernAttributeName:@-4
     } range:NSMakeRange(0,1)];</pre>
        <p>Now I’ll construct the paragraph style and add it to the first character:</p>
        <pre class="screen">NSMutableParagraphStyle* para2 = [NSMutableParagraphStyle new];
para2.headIndent = 10;
para2.firstLineHeadIndent = 10;
para2.tailIndent = -10;
para2.lineBreakMode = NSLineBreakByWordWrapping;
para2.alignment = NSTextAlignmentJustified;
para2.lineHeightMultiple = 1.2;
para2.hyphenationFactor = 1.0;
[content2 addAttribute:NSParagraphStyleAttributeName
                 value:para2 range:NSMakeRange(0,1)];</pre>
        <p>Now we come to the Really Amazing Part. I can make a <span class="emphasis"><em>single</em></span> attributed string consisting of <span class="emphasis"><em>both</em></span> paragraphs, and a single UILabel can portray it (<a class="xref" href="ch23.html#FIGgetty3">Figure 23.3</a>):</p>
        <pre class="screen">int end = content.length;
[content replaceCharactersInRange:NSMakeRange(end, 0) withString:@"\n"];
[content appendAttributedString:content2];</pre>
        <div class="figure">
          <a id="FIGgetty3"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2303.png" alt="figs/pios_2303.png" />
            </div>
          </div>
          <p class="title">Figure 23.3. A single label containing two differently styled paragraphs</p>
        </div>
        <br class="figure-break" />
        <p>The API for examining and modifying an attributed string invites us to think of style runs as extending over an entire range of characters, but that may be just a convenience. The content of a mutable attributed string may be better envisioned as a sequence of characters, <span class="emphasis"><em>each</em></span> of which has associated attributes. Thus we can coherently modify just the string part of a mutable attributed string. The key method here is <code class="literal">replaceCharactersInRange:withString:</code>, which can be used to replace characters with a plain string or, using a zero range length, to insert a plain string at the start, middle, or end of an attributed string (as demonstrated in the preceding code). The rule is that if we <span class="emphasis"><em>replace</em></span> characters, the inserted string takes on the attributes of the <span class="emphasis"><em>first replaced</em></span> character. If we <span class="emphasis"><em>insert</em></span> characters, the inserted string takes on the attributes of the character <span class="emphasis"><em>preceding</em></span> the insertion — except that, if we insert at the start, there is no such character, so the inserted string takes on the attributes of the character <span class="emphasis"><em>following</em></span> the insertion.</p>
        <p>You can query an attributed string about its attributes one character at a time — asking either about all attributes at once (<code class="literal">attributesAtIndex:effectiveRange:</code>) or about a particular attribute by name (<code class="literal">attribute:atIndex:effectiveRange:</code>). The last parameter is a pointer to an NSRange variable, which will be set to the range over which this same attribute value, or set of attribute values, applies:</p>
        <pre class="screen">NSRange range;
NSDictionary* d =
    [content attributesAtIndex:content.length-1 effectiveRange:&amp;range];</pre>
        <p>Because style runs are an artifice, however, you might not end up with what you would think of as the <span class="emphasis"><em>entire</em></span> style run. The methods with <code class="literal">longestEffectiveRange:</code> in their names, at the cost of some efficiency, do work out the full style run for you. Often, however, you don’t need the entire range, because you’re cycling through ranges, and you want to do that as fast as possible. In this example, I start with the combined two-paragraph attributed string derived in the previous examples, and change all the size 15 material to Arial Bold 20. I explicitly don’t care whether I’m handed longest effective ranges; I just want to cycle efficiently:</p>
        <pre class="screen">[content enumerateAttribute:NSFontAttributeName
    inRange:NSMakeRange(0,content.length)
    options:NSAttributedStringEnumerationLongestEffectiveRangeNotRequired
    usingBlock:^(id value, NSRange range, BOOL *stop)
{
    UIFont* font = value;
    if (font.pointSize == 15)
        [content addAttribute:NSFontAttributeName
                        value:[UIFont fontWithName: @"Arial-BoldMT" size:20]
                        range:range];
}];</pre>
        <p>You don’t need a UILabel to host an attributed string in the interface; you can draw the attributed string directly, and sometimes this will prove to be a more reliable approach. Just as an NSString can be drawn into a rect with <code class="literal">drawInRect:withFont:</code> and related methods, an NSAttributedString can be drawn with <code class="literal">drawInRect:</code>. (There’s no need to supply a font parameter, because the font is part of the attributed string!) Here, I draw the attributed string into an image:<a id="idm441644613664" class="indexterm"></a>
<a id="idm441644612384" class="indexterm"></a><a id="idm441644611472" class="indexterm"></a>
<a id="idm441644610160" class="indexterm"></a><a id="idm441644609248" class="indexterm"></a>
<a id="idm441644607936" class="indexterm"></a></p>
        <pre class="screen">UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);
[[UIColor whiteColor] setFill];
CGContextFillRect(UIGraphicsGetCurrentContext(), rect);
[self.content drawInRect:rect];
UIImage* im = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();</pre>
        <p>That image can then be displayed by an image view, for example. Similarly, you can draw an attributed string directly in a UIView’s <code class="literal">drawRect:</code>. That, in fact, is how the current version of the TidBITS News app works (<a class="xref" href="ch23.html#FIGtid6">Figure 23.4</a>). Previously, its table cells contained multiple UILabels, which had to be sized individually to fit their content (<a class="xref" href="ch21.html">Chapter 21</a>). Now, each cell is drawn as a <span class="emphasis"><em>single attributed string</em></span> consisting of the article title and the article summary.</p>
        <div class="figure">
          <a id="FIGtid6"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2304.png" alt="figs/pios_2304.png" />
            </div>
          </div>
          <p class="title">Figure 23.4. The TidBITS News app, rewritten for iOS 6</p>
        </div>
        <br class="figure-break" />
        <p>I’ll describe how that string is drawn. The cell’s <code class="literal">contentView</code> is completely occupied by a custom UIView class that I call StringDrawer; it has an <code class="literal">attributedText</code> property. In <code class="literal">tableView:cellForRowAtIndexPath:</code>, I set that property:</p>
        <pre class="screen">cell.drawer.attributedText = [self attributedStringForIndexPath: indexPath];</pre>
        <p>StringDrawer’s <code class="literal">drawRect:</code> draws its <code class="literal">attributedText</code>:</p>
        <pre class="screen">- (void)drawRect:(CGRect)rect {
    CGRect r = CGRectOffset(rect, 0, 2); // shoved down a little from top
    [self.attributedText drawWithRect:r
        options:NSStringDrawingTruncatesLastVisibleLine |
                NSStringDrawingUsesLineFragmentOrigin
        context:nil];
}</pre>
        <p>I want an <a id="idm441644592656" class="indexterm"></a>ellipsis at the end of the second paragraph if the whole thing doesn’t fit in the given rect (as shown in <a class="xref" href="ch23.html#FIGtid6">Figure 23.4</a>). This can’t be achieved using <code class="literal">NSLineBreakByTruncatingTail</code>, which truncates the <span class="emphasis"><em>first line</em></span> of the second paragraph.<a id="idm441644590160" class="indexterm"></a>
<a id="idm441644588864" class="indexterm"></a> Therefore, I’m using <code class="literal">drawWithRect:options:context:</code>, instead of simple <code class="literal">drawInRect:</code>, because it allows me to specify the option <code class="literal">NSStringDrawingTruncatesLastVisibleLine</code>. However, I must then also specify <code class="literal">NSStringDrawingUsesLineFragmentOrigin</code>; otherwise, the string is drawn with its <span class="emphasis"><em>baseline</em></span> at the rect origin (so that it appears <span class="emphasis"><em>above</em></span> that rect) and it doesn’t wrap. The rule is that <code class="literal">NSStringDrawingUsesLineFragmentOrigin</code> is the implicit default for simple <code class="literal">drawInRect:</code>, but with <code class="literal">drawWithRect:options:context:</code> you must specify it explicitly.</p>
        <p>To derive the height of the cell, I also <span class="emphasis"><em>measure</em></span> the attributed string beforehand, in <code class="literal">tableView:heightForRowAtIndexPath:</code>:<a id="idm441644580432" class="indexterm"></a>
<a id="idm441644579120" class="indexterm"></a></p>
        <pre class="screen">CGRect r =
    [s boundingRectWithSize:CGSizeMake(320,10000)
        options:NSStringDrawingUsesLineFragmentOrigin context:nil];
CGFloat result = r.size.height;
if (result &gt; 200) // set arbitrary limit on cell heights
    result = 200;</pre>
        <p>Again, the option <code class="literal">NSStringDrawingUsesLineFragmentOrigin</code> is crucial; without it, the measured text doesn’t wrap and the returned height will be very small.</p>
        <p>The <code class="literal">context:</code> parameter of <code class="literal">drawWithRect:options:context:</code> and <code class="literal">boundingRectWithSize:options:context:</code> lets you attach an instance of <a id="idm441644573488" class="indexterm"></a>NSStringDrawingContext. This simple class has properties that let you permit the text to shrink its size and compress its kerning automatically if doing so would allow it to fit in the given space. (This feature works only if the string consists of a single line — that is, a single paragraph whose line break mode doesn’t have <code class="literal">Wrapping</code> in its name.) It also lets you learn what actually happened. If you set an NSStringDrawingContext instance’s <code class="literal">minimumScaleFactor</code> (to a positive fraction, such as <code class="literal">0.7</code>) and then draw or measure with this instance as the <code class="literal">context:</code> argument, you can then get that instance’s <code class="literal">actualScaleFactor</code> to learn how much the drawing engine really did shrink the text size. The <code class="literal">minimumTrackingAdjustment</code> (a negative fraction, such as <code class="literal">-0.7</code>) and <code class="literal">actualTrackingAdjustment</code> work similarly.</p>
        <p>Additionally, an NSStringDrawingContext instance tells you where you just drew. With a plain NSString, you derive this information from the return value of the drawing command; for example, <code class="literal">drawInRect:withFont:</code> returns a CGSize telling you the size of the drawn string. But <code class="literal">drawWithRect:options:context:</code> has no return value. Instead, if you attach an NSStringDrawingContext, its <code class="literal">totalBounds</code> property tells you, after you draw, the bounds of the drawn string.
<a id="idm441644563360" class="indexterm"></a></p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>Remember CATextLayer from <a class="xref" href="ch16.html">Chapter 16</a>? Its <code class="literal">string</code> property can be an NSAttributedString. Thus, a CATextLayer is another way to get an attributed string drawn into the interface. If the width of the layer is insufficient to display the entire string, we can get truncation behavior with the <code class="literal">truncationMode</code> property. If the <code class="literal">wrapped</code> property is set to YES, the string will wrap. We can also set the alignment with the <code class="literal">alignmentMode</code> property.<a id="idm441644558336" class="indexterm"></a><a id="idm441644557408" class="indexterm"></a>
<a id="idm441644556112" class="indexterm"></a></p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_uilabel"></a>UILabel</h2>
            </div>
          </div>
        </div>
        <p>UILabel was introduced briefly in <a class="xref" href="ch21.html">Chapter 21</a> (in <a class="xref" href="ch21.html#SECcellstyles">Built-In Cell Styles</a>). If you’re configuring a UILabel through a plain NSString, by way of its <code class="literal">text</code> property, then you are likely also to set its <code class="literal">font</code>, <code class="literal">textColor</code>, and <code class="literal">textAlignment</code> properties, and possibly its <code class="literal">shadowColor</code> and <code class="literal">shadowOffset</code> properties. The label’s text can have an alternate <code class="literal">highlightedTextColor</code>, to be used when its <code class="literal">highlighted</code> property is YES (as happens, for example, when the label is in a selected cell of a table view).<a id="idm441644546480" class="indexterm"></a>
<a id="idm441644544880" class="indexterm"></a>
<a id="idm441644543568" class="indexterm"></a>
<a id="idxuilabel" class="indexterm"></a><a id="idxlabels" class="indexterm"></a></p>
        <p>If you’re using an NSAttributedString, then you’ll set the label’s <code class="literal">attributedText</code> property, and you’ll probably want to leave those other properties alone; they do still work, but they’re going to change the attributes of your <span class="emphasis"><em>entire</em></span> attributed string, in ways that you might not intend. Setting the <code class="literal">text</code> of a UILabel that has <code class="literal">attributedText</code> will basically eliminate the attributes. The <code class="literal">highlightedTextColor</code> property does <span class="emphasis"><em>not</em></span> work on the <code class="literal">attributedText</code>.</p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>The nib editor also includes an ingenious interface for letting you set attributes of the text of a label, and of other classes that accept attributed strings in iOS 6; it’s not perfect, however, and isn’t suitable for dealing with lengthy or complex text.</p>
        </div>
        <p>If a UILabel consists of only one line of text (<code class="literal">numberOfLines</code> is 1, the default), then if you set its <code class="literal">text</code>, any line breaks (<code class="literal">@"\n"</code>) are treated as spaces; but if you set its <code class="literal">attributedText</code>, line breaks are honored and you won’t see whatever follows the first line break.</p>
        <p>If a UILabel consists of only one line of text (<code class="literal">numberOfLines</code> is 1, the default), then you can elect to permit the text to shrink and compress if this would allow the text to fit when otherwise it wouldn’t. You can turn on <code class="literal">adjustsFontSizeToFitWidth</code> and provide a <code class="literal">minimumScaleFactor</code> (replacing the now-deprecated <code class="literal">minimumFontSize</code>), or you can turn on <code class="literal">adjustsLetterSpacingToFitWidth</code>. With plain <code class="literal">text</code>, you can turn on both; with <code class="literal">attributedText</code>, you can’t (this feels like a bug). If you’re using an attributed string, the label’s (or attributed string’s) line break mode must not have <code class="literal">Wrapping</code> in its name. How the text is repositioned when the size shrinks is determined by the label’s <code class="literal">baselineAdjustment</code> property.</p>
        <p>A UILabel may alternatively consist of multiple lines of text, where <code class="literal">numberOfLines</code> is greater than 1, or <code class="literal">0</code> to indicate no maximum. This matters even if you’re using an attributed string! In <a class="xref" href="ch23.html#FIGgetty3">Figure 23.3</a>, for example, the full text is shown because I set the label’s <code class="literal">numberOfLines</code> to <code class="literal">0</code>.</p>
        <p>Line breaking (wrapping) and truncation behavior, which applies to both single-line and multiline labels, is determined by its <code class="literal">lineBreakMode</code>. You can get a feel for line break behavior by experimenting in the nib. Your options are:<a id="idm441644518192" class="indexterm"></a>
<a id="idm441644516896" class="indexterm"></a><a id="idm441644516000" class="indexterm"></a>
<a id="idm441644514704" class="indexterm"></a></p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">NSLineBreakByWordWrapping</code>
</span>
            </dt>
            <dd>
Lines break at word-end. This is the default.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSLineBreakByClipping</code>
</span>
            </dt>
            <dd>
Lines break at word-end, but the last line can break in the middle of a word.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSLineBreakByCharWrapping</code>
</span>
            </dt>
            <dd>
All lines can break in the middle of a word.
</dd>
            <dt>
              <span class="term">
<code class="literal">NSLineBreakByTruncatingHead</code>
<br /></span>
              <span class="term">
<code class="literal">NSLineBreakByTruncatingTail</code>
<br /></span>
              <span class="term">
<code class="literal">NSLineBreakByTruncatingMiddle</code>
</span>
            </dt>
            <dd>
Lines break at word-end. But now suppose the text is too long for the label. (This might be because a single-line label isn’t wide enough, or because the <code class="literal">numberOfLines</code> is insufficient given the label’s width, or because the label isn’t tall enough to display the <code class="literal">numberOfLines</code>.) Then the last line displays an <a id="idm441644500768" class="indexterm"></a>ellipsis at the start, middle, or end respectively, and text is omitted at the point of the ellipsis. Thus, if the <code class="literal">lineBreakMode</code> is <code class="literal">UILineBreakModeHeadTruncation</code>, the last line is always displayed, and if the <code class="literal">lineBreakMode</code> is <code class="literal">UILineBreakModeMiddleTruncation</code>, the last words are displayed at the end of the last line — preceded, in both cases, by everything that will fit from the start of the text to the ellipsis.
</dd>
          </dl>
        </div>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>The UILabel line break mode names, which replace the now-deprecated <code class="literal">UILineBreakMode</code> options, are the same as the NSParagraphStyle line break mode names; but <span class="emphasis"><em>they do not behave the same way</em></span>. All the UILabel line break modes can wrap an NSString, but an NSAttributedString wraps only if its paragraph style’s line break mode has <code class="literal">Wrapping</code> in its name. UILabel will try to wrap and truncate an attributed string the way it wraps and truncates a plain string, but in some cases you will have to help it by setting the label’s <code class="literal">lineBreakMode</code> <span class="emphasis"><em>in code</em></span>, <span class="emphasis"><em>after</em></span> setting its <code class="literal">attributedText</code>. (Thanks to Kyle Sluder<a id="idm441644491264" class="indexterm"></a> for discovering this technique.)<a id="idm441644490192" class="indexterm"></a>
<a id="idm441644489136" class="indexterm"></a></p>
        </div>
        <p>If <code class="literal">numberOfLines</code> is larger than the number of lines actually needed, the text is vertically centered in the label. This may be undesirable; you might prefer to shrink (or grow) the label to fit its text. In iOS 5 and before, you couldn’t use <code class="literal">sizeToFit</code> to do this, because the default UILabel implementation of <code class="literal">sizeToFit</code> was to make the label the right width to contain all its text on a <span class="emphasis"><em>single</em></span> line. However, in iOS 6 that behavior is completely changed, so that in most simple cases <code class="literal">sizeToFit</code> will do exactly the right thing; I suspect that behind the scenes it is just calling <code class="literal">boundingRectWithSize:options:context:</code>.<a id="idm441644483392" class="indexterm"></a>
<a id="idm441644482048" class="indexterm"></a></p>
        <p>I say “in most simple cases” because there are cases where UILabel’s <code class="literal">sizeToFit</code> will misbehave. These happen to be exactly the cases where <code class="literal">boundingRectWithSize:options:context:</code> misbehaves. The problem arises particularly with paragraph styles involving margins (<code class="literal">headIndent</code> and <code class="literal">tailIndent</code>). Take, for example, the label displayed in <a class="xref" href="ch23.html#FIGgetty3">Figure 23.3</a>. It’s too tall for its content, but if we call <code class="literal">sizeToFit</code> it becomes too narrow for its content, presumably because <code class="literal">boundingRectWithSize:options:context:</code> ignores the margins. A possible workaround is to call <code class="literal">boundingRectWithSize:options:context:</code> and set the width back to the original width, like this:</p>
        <pre class="screen">CGRect rect =
    [self.lab.attributedText boundingRectWithSize:self.lab.bounds.size
     options:NSStringDrawingUsesLineFragmentOrigin context:nil];
// width is wrong so we have to widen it again
rect.size.width = self.lab.bounds.size.width;
rect.size.height += 5; // for good measure
CGRect f = self.lab.bounds;
f.size = rect.size;
self.lab.bounds = f;</pre>
        <p>But it turns out there’s a better way. Don’t forget about constraints! If we’re using autolayout, a UILabel will attempt to configure its own height and width (its <code class="literal">intrinsicContentSize</code>) to fit its contents.<a id="idm441644472320" class="indexterm"></a>
<a id="idm441644470976" class="indexterm"></a> Thus, if the label is left to its own devices, it will set its height correctly for its contents <span class="emphasis"><em>with no code at all</em></span>. Merely configuring the label — setting its text, changing its font, setting its attributed text, and so forth — automatically invalidates its intrinsic content size and causes that size to be recalculated.<a id="idm441644474544" class="indexterm"></a></p>
        <p>However, the label has two dimensions, so we must clearly give it a hint as to how it should mediate between them. One obvious way is to fix the width absolutely — for example, by an internal width constraint, or by pinning both the left and right edges of the label. In that case, assuming that no constraints prevent it, the label’s height will automatically adjust to accommodate its contents exactly. (If the label does have a height constraint, it will still adjust its own height, provided that the height constraint’s priority is less than its content hugging priority, which is 250.)</p>
        <p>An even more flexible approach is to set the label’s <code class="literal">preferredMaxLayoutWidth</code>. This is the width at which the label, as its contents increase, will stop growing horizontally to accommodate its contents and start growing vertically instead. (This implies that the contents will wrap, so clearly the <code class="literal">numberOfLines</code> can’t be 1.) For example, consider a label containing just a couple of words, whose right edge and top edge are pinned. Thanks to its intrinsic content size, that’s sufficient to position and size the label. Now set the label’s text to be several sentences long. Assuming that no other constraints intervene, and that the label’s <code class="literal">numberOfLines</code> is not 1, the label’s width will increase to its <code class="literal">preferredMaxLayoutWidth</code> and its height will increase to accommodate its text exactly.</p>
        <p>Conversely, you might wish to keep the label’s text the same, but make the label narrower and let it grow in height to accommodate its contents. Again, the key here is the <code class="literal">intrinsicContentSize</code>: we set the label’s width and its <code class="literal">intrinsicContentSize</code> together. For example, suppose we have an outlet to the label and to its width constraint; then this code makes the label narrower horizontally while letting it grow vertically to keep accommodating its contents:</p>
        <pre class="screen">self.widthConstraint.constant -= 10;
self.theLabel.preferredMaxLayoutWidth = self.widthConstraint.constant;</pre>
        <p>That’s all very well if we are changing the label’s width explicitly in code, but what if the label’s width is changing automatically in response to its constraints? An obvious example is a label whose left and right are pinned to its superview, and the superview changes size because the interface rotates. The label’s height will not change automatically to fit its contents; we must prompt it. For example, the view controller could respond to layout by setting the label’s <code class="literal">preferredMaxLayoutWidth</code> to its new width:</p>
        <pre class="screen">-(void)viewDidLayoutSubviews {
    self.lab.preferredMaxLayoutWidth = self.lab.bounds.size.width;
    [self.view layoutSubviews];
}</pre>
        <p>Or we could make the label self-adjusting, by subclassing UILabel and overriding <code class="literal">layoutSubviews</code>:</p>
        <pre class="screen">-(void)layoutSubviews {
    [super layoutSubviews];
    self.preferredMaxLayoutWidth = self.bounds.size.width;
}</pre>
        <p>Methods that you can override in a subclass to modify a label’s drawing are <code class="literal">drawTextInRect:</code> (an example appeared in <a class="xref" href="ch10.html">Chapter 10</a>) and <code class="literal">textRectForBounds:limitedToNumberOfLines:</code>.
<a id="idm441644452848" class="indexterm"></a><a id="idm441644451840" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_uitextfield"></a>UITextField</h2>
            </div>
          </div>
        </div>
        <p>A text field portrays just a single line of text (any return characters in its text are treated as spaces); otherwise, it has many of the same properties as a label. So, if you provide it with a plain NSString, it has a <code class="literal">text</code>, <code class="literal">font</code>, <code class="literal">textColor</code>, and <code class="literal">textAlignment</code>. It has <code class="literal">adjustsFontSizeToFitWidth</code> and <code class="literal">minimumFontSize</code> properties, although these don’t work exactly like a label; a text field won’t allow its font size to shrink automatically as small as a label will.
<a id="idm441644444752" class="indexterm"></a><a id="idxtextfields" class="indexterm"></a></p>
        <p>To provide a text field with an attributed string, you set its <code class="literal">attributedText</code>. In that case I would suggest that you <span class="emphasis"><em>not</em></span> set its <code class="literal">adjustsFontSizeToFitWidth</code> to YES, as this behaves rather badly; it doesn’t allow any intermediate sizes, but either shrinks the text absolutely or doesn’t; and, if it does shrink it, it will cause your text to appear all in a single font.<a id="idm441644440000" class="indexterm"></a>
<a id="idm441644438448" class="indexterm"></a>
<a id="idm441644437136" class="indexterm"></a></p>
        <p>Text that is too long for the text field is displayed with an <a id="idm441644435776" class="indexterm"></a>ellipsis at the end. You can change the position of the ellipsis by assigning the text field an attributed string with different truncation behavior, such as <code class="literal">NSLineBreakByTruncatingHead</code>. When overly long text is being edited, the text shifts horizontally to show the insertion point. On the whole, though, text that is too long for the text field is probably not a very good idea; the user usually has no arrow keys, as on the desktop, so navigating long text is daunting (the user must select text and stretch the selection into the offscreen part of the text).</p>
        <p>Regardless of whether you originally supplied a plain string or an attributed string, if the text field’s <code class="literal">allowsEditingTextAttributes</code> is YES, the user, when editing in the text field, can summon a menu toggling the selected text’s bold, italics, or underline features. (Oddly, there’s no way to set this property in a nib.)<a id="idm441644432240" class="indexterm"></a>
<a id="idm441644431088" class="indexterm"></a></p>
        <p>A text field has a <code class="literal">placeholder</code> property, which is the text that appears faded within the text field when it has no text; the idea is that you can use this to suggest to the user what the text field is for. It has a styled text alternative, <code class="literal">attributedPlaceholder</code>.</p>
        <p>If a text field’s <code class="literal">clearsOnBeginEditing</code> property is YES, it automatically deletes its existing text when the user begins editing within it. New in iOS 6, if a text field’s <code class="literal">clearsOnInsertion</code> property is YES, then when editing begins within it, the entire text is selected, but <span class="emphasis"><em>invisibly</em></span> selected, so that if the user starts typing immediately, the current contents of the text field will be removed.</p>
        <p>A text field’s border drawing is determined by its <code class="literal">borderStyle</code> property. Your options are:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">UITextBorderStyleNone</code>
</span>
            </dt>
            <dd>
No border.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextBorderStyleLine</code>
</span>
            </dt>
            <dd>
A plain rectangle.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextBorderStyleBezel</code>
</span>
            </dt>
            <dd>
A slightly bezeled rectangle: the top and left sides have a very slight, thin shadow.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextBorderStyleRoundedRect</code>
</span>
            </dt>
            <dd>
A rounded rectangle; the top and left sides have a stronger shadow, so that the text appears markedly recessed behind the border.
</dd>
          </dl>
        </div>
        <p>A text field can have a background color (because it is a UIView) or a background image (<code class="literal">background</code>), possibly along with a second image (<code class="literal">disabledBackground</code>) to be displayed when the text field’s <code class="literal">enabled</code> property, inherited from UIControl, is NO. The user can’t interact with a disabled text field, but without a <code class="literal">disabledBackground</code> image, the user may lack any visual clue to this fact. (A rounded rectangle text field doesn’t display these background images.)</p>
        <p>A text field may contain one or two ancillary overlay views, its <code class="literal">leftView</code> and <code class="literal">rightView</code>, and possibly a Clear button (a gray circle with a white X). The automatic visibility of each of these is determined by the <code class="literal">leftViewMode</code>, <code class="literal">rightViewMode</code>, and <code class="literal">clearViewMode</code>, respectively. The view mode values are:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">UITextFieldViewModeNever</code>
</span>
            </dt>
            <dd>
The view never appears.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextFieldViewModeWhileEditing</code>
</span>
            </dt>
            <dd>
A Clear button appears if there is text in the field and the user is editing. A left or right view appears if there is <span class="emphasis"><em>no</em></span> text in the field and the user is editing.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextFieldViewModeUnlessEditing</code>
</span>
            </dt>
            <dd>
A Clear button appears if there is text in the field and the user is not editing. A left or right view appears if the user is not editing, or if the user is editing but there is no text in the field.
</dd>
            <dt>
              <span class="term">
<code class="literal">UITextFieldViewModeAlways</code>
</span>
            </dt>
            <dd>
A left or right view always appears; a Clear button appears if there is text in the field.
</dd>
          </dl>
        </div>
        <p>Depending on what sort of view you use, your <code class="literal">leftView</code> and <code class="literal">rightView</code> may have to be sized manually so as not to overwhelm the text view contents. If a right view and a Clear button appear at the same time, the right view may cover the Clear button unless you reposition it. The positions and sizes of <span class="emphasis"><em>any</em></span> of the components of the text field can be set in relation to the text field’s bounds by overriding the appropriate method in a subclass:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
<code class="literal">clearButtonRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">leftViewRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">rightViewRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">borderRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">textRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">placeholderRectForBounds:</code>
</li>
            <li class="listitem">
<code class="literal">editingRectForBounds:</code>
</li>
          </ul>
        </div>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>You should make no assumptions about when or how frequently these methods will be called; the same method might be called several times in quick succession. Also, these methods should all be called with a parameter that is the bounds of the text field, but some are called with a 100×100 bounds; this feels like a bug.</p>
        </div>
        <p>You can also override in a subclass the methods <code class="literal">drawTextInRect:</code> and <code class="literal">drawPlaceholderInRect:</code>. You should either draw the specified text or call <code class="literal">super</code> to draw it; if you do neither, the text won’t appear. Both these methods are called with a parameter whose size is the dimensions of the text field’s text area, but whose origin is <code class="literal">{0,0}</code>. In effect what you’ve got is a graphics context for just the text area; any drawing you do outside the given rectangle will be clipped.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_summoning_and_dismissing_the_keyboard"></a>Summoning and Dismissing the Keyboard</h3>
              </div>
            </div>
          </div>
          <p>A text field’s editing status, as well as the presence or absence of the onscreen simulated keyboard, is intimately tied to its status as the <span class="emphasis"><em>first responder</em></span> (<a class="xref" href="ch11.html">Chapter 11</a>):<a id="idm441644376160" class="indexterm"></a><a id="idm441644375280" class="indexterm"></a>
<a id="idxtextfieldkeyboard" class="indexterm"></a><a id="idxkeyboard1" class="indexterm"></a></p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
When a text field is first responder, it is being edited and the keyboard is present.
</li>
              <li class="listitem">
When a text field is no longer first responder, it is no longer being edited, and if no other text field (or text view) becomes first responder, the keyboard is not present. The keyboard is not dismissed if one text field takes over first responder status from another.
</li>
            </ul>
          </div>
          <p>You can programmatically control a text field’s editing status, as well as the presence or absence of the keyboard, by way of the text field’s first responder status. To make the insertion point appear within a text field and to cause the keyboard to appear, you send <code class="literal">becomeFirstResponder</code> to that text field; to make a text field stop being edited and to cause the keyboard to disappear, you send <code class="literal">resignFirstResponder</code> to that text field. Actually, <code class="literal">resignFirstResponder</code> returns a BOOL, because a responder might return NO to indicate that for some reason it refuses to obey this command. Note also the UIView <code class="literal">endEditing:</code> method, which can be sent to the first responder <span class="emphasis"><em>or any superview</em></span> (including the window) to ask or compel the first responder to resign first responder status.</p>
          <p>In a view presented in the <code class="literal">UIModalPresentationFormSheet</code> style on the iPad (<a class="xref" href="ch19.html">Chapter 19</a>), the keyboard, by default, does <span class="emphasis"><em>not</em></span> disappear when a text field resigns first responder status. This is apparently because a form sheet is intended primarily for text input, so the keyboard is felt as accompanying the form as a whole, not individual text fields. Optionally, you can prevent this exceptional behavior: in your UIViewController subclass, override <code class="literal">disablesAutomaticKeyboardDismissal</code> to return NO.</p>
          <div class="warning" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Warning</h3>
            <p>There is no simple way to learn what view is first responder!<a id="idm441644360848" class="indexterm"></a> This is very odd, because a window surely knows what its first responder is — but it won’t tell you. There’s a method <code class="literal">isFirstResponder</code>, but you’d have to send it to every view in a window until you find the first responder. One workaround is to store a reference to the first responder yourself, typically in your implementation of the text field delegate’s <code class="literal">textFieldDidBeginEditing:</code>. <span class="emphasis"><em>Do not name this reference <code class="literal">firstResponder</code>!</em></span> This name is apparently already in use by Cocoa, and a name collision can cause your app to misbehave. (Can you guess how I know that?)</p>
          </div>
          <p>Once the user has tapped in a text field and the keyboard has automatically appeared, how is the user supposed to get rid of it? This is unlikely to be a problem on the iPad, where the keyboard typically contains a special button that dismisses the keyboard. But on the iPhone, it’s an oddly tricky issue. You would think that the “return” button in the keyboard would dismiss the keyboard; but, of itself, it doesn’t.<a id="idm441644356208" class="indexterm"></a></p>
          <p>One solution is to be the text field’s delegate and to implement a text field delegate method, <code class="literal">textFieldShouldReturn:</code>. When the user taps the Return key in the keyboard, we hear about it through this method, and we tell the text field to resign its first responder status, which dismisses the keyboard:</p>
          <pre class="screen">- (BOOL)textFieldShouldReturn: (UITextField*) tf {
    [tf resignFirstResponder];
    return YES;
}</pre>
          <p>I’ll provide a more self-contained, automatic solution later in this chapter.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_keyboard_covers_text_field"></a>Keyboard Covers Text Field</h3>
              </div>
            </div>
          </div>
          <p>The keyboard has a position “docked” at the bottom of the screen. This may cover the text field in which the user wants to type, even if it is first responder. On the iPad, this may not be an issue, because the user can “undock” the keyboard (possibly also splitting and shrinking it) and slide it up and down the screen freely. On the iPhone, you’ll typically want to do something to reveal the text field.</p>
          <p>To help with this, you can register for keyboard-related notifications:<a id="idm441644349152" class="indexterm"></a><a id="idm441644348240" class="indexterm"></a></p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
<code class="literal">UIKeyboardWillShowNotification</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardDidShowNotification</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardWillHideNotification</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardDidHideNotification</code>
</li>
            </ul>
          </div>
          <p>Those notifications all have to do with the <span class="emphasis"><em>docked</em></span> position of the keyboard. On the iPhone, keyboard docking and keyboard visibility are equivalent: the keyboard is visible if and only if it is docked. On the iPad, the keyboard is said to “show” if it is being docked, whether that’s because it is appearing from offscreen or because the user is docking it; and it is said to “hide” if it is undocked, whether that’s because it is moving offscreen or because the user is undocking it.</p>
          <p>Two additional notifications are sent <span class="emphasis"><em>both</em></span> when the keyboard enters and leaves the screen <span class="emphasis"><em>and</em></span> (on the iPad) when the user drags it, splits or unsplits it, and docks or undocks it:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
<code class="literal">UIKeyboardWillChangeFrameNotification</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardDidChangeFrameNotification</code>
</li>
            </ul>
          </div>
          <p>The notification’s <code class="literal">userInfo</code> dictionary contains information about the keyboard describing what it will do or has done, under these keys:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
<code class="literal">UIKeyboardFrameBeginUserInfoKey</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardFrameEndUserInfoKey</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardAnimationDurationUserInfoKey</code>
</li>
              <li class="listitem">
<code class="literal">UIKeyboardAnimationCurveUserInfoKey</code>
</li>
            </ul>
          </div>
          <p>Thus, to a large extent, you can coordinate your actions with those of the keyboard. In particular, by looking at the <code class="literal">UIKeyboardFrameEndUserInfoKey</code>, you know what position the keyboard is moving to; if necessary, you can compare this with the screen bounds to learn whether the keyboard will now be on or off the screen.</p>
          <p>(In the case of <code class="literal">UIKeyboardWillChangeFrameNotification</code>, however, there won’t be any <code class="literal">UIKeyboardFrameEndUserInfoKey</code> when the user starts dragging the keyboard on the iPad, because the runtime doesn’t know where the user will drag the keyboard to. The frame value for the split keyboard on the iPad is the size of the <span class="emphasis"><em>entire</em></span> keyboard, as if it weren’t split; but its height is shorter than the height of the normal keyboard, so you may be able to deduce that it is split, if you really need to know that.)</p>
          <p>Finding a strategy for dealing with the keyboard’s presence depends on the needs of your particular app. It may well be that even on the iPad you can ignore <code class="literal">UIKeyboardDidChangeFrameNotification</code> and concern yourself only with the docked position of the keyboard, because, as I mentioned a moment ago, if the keyboard isn’t docked, the user is free to move and split it. To illustrate, therefore, I’ll concentrate on the most universal case, where the keyboard moves into and out of docked position and we detect this with <code class="literal">UIKeyboardWillShowNotification</code> and <code class="literal">UIKeyboardWillHideNotification</code>. What should we do if, when the keyboard appears, it covers the text field being edited? I’ll describe a couple of basic approaches to get you started.</p>
          <p>A natural-looking approach is to slide the entire interface upward as the keyboard appears. To make this easy, you might start with a view hierarchy like this: the root view contains an invisible view that’s the same size as the root view; everything else is contained in that invisible view. The invisible view’s purpose is to host the rest of the interface; if we slide it upward, the whole interface will slide upward.</p>
          <p>Here’s an implementation involving constraints. The invisible view, which I’ll called the <span class="emphasis"><em>sliding view</em></span>, is pinned by constraints at the top and bottom to its superview with a <code class="literal">constant</code> of <code class="literal">0</code>, and we have outlets to those constraints. We also have an outlet to the sliding view itself, and we’ve got a property prepared to hold the first responder:</p>
          <pre class="screen">@property (nonatomic, strong)
    IBOutletCollection(NSLayoutConstraint) NSArray* verticalConstraints;
@property (nonatomic, weak) IBOutlet UIView *slidingView;
@property (nonatomic, weak) UIView* fr;</pre>
          <p>In our view controller’s <code class="literal">viewDidLoad</code>, we register for the keyboard notifications:</p>
          <pre class="screen">[super viewDidLoad];
[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(keyboardShow:)
                                         name:UIKeyboardWillShowNotification
                                         object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(keyboardHide:)
                                         name:UIKeyboardWillHideNotification
                                         object:nil];</pre>
          <p>We are the delegate of the various text fields in our interface. When one of them starts editing, we keep a reference to it as first responder:</p>
          <pre class="screen">- (void)textFieldDidBeginEditing:(UITextField *)tf {
    self.fr = tf; // keep track of first responder
}</pre>
          <p>As the keyboard threatens to appear, we examine where its top will be. If the keyboard will cover the text field that’s about to be edited, we animate the sliding view upward to compensate, by changing the <code class="literal">constant</code> value of the constraints that pin its top and bottom. Observe that the keyboard’s frame comes to us in window/screen coordinates, so it is necessary to convert it to our sliding view’s coordinates in order to make sense of it:</p>
          <pre class="screen">- (void) keyboardShow: (NSNotification*) n {
    NSDictionary* d = [n userInfo];
    CGRect r = [d[UIKeyboardFrameEndUserInfoKey] CGRectValue];
    r = [self.slidingView convertRect:r fromView:nil];
    CGRect f = self.fr.frame;
    CGFloat y =
        CGRectGetMaxY(f) + r.size.height -
            self.slidingView.bounds.size.height + 5;
    NSNumber* duration = d[UIKeyboardAnimationDurationUserInfoKey];
    if (r.origin.y &lt; CGRectGetMaxY(f)) {
        [UIView animateWithDuration:[duration floatValue] animations:^{
            for (NSLayoutConstraint* con in self.verticalConstraints) {
                con.constant = -y;
            }
            [self.view layoutIfNeeded];
        }];
    }
}</pre>
          <p>When the keyboard disappears, we reverse the procedure:</p>
          <pre class="screen">- (void) keyboardHide: (NSNotification*) n {
    NSNumber* duration = n.userInfo[UIKeyboardAnimationDurationUserInfoKey];
    [UIView animateWithDuration:[duration floatValue] animations:^{
        for (NSLayoutConstraint* con in self.verticalConstraints) {
            con.constant = 0;
        }
        [self.view layoutIfNeeded];
    }];
}</pre>
          <p>Sometimes, the interface already knows how to slide — because it’s a scroll view. In that case, we typically won’t move the scroll view; instead, we’ll change the behavior of the scroll view so that it operates coherently within the reduced space left by the keyboard. This is a job for <code class="literal">contentInset</code>, whose purpose, you will recall (<a class="xref" href="ch20.html">Chapter 20</a>), is precisely to make it possible for the user to view all of the scroll view’s content even though part of the scroll view is being covered by something. A nice byproduct of this approach is that the scroll view helps us by scrolling automatically when the first responder changes.</p>
          <p>This approach is in fact implemented automatically by a UITableViewController.<a id="idm441644303952" class="indexterm"></a>
<a id="idm441644302672" class="indexterm"></a> When a text field inside a table cell is first responder, the table view controller adjusts the table view’s <code class="literal">contentInset</code> and <code class="literal">scrollIndicatorInsets</code> to compensate for the keyboard. The result is that the entire table view is available within the space between the top of the keyboard and the top of the screen.</p>
          <p>Let’s imitate UITableViewController’s behavior with a scroll view containing text fields. In <code class="literal">viewDidLoad</code>, we register for keyboard notifications as before. When the keyboard appears, we store the current content offset, content inset, and scroll indicator insets; then we alter them:</p>
          <pre class="screen">- (void) keyboardShow: (NSNotification*) n {
    self-&gt;_oldContentInset = self.scrollView.contentInset;
    self-&gt;_oldIndicatorInset = self.scrollView.scrollIndicatorInsets;
    self-&gt;_oldOffset = self.scrollView.contentOffset;
    NSDictionary* d = [n userInfo];
    CGRect r = [[d objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];
    r = [self.scrollView convertRect:r fromView:nil];
    CGRect f = self.fr.frame;
    CGFloat y =
        CGRectGetMaxY(f) + r.size.height -
            self.scrollView.bounds.size.height + 5;
    if (r.origin.y &lt; CGRectGetMaxY(f))
        [self.scrollView setContentOffset:CGPointMake(0, y) animated:YES];
    UIEdgeInsets insets;
    insets = self.scrollView.contentInset;
    insets.bottom = r.size.height;
    self.scrollView.contentInset = insets;
    insets = self.scrollView.scrollIndicatorInsets;
    insets.bottom = r.size.height;
    self.scrollView.scrollIndicatorInsets = insets;
}</pre>
          <p>When the keyboard disappears, we restore the saved values; this works best if the insets are restored using delayed performance:</p>
          <pre class="screen">- (void) keyboardHide: (NSNotification*) n {
    [self.scrollView setContentOffset:self-&gt;_oldOffset animated:YES];
    [CATransaction setCompletionBlock:^{
        self.scrollView.scrollIndicatorInsets = self-&gt;_oldIndicatorInset;
        self.scrollView.contentInset = self-&gt;_oldContentInset;
    }];
}</pre>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_configuring_the_keyboard"></a>Configuring the Keyboard</h3>
              </div>
            </div>
          </div>
          <p>A UITextField implements the UITextInputTraits protocol, which defines properties on the UITextField that you can set to determine how the keyboard will look and how typing in the text field will behave. (These properties can also be set in the nib.) For example, you can set the <code class="literal">keyboardType</code> to <code class="literal">UIKeyboardTypePhonePad</code> to make the keyboard for this text field consist of digits only. You can set the <code class="literal">returnKeyType</code> to determine the text of the Return key (if the keyboard is of a type that has one). You can even supply your own keyboard or other input mechanism by setting the text field’s <code class="literal">inputView</code>.<a id="idm441644291296" class="indexterm"></a> You can turn off autocapitalization (<code class="literal">autocapitalizationType</code>) or autocorrection (<code class="literal">autocorrectionType</code>), make the Return key disable itself if the text field has no content (<code class="literal">enablesReturnKeyAutomatically</code>), and make the text field a <a id="idm441644288096" class="indexterm"></a>password field (<code class="literal">secureTextEntry</code>).</p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>The user’s choices in the Settings app with regard to certain text input features, such as autocapitalization or autocorrection, take priority over your configuration of these same features for a particular text field.</p>
          </div>
          <p>You can attach an accessory view to the top of the keyboard by setting the text field’s <code class="literal">inputAccessoryView</code>. In this example, the accessory view is a UIButton configured in the nib and accessed through an outlet property, <code class="literal">buttonView</code>. When editing starts, we configure the keyboard as we store our reference to the text field:</p>
          <pre class="screen">- (void)textFieldDidBeginEditing:(UITextField *)tf {
    self.fr = tf; // keep track of first responder
    tf.inputAccessoryView = self.buttonView;
}</pre>
          <p>The button is a Next button. When the user taps it, we use it to move editing to the next text field. In this code, I assume that the order of the text fields as subviews of their superview is the desired “tab” order:</p>
          <pre class="screen">- (IBAction)doNextField:(id)sender {
    NSMutableArray* marr = [NSMutableArray array];
    for (UIView* v in self.fr.superview.subviews) {
        if ([v isKindOfClass: [UITextField class]])
            [marr addObject:v];
    }
    NSUInteger ix = [marr indexOfObject:self.fr];
    if (ix == NSNotFound)
        return; // shouldn't happen
    ix++;
    if (ix &gt;= [marr count])
        ix = 0;
    UIView* v = marr[ix];
    [v becomeFirstResponder];
}</pre>
          <p>The user can control the localization of the keyboard character set in the Settings app, either through a choice of the system’s base language or by enabling additional “international keyboards.” In the latter case, the user can switch among keyboard character sets while the keyboard is showing. But, as far as I can tell, your code can’t make this choice, so you can’t, for example, have a Russian-teaching app in which a certain text field automatically shows the Cyrillic keyboard. You can ask the user to switch keyboards manually, but if you really want a particular keyboard to appear regardless of the user’s settings and behavior, you’ll have to create it yourself and provide it as the <code class="literal">inputView</code>.<a id="idm441644278976" class="indexterm"></a>
<a id="idm441644277984" class="indexterm"></a><a id="idm441644277056" class="indexterm"></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_text_field_delegate_and_control_event_messages"></a>Text Field Delegate and Control Event Messages</h3>
              </div>
            </div>
          </div>
          <p>As editing begins and proceeds in a text field, a sequence of messages is sent to the text field’s delegate. (Some of these are also available as notifications.) Using them, you can customize the text field’s behavior during editing:<a id="idm441644273440" class="indexterm"></a>
<a id="idm441644272240" class="indexterm"></a></p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
<code class="literal">textFieldShouldBeginEditing:</code>
</span>
              </dt>
              <dd>
Return NO to prevent the text field from becoming first responder.
</dd>
              <dt>
                <span class="term">
<code class="literal">textFieldDidBeginEditing:</code> (and <code class="literal">UITextFieldTextDidBeginEditingNotification</code>)
</span>
              </dt>
              <dd>
The text field has become first responder.
</dd>
              <dt>
                <span class="term">
<code class="literal">textFieldShouldClear:</code>
</span>
              </dt>
              <dd>
Return NO to prevent the operation of the Clear button or of automatic clearing on entry (<code class="literal">clearsOnBeginEditing</code>).
</dd>
              <dt>
                <span class="term">
<code class="literal">textFieldShouldReturn:</code>
</span>
              </dt>
              <dd>
The user has tapped the Return button in the keyboard. We have already seen that this can be used as a signal to dismiss the keyboard.
</dd>
              <dt>
                <span class="term">
<code class="literal">textField:shouldChangeCharactersInRange:replacementString:</code>
</span>
              </dt>
              <dd>
                <p class="simpara">
Sent when the user changes the text in the field by typing or pasting, or by backspacing or cutting (in which case the replacement string will have zero length). Return NO to prevent the proposed change; you can substitute text by changing the text field’s <code class="literal">text</code> directly (there is no circularity, as this delegate method is not called when you do that). In this example, the user can enter only lowercase characters:
</p>
                <pre class="screen">-(BOOL)textField:(UITextField *)textField
        shouldChangeCharactersInRange:(NSRange)range
        replacementString:(NSString *)string {
    NSString* lc = [string lowercaseString];
    if ([string isEqualToString:lc])
        return YES;
    textField.text =
        [textField.text stringByReplacingCharactersInRange:range
                                                withString:lc];
    return NO;
}</pre>
                <p class="simpara">Another use of this method is to take advantage of a new iOS 6 text field property, <code class="literal">typingAttributes</code>, to set the attributes of the text the user is about to enter. You can also fetch the <code class="literal">typingAttributes</code> to find out what the text styling of newly inserted text would otherwise be (following the same rules I enunciated earlier for insertion of text into an attributed string). Not every attribute can be set this way; for example, trying to set underlining will fail, and indeed will cause the <code class="literal">typingAttributes</code> to be completely ineffectual. I’ll set the user’s text to be red:</p>
                <pre class="screen">-(BOOL)textField:(UITextField *)textField
        shouldChangeCharactersInRange:(NSRange)range
        replacementString:(NSString *)string {
    NSDictionary* d = textField.typingAttributes;
    NSMutableDictionary* md = [d mutableCopy];
    [md addEntriesFromDictionary:
        @{NSForegroundColorAttributeName:[UIColor redColor]}];
    textField.typingAttributes = md;
    return YES;
}</pre>
                <p class="simpara">It is common practice to implement this delegate method as a way of learning that the text has been changed, even if you then always return YES. The <code class="literal">UITextFieldTextDidChangeNotification</code> corresponds loosely. This method is <span class="emphasis"><em>not</em></span> called when the user changes text styling through the Bold, Italics, or Underline menu items.</p>
              </dd>
              <dt>
                <span class="term">
<code class="literal">textFieldShouldEndEditing:</code>
</span>
              </dt>
              <dd>
Return NO to prevent the text field from resigning first responder (even if you just sent <code class="literal">resignFirstResponder</code> to it). You might do this, for example, because the text is invalid or unacceptable in some way. The user will not know why the text field is refusing to end editing, so the usual thing is to put up an alert (<a class="xref" href="ch26.html">Chapter 26</a>) explaining the problem.
</dd>
              <dt>
                <span class="term">
<code class="literal">textFieldDidEndEditing:</code> (and <code class="literal">UITextFieldTextDidEndEditingNotification</code>)
</span>
              </dt>
              <dd>
The text field has resigned first responder. See <a class="xref" href="ch21.html">Chapter 21</a> for an example of using <code class="literal">textFieldDidEndEditing:</code> to fetch the text field’s current text and store it in the model.
</dd>
            </dl>
          </div>
          <p>A text field is also a control. This means you can attach a target–action pair to any of the events that it reports in order to receive a message when that event occurs (see <a class="xref" href="ch11.html">Chapter 11</a> and <a class="xref" href="ch25.html">Chapter 25</a>):<a id="idm441644239568" class="indexterm"></a>
<a id="idm441644238272" class="indexterm"></a></p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
The user can touch and drag, triggering Touch Down and the various Touch Drag events.
</li>
              <li class="listitem">
If the user touches in such a way that the text field enters editing mode (and the keyboard appears), Editing Did Begin and Touch Cancel are triggered; if the user causes the text field to enter editing mode in some other way (such as by tabbing into it), Editing Did Begin is triggered without any Touch events.
</li>
              <li class="listitem">
As the user edits, Editing Changed is triggered. If the user taps while in editing mode, Touch Down (and possibly Touch Down Repeat) and Touch Cancel are triggered.
</li>
              <li class="listitem">
Finally, when editing ends, Editing Did End is triggered; if the user stops editing by tapping Return in the keyboard, Did End on Exit is triggered first.
</li>
            </ul>
          </div>
          <p>In general, you’re more likely to treat a text field as a text field (through its delegate messages) than as a control (through its control events). However, the Did End on Exit event message has an interesting property: it provides an alternative way to dismiss the keyboard when the user taps a text field keyboard’s Return button. If there is a Did End on Exit target–action pair for this text field, then if the text field’s delegate does not return NO from <code class="literal">textFieldShouldReturn:</code>, the keyboard will be dismissed <span class="emphasis"><em>automatically</em></span> when the user taps the Return key. (The action handler for Did End on Exit doesn’t actually have to <span class="emphasis"><em>do</em></span> anything.)<a id="idm441644229568" class="indexterm"></a></p>
          <p>This suggests the following trick for getting automatic keyboard dismissal <span class="emphasis"><em>with no code at all</em></span>. In the nib, edit the First Responder proxy object in the Attributes inspector, adding a new First Responder Action; let’s call it <code class="literal">dummy:</code>. Now hook the Did End on Exit event of the text field to the <code class="literal">dummy:</code> action of the First Responder proxy object. That’s it! Because the text field’s Did End on Exit event now has a target–action pair, the text field automatically dismisses its keyboard when the user taps Return; because there is no penalty for not finding a handler for a message sent up the responder chain, the app doesn’t crash even though there is no implementation of <code class="literal">dummy:</code> anywhere.</p>
          <p>Of course, you can implement that trick in code instead:</p>
          <pre class="screen">[textField addTarget:nil action:@selector(dummy:)
    forControlEvents:UIControlEventEditingDidEndOnExit];</pre>
          <p>A disabled text field emits no delegate messages or control events.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_the_text_field_menu"></a>The Text Field Menu</h3>
              </div>
            </div>
          </div>
          <p>When the user double-taps or long-presses in a text field, the menu appears. It contains menu items such as Select, Select All, Paste, Copy, Cut, and Suggest; which menu items appear depends on the circumstances.<a id="idm441644221008" class="indexterm"></a>
<a id="idm441644219760" class="indexterm"></a></p>
          <p>The menu can be customized, but you’ve no information about the text field’s selection, making it difficult to decide intelligently what menu items should appear or what they should do when chosen. If you still want to alter the menu, the key facts you need to know are these:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
You can add menu items to the menu through the singleton global shared <a id="idm441644216576" class="indexterm"></a>UIMenuController object. Its <code class="literal">menuItems</code> property is an array of <span class="emphasis"><em>custom</em></span> menu items — that is, menu items that may appear <span class="emphasis"><em>in addition</em></span> to those that the system puts there. A menu item is a <a id="idm441644214240" class="indexterm"></a>UIMenuItem, which is simply a title (which appears in the menu) plus an action selector. The action will be called, nil-targeted (<a class="xref" href="ch11.html">Chapter 11</a>), thus sending it up the responder chain, when the user taps the menu item (and, by default, the menu will be dismissed).
</li>
              <li class="listitem">
                <p class="simpara">
The actions for the standard menu items are nil-targeted, so they percolate up the responder chain, and you can interfere with their behavior by implementing their actions. Many of the selectors are listed in the UIResponderStandardEditActions informal protocol. Commonly used standard actions are:
</p>
                <div class="itemizedlist">
                  <ul class="itemizedlist" type="circle">
                    <li class="listitem">
<code class="literal">cut:</code>
</li>
                    <li class="listitem">
<code class="literal">copy:</code>
</li>
                    <li class="listitem">
<code class="literal">select:</code>
</li>
                    <li class="listitem">
<code class="literal">selectAll:</code>
</li>
                    <li class="listitem">
<code class="literal">paste:</code>
</li>
                    <li class="listitem">
<code class="literal">delete:</code>
</li>
                    <li class="listitem">
<code class="literal">_promptForReplace:</code>
</li>
                    <li class="listitem">
<code class="literal">_define:</code>
</li>
                    <li class="listitem">
<code class="literal">_showTextStyleOptions:</code>
</li>
                    <li class="listitem">
<code class="literal">toggleBoldface:</code>
</li>
                    <li class="listitem">
<code class="literal">toggleItalics:</code>
</li>
                    <li class="listitem">
<code class="literal">toggleUnderline:</code>
</li>
                  </ul>
                </div>
              </li>
              <li class="listitem">
You govern the presence or absence of <span class="emphasis"><em>any</em></span> menu item by implementing the <span class="keep-together">UIResponder</span> method <code class="literal">canPerformAction:withSender:</code> in the responder chain.
</li>
            </ul>
          </div>
          <p>As an example, we’ll devise a text field in which the standard menu is completely replaced by our own menu, which contains a single menu item, Expand. I’m imagining here, for instance, a text field where the user can type a U.S. state two-letter abbreviation (such as “CA”) and can then summon the menu and tap Expand to get the state’s full name (such as “California”). We’ll implement this by means of a UITextField subclass.</p>
          <p>At some point before the user can tap in an instance of our UITextField subclass, we modify the global menu; we could do this in the app delegate as the app starts up, for example:</p>
          <pre class="screen">UIMenuItem *mi = [[UIMenuItem alloc] initWithTitle:@"Expand"
                                            action:@selector(expand:)];
UIMenuController *mc = [UIMenuController sharedMenuController];
mc.menuItems = @[mi];</pre>
          <p>In our UITextField subclass, we implement <code class="literal">canPerformAction:withSender:</code> to govern the contents of the menu. The placement of this implementation is crucial. By putting it here, we guarantee that this implementation will be called when an instance of this subclass is first responder, but at no other time. Therefore, every other text field (or any other object that displays a menu) will behave normally, displaying Cut or Select All or whatever’s appropriate; only an instance of our subclass will have the special menu, displaying only Expand:</p>
          <pre class="screen">- (BOOL) canPerformAction:(SEL)action withSender: (id) sender {
    if (action == @selector(expand:))
        return ([self.text length] == 2); // could be more intelligent here
    return NO;
}</pre>
          <p>When the user chooses the Expand menu item, the <code class="literal">expand:</code> message is sent up the responder chain. We catch it in our UITextField subclass and obey it. Proceeding to match abbreviations with state names is left as an exercise for the reader:</p>
          <pre class="screen">- (void) expand: (id) sender {
    NSString* s = self.text;
    // ... alter s here ...
    self.text = s;
}</pre>
          <p>To demonstrate interference with the standard menu items, we’ll modify the example to allow the Copy menu item to appear if it wants to:</p>
          <pre class="screen">- (BOOL) canPerformAction:(SEL)action withSender:(id)sender {
    if (action == @selector(expand:))
        return ([self.text length] == 2);
    if (action == @selector(copy:))
        return [super canPerformAction:action withSender:sender];
    return NO;
}</pre>
          <p>Now we’ll implement <code class="literal">copy:</code> and modify its behavior. First we call <code class="literal">super</code> to get standard copying behavior; then we modify what’s now on the pasteboard:<a id="idm441644179648" class="indexterm"></a><a id="idm441644178784" class="indexterm"></a>
<a id="idm441644177760" class="indexterm"></a></p>
          <pre class="screen">- (void) copy: (id) sender {
    [super copy: sender];
    UIPasteboard* pb = [UIPasteboard generalPasteboard];
    NSString* s = pb.string;
    // ... alter s here ....
    pb.string = s;
}</pre>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_uitextview"></a>UITextView</h2>
            </div>
          </div>
        </div>
        <p>A text view is sort of a scrollable, multiline version of a text field (UITextField, with which it should not be confused). It is a scroll view subclass (UIScrollView, <a class="xref" href="ch20.html">Chapter 20</a>), and thus has (by default) no border; it is <span class="emphasis"><em>not</em></span> a control. Nevertheless, it has many close similarities to a text field. It has <code class="literal">text</code>, <code class="literal">font</code>, <code class="literal">textColor</code>, and <code class="literal">textAlignment</code> properties; it can be editable or not, according to its <code class="literal">editable</code> property. (You might use a scrollable noneditable text view instead of a UILabel, so as not to be limited to a fixed number of lines of text in a given height.) As with a text field, iOS 6 brings to a text view the <code class="literal">attributedText</code>, <code class="literal">allowsEditingTextAttributes</code>, and <code class="literal">typingAttributes</code> properties, as well as <code class="literal">clearsOnInsertion</code>.<a id="idm441644166704" class="indexterm"></a>
<a id="idm441644165392" class="indexterm"></a> An editable text view governs its keyboard just as a text field does: when it is first responder, it is being edited and shows the keyboard, and it implements the UITextInput protocol and has <code class="literal">inputView</code> and <code class="literal">inputAccessoryView</code> properties. Its menu works the same way as a text field’s as well.<a id="idm441644162640" class="indexterm"></a>
<a id="idm441644161040" class="indexterm"></a>
<a id="idm441644159728" class="indexterm"></a>
<a id="idm441644158688" class="indexterm"></a><a id="idxtextviews" class="indexterm"></a></p>
        <p>A thing to watch out for when replacing a UITextView’s <code class="literal">attributedText</code> is that aspects of its previous <code class="literal">attributedText</code> may contaminate the new attributed string. For example:</p>
        <pre class="screen">NSAttributedString* s1 =
    [[NSAttributedString alloc] initWithString:@"Hello there!"
     attributes:@{NSForegroundColorAttributeName:[UIColor redColor]}];
NSAttributedString* s2 = [[NSAttributedString alloc] initWithString:@"Howdy"];
self.tv.attributedText = s1;
self.tv.attributedText = s2;</pre>
        <p>The result is that the text view says “Howdy” in red. This is clearly wrong behavior; if you do the same thing with a UILabel, the label says “Howdy” in black. Apparently, setting the text view’s <code class="literal">attributedText</code> the first time also changes its <code class="literal">textColor</code>, and this color is then allowed to impose itself when you set the text view’s <code class="literal">attributedText</code> the second time, presumably because you didn’t explicitly set the second attributed string’s color. A good workaround is to reset the text view’s properties:</p>
        <pre class="screen">self.tv.attributedText = s1;
self.tv.text = nil;
self.tv.font = nil;
self.tv.textColor = nil;
self.tv.textAlignment = NSTextAlignmentLeft;
self.tv.attributedText = s2;</pre>
        <p>One big difference, from the programmer’s point of view, between a text view and a text field is that a text view gives you information about, and control of, its selection: it has a <code class="literal">selectedRange</code> property which you can get and set, and it adds a <code class="literal">scrollRangeToVisible:</code> method so that you can scroll in terms of a range of its text. The <code class="literal">selectedRange</code> is useful especially if the text view is first responder, because the selection is then meaningful and visible, but it does work (invisibly) even if the text view is not first responder.<a id="idm441644146368" class="indexterm"></a>
<a id="idm441644145056" class="indexterm"></a></p>
        <p>A text view also has a <code class="literal">dataDetectorTypes</code> property; this, if the text view is not editable, allows text of certain types (presumably located using NSDataDetector, see <a class="xref" href="ch10.html">Chapter 10</a>) to be rendered as tappable links.</p>
        <p>A text view’s delegate messages (UITextViewDelegate protocol) and notifications are quite parallel to those of a text field. The big differences are:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
There’s a <code class="literal">textViewDidChange:</code> delegate message (and an accompanying <code class="literal">UITextViewTextDidChangeNotification</code>), whereas a text field has its Editing Changed control event (and notification).
</li>
            <li class="listitem">
There’s a <code class="literal">textViewDidChangeSelection:</code> delegate message, whereas a text field is uninformative about the selection.
</li>
          </ul>
        </div>
        <p>A text view’s <code class="literal">contentSize</code> is maintained for you, automatically, as the text changes. You can track changes to the content size (in <code class="literal">textViewDidChange:</code>, for example). A common reason for doing so is to implement a <span class="emphasis"><em>self-sizing</em></span> text view, that is, a text view that adjusts its height automatically to embrace the amount of text it contains.<a id="idm441644134816" class="indexterm"></a>. In this example, we have an outlet to the text view’s internal height constraint:</p>
        <pre class="screen">- (void)textViewDidChange:(UITextView *)textView {
    self.heightConstraint.constant = textView.contentSize.height;
}</pre>
        <p>A self-sizing text view works best if the text view is not user-scrollable (<code class="literal">scrollEnabled</code> is NO). If it <span class="emphasis"><em>is</em></span> user-scrollable, it might scroll itself as the user enters text, and you might then have to struggle to prevent it from doing so:</p>
        <pre class="screen">- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    scrollView.contentOffset = CGPointZero;
}</pre>
        <p>Dismissing the keyboard for a text view works differently than for a text field. Because a text view is multiline, the Return key is meaningful for character entry; you aren’t likely to want to misuse it as a way of dismissing the keyboard, and you don’t get a special delegate message for it. On the iPad, the virtual keyboard may contain a button that dismisses the keyboard. On the iPhone, the interface might well consist of a text view and the keyboard, so that instead of dismissing the keyboard, the user dismisses the entire interface. For example, in the Mail app on the iPhone, when the user is composing a message, the keyboard is present the whole time. In the Notes app, a note alternates between being read fullscreen and being edited with the keyboard present; in the latter case, a Done button is provided to dismiss the keyboard. If there’s no good place to put a Done button in the interface, you could attach an accessory view to the keyboard itself.<a id="idm441644129680" class="indexterm"></a>
<a id="idxkeyboard2" class="indexterm"></a><a id="idxtextviewskeyboard" class="indexterm"></a></p>
        <p>In an interface where the text view occupies more or less the whole screen, the easiest way to deal with the keyboard is to adjust the text view’s <code class="literal">contentInset</code>, as we did with a scroll view in the previous section. Here’s a fairly straightforward implementation; the text view will helpfully scroll to the insertion point automatically after the keyboard appears:</p>
        <pre class="screen">-(void)viewDidLoad {
    [[NSNotificationCenter defaultCenter] addObserver:self
        selector:@selector(keyboardShow:)
        name:UIKeyboardWillShowNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
        selector:@selector(keyboardHide:)
        name:UIKeyboardWillHideNotification object:nil];
}

- (IBAction)doDone:(id)sender {
    [self.view endEditing:NO];
}

- (void) keyboardShow: (NSNotification*) n {
    NSDictionary* d = [n userInfo];
    CGRect r = [d[UIKeyboardFrameEndUserInfoKey] CGRectValue];
    self.tv.contentInset = UIEdgeInsetsMake(0,0,r.size.height,0);
    self.tv.scrollIndicatorInsets = UIEdgeInsetsMake(0,0,r.size.height,0);
}

- (void) keyboardHide: (NSNotification*) n {
    NSDictionary* d = [n userInfo];
    NSNumber* curve = d[UIKeyboardAnimationCurveUserInfoKey];
    NSNumber* duration = d[UIKeyboardAnimationDurationUserInfoKey];
    [UIView animateWithDuration:duration.floatValue delay:0
                        options:curve.integerValue &lt;&lt; 16
                     animations:
     ^{
         [self.tv setContentOffset:CGPointZero];
     } completion:^(BOOL finished) {
         self.tv.contentInset = UIEdgeInsetsZero;
         self.tv.scrollIndicatorInsets = UIEdgeInsetsZero;
     }];
}</pre>
        <p>
          <a id="idm441644123088" class="indexterm"></a>
          <a id="idm441644122208" class="indexterm"></a>
        </p>
        <p>
          <a id="idm441644120896" class="indexterm"></a>
        </p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_core_text"></a>Core Text</h2>
            </div>
          </div>
        </div>
        <p>Underlying all text drawing on iOS is Core Text. Before iOS 6, Core Text was the only way to draw styled text on iOS; now that an NSAttributedString can be drawn directly, or handed to an built-in interface object for it to draw, you may have less need of Core Text. Nevertheless, Core Text can still do some things you can’t do in any other way, and it is sitting there under the hood, so you may as well be aware of it. It is implemented by the Core Text framework; to utilize it, your app must link to <span class="emphasis"><em>CoreText.framework</em></span>, and your code must import <code class="literal">&lt;CoreText/CoreText.h&gt;</code>. It uses C, not Objective-C, and it’s rather verbose, but getting started with it is not difficult.<a id="idm441644116192" class="indexterm"></a><a id="idm441644115328" class="indexterm"></a><a id="idm441644114448" class="indexterm"></a>
<a id="idm441644113136" class="indexterm"></a>
<a id="idxcoretext" class="indexterm"></a></p>
        <p>A good example of the sort of thing Core Text can do that can’t be done any other way is to convert between fonts within a font family.<a id="idm441644109856" class="indexterm"></a> Under CoreText, a font is a CTFont (a CTFontRef), a type which is unfortunately <span class="emphasis"><em>not</em></span> bridged to UIFont. In this example, I’ll create an attributed string using only Core Text calls. You can use an NSAttributed string or its Core Foundation counterpart, CFAttributedString; they, at least, are toll-free bridged. The Core Text attribute names are listed in Apple’s <span class="emphasis"><em>Core Text String Attributes Reference</em></span>, along with their value types.</p>
        <p>I’ll start with a mutable attributed string:</p>
        <pre class="screen">NSString* s = @"Yo ho ho and a bottle of rum!";
NSMutableAttributedString* mas =
    [[NSMutableAttributedString alloc] initWithString:s];</pre>
        <p>Now I’ll apply some attributes, using Core Text calls exclusively. I’ll cycle through the words of the string; to each word I’ll apply a slightly larger size of the same font. The name supplied when creating a CTFont must be a PostScript name; a free app, Typefaces, is helpful for learning all the fonts on a device along with their PostScript names:</p>
        <pre class="screen">__block CGFloat f = 18.0;
CTFontRef basefont = CTFontCreateWithName((CFStringRef)@"Baskerville", f, nil);
[s enumerateSubstringsInRange:NSMakeRange(0, [s length])
                      options:NSStringEnumerationByWords
                   usingBlock:
 ^(NSString *substring, NSRange substringRange, NSRange encRange, BOOL *stop) {
     f += 3.5;
     CTFontRef font2 = CTFontCreateCopyWithAttributes(basefont, f, nil, nil);
     NSDictionary* d2 =
         @{(NSString*)kCTFontAttributeName: CFBridgingRelease(font2)};
     [mas addAttributes:d2 range:encRange];
 }];</pre>
        <p>Finally, I’ll make the last word bold. The easiest way to obtain the range of the last word is to cycle through the words backward and stop after the first one (by setting the incoming BOOL, <code class="literal">stop</code>, by indirection).<a id="idm441644102832" class="indexterm"></a> Boldness is a font trait; we must obtain a bold variant of the original font. The font we started with, Baskerville, has such a variant, so this will work:</p>
        <pre class="screen">[s enumerateSubstringsInRange:NSMakeRange(0, [s length])
                      options: (NSStringEnumerationByWords |
                                NSStringEnumerationReverse)
                   usingBlock:
 ^(NSString *substring, NSRange substringRange, NSRange encRange, BOOL *stop) {
     CTFontRef font2 =
         CTFontCreateCopyWithSymbolicTraits (
             basefont, f, nil, kCTFontBoldTrait, kCTFontBoldTrait);
     NSDictionary* d2 =
         @{(NSString*)kCTFontAttributeName: CFBridgingRelease(font2)};
     [mas addAttributes:d2 range:encRange];
     *stop = YES; // do just once, last word
 }];</pre>
        <p>Finally, let’s not forget to complete our memory management:</p>
        <pre class="screen">CFRelease(basefont);</pre>
        <p>(And did you notice the cool use of ARC’s <code class="literal">CFBridgingRelease</code>? Recall from <a class="xref" href="ch12.html">Chapter 12</a> that this is a way of crossing the bridge from a CFTypeRef to an Objective-C object and, at the same time, giving ARC responsibility for completing the memory management that we started by calling a <code class="literal">Create</code> function.)</p>
        <p>You’re probably wondering why I seem to ask for the bold variant (<code class="literal">kCTFontBoldTrait</code>) twice. The first time (the fourth argument in the call to <code class="literal">CTFontCreateCopyWithSymbolicTraits</code>) I’m providing a bitmask. The second time (the fifth argument) I’m providing a second bitmask that says which bits of the first bitmask are meaningful. For example, suppose I’m starting with a font that might or might not be italic, and I want to obtain its bold variant — meaning that if it <span class="emphasis"><em>is</em></span> italic, I want a bold italic font. It isn’t enough to supply a bitmask whose value is <code class="literal">kCTFontBoldTrait</code>, because this appears to switch boldness on and everything else off. Thus, the second bitmask says, “Only this one bit is important; leave all other attributes alone.” By the same token, to get a nonbold variant of a font that might be bold, you’d supply <code class="literal">0</code> as the fourth argument and <code class="literal">kCTFontBoldTrait</code> as the fifth argument.</p>
        <p>Core Text can also draw into a graphics context. Text will be drawn upside-down unless we flip the graphics context’s coordinate system. Positioning the drawing is up to us.</p>
        <p>If the string is a single line we can draw it directly into a graphics context with a CTLineRef. The following code, in a custom UIView subclass, draws the attributed string we created a moment ago (<a class="xref" href="ch23.html#FIGyohoho">Figure 23.5</a>):</p>
        <pre class="screen">- (void)drawRect:(CGRect)rect {
    if (!self.text)
        return;
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // flip context
    CGContextSaveGState(ctx);
    CGContextTranslateCTM(ctx, 0, self.bounds.size.height);
    CGContextScaleCTM(ctx, 1.0, -1.0);
    CTLineRef line =
        CTLineCreateWithAttributedString(
            (__bridge CFAttributedStringRef)self.text);
    CGContextSetTextPosition(ctx, 1, 3);
    CTLineDraw(line, ctx);
    CFRelease(line);
    CGContextRestoreGState(ctx);
}</pre>
        <div class="figure">
          <a id="FIGyohoho"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2305.png" alt="figs/pios_2305.png" />
            </div>
          </div>
          <p class="title">Figure 23.5. A single line of text, drawn by Core Text</p>
        </div>
        <br class="figure-break" />
        <p>If we want our string to be drawn wrapped, we must use a CTFramesetter. The framesetter requires a frame into which to draw; this is expressed as a CGPath, but don’t get all excited about the possibility of drawing wrapped into some interesting shape, such as an ellipse, because on iOS the path must describe a rectangle:</p>
        <pre class="screen">- (void)drawRect:(CGRect)rect {
    if (!self.text)
        return;
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // flip context
    CGContextSaveGState(ctx);
    CGContextTranslateCTM(ctx, 0, self.bounds.size.height);
    CGContextScaleCTM(ctx, 1.0, -1.0);
    CTFramesetterRef fs =
        CTFramesetterCreateWithAttributedString(
            (__bridge CFAttributedStringRef)self.text);
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathAddRect(path, nil, rect);
    // range (0,0) means "the whole string"
    CTFrameRef f = CTFramesetterCreateFrame(fs, CFRangeMake(0, 0), path, nil);
    CTFrameDraw(f, ctx);
    CGPathRelease(path);
    CFRelease(f);
    CFRelease(fs);
    CGContextRestoreGState(ctx);
}</pre>
        <p>That code wraps, but the text is left-aligned. Paragraph-level behaviors such as alignment and truncation can be expressed as part of the attributed string itself by applying a CTParagraphStyle. Paragraph styles can also include first-line indent, tab stops, line height, spacing, line break mode, and more. To center our text (which results in a drawing that looks like <a class="xref" href="ch23.html#FIGyohoho2">Figure 23.6</a>), we apply a centered style before drawing it:</p>
        <pre class="screen">NSMutableAttributedString* mas = [self.text mutableCopy];
NSString* s = [mas string];
CTTextAlignment centerValue = kCTCenterTextAlignment;
CTParagraphStyleSetting center =
    {kCTParagraphStyleSpecifierAlignment, sizeof(centerValue), &amp;centerValue};
CTParagraphStyleSetting pss[1] = {center};
CTParagraphStyleRef ps = CTParagraphStyleCreate(pss, 1);
[mas addAttribute:(NSString*)kCTParagraphStyleAttributeName
            value:CFBridgingRelease(ps)
            range:NSMakeRange(0, [s length])];
self.text = mas;</pre>
        <div class="figure">
          <a id="FIGyohoho2"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2306.png" alt="figs/pios_2306.png" />
            </div>
          </div>
          <p class="title">Figure 23.6. Text wrapped and centered, drawn by Core Text</p>
        </div>
        <br class="figure-break" />
        <p>Core Text can also access font typographical features that can’t be accessed in any other way, such as the built-in ability of Didot and Hoefler Text to render themselves in small caps.<a id="idm441644076096" class="indexterm"></a> As an example, we’ll draw the names of the 50 U.S. states in small caps, centered, in two columns on an iPad (<a class="xref" href="ch23.html#FIG2col">Figure 23.7</a>).</p>
        <div class="figure">
          <a id="FIG2col"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2307.png" alt="figs/pios_2307.png" />
            </div>
          </div>
          <p class="title">Figure 23.7. Two-column text in small caps</p>
        </div>
        <br class="figure-break" />
        <p>As we create the NSAttributedString, we use a convenience function, <code class="literal">CTFontDescriptorCreateCopyWithFeature</code>, to access Didot’s small caps variant. I had to log the result of <code class="literal">CTFontCopyFeatures</code> to learn how to access this variant of this font (there is also old documentation of font features at <a class="ulink" href="http://developer.apple.com/fonts/registry" target="_top">http://developer.apple.com/fonts/registry</a>). We apply a centered style, as before:</p>
        <pre class="screen">NSString* path =
    [[NSBundle mainBundle] pathForResource:@"states" ofType:@"txt"];
NSString* s =
    [NSString stringWithContentsOfFile:path
     encoding:NSUTF8StringEncoding error:nil];
CTFontRef font = CTFontCreateWithName((CFStringRef)@"Didot", 18, nil);
CTFontDescriptorRef fontdesc1 = CTFontCopyFontDescriptor(font);
// names come from SFNTLayoutTypes.h (iOS 6 new feature)
CTFontDescriptorRef fontdesc2 =
CTFontDescriptorCreateCopyWithFeature(fontdesc1,
    (__bridge CFNumberRef)@(kLetterCaseType),
    (__bridge CFNumberRef)@(kSmallCapsSelector));
CTFontRef basefont = CTFontCreateWithFontDescriptor(fontdesc2, 0, nil);
NSDictionary* d =
    @{(NSString*)kCTFontAttributeName: CFBridgingRelease(basefont)};
NSMutableAttributedString* mas =
    [[NSMutableAttributedString alloc] initWithString:s attributes:d];
CTTextAlignment centerValue = kCTCenterTextAlignment;
CTParagraphStyleSetting center =
    {kCTParagraphStyleSpecifierAlignment, sizeof(centerValue), &amp;centerValue};
CTParagraphStyleSetting pss[1] = {center};
CTParagraphStyleRef ps = CTParagraphStyleCreate(pss, 1);
[mas addAttribute:(NSString*)kCTParagraphStyleAttributeName
            value:CFBridgingRelease(ps)
            range:NSMakeRange(0, [s length])];
CFRelease(font); CFRelease(fontdesc1); CFRelease(fontdesc2);</pre>
        <p>The two-column arrangement is achieved by drawing into two frames. In our <code class="literal">drawRect:</code> code, after flipping the context as before (not shown), we draw the entire text into the first frame and then use <code class="literal">CTFrameGetVisibleStringRange</code> to learn how much of the text actually fits into it; this tells us where in the attributed string to start drawing into the second frame:<a id="idm441644065536" class="indexterm"></a></p>
        <pre class="screen">CGRect r1 = rect;
r1.size.width /= 2.0; // column 1
CGRect r2 = r1;
r2.origin.x += r2.size.width; // column 2
CTFramesetterRef fs =
    CTFramesetterCreateWithAttributedString(
        (__bridge CFAttributedStringRef)self.text);
// draw column 1
CGMutablePathRef path = CGPathCreateMutable();
CGPathAddRect(path, nil, r1);
CTFrameRef f = CTFramesetterCreateFrame(fs, CFRangeMake(0, 0), path, nil);
CTFrameDraw(f, ctx);
CGPathRelease(path);
CFRange drawnRange = CTFrameGetVisibleStringRange(f);
CFRelease(f);
// draw column 2
path = CGPathCreateMutable();
CGPathAddRect(path, nil, r2);
f = CTFramesetterCreateFrame(fs,
        CFRangeMake(drawnRange.location + drawnRange.length, 0), path, nil);
CTFrameDraw(f, ctx);
CGPathRelease(path);
CFRelease(f);
CFRelease(fs);</pre>
        <p>The result is <a class="xref" href="ch23.html#FIG2col">Figure 23.7</a>. But now let’s go further. A frame is itself composed of CTLines describing how each line of text was laid out. To demonstrate, let’s turn our two-column list of states into an interactive interface: when the user taps the name of a state, we’ll fetch that name, and we’ll briefly draw a rectangle around the name to provide feedback (<a class="xref" href="ch23.html#FIGcalifornia">Figure 23.8</a>).</p>
        <div class="figure">
          <a id="FIGcalifornia"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_2308.png" alt="figs/pios_2308.png" />
            </div>
          </div>
          <p class="title">Figure 23.8. The user has tapped on California</p>
        </div>
        <br class="figure-break" />
        <p>We have two NSMutableArray properties, <code class="literal">theLines</code> and <code class="literal">theBounds</code>. We initialize them to empty arrays at the start of our <code class="literal">drawRect:</code>, and each time we call <code class="literal">CTFrameDraw</code> we also call a utility method:</p>
        <pre class="screen">[self appendLinesAndBoundsOfFrame:f context:ctx];</pre>
        <p>In <code class="literal">appendLinesAndBoundsOfFrame:context:</code> we save the CTLines of the frame into <code class="literal">theLines</code>; we also calculate the drawn bounds of each line and save it into <code class="literal">theBounds</code>:</p>
        <pre class="screen">- (void) appendLinesAndBoundsOfFrame:(CTFrameRef)f context:(CGContextRef)ctx{
    CGAffineTransform t1 =
        CGAffineTransformMakeTranslation(0, self.bounds.size.height);
    CGAffineTransform t2 = CGAffineTransformMakeScale(1, -1);
    CGAffineTransform t = CGAffineTransformConcat(t2, t1);
    CGPathRef p = CTFrameGetPath(f);
    CGRect r = CGPathGetBoundingBox(p); // this is the frame bounds
    NSArray* lines = (__bridge NSArray*)CTFrameGetLines(f);
    [self.theLines addObjectsFromArray:lines];
    CGPoint origins[[lines count]];
    CTFrameGetLineOrigins(f, CFRangeMake(0,0), origins);
    for (int i = 0; i &lt; [lines count]; i++) {
        CTLineRef aLine = (__bridge CTLineRef)lines[i];
        CGRect b = CTLineGetImageBounds((CTLineRef)aLine, ctx);
        // the line origin plus the image bounds size is the bounds we want
        CGRect b2 = { origins[i], b.size };
        // but it is expressed in terms of the frame, so we must compensate
        b2.origin.x += r.origin.x;
        b2.origin.y += r.origin.y;
        // we must also compensate for the flippedness of the graphics context
        b2 = CGRectApplyAffineTransform(b2, t);
        [self.theBounds addObject: [NSValue valueWithCGRect:b2]];
    }
}</pre>
        <p>We have attached a UITapGestureRecognizer to our view; when the user taps, we cycle through the saved bounds to see if any of them contains the tap point. If it does, we fetch the name of the state, and we draw a rectangle around it:</p>
        <pre class="screen">- (void) tapped: (UITapGestureRecognizer*) tap {
    CGPoint loc = [tap locationInView:self];
    for (int i = 0; i &lt; [self.theBounds count]; i++) {
        CGRect rect = [self.theBounds[i] CGRectValue];
        if (CGRectContainsPoint(rect, loc)) {
            // draw rectangle for feedback
            CALayer* lay = [CALayer layer];
            lay.frame = CGRectInset(rect, -5, -5);
            lay.borderWidth = 2;
            [self.layer addSublayer: lay];
            dispatch_time_t popTime =
                dispatch_time(DISPATCH_TIME_NOW, 0.3 * NSEC_PER_SEC);
            dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
                [lay removeFromSuperlayer];
            });
            // fetch the drawn string tapped on
            CTLineRef theLine =
                (__bridge CTLineRef)[self.theLines[i];
            CFRange range = CTLineGetStringRange(theLine);
            CFStringRef s = CFStringCreateWithSubstring(
                nil, (__bridge CFStringRef)[self.text string], range);
            // ... could do something useful with string here ...
            NSLog(@"tapped %@", s);
            CFRelease(s);
            break;
        }
    }
}</pre>
        <p>If we needed to, we could even learn what character the user tapped by going down to the level of glyph runs (CTRun) and glyphs (CTGlyph). We have barely scratched the surface of what Core Text can do. Read Apple’s <span class="emphasis"><em>Core Text Programming Guide</em></span> for further information.
<a id="idm441644048912" class="indexterm"></a><a id="idm441644048176" class="indexterm"></a></p>
        <div class="sidebar">
          <div class="titlepage">
            <div>
              <div>
                <p class="title">UITextInput</p>
              </div>
            </div>
          </div>
          <p>The UITextInput protocol, along with related protocols, allows you to design your own interface object that interacts with the text input system to receive keypresses from the keyboard and draw the corresponding text (with Core Text); see the chapter “Drawing and Managing Text” in Apple’s <span class="emphasis"><em>Text, Web, and Editing Programming Guide for iOS</em></span>, as well as Apple’s SimpleTextInput example code. This is an involved subject and beyond the scope of this book, not least because I’ve no experience with it.</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch22.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt05.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch24.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 22. Popovers and Split Views </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 24. Web Views</td>
        </tr>
      </table>
    </div>
  </body>
</html>
