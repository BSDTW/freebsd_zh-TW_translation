<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 7. Nib Management</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt02.html" />
    <link rel="prev" href="ch06.html" />
    <link rel="next" href="ch08.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt02.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch08.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 6. Anatomy of an Xcode Project </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 8. Documentation</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id7"></a>Chapter 7. Nib Management</h2>
          </div>
        </div>
      </div>
      <p>A <span class="emphasis"><em>nib file</em></span>, or simply <span class="emphasis"><em>nib</em></span>, is a file containing a drawing of a piece of your interface. The term <span class="emphasis"><em>nib</em></span> is not really an English word (it has nothing to do with fountain pens or bits of chocolate); it is based on the file extension <span class="emphasis"><em>.nib</em></span>, which originated as an acronym for “NeXTStep Interface Builder”.<a id="idm441655065840" class="indexterm"></a> Nowadays, you will usually develop your interface using a file format whose extension is <span class="emphasis"><em>.xib</em></span>; when your app is built, your target’s <span class="emphasis"><em>.xib</em></span> files are translated (“compiled”) into <span class="emphasis"><em>.nib</em></span> format (<a class="xref" href="ch06.html">Chapter 6</a>). But a <span class="emphasis"><em>.xib</em></span> file is still referred to as a nib file. I will speak of the same nib file as having either a <span class="emphasis"><em>.xib</em></span> extension (if you’re editing it) or a <span class="emphasis"><em>.nib</em></span> extension (if it’s in the built app).<a id="idm441655061776" class="indexterm"></a>
<a id="idxnibs" class="indexterm"></a>
<a id="idxnibs2" class="indexterm"></a></p>
      <p>You construct your program in two ways — writing code, and drawing the interface. But these are really two ways of accomplishing the same ends; drawing the interface <span class="emphasis"><em>is</em></span> a way of writing code. When the app runs and your drawing of the interface in a nib file is loaded, it is translated into instructions for instantiating and initializing the objects in the nib file. You could equally have instantiated and initialized those same objects in code. (This point is crucial; see <a class="xref" href="ch05.html#SECnibbasedinstantiation">Nib-Based Instantiation</a>.) Indeed, deciding whether to create an interface object in code or through a nib file is not always easy; each approach has its advantages. The important thing is to understand how interface objects drawn in a nib file are instantiated and connected to your code when the app runs. That’s the subject of this chapter.</p>
      <p>(Most of this chapter applies equally to storyboards. Don’t skip this chapter on the grounds that you intend to use storyboards instead of nibs! Storyboards do not relieve you of the need to understand nib management. I’ll discuss the particular nature and use of storyboards in <a class="xref" href="ch19.html">Chapter 19</a>.)</p>
      <div class="note" style="margin-left: 0; margin-right: 10%;">
        <h3 class="title">Note</h3>
        <p>Up through Xcode 3.2.x, nib editing was performed in a separate application, Interface Builder. Starting in Xcode 4, the functionality of Interface Builder was rolled into Xcode itself.<a id="idm441655053520" class="indexterm"></a> Nevertheless, the Xcode interface for nib editing is still referred to as Interface Builder.</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_a_tour_of_the_nib_editing_interface"></a>A Tour of the Nib-Editing Interface</h2>
            </div>
          </div>
        </div>
        <p>Let’s use an actual nib file to explore the Xcode nib-editing interface. In <a class="xref" href="ch06.html">Chapter 6</a>, we created a simple Xcode project, Empty Window; it contains a nib file, so we’ll use that. In Xcode, open the Empty Window project, locate the <span class="emphasis"><em>ViewController.xib</em></span> listing in the Project navigator, and click it to edit it.</p>
        <div class="figure">
          <a id="FIGnibEditor"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0701.png" alt="figs/pios_0701.png" />
            </div>
          </div>
          <p class="title">Figure 7.1. Editing a nib file</p>
        </div>
        <br class="figure-break" />
        <p><a class="xref" href="ch07.html#FIGnibEditor">Figure 7.1</a> shows the project window after selecting <span class="emphasis"><em>ViewController.xib</em></span> and making some additional adjustments. The Navigator pane is hidden; the Utilities pane is showing. Within the Utilities pane, the Size inspector and the Object library are showing. The interface may be considered in four pieces:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
At the left of the editor is the <span class="emphasis"><em>dock</em></span>. In <a class="xref" href="ch07.html#FIGnibEditor">Figure 7.1</a>, the dock is collapsed, showing the nib’s top-level objects graphically. The dock can be expanded by dragging its right edge or by clicking the right-pointing triangle-in-a-square-in-a-circle at its lower right; then it shows <span class="emphasis"><em>all</em></span> of the nib’s objects hierarchically by name.
</li>
            <li class="listitem">
The remainder of the editor is devoted to the <span class="emphasis"><em>canvas</em></span>, where you physically design your app’s interface. The canvas portrays views in your app’s interface and things that can contain views. (A <span class="emphasis"><em>view</em></span> is an interface object, which draws itself into a rectangular area. The phrase “things that can contain views” is my way of including view controllers, which are represented in the canvas even though they are not drawn in your app’s interface.)<a id="idm441655039600" class="indexterm"></a>
</li>
            <li class="listitem">
The inspectors in the Utilities pane are where you view and edit details of the currently selected object.
</li>
            <li class="listitem">
The libraries in the Utilities pane, especially the Object library, are your source for interface objects to be added to the nib.
</li>
          </ol>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_the_dock"></a>The Dock</h3>
              </div>
            </div>
          </div>
          <p>The collapsed dock, as I’ve already said, shows the nib’s <span class="emphasis"><em>top-level objects</em></span>.<a id="idm441655034640" class="indexterm"></a>
<a id="idm441655033392" class="indexterm"></a> To see what this means, you need first to envision the nib as containing objects. Some of these objects — those that represent views — are arranged in a hierarchy of containment. Objects that are contained by no other object are top-level objects.<a id="idm441655031776" class="indexterm"></a>
<a id="idm441655030272" class="indexterm"></a>
<a id="idm441655029024" class="indexterm"></a></p>
          <p>A view can contain other views (its <span class="emphasis"><em>subviews</em></span>) and can be contained by another view (its <span class="emphasis"><em>superview</em></span>); for example, if we were to put a button into the view that occupies the canvas in <a class="xref" href="ch07.html#FIGnibEditor">Figure 7.1</a>, the button would be a subview of that view, and that view would be the button’s superview.<a id="idm441655026256" class="indexterm"></a><a id="idm441655025392" class="indexterm"></a> One view can contain many subviews, which might themselves contain subviews. But each view can have only one immediate superview. Thus there is a hierarchical tree of subviews contained by their superviews with a single object at the top. The highest superview of any such hierarchy in the nib is a top-level object and appears in the dock. That’s why the view object (labeled View in <a class="xref" href="ch07.html#FIGnibEditor">Figure 7.1</a>) appears in this nib’s dock: it is a view contained by no other view.</p>
          <p>A top-level object, then, is either a view without a superview or else not a view at all. A nib file can actually portray two types of top-level object:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Placeholders (proxy objects)
</span>
              </dt>
              <dd>
A placeholder, or proxy object, isn’t actually in the nib. It represents an object that already exists in your app’s code at the time the nib is loaded. Proxy objects are portrayed as top-level objects in a nib file chiefly so that you can provide communication between objects in your app’s code and objects instantiated from the nib (by means of connections, discussed later in this chapter). You can’t create or delete a proxy object; the dock is populated automatically with them. Proxy objects are shown above the dividing line in the dock.<a id="idm441655020928" class="indexterm"></a>
<a id="idm441655018464" class="indexterm"></a>
<a id="idm441655017312" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Nib objects
</span>
              </dt>
              <dd>
A nib object is an object that is instantiated by the nib — that is, the instance it represents will be created when your code runs and the nib loads. You can create new nib objects. Top-level nib objects are shown below the dividing line in the dock.<a id="idm441655014208" class="indexterm"></a>
<a id="idm441655012704" class="indexterm"></a>
<a id="idm441655011456" class="indexterm"></a>
</dd>
            </dl>
          </div>
          <p>The dock can be expanded (by clicking the right-pointing triangle-in-a-square-in-a-circle at its lower right); it then portrays objects by name, and shows as an outline the full hierarchy of objects in this nib (<a class="xref" href="ch07.html#FIGdockExpanded">Figure 7.2</a>). At present, expanding the dock may seem silly, because there is no hierarchy; all objects in this nib are top-level objects. But when a nib contains many levels of hierarchically arranged objects (plus, starting in iOS 6, their autolayout constraints — see <a class="xref" href="ch14.html">Chapter 14</a>), you’re going to be very glad of the ability to survey them all in a nice outline, and to select the one you’re after, thanks to the expanded dock. You can also rearrange the hierarchy here; for example, if you’ve made an object a subview of the wrong view, you can reposition it within this outline by dragging its name.</p>
          <div class="figure">
            <a id="FIGdockExpanded"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0702.png" alt="figs/pios_0702.png" />
              </div>
            </div>
            <p class="title">Figure 7.2. The dock, expanded</p>
          </div>
          <br class="figure-break" />
          <p>You can also select objects using the jump bar at the top of the editor.<a id="idm441655004000" class="indexterm"></a>
<a id="idm441655002752" class="indexterm"></a> For example, if you click on the canvas background so that no object is selected, and the rightmost jump bar path component reads No Selection, then the entire hierarchy of objects in your nib is shown as a set of hierarchical menus off that path component (Control-6). Again, this may seem like small potatoes now, when your nib contains just three top-level objects and nothing more, but it will be valuable when you’ve many nib objects in a hierarchy.</p>
          <p>The name by which a nib object is designated is its <span class="emphasis"><em>label</em></span>. This name is meaningful to the nib file, not to your code. When the dock is expanded, each object is portrayed by its label, as shown in <a class="xref" href="ch07.html#FIGdockExpanded">Figure 7.2</a>. When the dock is collapsed, you can see a top-level object’s label by hovering the mouse over it, as shown in <a class="xref" href="ch07.html#FIGnibEditor">Figure 7.1</a>. If you find an object’s label unhelpful, you can change it: select the object and edit the Label field in the Document section of the Identity inspector (<span class="keep-together">Command</span>-Option-3).<a id="idm441654997808" class="indexterm"></a>
<a id="idm441654996560" class="indexterm"></a> Alternatively, select the object’s label in the expanded dock and press Return to make it editable.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_canvas"></a>Canvas</h3>
              </div>
            </div>
          </div>
          <p>The canvas provides a graphical representation of a top-level nib object along with its subviews, similar to what you’re probably accustomed to in any drawing program.<a id="idm441654993824" class="indexterm"></a>
<a id="idm441654992320" class="indexterm"></a> If a top-level nib object has a graphical representation (not every top-level nib object has one), you can click on it in the dock to display that representation in the canvas.</p>
          <p>To remove the canvas representation of a top-level nib object, click the X at its upper left; this merely clears the representation from the canvas — it does not remove the top-level nib object from the dock (or from the nib), and of course you can always bring back the graphical representation by clicking that nib object in the dock again. On the other hand, the canvas is scrollable and automatically accommodates however many graphical representations it contains, so, rather than removing and restoring graphical representations, you can keep many graphical representations open in the canvas and scroll to see each one.</p>
          <p>Our simple Empty Window project’s <span class="emphasis"><em>ViewController.xib</em></span> contains just one top-level nib object that has a graphical representation — the UIView destined to be the root view of the app’s window, called View. The term “root” here implies that the view occupies the entire window.<a id="idm441654988688" class="indexterm"></a> Because this view will be the root view of our app’s window, any changes you make here will be reflected in the app’s user interface when you run it. To see this, we’re going to add a subview to it:<a id="idm441654987232" class="indexterm"></a></p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Ensure that the View in the dock is being displayed in the canvas.
</li>
              <li class="listitem">
Look at the Object library (Control-Option-Command-3). Click the second button in the segmented control to put the Object library into list view, if it isn’t in list view already. Locate the Round Rect Button (you can type “button” into the filter bar at the bottom of the library as a shortcut).<a id="idm441654983408" class="indexterm"></a>
<a id="idm441654982256" class="indexterm"></a>
</li>
              <li class="listitem">
Drag the Round Rect Button from the Object library into the View in the canvas (<a class="xref" href="ch07.html#FIGdraggingbutton">Figure 7.3</a>). Don’t accidentally drop the button onto the canvas background, outside of the View! This would cause the button to become a top-level object, which is not what you want. If that happens, select the button in the dock and press Delete, and try again.
</li>
            </ol>
          </div>
          <div class="figure">
            <a id="FIGdraggingbutton"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0703.png" alt="figs/pios_0703.png" />
              </div>
            </div>
            <p class="title">Figure 7.3. Dragging a button into a view</p>
          </div>
          <br class="figure-break" />
          <p>A button now appears in the view in the canvas. The move we’ve just performed — dragging from the Object library into the canvas — is extremely characteristic; you’ll do it often as you design your interface. Alternatively, select an object in the Object library and press Return to copy the object into your interface (you might first want to make sure the correct superview is selected in the canvas). Filtering by name with the filter bar also selects, and switching to the Object library with Control-Option-Command-3 also puts focus in the filter bar, so a rapid keyboard-only way to add a button to your interface is to type Control-Option-Command-3, “button”, possibly Up or Down arrow to select Round Rect Button, Return.</p>
          <p>Take a moment to play around with the button in the view in the canvas. Much as in a drawing program, the nib editor provides features to aid you in designing your interface. Here are some things to try:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
Select it: resizing handles appear.
</li>
              <li class="listitem">
Resize it to make it wider: dimension information appears.
</li>
              <li class="listitem">
Drag it near the edge of the view: a guideline appears, showing a standard margin space between the edge of the button and the edge of the view. Similarly, drag it near the center of the view: a guideline shows you when the button is centered.
</li>
              <li class="listitem">
With the button selected, hold down the Option key and hover the mouse outside the button: arrows and numbers appear showing the distance between the button and the edges of the view. (If you accidentally clicked and dragged while you were holding Option, you’ll now have two buttons. That’s because Option-dragging an object duplicates it. Select the unwanted button and press Delete to remove it.)
</li>
              <li class="listitem">
Shift-Control-click on the button: a menu appears, letting you select the button or whatever’s behind it (in this case, the view).
</li>
            </ul>
          </div>
          <p>(In Xcode 4.5 and later, you’ll also see what look like guidelines or dimension bars when the button is selected and at rest. Those are autolayout <a id="idm441654968928" class="indexterm"></a>constraints, to be discussed in <a class="xref" href="ch14.html">Chapter 14</a>.)</p>
          <p>Let’s prove that we really are designing our app’s interface. We’ll run the app to see that its interface has changed.</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Make sure that the Breakpoints button in the project window toolbar is <span class="emphasis"><em>not</em></span> selected, as we don’t want to pause at any breakpoints you may have created while reading the previous chapter.
</li>
              <li class="listitem">
Make sure the destination in the Scheme pop-up menu is the iPhone Simulator.
</li>
              <li class="listitem">
Choose Product → Run (or click the Run button in the toolbar).
</li>
            </ol>
          </div>
          <p>After a heart-stopping pause, the iOS Simulator opens, and presto, our empty window is empty no longer (<a class="xref" href="ch07.html#FIGemptynolonger">Figure 7.4</a>); it contains a round rect button! You can tap this button with the mouse, emulating what the user would do with a finger; the button highlights as you tap it.</p>
          <div class="figure">
            <a id="FIGemptynolonger"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0704.png" alt="figs/pios_0704.png" />
              </div>
            </div>
            <p class="title">Figure 7.4. The Empty Window app’s window is empty no longer</p>
          </div>
          <br class="figure-break" />
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_inspectors_and_libraries"></a>Inspectors and Libraries</h3>
              </div>
            </div>
          </div>
          <p>There are four inspectors that appear only when you’re editing a nib and apply to whatever object is selected in the dock or canvas:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Identity inspector (Command-Option-3)
</span>
              </dt>
              <dd>
Far and away the most important section of this inspector is the first one, the Custom Class. The selected object’s Class setting tells you the object’s class, and you can use it to change the object’s class. Some situations in which you’ll need to change the class of an object in the nib appear later in this chapter.<a id="idm441654954976" class="indexterm"></a>
<a id="idm441654953024" class="indexterm"></a><a id="idm441654952160" class="indexterm"></a>
<a id="idm441654950656" class="indexterm"></a>
<a id="idm441654949408" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Attributes inspector (Command-Option-4)
</span>
              </dt>
              <dd>
                <p class="simpara">
Settings here correspond to properties and methods that you might use to configure the object in code.<a id="idm441654946912" class="indexterm"></a>
<a id="idm441668981360" class="indexterm"></a> For example, changing the setting in the Background pop-up menu in the Attributes inspector for our view corresponds to setting the <code class="literal">backgroundColor</code> property for the view in code. Similarly, typing a value in the Title field in the Attributes inspector for our button is like calling the button’s <code class="literal">setTitle:forState:</code> method.
</p>
                <p class="simpara">The Attributes inspector has sections corresponding to the selected object’s class inheritance. For example, the UIButton Attributes inspector has three sections, because a UIButton is also a UIControl (“Control” in the inspector) and a UIView (“View” in the inspector).</p>
              </dd>
            </dl>
          </div>
          <div class="warning" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Warning</h3>
            <p>The correspondence between Attributes inspector settings and <span class="keep-together">Objective-C</span> methods is mostly a matter of guesswork. The Attributes inspector doesn’t always tell you, and there’s no way to see the code generated when the nib actually loads.</p>
          </div>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Size inspector (Command-Option-5)
</span>
              </dt>
              <dd>
                <p class="simpara">
The X, Y, Width, and Height fields determine the object’s frame (its position and size within its superview), corresponding to its <code class="literal">frame</code> property in code; you can equally do this in the canvas by dragging and resizing, but numeric precision can be desirable.<a id="idm441662578000" class="indexterm"></a>
<a id="idm441662576848" class="indexterm"></a>
</p>
                <p class="simpara">What else you see in the Size inspector depends on whether this nib is using autolayout or not. Autolayout, a new iOS 6 feature, may be toggled on or off for a nib at file level: select the nib file in the Project navigator, show the File inspector (Command-Option-1), and check or uncheck Use Autolayout. The default for new nibs in Xcode 4.5 and later, and thus for our Empty Window project, is that autolayout is on.<a id="idm441662575136" class="indexterm"></a>
<a id="idm441662573632" class="indexterm"></a>
<a id="idm441662572384" class="indexterm"></a><a id="idm441662571520" class="indexterm"></a>
<a id="idm441662570272" class="indexterm"></a> The possibilities for what you’ll see in the rest of the Size inspector are:</p>
                <div class="variablelist">
                  <dl>
                    <dt>
                      <span class="term">
Autolayout is off
</span>
                    </dt>
                    <dd>
The Size inspector displays an Autosizing box that corresponds to the <code class="literal">autoresizingMask</code> property, determining how the object will be repositioned and resized when its superview is resized; a delightful animation demonstrates visually the implications of your settings. The Arrange pop-up menu contains useful commands for positioning the selected object.
</dd>
                    <dt>
                      <span class="term">
Autolayout is on
</span>
                    </dt>
                    <dd>
The Size inspector displays autolayout-related settings: the object’s content hugging and content compression resistance priorities, plus any autolayout constraints involving this object. There is no Arrange pop-up menu, but effectively the same menu pops up from the leftmost segment of the little cartouche at the lower right of the canvas.<a id="idm441662563648" class="indexterm"></a>
<a id="idm441662562144" class="indexterm"></a>
<a id="idm441662560896" class="indexterm"></a>
</dd>
                  </dl>
                </div>
              </dd>
              <dt>
                <span class="term">
Connections inspector (Command-Option-6)
</span>
              </dt>
              <dd>
I’ll discuss this later in this chapter.
</dd>
            </dl>
          </div>
          <p>There are two libraries that are of particular importance when you’re editing a nib:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Object library (Control-Option-Command-3)
</span>
              </dt>
              <dd>
This library, as we’ve already seen, is your source for objects that you want to add to the nib.
</dd>
              <dt>
                <span class="term">
Media library (Control-Option-Command-4)
</span>
              </dt>
              <dd>
This library lists media in your project, such as images that you might want to drag into a UIImageView or directly into your interface (in which case a UIImageView is created for you).<a id="idm441662553376" class="indexterm"></a>
<a id="idm441662552128" class="indexterm"></a>
</dd>
            </dl>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_nib_loading_and_file_8217_s_owner"></a>Nib Loading and File’s Owner</h2>
            </div>
          </div>
        </div>
        <p>A nib file is useless until your app runs and the nib file is <span class="emphasis"><em>loaded</em></span>. If a nib is designated by the <span class="emphasis"><em>Info.plist</em></span> key “Main nib file base name” (<code class="literal">NSMainNibFile</code>, see <a class="xref" href="ch06.html">Chapter 6</a>), it is loaded automatically as the app launches; but this is an exceptional case, and has now fallen out of favor — there are no automatically loaded main nib files in the current project templates. In general, nibs are loaded explicitly as needed while the app runs.<a id="idm441662547040" class="indexterm"></a>
<a id="idm441662544992" class="indexterm"></a>
<a id="idm441662543744" class="indexterm"></a> In our Empty Window application, you can actually see where this happens, in <span class="emphasis"><em>AppDelegate.m</em></span>:</p>
        <pre class="screen">self.viewController =
    [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil];</pre>
        <p>That line of code does several things, one of which is that (for reasons to be explained more fully in <a class="xref" href="ch19.html">Chapter 19</a>) it causes the nib named <code class="literal">@"ViewController"</code> (i.e., the nib file compiled from <span class="emphasis"><em>ViewController.xib</em></span>, the nib file we’ve been editing) to be loaded, and the resulting views to be put into our app’s interface — which is how we were able to obtain the outcome shown in <a class="xref" href="ch07.html#FIGemptynolonger">Figure 7.4</a>.</p>
        <p>So a nib is not loaded until the app runs and our code decides, at some point in the life of the app, that that nib is needed. This architecture is a source of great efficiency. For example, imagine our app has two complete sets of interface, and the user might never ask to see the second one. It makes obvious sense not to load a nib containing the second set of interface until the user <span class="emphasis"><em>does</em></span> ask to see it. By this strategy, a nib is loaded when its instances are needed, and those instances are destroyed when they are no longer needed. Thus memory usage is kept to a minimum, which is important because memory is at a premium in a mobile device. Also, loading a nib takes time, so loading fewer nibs at launch time makes launching faster.</p>
        <p>In order to use nibs (or storyboards, since a storyboard is like a collection of multiple nibs), it is crucial that you understand what happens when a nib loads.</p>
        <p><span class="emphasis"><em>When a nib loads, some already existing instance is designated its owner</em></span>. A nib cannot load without an owner, and the owner must exist before the nib can load.<a id="idm441662535744" class="indexterm"></a>
<a id="idm441662534240" class="indexterm"></a>
<a id="idm441662532992" class="indexterm"></a> The nib owner can be an instance of any class; it will often, though not necessarily, be a UIViewController instance, because a UIViewController already knows how to load a nib and manage a view that it contains (<a class="xref" href="ch19.html">Chapter 19</a>).</p>
        <p>The three most common ways of telling a nib to load are:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">initWithNibName:bundle:</code>
</span>
            </dt>
            <dd>
This is UIViewController’s designated initializer. It tells the UIViewController to which it is sent to prepare to load the named nib <span class="emphasis"><em>with itself as owner</em></span>. (That’s what’s happening in the line of code from <span class="emphasis"><em>AppDelegate.m</em></span> that I quoted just a moment ago.) The moment of actual loading is automatically postponed until the nib is needed. I’ll talk much more about this in <a class="xref" href="ch19.html">Chapter 19</a>.
</dd>
            <dt>
              <span class="term">
<code class="literal">loadNibNamed:owner:options:</code>
</span>
            </dt>
            <dd>
An NSBundle instance method. Usually, you’ll direct it to <code class="literal">[NSBundle mainBundle]</code>. Observe that the owner is one of the parameters. I’ll show an example in the next section of this chapter.
</dd>
            <dt>
              <span class="term">
<code class="literal">instantiateWithOwner:options:</code>
</span>
            </dt>
            <dd>
A UINib instance method. The nib in question was specified when UINib was instantiated. Again, the owner is one of the parameters. An example appears in <a class="xref" href="ch21.html">Chapter 21</a>.
</dd>
          </dl>
        </div>
        <p><span class="emphasis"><em>When a nib loads, its nib objects are instantiated</em></span>,<a id="idm441662519744" class="indexterm"></a>
<a id="idm441662518496" class="indexterm"></a> meaning its top-level nib objects and all deeper-level nib objects hierarchically dependent on them. (Proxy objects, by definition, exist before the nib loads; nib loading does not instantiate them.) For example, in our nib, the view is instantiated when the nib loads, bringing with it the button inside it. (Again, see <a class="xref" href="ch05.html#SECnibbasedinstantiation">Nib-Based Instantiation</a>; make very sure you understand this point!) This is what nibs are for — to instantiate objects when they load. To put it another way, that is what nib loading is — it is the instantiation of the nib objects described in the nib. At that point, having loaded, the nib’s work is done; the nib does not, for example, have to be “unloaded.”</p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>The same nib can be loaded multiple times, generating an entirely new set of instances each time. A frequent beginner question is, “I have a view in a nib; how do I make multiple copies of this view?” The simple solution is to load that nib multiple times. This is common practice. For example, consider table view cells. Every “row” of a table view is a table view cell. Let’s say there’s a certain look and behavior you want each “row” to have. You design the cell in a nib of its own as a UITableViewCell. If the table has to display ten rows, you load that nib ten times (<a class="xref" href="ch21.html">Chapter 21</a>).</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_making_and_loading_a_nib"></a>Making and Loading a Nib</h2>
            </div>
          </div>
        </div>
        <p>Let’s create our own nib-loading code, illustrating at the same time the fact that any instance can be a nib’s owner. To do so, we’ll need a second nib file in our project.</p>
        <p>First, we’ll make the nib:<a id="idm441662512064" class="indexterm"></a>
<a id="idm441662510560" class="indexterm"></a>
<a id="idm441662509312" class="indexterm"></a></p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
Choose File → New → File. The “Choose a template” dialog for files appears.
</li>
            <li class="listitem">
At the left of the dialog, under iOS (not Mac OS X!), choose User Interface, and select View in the main part of the dialog. Click Next.
</li>
            <li class="listitem">
For the Device Family pop-up menu, specify iPhone. Click Next.
</li>
            <li class="listitem">
In the Save dialog, name the file <span class="emphasis"><em>MyNib</em></span>. Make sure you’re saving into the Empty Window project folder, that the group is Empty Window, and that the target is Empty Window (and checked); all those things should be true by default. Click Create.
</li>
          </ol>
        </div>
        <p>We’ve now created a nib file, <span class="emphasis"><em>MyNib.xib</em></span>, containing a single top-level nib object, a UIView. Look at <span class="emphasis"><em>MyNib.xib</em></span> in the editor to see that this is true.</p>
        <p>We’ll also need an instance to act as the nib’s owner. By the time our code will run, we will already have at least one instance we could use (the AppDelegate instance), but to illustrate the procedure fully, we’ll create our own class whose sole purpose is to be instantiated so that this instance can act as the owner of the nib file as it loads:<a id="idm441662500496" class="indexterm"></a></p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
In the Empty Window project in Xcode, choose File → New → File. The “Choose a template” dialog for files appears.
</li>
            <li class="listitem">
At the left of the dialog, under iOS (not Mac OS X!), select Cocoa Touch, and select Objective-C Class in the main part of the dialog. Click Next.
</li>
            <li class="listitem">
Name the file <span class="emphasis"><em>MyClass</em></span>. The dialog also offers you a chance to specify what superclass the new class should be a subclass of. Make sure this is NSObject. Click Next.
</li>
            <li class="listitem">
In the Save dialog be sure that you’re saving into the Empty Window project folder, that the group is Empty Window, and that the target is Empty Window (and checked); all those things should be true by default. Click Create.
</li>
          </ol>
        </div>
        <p>We’ve now created files <span class="emphasis"><em>MyClass.h</em></span> and <span class="emphasis"><em>MyClass.m</em></span> declaring a class called MyClass.</p>
        <p>Next, we’ll write code that will load our new nib when the app runs. We need a place in our little app where our code is guaranteed to run: we’ll use the AppDelegate instance method <code class="literal">application:didFinishLaunchingWithOptions:</code> in the file <span class="emphasis"><em>AppDelegate.m</em></span>. Just before or after the call to <code class="literal">makeKeyAndVisible</code>, insert this code to instantiate MyClass and load <span class="emphasis"><em>MyNib.nib</em></span> with that instance as its owner:<a id="idm441662489536" class="indexterm"></a>
<a id="idm441662488032" class="indexterm"></a>
<a id="idm441662486784" class="indexterm"></a></p>
        <pre class="screen">MyClass* mc = [MyClass new];
[[NSBundle mainBundle] loadNibNamed:@"MyNib" owner:mc options:nil];</pre>
        <p>Xcode will complain about this, because you can’t speak of MyClass without importing its declaration, so after the existing <code class="literal">#import</code> at the start of this file, add this line:</p>
        <pre class="screen">#import "MyClass.h"</pre>
        <p>Now build and run the project. Our new <span class="emphasis"><em>MyNib.nib</em></span> file loads, and its UIView top-level nib object is instantiated. Unfortunately, you can’t <span class="emphasis"><em>see</em></span> that this is true! That’s because we haven’t done anything to obtain the UIView instance that came into existence from the nib loading; in fact, what really happened is that the UIView instance popped into existence and popped right back out again, like a virtual particle in quantum field theory. The next section corrects this, and shows how to obtain visible proof that our nib is loading and that its top-level nib objects are being instantiated.</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_outlet_connections"></a>Outlet Connections</h2>
            </div>
          </div>
        </div>
        <p>You know how to load a nib file, thus instantiating its top-level nib objects. But those instances are useless to you if you don’t know how to get a <span class="emphasis"><em>reference</em></span> to any of them in your code! Doing things with an object such as a label or a button or a text field or whatever (such as setting or getting the text it displays) is easy; but you have to be able to talk <span class="emphasis"><em>to</em></span> the object in the first place, meaning that you need a reference to it, a variable that points to that instance (<a class="xref" href="ch03.html">Chapter 3</a>). Getting a reference to an instance that you created in code is trivial, because you assigned it to a variable at the time you created it (<a class="xref" href="ch05.html">Chapter 5</a>). But there’s no such assignment when you load a nib; you just load it and that’s the end of that:</p>
        <pre class="screen">[[NSBundle mainBundle] loadNibNamed:@"MyNib" owner:mc options:nil];
// no assignment??!! dude, where are my nib-created instances?</pre>
        <p>To refer in code to instances generated from nib objects when the nib loads, you need to have previously set up <span class="emphasis"><em>an outlet connection from a proxy object in the same nib</em></span>.</p>
        <p>A <span class="emphasis"><em>connection</em></span> is a named unidirectional linkage from one object in a nib file (the connection’s source) to another object in the same nib file (the connection’s target).<a id="idm441662473568" class="indexterm"></a>
<a id="idm441662472416" class="indexterm"></a><a id="idm441662471552" class="indexterm"></a>
<a id="idm441662470048" class="indexterm"></a>
<a id="idm441662468800" class="indexterm"></a> An <span class="emphasis"><em>outlet</em></span> is a connection whose name corresponds to an instance variable in the source object.<a id="idm441662467328" class="indexterm"></a>
<a id="idm441662466080" class="indexterm"></a> When the nib loads, and the target object is instantiated, the nib-loading mechanism <span class="emphasis"><em>assigns the value of the instance variable to be the target object</em></span>. Thus the source object winds up with a reference to the target object as the value of one of its instance variables.</p>
        <p>Connections can link any two objects in a nib file, but a proxy object as the source of a connection is special because it represents an object that exists before the nib loads. Thus an outlet from a proxy object causes an object that exists <span class="emphasis"><em>before</em></span> the nib loads to end up with a reference to an object that doesn’t exist until <span class="emphasis"><em>after</em></span> the nib loads — an object that is in fact instantiated by the loading of the nib.</p>
        <p>In the most typical configuration, the proxy object will be the File’s Owner. The idea is that the instance that owns the nib has an instance variable, and the File’s Owner in the nib has a corresponding outlet to a nib object; the nib loads, and the owner instance ends up with an instance variable that refers to the instance generated from the nib object (<a class="xref" href="ch07.html#FIGoutlet">Figure 7.5</a>).</p>
        <div class="figure">
          <a id="FIGoutlet"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0705.png" alt="figs/pios_0705.png" />
            </div>
          </div>
          <p class="title">Figure 7.5. How an outlet provides a reference to a nib-instantiated object</p>
        </div>
        <br class="figure-break" />
        <p>The File’s Owner top-level object in a nib file is a proxy for the instance that will be the nib’s owner when the nib loads. To form a successful connection between this proxy object and a nib object, the nib needs to know the class of that instance. In the nib editor, <span class="emphasis"><em>you must set the File’s Owner’s class to match the nib owner’s class</em></span>.<a id="idm441662456400" class="indexterm"></a>
<a id="idm441662455072" class="indexterm"></a> Obviously this means that you must know in advance, while editing the nib, what the class of the nib owner will be when the nib loads. But you do know this, because you (i.e. your code) is what’s going to load the nib.</p>
        <p>To demonstrate the use of an outlet connection, we’ll implement exactly the schema illustrated in <a class="xref" href="ch07.html#FIGoutlet">Figure 7.5</a>, by making an outlet from the File’s Owner to a nib object in <span class="emphasis"><em>MyNib.xib</em></span>.<a id="idm441662452160" class="indexterm"></a></p>
        <p>The nib owner is going to be a MyClass instance when the nib loads. As I’ve just said, we must tell the nib that this is the case. Let’s do that first:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
In Xcode, click <span class="emphasis"><em>MyNib.xib</em></span> to edit it.
</li>
            <li class="listitem">
In the dock, select the File’s Owner proxy object.
</li>
            <li class="listitem">
Show the Identity inspector (Command-Option-3). The Class, under Custom Class, is NSObject. Change this to MyClass. (If you type “My,” the word “MyClass” should just appear, as it’s the only class Xcode knows about whose name starts with “My.” Accept this by pressing Return.)
</li>
          </ol>
        </div>
        <p>Next, we need a nib object in <span class="emphasis"><em>MyNib.xib</em></span> to make an outlet to. We already have one — the nib’s existing top-level UIView. But this lacks visual impact, so we’ll replace the UIView with a top-level UILabel, which will draw some text:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
In Xcode, click <span class="emphasis"><em>MyNib.xib</em></span> to edit it.
</li>
            <li class="listitem">
In the dock, select the View object and delete it.
</li>
            <li class="listitem">
Drag a Label object (UILabel) from the Object library into the canvas to become a new top-level object. Its graphical representation appears in the canvas.
</li>
            <li class="listitem">
Double-click the word “Label” in the label’s graphical representation in the canvas and type “Hello, world!” Hit Return to stop editing; the label resizes to match the size of its text.
</li>
          </ol>
        </div>
        <p>Now comes the really crucial part. We need two things, in two different places:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
The instance variable
</span>
            </dt>
            <dd>
In its code, MyClass needs an instance variable.
</dd>
            <dt>
              <span class="term">
The outlet
</span>
            </dt>
            <dd>
In the nib, the File’s Owner proxy, representing a MyClass instance, needs an outlet pointing at the label — an outlet with the same name as the instance variable.
</dd>
          </dl>
        </div>
        <p>When the app runs and <span class="emphasis"><em>MyNib.nib</em></span> is loaded with a MyClass instance as its owner, as we arranged in the code we’ve already written, those two pairs of things will be effectively equated:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
The MyClass instance will be equated with the File’s Owner proxy in the nib, because it <span class="emphasis"><em>will</em></span> be the nib’s owner as it loads.
</li>
            <li class="listitem">
MyClass’s instance variable will be equated with the File’s Owner outlet pointing at the label, because <span class="emphasis"><em>they have the same name</em></span>.
</li>
          </ul>
        </div>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>I’m simplifying. It isn’t really the identity of an instance variable’s name with that of the outlet that makes the match. It’s more complicated than that; the match is made using key–value coding. The rigorous details appear in <a class="xref" href="ch12.html">Chapter 12</a>.</p>
        </div>
        <p>You thus need to work in two places at once: the nib, and MyClass’s code. Before Xcode 4, this required working separately in two <span class="emphasis"><em>different</em></span> places, Xcode (where the code was edited) and Interface Builder (where the nib was edited). Nowadays, Xcode itself edits both the code and the nib, and furthermore you can see the code and the nib <span class="emphasis"><em>at the same time</em></span>, all of which will make creating this pair of things, the instance variable and the outlet, much easier than it once was.</p>
        <p>I want you now to arrange to see two things at once: <span class="emphasis"><em>MyClass.m</em></span> (the MyClass implementation file, where we’ll declare the instance variable) and <span class="emphasis"><em>MyNib.xib</em></span> (where we’ll create the outlet). You could use two project windows if you wanted, but for simplicity, let’s use an assistant: while editing <span class="emphasis"><em>MyNib.xib</em></span>, switch to Assistant view (View → Assistant Editor → Show Assistant Editor) as in <a class="xref" href="ch07.html#FIGtwoAtOnce">Figure 7.6</a>. If, when you showed the assistant pane, it didn’t appear with MyClass’s implementation file showing, use the jump bar in the assistant pane to make the assistant pane show <span class="emphasis"><em>MyClass.m</em></span>: for example, in the first path component choose Manual → Top Level Objects → MyClass.m. If the assistant pane is beside the nib editor pane rather than below it, choose View → Assistant Editor → All Editors Stacked Vertically.</p>
        <div class="figure">
          <a id="FIGtwoAtOnce"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0706.png" alt="figs/pios_0706.png" />
            </div>
          </div>
          <p class="title">Figure 7.6. Editing a nib, with code in the assistant pane</p>
        </div>
        <br class="figure-break" />
        <p>In <span class="emphasis"><em>MyClass.m</em></span> in the assistant pane, at the start of the implementation section, create curly braces and declare a UILabel instance variable (and save):</p>
        <pre class="screen">@implementation MyClass
{
    IBOutlet UILabel* theLabel;
}
@end</pre>
        <p>The term <code class="literal">IBOutlet</code> is linguistically meaningless; it is <code class="literal">#define</code>d as an empty string, so it is deleted by the preprocessor before the compiler ever sees it.<a id="idm441662417728" class="indexterm"></a> It’s purely a hint to Xcode to make it easy for you to create the outlet. Xcode responds by displaying an empty circle in the gutter to the left of the <code class="literal">IBOutlet</code> line; this indicates that although we’re speaking of an outlet in our code, no corresponding outlet connection yet exists in a nib. We’ll fix that in a moment.</p>
        <p>We have typed the instance variable as a <code class="literal">UILabel*</code>, because we happen to know that this is the type of object that this instance variable will be pointing to; we could also use <code class="literal">id</code>, or any superclass of UILabel. If we do not use one of these alternatives (<code class="literal">id</code>, UILabel, or a superclass of UILabel), we will not be able to form the connection to a UILabel in the nib.</p>
        <p>We have accomplished half our task: we’ve made the instance variable. Now we’re ready for the other half, namely, to make the outlet connection. There are several ways to do this, so I’ll just pick one for now and demonstrate the others later:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
Select File’s Owner in the nib (which, you remember, represents a MyClass instance) and switch to the Connections inspector (Command-Option-6). Lo and behold, the name of our instance variable, <code class="literal">theLabel</code>, is listed here! This is the work of the <code class="literal">IBOutlet</code> hint we created earlier.<a id="idm441662408864" class="indexterm"></a>
<a id="idm441662407616" class="indexterm"></a>
</li>
            <li class="listitem">
Click in the empty circle to the right of <code class="literal">theLabel</code> in the Connections inspector, drag to the Label object in the canvas (<a class="xref" href="ch07.html#FIGconnectingoutlet">Figure 7.7</a>), and release the mouse. (A kind of elastic line follows the mouse as you drag from the circle to show that you’re creating a connection.)
</li>
          </ol>
        </div>
        <div class="figure">
          <a id="FIGconnectingoutlet"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0707.png" alt="figs/pios_0707.png" />
            </div>
          </div>
          <p class="title">Figure 7.7. Connecting an outlet from the Connections inspector</p>
        </div>
        <br class="figure-break" />
        <p>With the File’s Owner object selected, look again at the Connections inspector; it shows that <code class="literal">theLabel</code> is connected to the Label nib object, and if you hover the mouse over the filled circle at the right, the label object in the nib is highlighted. And look at the <code class="literal">IBOutlet</code> line in <span class="emphasis"><em>MyClass.m</em></span>; the circle in the gutter is now filled in, and if you click that filled circle, the label is specified in a pop-up menu next to the circle, and the label object in the nib is highlighted. Mission accomplished! We have made an outlet connection in the nib from the File’s Owner proxy (representing a MyClass instance) to the Label object, and this outlet connection has the same name as the instance variable <code class="literal">theLabel</code> in MyClass’s code.</p>
        <p>Therefore, when the nib loads and a MyClass instance is the nib’s owner, its <code class="literal">theLabel</code> instance variable will be set to the UILabel object that will be instantiated through the loading of the nib. To prove that this is indeed the case, we’ll use that instance variable in our code to do something dramatic. In particular, we’ll stick the UILabel into our window, thus making it visible. Its visibility will prove that the nib is loading and that the instance variable is being set by the outlet.</p>
        <p>Return to <span class="emphasis"><em>AppDelegate.m</em></span> and modify the nib-loading code like this (you added the first two lines earlier):</p>
        <pre class="screen">MyClass* mc = [MyClass new];
[[NSBundle mainBundle] loadNibNamed:@"MyNib" owner:mc options:nil];
UILabel* lab = [mc valueForKey: @"theLabel"];
[self.window.rootViewController.view addSubview: lab];
lab.center = CGPointMake(100,100);
lab.frame = CGRectIntegral(lab.frame);</pre>
        <p>(We haven’t written an accessor method in MyClass for <code class="literal">theLabel</code>, so to save time I used key–value coding.) Build and run the app. The words “Hello, world!” appear! This proves that our outlet worked. We loaded a nib and, using an outlet, we obtained a reference to a nib object and were able to manipulate that object, putting it into our interface.</p>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Making an instance variable and giving it an <code class="literal">IBOutlet</code> hint, but forgetting to connect the outlet to anything in the nib, is an unbelievably common beginner (and not-so-beginner) mistake. Had we made this mistake, our code would have run without error, but “Hello, world!” would not appear in the interface because <code class="literal">lab</code> would be nil. The unfilled circle that appears in the gutter next to an <code class="literal">IBOutlet</code> line for which no corresponding nib connection exists is your only clue that something’s amiss, so watch for it. <a id="idm441662390016" class="indexterm"></a>
<a id="idm441662386912" class="indexterm"></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_more_ways_to_create_outlets"></a>More Ways to Create Outlets</h3>
              </div>
            </div>
          </div>
          <p>I said a moment ago that there were other ways to create the outlet. Let’s try some of them. Return to our assistant-paned nib editor, select the File’s Owner, switch to the Connections inspector, and delete the outlet by clicking the little X to its left.<a id="idm441662384176" class="indexterm"></a>
<a id="idm441662382928" class="indexterm"></a> We’re going to make this outlet again, a different way:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Select the File’s Owner in the dock.
</li>
              <li class="listitem">
Hold down the Control key and drag from the File’s Owner to the label. An elastic line follows the mouse. Release the mouse.
</li>
              <li class="listitem">
A little window (called a HUD, for “heads-up display”) appears, titled Outlets, listing <code class="literal">theLabel</code> as a possibility (<a class="xref" href="ch07.html#FIGconnectingoutlet2">Figure 7.8</a>).<a id="idm441662377008" class="indexterm"></a> Click <code class="literal">theLabel</code>.
</li>
            </ol>
          </div>
          <div class="figure">
            <a id="FIGconnectingoutlet2"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0708.png" alt="figs/pios_0708.png" />
              </div>
            </div>
            <p class="title">Figure 7.8. Connecting an outlet by Control-dragging from the source object</p>
          </div>
          <br class="figure-break" />
          <p>Once again, look at the Connections inspector with the File’s Owner selected to confirm that this worked. You can even build and run the project again, to prove it to yourself if you’re in any doubt. Now delete the outlet <span class="emphasis"><em>again</em></span>; we’re going to make this outlet in yet a <span class="emphasis"><em>different</em></span> way:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Select the File’s Owner in the dock.
</li>
              <li class="listitem">
Control-click the File’s Owner in the dock. A HUD appears, looking a lot like the Connections inspector.
</li>
              <li class="listitem">
Drag from the circle to the right of <code class="literal">theLabel</code> to the label (<a class="xref" href="ch07.html#FIGotherHud">Figure 7.9</a>). Release the mouse.
</li>
            </ol>
          </div>
          <div class="figure">
            <a id="FIGotherHud"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0709.png" alt="figs/pios_0709.png" />
              </div>
            </div>
            <p class="title">Figure 7.9. Connecting an outlet by dragging from the Connections HUD</p>
          </div>
          <br class="figure-break" />
          <p>Now delete the outlet <span class="emphasis"><em>again</em></span>; we’re going to make this outlet in <span class="emphasis"><em>another</em></span> way. This time, we’re going to operate from the point of view of the label. The Connections inspector shows all connections emanating <span class="emphasis"><em>from</em></span> the selected object; it also shows all connections linking <span class="emphasis"><em>to</em></span> the selected object. So, select the label and look at the Connections inspector. It lists “New Referencing Outlet.” This means an outlet <span class="emphasis"><em>from</em></span> something else <span class="emphasis"><em>to</em></span> the thing we’re inspecting, the label. So:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
From the circle at the right of “New Referencing Outlet,” drag to the File’s Owner. An elastic line follows the mouse. Release the mouse.
</li>
              <li class="listitem">
A HUD saying <code class="literal">theLabel</code> appears. Click it.
</li>
            </ol>
          </div>
          <p>Confirm that, once again, we’ve made an outlet from the File’s Owner to the label. (And we could also have done the same thing by Control-clicking the label to start with, to show its Connections HUD.) Now delete the outlet <span class="emphasis"><em>again</em></span>; we’re going to make this outlet in <span class="emphasis"><em>another</em></span> way. This time, we’re going to start with the label, but (hold onto your hat) we’re going to connect directly to the <span class="emphasis"><em>code</em></span> which is sitting in the assistant pane:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Select the label.
</li>
              <li class="listitem">
Make sure that <span class="emphasis"><em>MyClass.m</em></span> is showing in the assistant pane and that you can see the <code class="literal">IBOutlet</code> line declaring the instance variable <code class="literal">theLabel</code>.
</li>
              <li class="listitem">
Hold down the Control key and drag from the label in the nib <span class="emphasis"><em>across the barrier between panes</em></span> to that line of code. An elastic line follows the mouse. When you’ve got the mouse positioned correctly, the words Connect Outlet will appear. Release the mouse.
</li>
            </ol>
          </div>
          <p>Yet again, confirm that we’ve successfully made the desired outlet. And you could also have done the same thing in reverse; starting with the circle at the left of the <code class="literal">IBOutlet</code> line in the code, you can drag (without holding Control) to the label in the nib.</p>
          <p>Now delete the outlet one last time, and (get this) <span class="emphasis"><em>delete the line of code</em></span> declaring the instance variable (but leave the curly braces). We’re going to create the outlet and the instance variable declaration, all in a single amazing move:</p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
Select the label.
</li>
              <li class="listitem">
Make sure <span class="emphasis"><em>MyClass.m</em></span> is showing in the assistant pane.
</li>
              <li class="listitem">
Hold down the Control key and drag from the label in the nib to the area within the curly braces in the code. An elastic line follows the mouse. The words Insert Outlet or Outlet Collection appear. Release the mouse.
</li>
              <li class="listitem">
A little HUD appears, asking for the name of the instance variable that’s about to be created. Call it <code class="literal">theLabel</code> (and make sure the type is UILabel), and press Return. The <code class="literal">IBOutlet</code> line declaring the instance variable is created, and the outlet is formed to match it.
</li>
            </ol>
          </div>
          <div class="sidebar">
            <a id="SECconnectionIllusion"></a>
            <div class="titlepage">
              <div>
                <div>
                  <p class="title">Connecting to Code is an Illusion</p>
                </div>
              </div>
            </div>
            <p>Making an outlet by connecting directly between code and an interface object in the nib is extremely cool and convenient, but coolness and convenience do not relieve you of the necessity of understanding what an outlet is and how it works. No matter what physical gesture you make in Xcode, and no matter how much Xcode may give you the illusion that you are somehow connecting an object in the nib to the code, that’s not really the case. There is no connection between the instance variable in the code and the object in the nib; there is no identity between the instance variable in the code and the outlet connection in the nib. There are always, if an outlet is to work properly, <span class="emphasis"><em>two distinct and separate things</em></span> — an instance variable in a class, and an outlet in the nib, <span class="emphasis"><em>with the same name</em></span> and <span class="emphasis"><em>coming from an instance of that class</em></span>. It is the identity of the names that allows the two to be matched at runtime when the nib loads, so that the instance variable is properly set at that moment. Xcode tries to help you by enforcing this identity of names and by indicating that the connection should work when the code runs, but it is not in fact magically connecting the code to the nib.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_more_about_outlets"></a>More About Outlets</h3>
              </div>
            </div>
          </div>
          <p>All our examples so far have involved a proxy object, but an outlet connection can connect any two objects in the nib. The only requirement is that the source object be of a class that has an instance variable whose type matches the class of the target object. This class might be your own custom class with an ivar that you gave it, as in our earlier examples, or it might be a built-in Cocoa class with a built-in instance variable that can be used as an outlet.</p>
          <div class="warning" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Warning</h3>
            <p>Nothing in the documentation for a built-in Cocoa class tells you which of its instance variables are available as outlets. In general, the only way to learn what outlets a built-in class provides is to examine a representative of that class in a nib.</p>
          </div>
          <p>It is also possible to create an <span class="emphasis"><em>outlet collection</em></span>.<a id="idm441662329680" class="indexterm"></a>
<a id="idm441662328432" class="indexterm"></a> This is an NSArray instance variable matched by multiple connections to objects of the same type. For example, suppose a class contains this instance variable declaration:</p>
          <pre class="screen">IBOutletCollection(UILabel) NSArray* labels;</pre>
          <p>Then it is possible to form multiple <code class="literal">labels</code> outlets from an instance of that class in a nib, each one to a different UILabel in that nib. When the nib loads, those UILabel instances become the elements of the NSArray <code class="literal">labels</code>. The order in which the outlets are formed is the order of the elements in the array. This turns out to be particularly useful when forming outlets to autolayout constraints; examples will appear in <a class="xref" href="ch20.html">Chapter 20</a> and <a class="xref" href="ch23.html">Chapter 23</a>.</p>
          <div class="sidebar">
            <a id="SECconnectionBetweenNibs"></a>
            <div class="titlepage">
              <div>
                <div>
                  <p class="title">Connections Between Nibs</p>
                </div>
              </div>
            </div>
            <p>You cannot draw a connection from an object in one nib to an object in another nib. If you expect to be able to do this, you haven’t understood what a nib is (or what a connection is). A connection applies to specific instances. An object in a nib, however, is only a potential object, becoming a real object when the nib is loaded and the object is instantiated. This potentiality can be realized never, once, or many times. Two objects in the same nib will be instantiated together on any particular occasion when the nib loads, so it’s clear what instances a connection between them is intended to connect. But a connection from an object in one nib to an object in another nib would be meaningless, because there’s no way to say what actual future instances the connection is supposed to connect. The problem of communicating between an instance instantiated from one nib and an instance instantiated from another nib is just a special case of the more general problem of how to communicate between instances in a program and is discussed in <a class="xref" href="ch13.html">Chapter 13</a>.</p>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_action_connections"></a>Action Connections</h2>
            </div>
          </div>
        </div>
        <p>Having explored outlet connections, we should also discuss the other kind of connection, action connections.</p>
        <p>An <span class="emphasis"><em>action</em></span> is a message emitted automatically by a Cocoa UIControl interface object (a <span class="emphasis"><em>control</em></span>) when the user does something to it, such as tapping the control.<a id="idm441662318480" class="indexterm"></a><a id="idm441662317616" class="indexterm"></a> The various user behaviors that will cause a control to emit an action message are called <span class="emphasis"><em>events</em></span>.<a id="idm441662316144" class="indexterm"></a><a id="idm441662315280" class="indexterm"></a> To see a list of possible events, look at the UIControl class documentation, under “Control Events.” For example, in the case of a UIButton, the user tapping the button corresponds to the <code class="literal">UIControlEventTouchUpInside</code> event. In the case of a UITextField, the user typing or deleting or cutting or pasting corresponds to the <code class="literal">UIControlEventEditingChanged</code> event. A complete list of UIControls and what events they report is provided in <a class="xref" href="ch11.html">Chapter 11</a>, and each type of control is thoroughly dealt with in later chapters, especially <a class="xref" href="ch25.html">Chapter 25</a>.</p>
        <p>An action message, then, is a way for your code to respond when the user does something to a control in the interface, such as tapping a button.<a id="idm441662310640" class="indexterm"></a>
<a id="idm441662309392" class="indexterm"></a> But your code will not receive an action message from a control unless you explicitly make prior arrangements with that control. You must tell the control what event should trigger an action message, what instance to send the action message to, and what the action message’s name should be. There are two ways to make this arrangement: in code, or in a nib.<a id="idm441662308400" class="indexterm"></a>
<a id="idm441662306272" class="indexterm"></a>
<a id="idm441662305024" class="indexterm"></a></p>
        <p>Either way, we’re going to need a method for the action message to call. There are three standard signatures for a method that is to be called through an action message; the most commonly used one takes a single parameter, which will be a reference to the object that emitted the action message. (For full details, see <a class="xref" href="ch11.html">Chapter 11</a>.) So, for example, you could have a method like this (let’s agree to put it in the implementation section for ViewController, in <span class="emphasis"><em>ViewController.m</em></span>):</p>
        <pre class="screen">- (void) buttonPressed: (id) sender {
    UIAlertView* av = [[UIAlertView alloc] initWithTitle:@"Howdy!"
                                                 message:@"You tapped me."
                                                delegate:nil
                                       cancelButtonTitle:@"Cool"
                                       otherButtonTitles:nil];
    [av show];
}</pre>
        <p>Now, as I mentioned a moment ago, it is possible to arrange in code for <code class="literal">buttonPressed:</code> to be called when the user taps a button. In particular, if <code class="literal">b</code> is a reference to the button, then some ViewController code could say:</p>
        <pre class="screen">[b addTarget:self action:@selector(buttonPressed:)
        forControlEvents:UIControlEventTouchUpInside];</pre>
        <p>That code means: “Hey there, button! When the user taps on you (<code class="literal">UIControlEventTouchUpInside</code>), send me (<code class="literal">self</code>) a <code class="literal">buttonPressed:</code> message.” (See <a class="xref" href="ch03.html">Chapter 3</a> if you’ve forgotten about the <code class="literal">@selector</code> directive.) Of course, such an instruction assumes that this object (<code class="literal">self</code>) really does implement a <code class="literal">buttonPressed:</code> method. (If it doesn’t, then when the user taps the button, the app will crash.)</p>
        <p>However, instead of doing that, we’re going to use the existing button in <span class="emphasis"><em>ViewController.xib</em></span> and arrange <span class="emphasis"><em>in the nib</em></span> for its action message to be <code class="literal">buttonPressed:</code> and to be sent to a ViewController instance. We’re going to form an <span class="emphasis"><em>action connection</em></span> in the nib. We can do this because, as I’ve already mentioned, a ViewController instance is the owner of <span class="emphasis"><em>ViewController.nib</em></span> when it loads. The template has already set the File’s Owner proxy in <span class="emphasis"><em>ViewController.xib</em></span> to be of the ViewController class (look at it and see!). So we can create an action connection in the nib from the button to the File’s Owner, as a way of communicating between the button and the ViewController instance that loads the nib when the app runs.</p>
        <p>As with outlets, there are several ways to do this; I’ll just show you the main ones and leave you to discover the rest. (They are all directly comparable to the many ways of creating an outlet connection.) <a id="idm441662288272" class="indexterm"></a></p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">
We need a hint, in our code, that a method with the expected signature exists. This hint involves substituting <code class="literal">IBAction</code> for the method’s <code class="literal">void</code> return type. (The substitution is legal because <code class="literal">IBAction</code> is <code class="literal">#define</code>d as <code class="literal">void</code>; Xcode can see the hint in your code, but the preprocessor will turn <code class="literal">IBAction</code> back to <code class="literal">void</code> before the compiler ever sees it.)<a id="idm441662280880" class="indexterm"></a> So, in <span class="emphasis"><em>ViewController.m</em></span>, change the first line of our <code class="literal">buttonPressed:</code> method implementation to look like this (and save the file):
</p>
              <pre class="screen">- (IBAction) buttonPressed: (id) sender {</pre>
              <p class="simpara">This causes an empty circle to appear in the gutter next to the <code class="literal">IBAction</code> line.</p>
            </li>
            <li class="listitem">
Now edit <span class="emphasis"><em>ViewController.xib</em></span>, select the button in the window, and look at the Connections inspector.<a id="idm441662275744" class="indexterm"></a>
<a id="idm441662274496" class="indexterm"></a> The event for which we’d like to send the action message is Touch Up Inside. Drag from its circle to the File’s Owner nib object in the dock, which is to receive the message (<a class="xref" href="ch07.html#FIGconnectingactions">Figure 7.10</a>). Release the mouse.
</li>
            <li class="listitem">
A little window listing possible ViewController action methods appears; in this case, it lists only <code class="literal">buttonPressed:</code>. Click on <code class="literal">buttonPressed:</code> to form the connection.
</li>
          </ol>
        </div>
        <div class="figure">
          <a id="FIGconnectingactions"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0710.png" alt="figs/pios_0710.png" />
            </div>
          </div>
          <p class="title">Figure 7.10. Connecting an action from the Connections inspector</p>
        </div>
        <br class="figure-break" />
        <p>To see that the action connection has been formed, look at the Connections inspector. If you select the button, the Connections inspector reports that the button’s Touch Up Inside event is connected to the File’s Owner’s <code class="literal">buttonPressed:</code> method. If you select the File’s Owner object, the Connections inspector reports a Received Action where <code class="literal">buttonPressed:</code> is called by the Rounded Rect Button’s Touch Up Inside event. Finally, look at the code in <span class="emphasis"><em>ViewController.m</em></span>; the circle next to the <code class="literal">IBAction</code> line is filled, and you can click it to reveal that the connection is from the button.</p>
        <p>Finally, to make assurance doubly sure, you can also build and run the project to confirm that the action connection is working. In the running app, the button inside the window now actually does something when the user taps it! It summons an alert.</p>
        <p>As with outlets, we could have formed the action connection by Control-dragging from the button directly to the File’s Owner, instead of involving the Connections inspector. If you <span class="emphasis"><em>just</em></span> Control-drag, Interface Builder assumes a default event for you (in this case, it would assume Touch Up Inside). If that isn’t what you want, start by Control-clicking on the button to summon a HUD version of the Connections inspector, and drag from the desired event’s circle just as you would do from the real Connections inspector.</p>
        <p>As with outlets, you can also form the action connection directly from nib to code. (But please reread <a class="xref" href="ch07.html#SECconnectionIllusion">Connecting to Code is an Illusion</a>; that warning applies equally to action connections.) In <a class="xref" href="ch07.html#FIGactionToCode">Figure 7.11</a>, we’ve Control-clicked the button in the nib to summon its Connections HUD, and dragged from the Touch Up Inside circle to the <code class="literal">buttonPressed:</code> implementation in code. And we could equally have gone the other way, dragging from the unfilled circle next to the <code class="literal">IBAction</code> line in the code to the button in the nib.</p>
        <div class="figure">
          <a id="FIGactionToCode"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0711.png" alt="figs/pios_0711.png" />
            </div>
          </div>
          <p class="title">Figure 7.11. Connecting an action to a method implementation</p>
        </div>
        <br class="figure-break" />
        <p>But wait, there’s more! Instead of writing the action method ahead of time, you can ask Xcode to stub it out for you. To do so, Control-drag from the nib to an empty spot in ViewController’s implementation section; the words Insert Action appear, and when you release the mouse, a dialog appears, letting you specify the name of the action method, the number of arguments it should take, and the control event to be used as a trigger. Xcode inserts the method implementation, but doesn’t put any code between the curly braces; it’s smart, but not smart enough to guess what you want the method to do!</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_additional_initialization_of_nib_based_instances"></a>Additional Initialization of Nib-Based Instances</h2>
            </div>
          </div>
        </div>
        <p>By the time a nib finishes loading, its instances are fully fledged; they have been initialized and configured with all the attributes dictated through the Attributes and Size inspectors, and their outlets have been used to set the values of the corresponding instance variables. Nevertheless, you might want to append your own code to the initialization process as an object is instantiated from a loading nib. Most commonly, to do this, you’ll implement <code class="literal">awakeFromNib</code> (possibly subclassing a Cocoa class in order to do so). The <code class="literal">awakeFromNib</code> message is sent to all nib-instantiated objects just after they are instantiated by the loading of the nib: at the point where this happens, the object has been initialized and configured and its connections are operational.<a id="idm441662250416" class="indexterm"></a></p>
        <p>For example, our Empty Window app is loading <span class="emphasis"><em>MyNib.xib</em></span>, extracting a UILabel from it, and inserting that label into our interface; the result is that the words “Hello, world!” appear in our window. Let’s modify the behavior of this UILabel so that it does some additional self-initialization in code. To do that, we will need a class of our own to which our UILabel will belong. Clearly, this needs to be a UILabel subclass. So:</p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
In Xcode, choose File → New → File and specify that you want a Cocoa Touch Objective-C class. Click Next.
</li>
            <li class="listitem">
Call the new class MyLabel. Make it a subclass of UILabel. Click Next.
</li>
            <li class="listitem">
Make sure you’re saving into the project folder, with the Empty Window group and the Empty Window target (this should be right by default). Click Create.
</li>
            <li class="listitem">
              <p class="simpara">
In <span class="emphasis"><em>MyLabel.m</em></span>, somewhere in the implementation section, implement <code class="literal">awakeFromNib</code>:
</p>
              <pre class="screen">- (void) awakeFromNib {
    [super awakeFromNib];
    self.text = @"I initialized myself!";
    [self sizeToFit];
}</pre>
            </li>
            <li class="listitem">
That code won’t apply to the label in <span class="emphasis"><em>MyNib.xib</em></span> unless that label <span class="emphasis"><em>is</em></span> a MyLabel, so edit <span class="emphasis"><em>MyNib.xib</em></span> and change the label’s class to MyLabel in the Identity inspector.
</li>
          </ol>
        </div>
        <p>Now build and run the project. Instead of “Hello, world!” we now see “I initialized myself!” in the window.</p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Mac OS X Programmer Alert</h3>
          <p>If you’re an experienced Mac OS X programmer, you may be accustomed to rarely or never calling <code class="literal">super</code> from <code class="literal">awakeFromNib</code>; doing so used to raise an exception, in fact. In iOS, you must always call <code class="literal">super</code> in <code class="literal">awakeFromNib</code>. Another major difference is that in Mac OS X, a nib owner’s <code class="literal">awakeFromNib</code> is called when the nib loads, so it’s possible for an object to be sent <code class="literal">awakeFromNib</code> multiple times; in iOS, <code class="literal">awakeFromNib</code> is sent to an object only when that object is itself instantiated from a nib, so it can be sent to an object a maximum of once.</p>
        </div>
        <p>Sometimes, you might need to interfere with a nib object’s initialization at an even earlier stage. If this object is a UIView or UIViewController (or a subclass of either), you can implement <code class="literal">initWithCoder:</code>. In your implementation, be sure to call <code class="literal">super</code> and return <code class="literal">self</code> as you would do in any initializer. Your purpose here would typically be to initialize additional instance variables that your subclass has declared, as with any initializer.</p>
        <p>Here, for example, is an implementation of MyLabel that declares an instance variable that is an int called <code class="literal">_num</code> and manipulates it first in <code class="literal">initWithCoder:</code> and then in <code class="literal">awakeFromNib</code>, thus proving that the two are called in that order:</p>
        <pre class="screen">@implementation MyLabel
{
    int _num;
}

- (id) initWithCoder:(NSCoder *)aDecoder {
    self = [super initWithCoder:aDecoder];
    if (self) {
        self-&gt;_num = 42;
    }
    return self;
}

- (void) awakeFromNib {
    [super awakeFromNib];
    self.text = [NSString stringWithFormat: @"The answer is %i", self-&gt;_num];
    [self sizeToFit];
}
@end</pre>
        <p>That’s trivial and unnecessary, but it illustrates the principle.
<a id="idm441662224624" class="indexterm"></a>
<a id="idm441662223792" class="indexterm"></a></p>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt02.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch08.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 6. Anatomy of an Xcode Project </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 8. Documentation</td>
        </tr>
      </table>
    </div>
  </body>
</html>
