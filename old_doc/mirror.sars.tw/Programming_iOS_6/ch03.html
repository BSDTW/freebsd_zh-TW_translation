<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 3. Objective-C Objects and Messages</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt01.html" />
    <link rel="prev" href="ch02.html" />
    <link rel="next" href="ch04.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch02.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 2. Object-Based Programming </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 4. Objective-C Classes</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id3"></a>Chapter 3. Objective-C Objects and Messages</h2>
          </div>
        </div>
      </div>
      <p>One of the first object-based programming languages to achieve maturity and widespread dissemination was Smalltalk.<a id="idm441656865136" class="indexterm"></a> It was developed during the 1970s at Xerox PARC under the leadership of Alan Kay and started becoming widely known in 1980.<a id="idm441656864112" class="indexterm"></a> The purpose of Objective-C, created by Brad Cox and Tom Love in 1986, was to build Smalltalk-like syntax and behavior on top of C.<a id="idm441656863072" class="indexterm"></a><a id="idm441656862304" class="indexterm"></a><a id="idm441656861536" class="indexterm"></a><a id="idm441656860768" class="indexterm"></a> Objective-C was licensed by NeXT in 1988 and was the basis for its application framework API, NeXTStep.<a id="idm441656859872" class="indexterm"></a> Eventually, NeXT and Apple merged, and the NeXT application framework evolved into Cocoa, the framework for Mac OS X applications, still revolving around Objective-C.<a id="idm441656858800" class="indexterm"></a> That history explains why Objective-C is the base language for iOS programming. (It also explains<a id="idm441656857792" class="indexterm"></a> why Cocoa class names often begin with “NS” — it stands for “NeXTStep.”)
<a id="idxobjc" class="indexterm"></a></p>
      <p>Having learned the basics of C (<a class="xref" href="ch01.html">Chapter 1</a>) and the nature of object-based programming (<a class="xref" href="ch02.html">Chapter 2</a>), you are ready to meet Objective-C. This chapter describes Objective-C structural fundamentals; the next two chapters provide more detail about how <span class="keep-together">Objective-C</span> classes and instances work. (A few additional features of the language are discussed in <a class="xref" href="ch10.html">Chapter 10</a>.) As with the C language, my intention is not to describe the Objective-C language completely, but to provide a practical linguistic grounding, founded on my own experience of those aspects of the language that need to be firmly understood as a basis for iOS programming.</p>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_an_instance_reference_is_a_pointer"></a>An Instance Reference Is a Pointer</h2>
            </div>
          </div>
        </div>
        <p>In C, every variable must be declared to be of some type. In an object-based language such as Objective-C, an instance’s type is its class. The C language includes very few basic data types. To facilitate the multiplicity of class types required by its object-based nature, Objective-C takes advantage of C pointers. So, in Objective-C, if a variable is an instance of the class MyClass, that variable is of type <code class="literal">MyClass*</code> — a pointer to a MyClass. In general, in Objective-C, a reference to an instance is a pointer and the name of the data type of what’s at the far end of that pointer is the name of the instance’s class.<a id="idm441656851696" class="indexterm"></a>
<a id="idm441656850544" class="indexterm"></a><a id="idm441656849776" class="indexterm"></a>
<a id="idm441656848624" class="indexterm"></a><a id="idm441656847856" class="indexterm"></a>
<a id="idm441656846704" class="indexterm"></a></p>
        <div class="tip" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Tip</h3>
          <p>Note the convention for capitalization. Variable names tend to start with a lowercase letter; class names tend to start with an uppercase letter.<a id="idm441656845264" class="indexterm"></a>
<a id="idm441656844112" class="indexterm"></a></p>
        </div>
        <p>As I mentioned in <a class="xref" href="ch01.html">Chapter 1</a>, the fact that a reference to an instance is a pointer in Objective-C will generally not cause you any difficulties, because pointers are used consistently throughout the language. For example, a message to an instance is directed at the pointer, so there is no need to dereference the pointer. Indeed, having established that a variable representing an instance is a pointer, you’re likely to forget that this variable even <span class="emphasis"><em>is</em></span> a pointer and just work directly with that variable:</p>
        <pre class="screen">NSString* s = @"Hello, world!";
NSString* s2 = [s uppercaseString];</pre>
        <p>Having established that <code class="literal">s</code> is an <code class="literal">NSString*</code>, you would never dereference <code class="literal">s</code> (that is, you would never speak of <code class="literal">*s</code>) to access the “real” NSString. So it feels as if the pointer <span class="emphasis"><em>is</em></span> the real NSString. Thus, in the previous example, once the variable <code class="literal">s</code> is declared as a pointer to an NSString, the <code class="literal">uppercaseString</code> message is sent directly to the variable <code class="literal">s</code>. (The <code class="literal">uppercaseString</code> message asks an NSString to generate and return an uppercase version of itself; so, after that code, <code class="literal">s2</code> is <code class="literal">@"HELLO, WORLD!"</code>)</p>
        <p>The tie between a pointer, an instance, and the class of that instance is so close that it is natural to speak of an expression like <code class="literal">MyClass*</code> as meaning “a MyClass instance,” and of a <code class="literal">MyClass*</code> value as “a MyClass.” A Objective-C programmer will say simply that, in the previous example, <code class="literal">s</code> <span class="emphasis"><em>is</em></span> an NSString, that <code class="literal">uppercaseString</code> returns “an NSString,” and so forth. It is fine to speak like that, and I do it myself (and will do it in this book) — provided you remember that this is a shorthand. Such an expression means “an NSString instance,” and because an instance is represented as a C pointer, it means an <code class="literal">NSString*</code>, a pointer to an NSString.</p>
        <p>Although the fact that instance references in Objective-C are pointers does not cause any special difficulty, you must still be conscious of what pointers are and how they work. As I emphasized in <a class="xref" href="ch01.html">Chapter 1</a>, when you’re working with pointers, you must keep in mind the special meaning of your actions. So here are some basic facts about pointers that you should keep in mind when working with instance references in <span class="keep-together">Objective-C</span>.</p>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Forgetting the asterisk in an instance declaration is a common beginner mistake, and will net you a mysterious compiler error message, such as “Interface type cannot be statically allocated.”<a id="idm441656827552" class="indexterm"></a>
<a id="idm441656826400" class="indexterm"></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_instance_references_initialization_and_nil"></a>Instance References, Initialization, and nil</h3>
              </div>
            </div>
          </div>
          <p>Merely declaring an instance reference’s type doesn’t bring any instance into existence.<a id="idm441656824368" class="indexterm"></a>
<a id="idm441656823216" class="indexterm"></a><a id="idm441656822448" class="indexterm"></a>
<a id="idm441656821296" class="indexterm"></a><a id="idm441656820528" class="indexterm"></a><a id="idm441656819760" class="indexterm"></a> For example:</p>
          <pre class="screen">NSString* s; // only a declaration; no instance is pointed to</pre>
          <p>After that declaration, <code class="literal">s</code> is <span class="emphasis"><em>typed</em></span> as a pointer to an NSString, but it is not <span class="emphasis"><em>in fact</em></span> pointing to an NSString. You have created a pointer, but you haven’t supplied an NSString for it to point to. It’s just sitting there, waiting for you to point it at an NSString, typically by assignment (as we did with <code class="literal">@"Hello, world!"</code> earlier). Such assignment <span class="emphasis"><em>initializes</em></span> the variable, giving it an actual meaningful value of the proper type.</p>
          <p>You can declare a variable as an instance reference in one line of code and initialize it later, like this:</p>
          <pre class="screen">NSString* s;
// ... time passes ...
s = @"Hello, world!";</pre>
          <p>But this is not common. It is much more common, wherever possible, to declare and initialize a variable all in one line of code:</p>
          <pre class="screen">NSString* s = @"Hello, world!";</pre>
          <p>Declaration <span class="emphasis"><em>without</em></span> initialization, before the advent of ARC in iOS 5 (<a class="xref" href="ch12.html">Chapter 12</a>), created a dangerous situation:</p>
          <pre class="screen">NSString* s;</pre>
          <p>What <span class="emphasis"><em>is</em></span> <code class="literal">s</code> after a mere declaration like that? It could be anything. But it is <span class="emphasis"><em>claiming</em></span> to be a pointer to an NSString, and so your code might proceed to <span class="emphasis"><em>treat</em></span> it as a pointer to an NSString. But it is pointing at garbage. A pointer pointing at garbage is liable to cause serious trouble down the road when you accidentally try to use it as an instance.<a id="idm441656809312" class="indexterm"></a>
<a id="idm441656808160" class="indexterm"></a><a id="idm441656807392" class="indexterm"></a>
<a id="idm441656806240" class="indexterm"></a><a id="idm441656805472" class="indexterm"></a>
<a id="idm441656804320" class="indexterm"></a><a id="idm441656803552" class="indexterm"></a>
<a id="idm441656802400" class="indexterm"></a> Sending a message to a garbage pointer, or otherwise treating it as a meaningful instance, can crash your program. Even worse, it might <span class="emphasis"><em>not</em></span> crash your program: it might cause your program to behave very, very oddly instead — and figuring out why can be difficult.</p>
          <p>For this reason, if you <span class="emphasis"><em>aren’t</em></span> going to initialize an instance reference pointer at the moment you declare it by assigning it a real value, it’s a good idea to assign it nil:</p>
          <pre class="screen">NSString* s = nil;</pre>
          <p>A small but delightful bonus feature of using ARC is that this assignment is performed for you, implicitly and invisibly, as soon as you declare a variable without initializing it:<a id="idm441656798624" class="indexterm"></a>
<a id="idm441656797472" class="indexterm"></a></p>
          <pre class="screen">NSString* s; // under ARC, s is immediately set to nil for you</pre>
          <p>This prevents the existence of a garbage pointer, and could save you from yourself by preventing a crash when you accidentally use <code class="literal">s</code> as an instance without initializing it. Nevertheless, long years of habit have trained me to initialize or explicitly set to nil an instance pointer as soon as I declare it, and you’ll see that I continue to do so in examples in this book.</p>
          <p>What is nil?<a id="idm441656794192" class="indexterm"></a>
<a id="idm441656793040" class="indexterm"></a><a id="idm441656792272" class="indexterm"></a> It’s simply a form of zero — the form of zero appropriate to an instance reference. The nil value simply means: “This instance reference isn’t pointing to any instance.” Indeed, you can test an instance reference against nil as a way of finding out whether it is in fact pointing to a real instance. This is an extremely common thing to do:</p>
          <pre class="screen">if (nil == s) // ...</pre>
          <p>As I mentioned in <a class="xref" href="ch01.html">Chapter 1</a>, the explicit comparison with nil isn’t strictly necessary; because nil is a form of zero, and because zero means false in a condition, you can perform the same test like this:</p>
          <pre class="screen">if (!s) // ...</pre>
          <p>I do in fact write nil tests in that second form all the time, but some programmers would take me to task for bad style. The first form has the advantage that its real meaning is made explicit, rather than relying on a cute implicit feature of C. The first form places nil first in the comparison so that if the programmer accidentally omits an equal sign, performing an assignment instead of a comparison, the compiler will catch the error (because assignment to nil is illegal).</p>
          <p>Many Cocoa methods use a return value of nil, instead of an expected instance, to signify that something went wrong. You are supposed to capture this return value and test it for nil in order to discover whether something <span class="emphasis"><em>did</em></span> go wrong. For example, the <span class="keep-together">documentation</span> for the NSString class method <code class="literal">stringWithContentsOfFile:encoding:error:</code>
says that it returns “a string created by reading data from the file named by <code class="literal">path</code> using the encoding, <code class="literal">enc</code>. If the file can’t be opened or there is an encoding error, returns nil.” So, as I described in <a class="xref" href="ch01.html">Chapter 1</a>, your next move after calling this method and capturing the result should be to test that result against nil, just to make sure you’ve really got an instance now:<a id="idm441656783024" class="indexterm"></a><a id="idm441656782256" class="indexterm"></a></p>
          <pre class="screen">NSString* path = // ... whatever;
NSStringEncoding enc = // ... whatever;
NSError* err = nil;
NSString* s =
    [NSString stringWithContentsOfFile:path encoding:enc error:&amp;err];
if (nil == s) // oops! something went wrong...</pre>
          <p>You should now be wondering about the implications of a nil-value pointer for sending a message to a noninstance.<a id="idm441656780000" class="indexterm"></a>
<a id="idm441656778848" class="indexterm"></a> For example, you can send a message to an NSString instance like this:</p>
          <pre class="screen">NSString* s2 = [s uppercaseString];</pre>
          <p>That code sends the <code class="literal">uppercaseString</code> message to <code class="literal">s</code>. So <code class="literal">s</code> is supposedly an NSString instance. But what if <code class="literal">s</code> is nil? With some object-based programming languages, sending a message to nil constitutes a runtime error and will cause your program to terminate prematurely (REALbasic and Ruby are examples). But Objective-C doesn’t work like that. In Objective-C, sending a message to nil is legal and does not interrupt execution. Moreover, if you capture the result of the method call, it will be a form of zero — which means that if you assign that result to an instance reference pointer, it too will be nil:</p>
          <pre class="screen">NSString* s = nil; // now s is nil
NSString* s2 = [s uppercaseString]; // now s2 is nil</pre>
          <p>Whether this behavior of Objective-C is a good thing is a quasi-religious issue and a subject of vociferous debate among programmers. It is useful, but it is also extremely easy to be tricked by it. The usual scenario is that you accidentally send a message to a nil reference without realizing it, and then later your program doesn’t behave as expected. Because the point where the unexpected behavior occurs is later than the moment when the nil pointer arose in the first place, the genesis of the nil pointer can be difficult to track down (indeed, it often fails to occur to the programmer that a nil pointer is the cause of the trouble in the first place).</p>
          <p>Short of peppering your code with tests to ascertain that your instance reference pointers are not accidentally nil, which is not generally a good idea, there isn’t much you can do about this. This behavior is strongly built into the language and is not going to change. It’s just something you need to be aware of.</p>
          <p>If, on the other hand, a method call can return nil, be conscious of that fact. Don’t assume that everything will go well and that it won’t return nil. On the contrary, if something can go wrong, it probably will. For example, to omit the nil test after calling <code class="literal">stringWithContentsOfFile:encoding:error:</code> is just stupid. I don’t care if you know perfectly well that the file exists and the encoding is what you say it is — test the result for nil!</p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>In pure C code, you will sometimes see a pointer-to-nothing expressed as <a id="idm441656770064" class="indexterm"></a>NULL. NULL and nil are functionally equivalent nowadays, and I’ll use nil exclusively in this book.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_instance_references_and_assignment"></a>Instance References and Assignment</h3>
              </div>
            </div>
          </div>
          <p>As I said in <a class="xref" href="ch01.html">Chapter 1</a>, assigning to a pointer does not mutate the value at the far end of the pointer; rather, it repoints the pointer.<a id="idm441656767488" class="indexterm"></a>
<a id="idm441656766336" class="indexterm"></a><a id="idm441656765568" class="indexterm"></a>
<a id="idm441656764416" class="indexterm"></a> Moreover, assigning one pointer to another repoints the pointer in such a way that both pointers are now pointing to the very same thing. Failure to keep these simple facts firmly in mind can have results that range from surprising to disastrous.</p>
          <p>For example, instances in general are usually mutable: they typically have instance variables that can change. If two references are pointing at one and the same instance, then when the instance is mutated by way of one reference, that mutation also affects the instance as seen through the other reference. To illustrate, pretend that we’ve implemented the Stack class described in the previous chapter:<a id="idm441656762880" class="indexterm"></a></p>
          <pre class="screen">Stack* myStack1 = // ... create Stack instance and initialize myStack1 ... ;
Stack* myStack2 = myStack1;
[myStack1 push: @"Hello"];
[myStack1 push: @"World"];
NSString* s = [myStack2 pop];</pre>
          <p>After we pop <code class="literal">myStack2</code>, <code class="literal">s</code> is <code class="literal">@"World"</code> even though nothing was ever pushed onto <code class="literal">myStack2</code> (and the stack <code class="literal">myStack1</code> contains only <code class="literal">@"Hello"</code> even though nothing was ever popped off of <code class="literal">myStack1</code>). That’s because we did push two strings onto <code class="literal">myStack1</code> and then pop one string off <code class="literal">myStack2</code>, and <code class="literal">myStack1</code> <span class="emphasis"><em>is</em></span> <code class="literal">myStack2</code> — in the sense that they are both pointers to the very same stack instance. That’s perfectly fine, as long as you understand and intend this behavior.</p>
          <p>In real life, you’re likely to pass an instance off to some other object, or to receive it from some other object:</p>
          <pre class="screen">Stack* myStack = // ... create Stack instance and initialize myStack ... ;
// ... more code might go here ...
[myObject doSomethingWithThis: myStack]; // pass myStack to myObject</pre>
          <p>After that code, <code class="literal">myObject</code> has a pointer to the very same instance we’re already pointing to as <code class="literal">myStack</code>. So we must be careful and thoughtful. The object <code class="literal">myObject</code> might mutate <code class="literal">myStack</code> right under our very noses. Even more, the object <code class="literal">myObject</code> might <span class="emphasis"><em>keep</em></span> its reference to the stack instance and mutate it <span class="emphasis"><em>later</em></span> — possibly much later, in a way that could surprise us. This is possible because instances can have instance variables that point to other objects, and those pointers can persist as long as the instances themselves do. This kind of shared referent situation can be intentional, but it is also something to watch out for and be conscious of (<a class="xref" href="ch03.html#FIGtwoptrsoneinstance">Figure 3.1</a>).<a id="idm441656747776" class="indexterm"></a>
<a id="idm441656746624" class="indexterm"></a></p>
          <div class="figure">
            <a id="FIGtwoptrsoneinstance"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0301.png" alt="figs/pios_0301.png" />
              </div>
            </div>
            <p class="title">Figure 3.1. Two instances end up with pointers to the same third instance</p>
          </div>
          <br class="figure-break" />
          <p>Another possible misunderstanding is to imagine that the assignment <code class="literal">myStack2 = myStack1</code> somehow makes a new, separate instance that duplicates <code class="literal">myStack1</code>. That’s not at all the case. It doesn’t make a new instance; it just points <code class="literal">myStack2</code> at the very same instance that <code class="literal">myStack1</code> is pointing at. It may be possible to make a new instance that duplicates a given instance, but the ability to do so is not a given and it is not going to happen through mere assignment. (For how a separate duplicate instance might be generated, see the NSCopying protocol and the <code class="literal">copy</code> method mentioned in <a class="xref" href="ch10.html">Chapter 10</a>.)</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_instance_references_and_memory_management"></a>Instance References and Memory Management</h3>
              </div>
            </div>
          </div>
          <p>The pointer nature of instance references in Objective-C also has implications for management of memory.<a id="idm441656738176" class="indexterm"></a>
<a id="idm441656737024" class="indexterm"></a> The scope, and in particular the lifetime, of variables in pure C is typically quite straightforward: if you bring a piece of variable storage into existence by declaring that variable within a certain scope, then when that scope ceases to exist, the variable storage ceases to exist. That sort of variable is called <span class="emphasis"><em>automatic</em></span> (K&amp;R 1.10). So, for example:</p>
          <pre class="screen">void myFunction() {
    int i; // storage for an int is set aside
    i = 7; // 7 is placed in that storage
} // the scope ends, so the int storage and its contents vanish</pre>
          <p>But in the case of a pointer, there are two pieces of memory to worry about: the pointer itself, which is an integer signifying an address in memory, and whatever is at that address, at the far end of that pointer. Nothing about the C language causes the destruction of what a pointer points to when the pointer itself is automatically destroyed as it goes out of scope:</p>
          <pre class="screen">void myFunction() {
    NSString* s = @"Hello, world!"; // pointer and NSString
    NSString* s2 = [s uppercaseString]; // pointer and NSString
} // the two pointers go out of existence...
// ... but what about the two NSStrings they point to?</pre>
          <p>Some object-based programming languages in which a reference to an instance is a pointer do manage automatically the memory pointed to by instance references (<span class="keep-together">REALbasic</span> and Ruby are examples). But Objective-C, at least the way it’s implemented when you’re programming for iOS, is not one of those languages. Because the C language has nothing to say about the automatic destruction of what is pointed to by a reference to an instance, Objective-C implements an explicit mechanism for the management of memory. I’ll talk in a later chapter (<a class="xref" href="ch12.html">Chapter 12</a>) about what that mechanism is and what responsibilities for the programmer it entails. Fortunately, under ARC, those responsibilities are fewer than they used to be; but memory must still be managed, and you must still understand how memory management works.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_messages_and_methods_2"></a>Messages and Methods</h2>
            </div>
          </div>
        </div>
        <p>An Objective-C method is defined as part of a class. It has three aspects:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
Whether it’s a class method or an instance method
</span>
            </dt>
            <dd>
If it’s a class method, you call it by sending a message to the class itself. If it’s an instance method, you call it by sending a message to an instance of the class.
</dd>
            <dt>
              <span class="term">
Its parameters and return value
</span>
            </dt>
            <dd>
As with a C function, an Objective-C method takes some number of parameters; each parameter is of some specified type. And, as with a C function, it may return a value, which is also of some specified type; if the method returns nothing, its return type is declared as <code class="literal">void</code>.<a id="idm441656724672" class="indexterm"></a>
</dd>
            <dt>
              <span class="term">
Its name
</span>
            </dt>
            <dd>
An Objective-C method’s name must contain as many colons as it takes parameters. The name is split after each colon in a method call or declaration, so it is usual for the part of the name preceding each colon to describe the corresponding parameter.<a id="idm441656721680" class="indexterm"></a>
<a id="idm441656720528" class="indexterm"></a>
</dd>
          </dl>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_sending_a_message"></a>Sending a Message</h3>
              </div>
            </div>
          </div>
          <p>As you’ve doubtless gathered, the syntax for sending a message to an object involves square brackets. The first thing in the square brackets is the object to which the message is to be sent; this object is the message’s <span class="emphasis"><em>receiver</em></span>. Then follows the message:<a id="idm441656717248" class="indexterm"></a><a id="idm441656716384" class="indexterm"></a><a id="idm441656715520" class="indexterm"></a>
<a id="idm441656714272" class="indexterm"></a><a id="idm441656713408" class="indexterm"></a>
<a id="idm441656712160" class="indexterm"></a><a id="idm441656711296" class="indexterm"></a>
<a id="idm441656710048" class="indexterm"></a></p>
          <pre class="screen">NSString* s2 = [s uppercaseString]; // send "uppercaseString" message to s ...
// ... (and assign result to s2)</pre>
          <p>If the message is a method that takes parameters, each corresponding argument value comes after a colon:</p>
          <pre class="screen">[myStack1 push: @"Hello"]; // send "push:" message to myStack1 ...
// ...with one argument, the NSString @"Hello"</pre>
          <p>To send a message to a class (calling a class method), you can represent the class by the literal name of the class:</p>
          <pre class="screen">NSString* s = [NSString string]; // send "string" message to NSString class</pre>
          <p>To send a message to an instance (calling an instance method), you’ll need a reference to an instance, which (as you know) is a pointer:</p>
          <pre class="screen">NSString* s = @"Hello, world!"; // s is initialized as an NSString instance
NSString* s2 = [s uppercaseString]; // send "uppercaseString" message to s</pre>
          <p>You can send a class method to a class, and an instance method to an instance, no matter how you got hold of and represent the class or the instance. For example, <code class="literal">@"Hello, world!"</code> is itself an NSString instance, so it’s legal to say:</p>
          <pre class="screen">NSString* s2 = [@"Hello, world!" uppercaseString];</pre>
          <p>If a method takes no parameters, then its name contains no colons, like the NSString instance method <code class="literal">uppercaseString</code>. If a method takes one parameter, then its name contains one colon, which is the final character of the method name, like the hypothetical Stack instance method <code class="literal">push:</code>. If a method takes two or more parameters, its name contains that number of colons. In the minimal case, its name ends with that number of colons. For example, a method taking three parameters might be called <code class="literal">hereAreThreeStrings:::</code>. To call it, we split the name after each colon and follow each colon with an argument, which looks like this:</p>
          <pre class="screen">[someObject hereAreThreeStrings: @"string1" : @"string2" : @"string3"];</pre>
          <p>That’s a legal way to name a method, but it isn’t very common, mostly because it isn’t very informative. Usually the name will have more text; in particular, the part before each colon will describe the parameter that follows that colon.</p>
          <p>For example, there’s a UIColor class method for generating an instance of a UIColor from four CGFloat numbers representing its red, green, blue, and alpha (transparency) components, and it’s called <code class="literal">colorWithRed:green:blue:alpha:</code>. Notice the clever construction of this name. The <code class="literal">colorWith</code> part tells something about the method’s purpose: it generates a <span class="emphasis"><em>color</em></span>, starting <span class="emphasis"><em>with</em></span> some set of information. All the rest of the name, <code class="literal">Red:green:blue:alpha:</code>, describes the meaning of each parameter. And you call it like this:</p>
          <pre class="screen">UIColor* c = [UIColor colorWithRed: 0.0 green: 0.5 blue: 0.25 alpha: 1.0];</pre>
          <p>The space after each colon in the method call is optional. (Space before a colon is also legal, though in practice one rarely sees this.)</p>
          <p>The rules for naming an Objective-C method, along with the conventions governing such names (like trying to make the name informative about the method’s purpose and the meanings of its parameters), lead to some rather long and unwieldy method names, such as <code class="literal">getBytes:maxLength:usedLength:encoding:options:range:remainingRange:</code>. Such verbosity of nomenclature is characteristic of Objective-C. Method calls, and even method declarations, are often split across multiple lines to prevent a single line of code from becoming so long that it wraps within the editor, as well as for clarity.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_declaring_a_method"></a>Declaring a Method</h3>
              </div>
            </div>
          </div>
          <p>The declaration for a method has three parts:<a id="idm441656690048" class="indexterm"></a>
<a id="idm441656688800" class="indexterm"></a></p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
Either <code class="literal">+</code> or <code class="literal">-</code>, meaning that the method is a class method or an instance method, respectively.<a id="idm441656685728" class="indexterm"></a>
<a id="idm441656684480" class="indexterm"></a><a id="idm441656683616" class="indexterm"></a>
<a id="idm441656682368" class="indexterm"></a>
</li>
              <li class="listitem">
The data type of the return value, in parentheses.
</li>
              <li class="listitem">
The name of the method, split after each colon. Following each colon is the corresponding parameter, expressed as the data type of the parameter, in parentheses, followed by a placeholder name for the parameter.
</li>
            </ul>
          </div>
          <p>So, for example, Apple’s documentation tells us that the declaration for the UIColor class method <code class="literal">colorWithRed:green:blue:alpha:</code> is:</p>
          <pre class="screen">+ (UIColor*) colorWithRed: (CGFloat) red green: (CGFloat) green
                     blue: (CGFloat) blue alpha: (CGFloat) alpha</pre>
          <p>(Note that I’ve split the declaration into two lines, for legibility and to fit onto this page. The documentation puts it all on a single line.)</p>
          <p>Make very sure you can read this declaration! You should be able to look at it and say to yourself instantly, “The name of this method is <code class="literal">colorWithRed:green:blue:alpha:</code>. It’s a class method that takes four CGFloat parameters and returns a UIColor.”</p>
          <p>It is not uncommon, outside of code, to write a method’s name along with the plus sign or the minus sign, to make it clear whether this is a class method or an instance method. So you might speak informally of “-uppercaseString,” just as a way of reminding yourself or a reader that this is an instance method. Again outside of code, it is not uncommon, especially when communicating with other Objective-C programmers, to speak of a method’s name along with the class in which this method is defined. So you might say “NSString’s -uppercaseString,”
or even something like “-[NSString uppercaseString].” Notice that that isn’t code, or even pseudo-code, because you are not actually speaking of a method call, and in any case you could never send the <code class="literal">uppercaseString</code> message to the NSString class; it’s just a compact way of saying, “I’m talking about the <code class="literal">uppercaseString</code> that’s an instance method of NSString.”</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_nesting_method_calls"></a>Nesting Method Calls</h3>
              </div>
            </div>
          </div>
          <p>Wherever in a method call an object of a certain type is supposed to appear, you can put another method call that returns that type. Thus you can nest method calls.<a id="idm441656671264" class="indexterm"></a>
<a id="idm441656669760" class="indexterm"></a>
<a id="idm441656668512" class="indexterm"></a> A method call can appear as the message’s receiver:</p>
          <pre class="screen">NSString* s = [[NSString string] uppercaseString]; // silly but legal</pre>
          <p>That’s legal because NSString’s class method <code class="literal">string</code> returns an NSString instance (formally, an <code class="literal">NSString*</code> value, remember), so we can send an NSString instance method to that result. Similarly, a method call can appear as an argument in a method call:</p>
          <pre class="screen">[myStack push: [NSString string]]; // ok if push: expects NSString* parameter</pre>
          <p>However, I must caution you against overdoing that sort of thing. Code with a lot of nested square brackets is very difficult to read (and to write). Furthermore, if one of the nested method calls happens to return nil unexpectedly, you have no way to detect this fact. It is often better, then, to be even more verbose and declare a temporary variable for each piece of the method call. Just to take an example from my own code, instead of writing this:</p>
          <pre class="screen">NSArray* arr = [[MPMediaQuery albumsQuery] collections];</pre>
          <p>I might write this:</p>
          <pre class="screen">MPMediaQuery* query = [MPMediaQuery albumsQuery];
NSArray* arr = [query collections];</pre>
          <p>Even though the first version is quite short and legible, and even though in the second version the variable <code class="literal">query</code> will never be used again — it exists solely in order to be the receiver of the <code class="literal">collections</code> message in the second line — it is worth creating it as a separate variable. For one thing, it makes this code far easier to step through in the debugger later on, when I want to pause after the <code class="literal">albumsQuery</code> call and see whether the expected sort of result is being returned.</p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>Incorrect number or pairing of nested square brackets can net you some curious messages from the compiler. For example, too many pairs of square brackets (<code class="literal">[[query collections]]</code>) or an unbalanced left square bracket (<code class="literal">[[query collections]</code>) is reported as “Expected identifier.”<a id="idm441656656560" class="indexterm"></a>
<a id="idm441656655312" class="indexterm"></a></p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_no_overloading"></a>No Overloading</h3>
              </div>
            </div>
          </div>
          <p>The data type returned by a method, together with the data types of each of its parameters in order, constitute that method’s <span class="emphasis"><em>signature</em></span>.<a id="idm441656652432" class="indexterm"></a>
<a id="idm441656651184" class="indexterm"></a> It is illegal for two methods of the same type (class method or instance method) to exist in the same class with the same name but different signatures.</p>
          <p>So, for example, you could not have two MyClass instance methods called <code class="literal">myMethod</code>, one of which returns void and one of which returns an NSString. Similarly, you could not have two MyClass instance methods called <code class="literal">myMethod:</code>, both returning void, one taking a CGFloat parameter and one taking an NSString parameter.
An attempt to violate this rule will be stopped dead in its tracks by the compiler, which will announce a “duplicate declaration” error.<a id="idm441656647712" class="indexterm"></a>
<a id="idm441656646560" class="indexterm"></a> The reason for this rule is that if two such conflicting methods were allowed to exist, there would be no way to determine from a method call to one of them which method was being called.</p>
          <p>You might think that the issue could be decided by looking at the types involved in the call. If one <code class="literal">myMethod:</code> takes a CGFloat parameter and the other <code class="literal">myMethod:</code> takes an NSString parameter, you might think that when <code class="literal">myMethod:</code> is called, Objective-C could look at the actual argument and realize that the former method is meant if the argument is a CGFloat and the latter if the argument is an NSString. But Objective-C doesn’t work that way. There are languages that permit this feature, called <span class="emphasis"><em>overloading</em></span>, but Objective-C is not one of them.<a id="idm441656642048" class="indexterm"></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_parameter_lists"></a>Parameter Lists</h3>
              </div>
            </div>
          </div>
          <p>It isn’t uncommon for an Objective-C method to require an unknown number of parameters.<a id="idm441656639728" class="indexterm"></a>
<a id="idm441656638480" class="indexterm"></a> A good example is the NSArray class method <code class="literal">arrayWithObjects:</code>, which looks from the name as if it takes one parameter but in fact takes any number of parameters, separated by comma. The parameters are the objects of which the NSArray is to consist. The trick here, however, which you must discover by reading the documentation, is that the list must end with nil. The nil is not one of the objects to go into the NSArray (nil isn’t an object, so an NSArray can’t contain nil); it’s to show where the list ends.</p>
          <p>So, here’s a correct way to call the <code class="literal">arrayWithObjects:</code> method:</p>
          <pre class="screen">NSArray* pep = [NSArray arrayWithObjects:@"Manny", @"Moe", @"Jack", nil];</pre>
          <p>The declaration for <code class="literal">arrayWithObjects:</code> uses three dots to show that a comma-separated list is legal:</p>
          <pre class="screen">+ (id)arrayWithObjects:(id)firstObj, ... ;</pre>
          <p>Without the nil terminator, the program will not know where the list ends, and bad things will happen when the program runs, as it goes hunting off into the weeds of memory, incorporating all sorts of garbage into the NSArray that you never meant to have incorporated.</p>
          <p>Forgetting the nil terminator is a common beginner error, but not as common as it used to be: by a bit of deep-C voodoo, the Objective-C compiler now notices if you’ve forgotten the nil, and warns you (“missing sentinel in method dispatch”). Even though it’s just a warning, don’t run that code!<a id="idm441656631200" class="indexterm"></a>
<a id="idm441656629952" class="indexterm"></a><a id="idm441656629088" class="indexterm"></a><a id="idm441656628224" class="indexterm"></a>
<a id="idm441656626976" class="indexterm"></a> Another way to avoid forgetting the nil terminator is to avoid calling <code class="literal">arrayWithObjects:</code> altogether; this is now possible starting with LLVM compiler version 4.0 (Xcode 4.4 or later), which allows you to form a literal NSArray object directly, using <code class="literal">@[...]</code> syntax, like this:<a id="idm441656624688" class="indexterm"></a>
<a id="idm441656623440" class="indexterm"></a></p>
          <pre class="screen">NSArray* pep = @[@"Manny", @"Moe", @"Jack"];</pre>
          <p>That’s just a notation, a kind of syntactic sugar; behind the scenes, <code class="literal">arrayWithObjects:</code> is presumably still being called for you. But it’s being called for you correctly, nil terminator and all, so this notation is much more bullet-proof than explicitly calling <code class="literal">arrayWithObjects:</code> yourself; plus it’s a lot less typing. I’ll be using this new Objective-C notation for literal arrays throughout this book.</p>
          <p>Nevertheless, you will still encounter other Objective-C methods that do have a parameter that’s a nil-terminated list of variable length. For example, there’s the UIAppearance protocol class method <code class="literal">appearanceWhenContainedIn:</code> (<a class="xref" href="ch25.html">Chapter 25</a>), or UIAlertView’s <code class="literal">initWithTitle:message:delegate:cancelButtonTitle:otherButtonTitles:</code> (<a class="xref" href="ch26.html">Chapter 26</a>). It’s a pity that Apple hasn’t somehow tweaked Objective-C or these methods to avoid the use of the nil terminator; for instance, they could have made the variable-length list parameter into an NSArray parameter instead. But until they do, knowing how to call such methods remains important.</p>
          <p>The C language has explicit provision for argument lists of unspecified length, which Objective-C methods such as <code class="literal">arrayWithObjects:</code> are using behind the scenes. I’m not going to explain the C mechanism, because I don’t expect you’ll ever write a method or function that requires it; see K&amp;R 7.3 if you need the gory details.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_unrecognized_selectors"></a>Unrecognized Selectors</h3>
              </div>
            </div>
          </div>
          <p>Objective-C messaging is dynamic,<a id="idm441656612672" class="indexterm"></a>
<a id="idm441656611424" class="indexterm"></a> meaning that the compiler takes no formal responsibility for whether a particular object is a legal recipient of a given message. That’s because whether an object can deal with a message sent to it isn’t decided until the program actually runs and the message actually arrives. Objective-C has various devices for dealing at runtime with a message that doesn’t correspond directly to a method, and for all the compiler knows, one of them might come into play in this case. For example, at the time the program runs, the recipient of the message might be nil — and it’s harmless to send <span class="emphasis"><em>any</em></span> message to nil.</p>
          <p>Thus, it is theoretically legal to direct a message at an object with no corresponding method. The only guardian against this possibility is the compiler. Before ARC, the compiler was not a very strong guardian in this respect. For example:</p>
          <pre class="screen">NSString* s = @"Hello, world!";
[s rockTheCasbah]; // without ARC, compiler warns</pre>
          <p>An NSString has no method <code class="literal">rockTheCasbah</code>. But the (non-ARC) compiler will not stop you from running a program containing this code; it’s legal. The compiler will <span class="emphasis"><em>warn</em></span> you, but it won’t stop you.<a id="idm441656606016" class="indexterm"></a>
<a id="idm441656604864" class="indexterm"></a><a id="idm441656604000" class="indexterm"></a>
<a id="idm441656602752" class="indexterm"></a> There are actually two possible warnings:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
If no <code class="literal">rockTheCasbah</code> method is defined <span class="emphasis"><em>anywhere</em></span> in your code, the compiler will say: “Instance method ‘-rockTheCasbah’ not found (return type defaults to ‘id’).” Without going into the details, what the compiler means is: “I know of no instance method <code class="literal">rockTheCasbah</code>, so I can’t check its signature against the return type and arguments you’re actually using, so I’ll just make some loose assumptions and let it pass.”
</li>
              <li class="listitem">
If a <code class="literal">rockTheCasbah</code> method <span class="emphasis"><em>is</em></span> defined somewhere in your code, the compiler will say: “‘NSString’ may not respond to ‘rockTheCasbah’.” This means: “There’s a <code class="literal">rockTheCasbah</code> method, all right, but you seem to be sending the <code class="literal">rockTheCasbah</code> method to an instance of a class that doesn’t have it as an instance method.”
</li>
            </ul>
          </div>
          <p>This is a good example of what I meant in <a class="xref" href="ch02.html">Chapter 2</a> when I said that sending a message and calling a method were not the same thing. The compiler is saying that NSString has no <code class="literal">rockTheCasbah</code> instance method, but that it isn’t going to stop you from sending an NSString a <code class="literal">rockTheCasbah</code> message. At runtime, the object that receives the <code class="literal">rockTheCasbah</code> message might be able to deal with it, for all the compiler knows.</p>
          <p>With ARC, however, the compiler is much stricter.<a id="idm441656591568" class="indexterm"></a>
<a id="idm441656590256" class="indexterm"></a> The example above won’t compile at all under ARC!<a id="idm441656588976" class="indexterm"></a>
<a id="idm441656587728" class="indexterm"></a> The compiler declares a fatal compilation error: “Receiver type ‘NSString’ for instance message does not declare a method with selector ‘rockTheCasbah’.” There is no NSString method <code class="literal">rockTheCasbah</code>, and by golly the compiler isn’t going to let you send the <code class="literal">rockTheCasbah</code> message to an NSString, and that’s final.</p>
          <p>This is another of those delightful secondary benefits of using ARC. In order to do what it primarily does (manage memory), ARC must insist on more information about classes and their methods than the Objective-C standard calls for. Here, ARC is demanding that you <span class="emphasis"><em>prove</em></span> that an NSString can respond to <code class="literal">rockTheCasbah</code>, or it won’t let you run this code at all. (Nevertheless, if you really want to, you can slip past even ARC’s stringent guardianship; I’ll explain how in the next section.)</p>
          <p>Let us assume for a moment that we are compiling without ARC, or that we have somehow tricked even ARC into letting us compile successfully. Warning or no warning, we are now ready to run a program that sends the <code class="literal">rockTheCasbah</code> message to an NSString, and damn the consequences. What might those consequences be? Quite simply, if you send a message to an object that can’t deal with it, your program will crash at that instant. So, for example, our attempt to send an NSString the <code class="literal">rockTheCasbah</code> message will crash our program, with a message (in the console log) of this form: “-[NSCFConstantString rockTheCasbah]: unrecognized selector sent to instance 0x3048.”</p>
          <p>The important thing here is the phrase <span class="emphasis"><em>unrecognized selector</em></span>.<a id="idm441656579840" class="indexterm"></a>
<a id="idm441656578688" class="indexterm"></a><a id="idm441656577824" class="indexterm"></a>
<a id="idm441656576576" class="indexterm"></a><a id="idm441656575712" class="indexterm"></a> The term “selector”
is roughly equivalent to “message,”
so this is a way of saying that a certain instance was sent a message it couldn’t deal with. The console message also tries to tell us <span class="emphasis"><em>what</em></span> instance this was. <code class="literal">0x3048</code> is the value of the instance pointer; it is the address in memory to which our <code class="literal">NSString*</code> variable <code class="literal">s</code> was actually pointing. (Never mind why the NSString is described as an NSCFConstantString; this has to do with NSString’s implementation behind the scenes.)</p>
          <p>(Strictly speaking, I should not say that a situation like this will “crash our program.” What it will actually do is to generate an <span class="emphasis"><em>exception</em></span>, an internal message as the program runs signifying that something bad has happened.<a id="idm441656570640" class="indexterm"></a><a id="idm441656569776" class="indexterm"></a>
<a id="idm441656568528" class="indexterm"></a><a id="idm441656567664" class="indexterm"></a>
<a id="idm441656566416" class="indexterm"></a> It is possible for Objective-C code to “catch” an exception, in which case the program will not crash. The reason the program crashes, technically, is not that a message was sent to an object that couldn’t handle it, but that the exception generated in response wasn’t caught. That’s why the crash log may also say, “Terminating app due to uncaught exception.”)</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_typecasting_and_the_id_type"></a>Typecasting and the id Type</h2>
            </div>
          </div>
        </div>
        <p>One way to silence the compiler when it warns in the way I’ve just described is by typecasting.<a id="idm441656563296" class="indexterm"></a>
<a id="idm441656562048" class="indexterm"></a> A typecast, however, is not a viable way of fixing the problem unless it also tells the truth. It is perfectly possible to lie to the compiler by typecasting; this is not nice, and is not likely to yield nice consequences.</p>
        <p>For example, suppose we’ve defined a class MyClass that does contain an instance method <code class="literal">rockTheCasbah</code>. As a result, it is fine with the compiler if you send the <code class="literal">rockTheCasbah</code> message to a MyClass, although it is not fine to send the <code class="literal">rockTheCasbah</code> message to an NSString. So you can silence the compiler by claiming that an NSString instance <span class="emphasis"><em>is</em></span> a MyClass instance:</p>
        <pre class="screen">NSString* s = @"Hello, world!";
[(MyClass*)s rockTheCasbah];</pre>
        <p>The typecast silences the compiler; there is no warning. Notice that the typecast is not a value conversion; it’s merely a claim about what the type will turn out to be at runtime. You’re saying that when the program runs, <code class="literal">s</code> will magically turn out to be a MyClass instance. Because MyClass has a <code class="literal">rockTheCasbah</code> instance method, that silences the compiler. Of course, you’ve lied to the compiler, so when the program runs it will crash anyway, in exactly the same way as before! You’re still sending an NSString a message it can’t deal with, so the very same exception about sending an unrecognized selector to an NSCFConstantString instance will result. So don’t do that!</p>
        <p>Sometimes, however, typecasting to silence the compiler is exactly what you do want to do. This situation quite often arises in connection with class inheritance.<a id="idm441656554032" class="indexterm"></a>
<a id="idm441656552880" class="indexterm"></a><a id="idm441656552016" class="indexterm"></a> We haven’t discussed class inheritance yet, but I’ll give an example anyway. Let’s take the built-in Cocoa class UINavigationController. Its <code class="literal">topViewController</code> method is declared to return a UIViewController instance. In real life, though, it is likely to return an instance of some class you’ve created. So in order to call a method of the class you’ve created on the instance returned by <code class="literal">topViewController</code> without upsetting the compiler, you have to reassure the compiler that this instance really will be an instance of the class you’ve created. That’s what I’m doing in this line from one of my own apps:</p>
        <pre class="screen">[(RootViewController*)[navigationController topViewController] setAlbums: arr];</pre>
        <p>The expression <code class="literal">(RootViewController*)</code> is a typecast in which I’m assuring the compiler that at this moment in the program, the value returned by the <code class="literal">topViewController</code> method call will in fact be an instance of RootViewController, which is my own defined class. The typecast silences the compiler when I send this instance the <code class="literal">setAlbums:</code> message, because my RootViewController class has a <code class="literal">setAlbums:</code> instance method and the compiler knows this. And the program doesn’t crash, because I’m not lying: this <code class="literal">topViewController</code> method call really <span class="emphasis"><em>will</em></span> return a RootViewController instance.</p>
        <p>Objective-C also provides a special type designed to silence the compiler’s worries about object data types altogether. This is the <code class="literal">id</code> type.<a id="idm441656542512" class="indexterm"></a> An <code class="literal">id</code> is a pointer, so you don’t say <code class="literal">id*</code>. It is defined to mean “an object pointer,” plain and simple, with no further specification. Thus, every instance reference is also an <code class="literal">id</code>.</p>
        <p>Use of the <code class="literal">id</code> type causes the compiler to stop worrying about the relationship between object types and messages. The compiler can’t know anything about what the object will really be, so it throws up its hands and doesn’t warn about anything. Moreover, any object value can be assigned or typecast to an <code class="literal">id</code>, and a value typed as an <code class="literal">id</code> can be assigned where any object type is expected. The notion of assignment includes parameter passing. So you can pass a value typed as an <code class="literal">id</code> as an argument where a parameter of some particular object type is expected, and you can pass any object as an argument where a parameter of type <code class="literal">id</code> is expected. (I like to think of an <code class="literal">id</code> as analogous to both type AB blood and type O blood: it is both a universal recipient and a universal donor.) So, for example:</p>
        <pre class="screen">NSString* s = @"Hello, world!";
id unknown = s;
[unknown rockTheCasbah];</pre>
        <p>The second line is legal, because any object value can be assigned to an <code class="literal">id</code>. The third line doesn’t generate any compiler warning, because any message can be sent to an <code class="literal">id</code>. (Of course the program will <span class="emphasis"><em>still</em></span> crash when it actually runs and <code class="literal">unknown</code> turns out to be an NSString — which is incapable of receiving of the <code class="literal">rockTheCasbah</code> message!)</p>
        <p>That trick works even under ARC, with one caveat. ARC is willing to let that code compile — but only if a matching <code class="literal">rockTheCasbah</code> method is defined <span class="emphasis"><em>somewhere</em></span> in your code (even if it isn’t an NSString method).<a id="idm441656528080" class="indexterm"></a>
<a id="idm441656526832" class="indexterm"></a><a id="idm441656525968" class="indexterm"></a>
<a id="idm441656524720" class="indexterm"></a> If there’s no such method, ARC will stop you with a different error: “No known instance method for selector ‘rockTheCasbah’.” This is another way of saying the same thing the non-ARC compiler said earlier: “I know of no instance method <code class="literal">rockTheCasbah</code>, so I can’t check its signature against the return type and arguments you’re actually using.” But instead of implicitly adding, “So I’ll just make some loose assumptions and let it pass,” ARC is stricter. After all, even without knowing what class <code class="literal">unknown</code> will turn out to be when the program runs, ARC can be pretty sure that that class won’t have a <code class="literal">rockTheCasbah</code> method, because <span class="emphasis"><em>no</em></span> known class has a <code class="literal">rockTheCasbah</code> method. So ARC, like a good guardian, continues to bar the way.</p>
        <p>If, however, a matching <code class="literal">rockTheCasbah</code> method <span class="emphasis"><em>is</em></span> defined somewhere in your code, even though it isn’t an NSString method, ARC now takes its hands off the tiller entirely, and permits the program to compile and run without warning. You are now sending a message to an <code class="literal">id</code>, and an <code class="literal">id</code> can legally receive any message. If you crash at runtime, that’s your problem; ARC can’t save you from yourself.</p>
        <p>If an <code class="literal">id</code>’s ability to receive any message reminds you of nil, it should. I have already said that nil is a form of zero; I can now specify what form of zero it is. It’s zero cast as an <code class="literal">id</code>. Of course, it still makes a difference at runtime whether an <code class="literal">id</code> is nil or something else; sending a message to nil won’t crash the program, but sending an unknown message to an actual object will.</p>
        <p>Thus, <code class="literal">id</code> is a device for turning off the compiler’s type checking altogether. Concerns about what type an object is are postponed until the program is actually running. All the compiler can do is intelligently analyze your code to see if you might be making a mistake that could matter at runtime. Using <code class="literal">id</code> turns off this part of the compiler’s intelligence and leaves you to your own devices.</p>
        <p>I do not recommend that you make extensive use of <code class="literal">id</code> to live in a world of pure dynamism. The compiler is your friend; you should let it use what intelligence it has to catch mistakes in your code. Thus, I almost never declare a variable or parameter as an <code class="literal">id</code>. I want my object types to be specific, so that the compiler can help check my code.</p>
        <p>On the other hand, the Cocoa API does make frequent use of <code class="literal">id</code>, because it has to. For example, consider the NSArray class, which is the object-based version of an array. In pure C, you have to declare what type of thing lives in an array; for example, you could have “an array of int.” In Objective-C, using an NSArray, you can’t do that. Every NSArray is an array of <code class="literal">id</code>, meaning that each element of the array can be of any object type. You can put a specific type of object into an NSArray because any specific type of object can be assigned to an <code class="literal">id</code> (<code class="literal">id</code> is the universal recipient). You can get any specific type of object back out of an NSArray because an <code class="literal">id</code> can be assigned to any specific type of object (<code class="literal">id</code> is the universal donor).</p>
        <p>So, for example, NSArray’s <code class="literal">lastObject</code> method is defined as returning an <code class="literal">id</code>. So, given an NSArray <code class="literal">arr</code>, I can fetch its last element like this:</p>
        <pre class="screen">id unknown = [arr lastObject];</pre>
        <p>However, after that code, <code class="literal">unknown</code> can now be sent any message at all, and we are dispensing with the compiler’s type checking. Therefore, if I happen to <span class="emphasis"><em>know</em></span> what type of object an array element is, I always assign or cast it to that type. For example, let’s say I happen to know that <code class="literal">arr</code> contains nothing but NSString instances (because I put them there in the first place). Then I will say:</p>
        <pre class="screen">NSString* s = [arr lastObject];</pre>
        <p>The compiler doesn’t complain, because an <code class="literal">id</code> can be assigned to any specific type of object (<code class="literal">id</code> is the universal donor). Moreover, from here on in, the compiler regards <code class="literal">s</code> as an NSString, and uses its type checking abilities to make sure I don’t send <code class="literal">s</code> any non-NSString messages, which is just what I wanted. And I didn’t lie to the compiler; at runtime, <code class="literal">s</code> really <span class="emphasis"><em>is</em></span> an NSString, so everything is fine.</p>
        <p>The compiler’s type checking is called <span class="emphasis"><em>static typing</em></span>, as opposed to the dynamic behavior that takes place when the program actually runs.<a id="idm441656492464" class="indexterm"></a>
<a id="idm441656491216" class="indexterm"></a> What I’m saying here, then, is that I prefer to take advantage of static typing as much as possible.</p>
        <p>The Cocoa API will sometimes return an <code class="literal">id</code> from a method call where you might not expect it. It’s good to be conscious of this, because otherwise the compiler can mislead you into thinking you’re doing something safe when you’re not. For example, consider this code:</p>
        <pre class="screen">UIColor* c = [NSString string];</pre>
        <p>This is clearly a mistake — you’re assigning an NSString to a UIColor variable, which is likely to lead to a crash later on — but the compiler is silent. Why doesn’t the compiler warn here? It’s because the NSString <code class="literal">string</code> class method is declared like this:</p>
        <pre class="screen">+ (id)string</pre>
        <p>The <code class="literal">string</code> method returns an NSString, but its return value is typed as an <code class="literal">id</code>. An <code class="literal">id</code> can be assigned where any object type is expected, so the compiler doesn’t complain when it’s assigned to a UIColor variable. This fact is a common source of programmer mistakes (especially if the programmer is me).</p>
        <p>Earlier, I said that it is illegal for the same class to define methods of the same type (class method or instance method) with the same name but different signatures. But I did not say what happens when two <span class="emphasis"><em>different</em></span> classes declare conflicting signatures for the same method name.<a id="idm441656482032" class="indexterm"></a>
<a id="idm441656480784" class="indexterm"></a><a id="idm441656479920" class="indexterm"></a>
<a id="idm441656478672" class="indexterm"></a><a id="idm441656477808" class="indexterm"></a>
<a id="idm441656476560" class="indexterm"></a><a id="idm441656475696" class="indexterm"></a>
<a id="idm441656474448" class="indexterm"></a> This is another case in which it matters whether you’re using static or dynamic typing. If you’re using static typing — that is, the type of the object receiving the message is specified — there’s no problem, because there’s no doubt which method is being called (it’s the one in that object’s class). But if you’re using dynamic typing, where the object receiving the message is an <code class="literal">id</code>, you might get a warning from the compiler; and if you’re using ARC, you’ll get a downright error: “Multiple methods named ‘rockTheCasbah’ found with mismatched result, parameter type or attributes.” This is another reason why method names are so verbose: it’s in order to make each method name unique, preventing two different classes from declaring conflicting signatures for the same method.</p>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Accidentally defining your own method with the same name as an existing Cocoa method can cause mysterious problems. For example, in a recent online query, a programmer was confused because the compiler complained that his call to <code class="literal">initWithObjects:</code> lacked a nil terminator, even though his <code class="literal">initWithObjects:</code> didn’t need a nil terminator. No, <span class="emphasis"><em>his</em></span> <code class="literal">initWithObjects:</code> didn’t, but <span class="emphasis"><em>Cocoa’s</em></span> did, and the compiler couldn’t distinguish them because this message was being sent to an <code class="literal">id</code>. He should have picked a different name.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_messages_as_data_type"></a>Messages as Data Type</h2>
            </div>
          </div>
        </div>
        <p>Objective-C is so dynamic that it doesn’t have to know until runtime what message to send to an object or what object to send it to. Certain important methods actually accept both pieces of information as parameters. For example, consider this method declaration from Cocoa’s NSNotificationCenter class:<a id="idm441656464832" class="indexterm"></a></p>
        <pre class="screen">- (void)addObserver:(id)notificationObserver
           selector:(SEL)notificationSelector
               name:(NSString *)notificationName
             object:(id)notificationSender</pre>
        <p>We’ll discuss later what this method does (when we talk about notifications in <a class="xref" href="ch11.html">Chapter 11</a>), but the important thing to understand here is that it constitutes an instruction to send a certain message to a certain object at some later, appropriate time. For example, our purpose in calling this method might be to arrange to have the message <code class="literal">tickleMeElmo:</code> sent at some later, appropriate time to the object <code class="literal">myObject</code>.</p>
        <p>So let’s consider how we might actually make this method call. The object to which the message will be sent is here called <code class="literal">notificationObserver</code>, and is typed as an <code class="literal">id</code> (making it possible to specify any type of object to send the message to). So, for the <code class="literal">notificationObserver</code> parameter, we’re going to pass <code class="literal">myObject</code>. The message itself is the <code class="literal">notificationSelector</code> parameter, which has a special data type, SEL (for “selector,” the technical term for a message name). The question now is how to express the message name <code class="literal">tickleMeElmo:</code>.<a id="idm441656455488" class="indexterm"></a></p>
        <p>You can’t just put <code class="literal">tickleMeElmo:</code> as a bare term; that doesn’t work syntactically. You might think you could express it as an NSString, <code class="literal">@"tickleMeElmo:"</code>, but surprisingly, that doesn’t work either. It turns out that the correct way to do it is like this:<a id="idm441656452544" class="indexterm"></a>
<a id="idm441656451296" class="indexterm"></a><a id="idm441656450432" class="indexterm"></a>
<a id="idm441656449184" class="indexterm"></a></p>
        <pre class="screen">@selector(tickleMeElmo:)</pre>
        <p>The term <code class="literal">@selector()</code> is a directive to the compiler, telling it that what’s in parentheses is a message name. Notice that what’s in parentheses is not an NSString; it’s the bare message name. And because it is the name, it must have no spaces and must include any colons that are part of the message name.</p>
        <p>So the rule is extremely easy: when a SEL is expected, you’ll usually pass a <code class="literal">@selector</code> expression. Failure to get this syntax right, however, is a common beginner error. Notice also that this syntax is an invitation to make a typing mistake, especially because there is no checking by the compiler. If <code class="literal">myObject</code> implements a <code class="literal">tickleMeElmo:</code> method and I accidentally type <code class="literal">@selector(tickleMeElmo)</code>, forgetting the colon or making any other mistake in specifying the message name, there is no compiler error; the problem won’t be discovered until the program runs and something bad happens. (In this case, if the <code class="literal">tickleMeElmo</code> message without the colon is ever sent to <code class="literal">myObject</code>, the app will probably crash with an unrecognized selector exception.)</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_c_functions"></a>C Functions</h2>
            </div>
          </div>
        </div>
        <p>Although your code will certainly call many Objective-C methods, it will also probably call quite a few C functions. For example, I mentioned in <a class="xref" href="ch01.html">Chapter 1</a> that the usual way of initializing a CGPoint based on its <code class="literal">x</code> and <code class="literal">y</code> values is to call CGPointMake, which is declared like this:</p>
        <pre class="screen">CGPoint CGPointMake (
   CGFloat x,
   CGFloat y
);</pre>
        <p>Make certain that you can see at a glance that this <span class="emphasis"><em>is</em></span> a C function, not an Objective-C method, and be sure you understand the difference in the calling syntax. To call an Objective-C method, you send a message to an object, in square brackets, with each argument following a colon in the method’s name; to call a C function, you use the function’s name followed by parentheses containing the arguments.</p>
        <p>You might even have reason to write your own C functions as part of a class, instead of writing a method. A C function has lower overhead than a full-fledged method; so even though it lacks the object-oriented abilities of a method, it is sometimes useful to write one, as when some utility calculation must be called rapidly and frequently. Also, once in a while you might encounter a Cocoa method or function that requires you to supply a C function as a “callback.”<a id="idm441656436112" class="indexterm"></a><a id="idm441656434208" class="indexterm"></a>
<a id="idm441656432800" class="indexterm"></a>
<a id="idm441656431552" class="indexterm"></a><a id="idm441656430688" class="indexterm"></a>
<a id="idm441656429184" class="indexterm"></a>
<a id="idm441656427936" class="indexterm"></a></p>
        <p>An example is the NSArray method <code class="literal">sortedArrayUsingFunction:context:</code>. The first parameter is typed like this:</p>
        <pre class="screen">NSInteger (*)(id, id, void *)</pre>
        <p>That expression denotes, in the rather tricky C syntax used for these things, a pointer to a function that takes three parameters and returns an NSInteger. The three parameters of the function are an <code class="literal">id</code>, an <code class="literal">id</code>, and a pointer-to-void (which means any C pointer). The bare name of a function (see <a class="xref" href="ch01.html">Chapter 1</a>) can be used as a pointer to a C function.<a id="idm441656423088" class="indexterm"></a>
<a id="idm441656421584" class="indexterm"></a>
<a id="idm441656420336" class="indexterm"></a> So to call <code class="literal">sortedArrayUsingFunction:context:</code> you’d need to write a C function that meets this description, and use its name as the first argument.</p>
        <p>To illustrate, I’ll write a “callback” function to sort an NSArray of NSStrings on the last character of each string. (This would be an odd thing to do, but it’s only an example!) The NSInteger returned by the function has a special meaning: it indicates whether the first parameter is to be considered less than, equal to, or larger than the second. I’ll obtain it by calling the NSString <code class="literal">compare:</code> method, which returns an NSInteger with that same meaning. <a class="xref" href="ch03.html#EXcallback">Example 3.1</a> defines the function and shows how we’d call <code class="literal">sortedArrayUsingFunction:context:</code> with that function as our callback (assume that <code class="literal">arr</code> is an NSArray of strings).</p>
        <div class="example">
          <a id="EXcallback"></a>
          <p class="title">Example 3.1. Using a pointer to a callback function</p>
          <div class="example-contents">
            <pre class="screen">NSInteger sortByLastCharacter(id string1, id string2, void* context) {
    NSString* s1 = (NSString*) string1;
    NSString* s2 = (NSString*) string2;
    NSString* string1end = [s1 substringFromIndex:[s1 length] - 1];
    NSString* string2end = [s2 substringFromIndex:[s2 length] - 1];
    return [string1end compare:string2end];
}

NSArray* arr2 = [arr sortedArrayUsingFunction:sortByLastCharacter context:nil];</pre>
          </div>
        </div>
        <br class="example-break" />
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_cftyperefs"></a>CFTypeRefs</h2>
            </div>
          </div>
        </div>
        <p>Many Objective-C objects have lower-level C counterparts, along with C functions for manipulating them. For example, besides the Objective-C NSString, there is also something called a CFString; the “CF” stands for “Core Foundation,” which is a lower-level C-based API. A CFString is an opaque C struct (“opaque” means that the elements constituting this struct are kept secret, and that you should operate on a CFString only by means of appropriate functions). As with an NSString or any other object, in your code you’ll typically refer to a CFString by way of a C pointer; the pointer to a CFString has a type name, CFStringRef (a “reference to a CFString,” evidently). You work with a CFString in pure C, by calling functions.<a id="idm441656411312" class="indexterm"></a><a id="idm441656410384" class="indexterm"></a><a id="idm441656409520" class="indexterm"></a></p>
        <p>You might, on occasion, actually have to work with a Core Foundation type even when a corresponding object type exists. For example, you might find that NSString, for all its power, fails to implement a needed piece of functionality, which is in fact available for a CFString. Luckily, an NSString (a value typed as <code class="literal">NSString*</code>) and a CFString (a value typed as <code class="literal">CFStringRef</code>) are interchangeable: you can use one where the other is expected, though you will have to typecast in order to quiet the worries of the compiler. The documentation describes this interchangeability by saying that NSString and CFString are “toll-free bridged” to one another.<a id="idm441656406736" class="indexterm"></a><a id="idm441656405344" class="indexterm"></a><a id="idm441656404480" class="indexterm"></a>
<a id="idm441656403232" class="indexterm"></a></p>
        <p>To illustrate, I’ll use a CFString to convert an NSString representing an integer to that integer (this use of CFString is unnecessary, and is just by way of demonstrating the syntax; NSString has an <code class="literal">intValue</code> method):</p>
        <pre class="screen">NSString *answer = @"42";
CFStringRef stringRef = (CFStringRef)answer; // non-ARC
int ans = CFStringGetIntValue(stringRef);</pre>
        <p>The typecast prevents the compiler from complaining, and works because NSString is toll-free bridged to CFString — in effect, behind the scenes, an NSString <span class="emphasis"><em>is</em></span> a CFString.</p>
        <p>Under ARC, that code won’t compile unless you supply a little more information. ARC, as we’ll see in <a class="xref" href="ch12.html">Chapter 12</a>, is about memory management; but ARC manages only Objective-C objects, not their C counterparts. So although ARC manages the memory for an NSString, it leaves memory management for a CFStringRef up to you; and in order to compile that code, it needs you to show it that you understand the memory management status of this value as it crosses the toll-free bridge. You do so like this:</p>
        <pre class="screen">NSString *answer = @"42";
CFStringRef stringRef = (__bridge CFStringRef)answer;
int ans = CFStringGetIntValue(stringRef);</pre>
        <p>The extra qualifier <code class="literal">__bridge</code> means: “Don’t worry, ARC, I know I’m crossing the toll-free bridge, and I assure you that this has no implications for memory management.” On the other hand, there are situations where crossing the toll-free bridge <span class="emphasis"><em>does</em></span> have implications for memory management, and you may rest assured that I’ll discuss them in <a class="xref" href="ch12.html">Chapter 12</a>.<a id="idm441656394480" class="indexterm"></a>
<a id="idm441656393232" class="indexterm"></a></p>
        <p>The pointer-to-struct C data types, whose name typically ends in “Ref”, may be referred to collectively as CFTypeRef, which is actually just the generic pointer-to-void.<a id="idm441656391360" class="indexterm"></a><a id="idm441656390496" class="indexterm"></a> Thus, crossing the toll-free bridge may usefully be thought of as a cast between an object pointer and a generic pointer — that is, in general terms, from <code class="literal">id</code> to <code class="literal">void*</code> or from <code class="literal">void*</code> to <code class="literal">id</code>. Even where there is no toll-free bridging between <span class="emphasis"><em>specific</em></span> types (as there is with NSString and CFString), there is always bridging at the top of the hierarchy, so to speak, between NSObject (the base object class, as explained in <a class="xref" href="ch04.html">Chapter 4</a>) and CFTypeRef.</p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>It is sometimes necessary to assign a CFTypeRef to an <code class="literal">id</code> variable or parameter. For example, a CALayer’s <code class="literal">setContents:</code> method (<a class="xref" href="ch16.html">Chapter 16</a>) expects an <code class="literal">id</code> parameter, but the actual value must be a CGImageRef.<a id="idm441656366512" class="indexterm"></a> This is legal, because a pointer is just a pointer, but the compiler will complain unless you also typecast to an <code class="literal">id</code>, along with a <code class="literal">__bridge</code> qualifier if you’re using ARC.
<a id="idm441656364176" class="indexterm"></a><a id="idm441656363312" class="indexterm"></a></p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_blocks"></a>Blocks</h2>
            </div>
          </div>
        </div>
        <p>A <span class="emphasis"><em>block</em></span> is an extension to the C language, introduced in Mac OS X 10.6 and available in iOS 4.0 or later. It’s a way of bundling up some code and handing off that entire bundle as an argument to a C function or Objective-C method. This is similar to what we did in <a class="xref" href="ch03.html#EXcallback">Example 3.1</a>, handing off a pointer to a function as an argument, but instead we’re handing off the code <span class="emphasis"><em>itself</em></span>. The latter has some major advantages over the former, which I’ll discuss in a moment.<a id="idm441656358624" class="indexterm"></a>
<a id="idm441656357472" class="indexterm"></a></p>
        <p>As an example, I’ll rewrite <a class="xref" href="ch03.html#EXcallback">Example 3.1</a> to use a block instead of a function pointer. Instead of calling <code class="literal">sortedArrayUsingFunction:context:</code>, I’ll call <code class="literal">sortedArrayUsingComparator:</code>, which takes a block as its parameter. The block is typed like this:</p>
        <pre class="screen">NSComparisonResult (^)(id obj1, id obj2)</pre>
        <p>That’s similar to the syntax for specifying the type of a pointer to a function, but a caret character is used instead of an asterisk character.<a id="idm441656353056" class="indexterm"></a>
<a id="idm441656351808" class="indexterm"></a> So this means a block that takes two <code class="literal">id</code> parameters and returns an NSComparisonResult (which is merely an NSInteger, with just the same meaning as in <a class="xref" href="ch03.html#EXcallback">Example 3.1</a>). We can define the block and hand it off as the argument to <code class="literal">sortedArrayUsingComparator:</code> all in a single move, as in <a class="xref" href="ch03.html#EXblock">Example 3.2</a>.</p>
        <div class="example">
          <a id="EXblock"></a>
          <p class="title">Example 3.2. Using a block instead of a callback function</p>
          <div class="example-contents">
            <pre class="screen">NSArray* arr2 = [arr sortedArrayUsingComparator: ^(id obj1, id obj2) {
    NSString* s1 = (NSString*) obj1;
    NSString* s2 = (NSString*) obj2;
    NSString* string1end = [s1 substringFromIndex:[s1 length] - 1];
    NSString* string2end = [s2 substringFromIndex:[s2 length] - 1];
    return [string1end compare:string2end];
}];</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>The syntax of the inline block definition is:</p>
        <pre class="screen">^<a id="CO2-1"></a>❶(id obj1, id obj2)<a id="CO2-2"></a>❷ {<a id="CO2-3"></a>❸</pre>
        <div class="calloutlist">
          <table border="0" summary="Callout list">
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO2-1">❶</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
First, the caret character.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO2-2">❷</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
Then, parentheses containing the parameters.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO2-3">❸</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
Finally, curly braces containing the block’s content.
</p>
              </td>
            </tr>
          </table>
        </div>
        <p>Thanks to the block, as you can see, we’ve combined the definition of the callback function with its use. You might object that this means the callback isn’t reusable; if we had <span class="emphasis"><em>two</em></span> calls to <code class="literal">sortedArrayUsingComparator:</code> using the same callback, we’d have to write out the callback in full twice. To avoid such repetition, or simply for clarity, a block can be assigned to a variable:</p>
        <pre class="screen">NSComparisonResult (^sortByLastCharacter)(id, id) = ^(id obj1, id obj2) {
    NSString* s1 = (NSString*) obj1;
    NSString* s2 = (NSString*) obj2;
    NSString* string1end = [s1 substringFromIndex:[s1 length] - 1];
    NSString* string2end = [s2 substringFromIndex:[s2 length] - 1];
    return [string1end compare:string2end];
};
NSArray* arr2 = [arr sortedArrayUsingComparator: sortByLastCharacter];
NSArray* arr4 = [arr3 sortedArrayUsingComparator: sortByLastCharacter];</pre>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>The return type in an inline block definition is usually omitted. If included, it <span class="emphasis"><em>follows</em></span> the caret character, <span class="emphasis"><em>not</em></span> in parentheses. If omitted, you may have to use typecasting in the <code class="literal">return</code> line to make the returned type match the expected type.<a id="idm441656334640" class="indexterm"></a> For a complete technical syntax specification for blocks, see <a class="ulink" href="http://clang.llvm.org/docs/BlockLanguageSpec.html" target="_top">http://clang.llvm.org/docs/BlockLanguageSpec.html</a>.</p>
        </div>
        <p>The power of blocks really starts to emerge when they are used instead of a selector name. In an example earlier in this chapter, we talked about how you could pass <code class="literal">@selector(tickleMeElmo:)</code> as the second argument to <code class="literal">add⁠Observer:⁠selector:​name:object:</code> as a way of saying, “When the time comes, please call my <code class="literal">tickleMeElmo:</code> method.” We also talked about how error-prone this syntax was: make a typing error, and your <code class="literal">tickleMeElmo:</code> method mysteriously won’t be called. Moreover, such code is hard to maintain; there’s the <code class="literal">tickleMeElmo:</code> method sitting there, completely separate from the code that calls <code class="literal">addObserver:selector:name:object:</code>, yet existing only to specify what should happen at the later time when our message arrives. It might well be clearer and more compact to call <code class="literal">addObserverForName:object:queue:usingBlock:</code> and specify there and then as a block what should happen at message time, with no separate method callback. (I’ll talk about this again, along with an example, in <a class="xref" href="ch11.html">Chapter 11</a>.)</p>
        <p>Perhaps the most remarkable feature of blocks is this: variables in scope at the point where a block is defined keep their value within the block at that moment, even though the block may be executed at some later moment. (Technically, we say that a block is a <span class="emphasis"><em>closure</em></span>.) It is this aspect of blocks that makes them useful for specifying functionality to be executed at some later time, or even, as we’ll see in <a class="xref" href="ch38.html">Chapter 38</a>, in some other thread.<a id="idm441656324736" class="indexterm"></a></p>
        <p>Here’s an example that will appear in <a class="xref" href="ch17.html">Chapter 17</a>. It will make perfect sense to you in its proper context, so I won’t explain it fully now; but the point is that <span class="emphasis"><em>outside</em></span> any blocks we have a UIView object <code class="literal">v</code> in scope, along with a CGPoint <code class="literal">p</code> and another CGPoint <code class="literal">pOrig</code>, and we can use the two CGPoint values to mutate <code class="literal">v</code> <span class="emphasis"><em>inside</em></span> two blocks (called <code class="literal">anim</code> and <code class="literal">after</code>), even though these blocks won’t be executed until some indeterminate moment in the future, at the start and end of an animation:</p>
        <pre class="screen">CGPoint p = v.center;
CGPoint pOrig = p;
p.x += 100;
void (^anim) (void) = ^{
    v.center = p;
};
void (^after) (BOOL) = ^(BOOL f) {
    v.center = pOrig;
};
NSUInteger opts = UIViewAnimationOptionAutoreverse;
[UIView animateWithDuration:1 delay:0 options:opts
                 animations:anim completion:after];</pre>
        <p>If a variable outside a block is in scope within the block, and if that variable is an object reference,
messages can be sent to it and the object may be mutated, as we did with the UIView object <code class="literal">v</code> in that example. But if we try, inside a block, to assign <span class="emphasis"><em>directly</em></span> to a variable outside the block, we can’t do it; the variable is protected, and the compiler will stop us (“variable is not assignable”):<a id="idm441656314416" class="indexterm"></a>
<a id="idm441656313264" class="indexterm"></a><a id="idm441656312496" class="indexterm"></a></p>
        <pre class="screen">CGPoint p;
void (^aBlock) (void) = ^{
    p = CGPointMake(1,2); // error
};</pre>
        <p>On rare occasions, you may need to turn off this protection; you can do so by declaring the variable using the <code class="literal">__block</code> qualifier. Here’s an example that will appear in <a class="xref" href="ch35.html">Chapter 35</a>. We cycle through an array until we find the value we want; when we find it, we set a variable (<code class="literal">dir</code>) to that value. That variable is declared outside the block, because we intend to use its value after executing the block; therefore we qualify the variable’s declaration with <code class="literal">__block</code>, so that we can assign to it from inside the block:</p>
        <pre class="screen">CGFloat h = newHeading.magneticHeading;
__block NSString* dir = @"N";
NSArray* cards = @[@"N", @"NE", @"E", @"SE",
                  @"S", @"SW", @"W", @"NW"];
[cards enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    if (h &lt; 45.0/2.0 + 45*idx) {
        dir = obj;
        *stop = YES;
    }
}];
// now we can use dir</pre>
        <p>(Note also the assignment to a dereferenced pointer-to-BOOL. When the method to which we are submitting a block is going to call the block repeatedly as the equivalent of a for loop, we can’t abort the loop with a <code class="literal">break</code> statement, because this isn’t a <span class="emphasis"><em>real</em></span> for loop. So the method will commonly specify that our block should take a pointer-to-BOOL parameter; the idea is that we can set this BOOL by indirection to YES, and the method will notice this as it prepares to call the block for the next iteration, and will stop instead. This is one of the few common situations in iOS programming where it is necessary to dereference a pointer.)<a id="idm441656304608" class="indexterm"></a>
<a id="idm441656302240" class="indexterm"></a>
<a id="idm441656300992" class="indexterm"></a></p>
        <p>Another use of the <code class="literal">__block</code> qualifier is to allow a block to capture the value of a variable that is set by the very same method call that takes the block as an argument. Here’s an example that will appear in <a class="xref" href="ch38.html">Chapter 38</a>:</p>
        <pre class="screen">__block UIBackgroundTaskIdentifier bti =
    [[UIApplication sharedApplication]
        beginBackgroundTaskWithExpirationHandler: ^{
            [[UIApplication sharedApplication] endBackgroundTask:bti];
        }];</pre>
        <p>The method <code class="literal">beginBackgroundTaskWithExpirationHandler:</code> takes a block and returns a <code class="literal">UIBackgroundTaskIdentifier</code>, which is really just an integer. We want to use that integer inside the block, which will actually be executed at some later time (if ever). If we don’t declare the integer variable with the <code class="literal">__block</code> qualifier, the block will capture the variable’s value <span class="emphasis"><em>at the time the block is defined</em></span>, which is <span class="emphasis"><em>before</em></span> the <code class="literal">beginBackgroundTaskWithExpirationHandler:</code> method call is actually executed. After the method call is executed, the variable is set to its true value, the value we want to use inside the block; because we declared the variable with <code class="literal">__block</code>, the block has access to that true value.</p>
        <p>Note that this trick works only because the block is being stored (by the receiver of the <code class="literal">beginBackgroundTaskWithExpirationHandler:</code> message) for later execution. If the block were to be executed right now, before returning from the <code class="literal">beginBackgroundTaskWithExpirationHandler:</code> call, the result of that call would not yet have been set.</p>
        <p>At the same time that blocks were introduced into Objective-C, Apple introduced a system library of C functions called Grand Central Dispatch (GCD) that makes heavy use of them.<a id="idm441656290016" class="indexterm"></a><a id="idm441656289152" class="indexterm"></a> GCD’s most important use is for threading (<a class="xref" href="ch38.html">Chapter 38</a>), but it also comes in handy for expressing neatly and compactly certain notions about when code should be executed. For example, GCD can help us delay execution of our code (<span class="emphasis"><em>delayed performance</em></span>).<a id="idm441656286992" class="indexterm"></a> The following code (from <a class="xref" href="ch14.html">Chapter 14</a>) means, “change the bounds of <code class="literal">v1</code>, but not right this moment — wait two seconds and then do it”:</p>
        <pre class="screen">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    CGRect f = v1.bounds;
    f.size.width += 40;
    f.size.height -= 50;
    v1.bounds = f;
});</pre>
        <p>This next example rewrites the code from the end of <a class="xref" href="ch01.html">Chapter 1</a>, where a class method vends a <a id="idm441656282864" class="indexterm"></a>singleton object. GCD promises that the block creating the singleton object to begin with will execute only once in the entire life of our program, thus guaranteeing that the singleton <span class="emphasis"><em>is</em></span> a singleton:</p>
        <pre class="screen">+ (CardPainter*) sharedPainter {
    static CardPainter* sp = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sp = [CardPainter new];
    });
    return sp;
}</pre>
        <p>Why is calling <code class="literal">dispatch_once</code> better, as a way of making sure we generate the singleton instance only once, than testing <code class="literal">sp</code> against nil, as in <a class="xref" href="ch01.html">Chapter 1</a>? Aside from being thread-safe, it isn’t; it’s just an example of GCD’s elegant use of a block.</p>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="ch02.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Chapter 2. Object-Based Programming </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 4. Objective-C Classes</td>
        </tr>
      </table>
    </div>
  </body>
</html>
