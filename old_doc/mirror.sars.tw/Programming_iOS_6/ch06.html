<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 6. Anatomy of an Xcode Project</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt02.html" />
    <link rel="prev" href="pt02.html" />
    <link rel="next" href="ch07.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt02.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Part II. IDE </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 7. Nib Management</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id6"></a>Chapter 6. Anatomy of an Xcode Project</h2>
          </div>
        </div>
      </div>
      <p>Xcode is the application used to develop an iOS app. An Xcode <span class="emphasis"><em>project</em></span> is the source for an app; it’s the entire collection of files and settings needed to construct the app.<a id="idm441655673264" class="indexterm"></a> To create, develop, and maintain an app, you must know how to manipulate and navigate an Xcode project. So you must know something about Xcode, and you must know something about the nature and structure of Xcode projects and how Xcode shows them to you. That’s the subject of this chapter.
<a id="idxxcode" class="indexterm"></a></p>
      <div class="note" style="margin-left: 0; margin-right: 10%;">
        <h3 class="title">Note</h3>
        <p>The term “Xcode” is actually used in two ways. It’s the name for the entire suite of developer tools — the Xcode tools — and it’s the name of one application within that suite, the application in which you edit and build your app. This ambiguity should generally present little difficulty.</p>
      </div>
      <p>Xcode is a powerful, complex, and extremely large program. My approach in introducing Xcode is to suggest that you adopt a kind of deliberate tunnel vision: if you don’t understand something, don’t worry about it — don’t even look at it, and don’t touch it, because you might change something important. Our survey of Xcode will chart a safe, restricted, and essential path, focusing on aspects of Xcode that you most need to understand immediately, and resolutely ignoring everything else.</p>
      <p>For full information, study Apple’s own documentation (choose Help → Xcode Help); it may seem overwhelming at first, but what you need to know is probably in there somewhere. There are also entire books devoted to describing and explaining Xcode.</p>
      <div class="note" style="margin-left: 0; margin-right: 10%;">
        <h3 class="title">Note</h3>
        <p>The structure of the Xcode installation changed starting with Xcode 4.3. The Developer folder in Xcode 4.2 and before was a top-level install folder. In Xcode 4.3 and later, the Developer folder is inside the Xcode application bundle itself, <span class="emphasis"><em>Xcode.app/Contents/Developer</em></span>. When I say <span class="keep-together"><span class="emphasis"><em>/Developer</em></span></span>, this is the folder I’m referring to.<a id="idm441655665936" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_new_project"></a>New Project</h2>
            </div>
          </div>
        </div>
        <p>Even before you’ve written any code, an Xcode project is quite elaborate. To see this, let’s make a new, essentially “empty” project; you’ll see instantly that it isn’t empty at all.<a id="idm441655663600" class="indexterm"></a>
<a id="idm441655662608" class="indexterm"></a></p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
Start up Xcode and choose File → New → Project.
</li>
            <li class="listitem">
              <p class="simpara">
The “Choose a template” dialog appears. The template is your project’s initial set of files and settings. When you pick a template, you’re really picking an existing <span class="keep-together">folder full</span> of files; basically, it will be one of the folders inside <span class="emphasis"><em>/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project Templates/Application</em></span>. This template folder will essentially be copied, and a few values will be filled in, in order to create your project.<a id="idm441655657792" class="indexterm"></a>
<a id="idm441655656544" class="indexterm"></a>
</p>
              <p class="simpara">So, in this case, on the left, under iOS (not Mac OS X!), choose Application. On the right, select Single View Application. Click Next.</p>
            </li>
            <li class="listitem">
              <p class="simpara">
You are now asked to provide a name for your project (Product Name).<a id="idm441655654256" class="indexterm"></a> Let’s call our new project <span class="emphasis"><em>Empty Window</em></span>.
</p>
              <p class="simpara">In a real project, you should give some thought to the project’s name, as you’re going to be living in close quarters with it. As Xcode copies the template folder, it’s going to use the project’s name to “fill in the blank” in several places, including some filenames and some settings, such as the name of the app. Thus, whatever you type at this moment is something you’ll be seeing in a lot of places throughout your project. I’ll talk at the end of this chapter about how to change an existing project’s name.</p>
              <p class="simpara">It’s fine to use spaces in a project name. Spaces are legal in the folder name, the project name, the app name, and the various names of files that Xcode will generate automatically; and in the few places where spaces are problematic (such as the bundle identifier, discussed in the next paragraph), the name you type as the Product Name will have its spaces converted to hyphens.</p>
            </li>
            <li class="listitem">
Note the Company Identifier field.<a id="idm441655649328" class="indexterm"></a><a id="idm441655648464" class="indexterm"></a> The first time you create a project, this field will be blank, and you should fill it in. The goal here is to create a unique string (unique to you personally); your app’s bundle identifier, which is shown in gray below the company identifier, will consist of the company identifier plus a version of the project’s name, and because every project should have a unique name, the bundle identifier will also be unique and will thus uniquely identify this project along with the app that it produces and everything else connected with it. The convention is to start the company identifier with <code class="literal">com.</code> and to follow it with a string (possibly with multiple dot-components) that no one else is likely to use. For example, I use <code class="literal">com.neuburg.matt</code>.
</li>
            <li class="listitem">
Make sure the Devices pop-up menu is set to iPhone. Make sure that Use Automatic Reference Counting is checked but that the other two checkboxes are unchecked. (Ignore the Class Prefix field for now; it should be empty, with its default value “XYZ” shown in gray.) Click Next.
</li>
            <li class="listitem">
              <p class="simpara">
You’ve now told Xcode how to construct your project. Basically, it’s going to copy the <span class="emphasis"><em>Single View Application.xctemplate</em></span> folder from within the <span class="emphasis"><em>Project Templates/Application</em></span> folder I mentioned earlier. But you need to tell it where to copy this template folder to. That’s why Xcode is now presenting a Save dialog. You are to specify the location of a folder that is about to be created — a folder that will be the <span class="emphasis"><em>project folder</em></span> for this project.
</p>
              <p class="simpara">The project folder can go just about anywhere, and you can move it after creating it. I usually create new projects on the Desktop.</p>
            </li>
            <li class="listitem">
Xcode also offers to create a git repository for your project. In real life, this can be a great convenience (see <a class="xref" href="ch09.html">Chapter 9</a>), but for now, uncheck that checkbox. Click Create.
</li>
            <li class="listitem">
The <span class="emphasis"><em>Empty Window</em></span> project folder is created on disk (on the Desktop, if that’s the location you just specified), and the project window for the Empty Window project opens in Xcode.
</li>
          </ol>
        </div>
        <p>The project we’ve just created is a working project; it really does build an iOS app called Empty Window. To see this, make sure that the Scheme pop-up menu in the project window’s toolbar reads Empty Window → iPhone 6.0 Simulator (though the exact system version number might be different), and choose Product → Run. After some delay, the iOS Simulator application eventually opens and displays your app running — an empty gray screen.</p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>To <span class="emphasis"><em>build</em></span> a project is to compile its code and assemble the compiled code, together with various resources, into the actual app.<a id="idm441655635680" class="indexterm"></a><a id="idm441655634816" class="indexterm"></a> Typically, if you want to know whether your code compiles and your project is consistently and correctly constructed, you’ll build the project (Product → Build). To <span class="emphasis"><em>run</em></span> a project is to launch the built app, in the Simulator or on a connected device; if you want to know whether your code works as expected, you’ll run the project (Product → Run), which automatically builds first if necessary.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_project_window"></a>The Project Window</h2>
            </div>
          </div>
        </div>
        <p>An Xcode project embodies a lot of information about what files constitute the project and how they are to be used when building the app, such as:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
The source files (your code) that are to be compiled
</li>
            <li class="listitem">
Any resources, such as icons, images, or sound files, as well as nib and storyboard files, that are to be part of the app
</li>
            <li class="listitem">
Any frameworks to which the code must be linked as the app is built
</li>
            <li class="listitem">
All settings (instructions to the compiler, to the linker, and so on) that are to be obeyed as the app is built
</li>
          </ul>
        </div>
        <p>Xcode presents this information in graphical form, and this is one reason why a project window is so elaborate, and why learning to navigate and understand it takes time. Also, this single window must let you access, edit, and navigate your code, as well as reporting the progress and results of such procedures as building or debugging an app. In short, the single project window displays a lot of information and embodies a lot of functionality. You won’t lose your way, however, if you just take a moment to explore this window and see how it is constructed.<a id="idm441655626736" class="indexterm"></a>
<a id="idm441655624448" class="indexterm"></a></p>
        <p><a class="xref" href="ch06.html#FIGprojectWindowLoaded">Figure 6.1</a> shows the project window, configured in rather an extreme manner, so as to display as many parts of the window as possible. In real life, you’d probably never show all these parts of the window at the same time, except very briefly, unless you had a really big monitor.</p>
        <div class="figure">
          <a id="FIGprojectWindowLoaded"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0601.png" alt="figs/pios_0601.png" />
            </div>
          </div>
          <p class="title">Figure 6.1. The project window, on steroids</p>
        </div>
        <br class="figure-break" />
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
On the left is the Navigator pane. Show and hide it with View → Navigators → Show/Hide Navigator (Command-0) or with the first button in the View segmented control in the toolbar.
</li>
            <li class="listitem">
In the middle is the Editor pane (or simply “editor”). This is the main area of a project window. A project window nearly always displays at least one Editor pane. I could have made this window display multiple Editor panes, but I was afraid that might make you run screaming from the room.
</li>
            <li class="listitem">
On the right is the Utilities pane. Show and hide it with View → Utilities → Show/Hide Utilities (Command-Option-0) or with the third button in the View segmented control in the toolbar.
</li>
            <li class="listitem">
At the bottom is the Debugger pane. Show and hide it with View → Show/Hide Debug Area (Shift-Command-Y) or with the second button in the View segmented control in the toolbar.
</li>
          </ol>
        </div>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>All Xcode keyboard shortcuts can be customized; see the Key Bindings pane of the Preferences window. Keyboard shortcuts that I cite are the defaults.<a id="idm441655612528" class="indexterm"></a>
<a id="idm441655611376" class="indexterm"></a></p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_the_navigator_pane"></a>The Navigator Pane</h3>
              </div>
            </div>
          </div>
          <p>The Navigator pane is the column of information at the left of the window. Among other things, it’s your primary mechanism for controlling what you see in the main area of the project window. An important general use pattern for Xcode is: you select something in the Navigator pane, and that thing is displayed in the main area (the editor) of the project window.</p>
          <p>It is possible to toggle the visibility of the Navigator pane (View → Navigators → Hide/Show Navigator, or Command-0); for example, once you’ve used the Navigator pane to reach the item you want to see or work on in the editor, you might hide the Navigator pane temporarily to maximize your screen real estate (especially on a smaller monitor). You can change the Navigator pane’s width by dragging the vertical line at its right edge.<a id="idm441655609392" class="indexterm"></a>
<a id="idm441655605616" class="indexterm"></a></p>
          <p>The Navigator pane itself can display seven different sets of information; thus, there are actually seven navigators. These are represented by the seven icons across its top; to switch among them, use these icons or their keyboard shortcuts (Command-1, Command-2, and so on). You will quickly become adept at switching to the navigator you want; their keyboard shortcuts will become second nature. If the Navigator pane is hidden, pressing a navigator’s keyboard shortcut both shows the Navigator pane and switches to that navigator.</p>
          <p>Depending on your settings in the Behaviors pane of Xcode’s preferences, a navigator might show itself automatically when you perform a certain action. For example, by default, when you build your project, if warning messages or error messages are generated, the Issue navigator will appear. This automatic behavior will not prove troublesome, because it is generally precisely the behavior you want, and if it isn’t, you can change it; plus you can easily switch to a different navigator at any time.</p>
          <p>Let’s begin experimenting immediately with the various navigators:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Project navigator (Command-1)
</span>
              </dt>
              <dd>
                <p class="simpara">
Click here for basic navigation through the files that constitute your project. For example, in the Empty Window folder (these folder-like things in the Project navigator are actually called <span class="emphasis"><em>groups</em></span>), click <span class="emphasis"><em>AppDelegate.m</em></span> to view its code in the editor (<a class="xref" href="ch06.html#FIGprojectNavigator">Figure 6.2</a>).<a id="idm441655598720" class="indexterm"></a>
<a id="idm441655596896" class="indexterm"></a>
<a id="idm441655595648" class="indexterm"></a><a id="idm441655594784" class="indexterm"></a>
<a id="idm441655593536" class="indexterm"></a>
</p>
                <p class="simpara">At the top level of the Project navigator, with a blue Xcode icon, is the Empty Window project itself; click it to view the settings associated with your project and its targets. Don’t change anything here without knowing what you’re doing! I’ll talk later in this chapter about what these settings are for.</p>
                <p class="simpara">The filter bar at the bottom of the Project navigator lets you limit what files are shown; when there are many files, this is great for quickly reaching a file with a known name. For example, try typing “delegate” in the filter bar search field. Don’t forget to remove your filter when you’re done experimenting.</p>
              </dd>
            </dl>
          </div>
          <div class="warning" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Warning</h3>
            <p>Once you’ve filtered a navigator, it stays filtered until you remove the filter — even if you close the project! A common mistake is to filter a navigator, forget that you’ve done so, fail to notice the filter (because you’re looking at the navigator itself, not down at the bottom where the filter bar is), and wonder, “Hey, where did all my files go?”</p>
          </div>
          <div class="figure">
            <a id="FIGprojectNavigator"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0602.png" alt="figs/pios_0602.png" />
              </div>
            </div>
            <p class="title">Figure 6.2. The Project navigator</p>
          </div>
          <br class="figure-break" />
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Symbol navigator (Command-2)
</span>
              </dt>
              <dd>
                <p class="simpara">
A <span class="emphasis"><em>symbol</em></span> is a name, typically the name of a class or method. Depending on which of the three icons in the filter bar at the bottom of the Symbol navigator you highlight, you can view Cocoa’s built-in symbols or the symbols defined in your project. The former can be a useful form of documentation; the latter can be helpful for navigating your code. For example, highlight the first two icons in the filter bar (the first two are dark-colored, the third is light), and see how quickly you can reach the definition of AppDelegate’s <code class="literal">applicationDidBecomeActive:</code> method.<a id="idm441655583936" class="indexterm"></a>
<a id="idm441655582432" class="indexterm"></a>
<a id="idm441655581184" class="indexterm"></a>
</p>
                <p class="simpara">Try highlighting the filter bar icons in various ways to see how the contents of the Symbol navigator change. Type in the search field in the filter bar to limit what appears in the Symbol navigator; for example, try typing “active” in the search field, and see what happens.</p>
              </dd>
              <dt>
                <span class="term">
Search navigator (Command-3)
</span>
              </dt>
              <dd>
                <p class="simpara">
This is a powerful search facility for finding text globally in your project, and even in the headers of Cocoa frameworks. You can also summon the Search navigator with Edit → Find → Find in Workspace (Shift-Command-F). To access the full set of options, click the magnifying glass and choose Show Find Options. For example, try searching for “delegate” (<a class="xref" href="ch06.html#FIGsearchNavigator">Figure 6.3</a>). Click a search result to jump to it in your code.<a id="idm441655576544" class="indexterm"></a>
<a id="idm441655575136" class="indexterm"></a>
<a id="idm441655573888" class="indexterm"></a>
</p>
                <p class="simpara">You can type in the other search field, the one in the filter bar at the bottom, to limit further which search results are displayed. (I’m going to stop calling your attention to the filter bar now, but every navigator has it in some form.)</p>
              </dd>
            </dl>
          </div>
          <div class="figure">
            <a id="FIGsearchNavigator"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0603.png" alt="figs/pios_0603.png" />
              </div>
            </div>
            <p class="title">Figure 6.3. The Search navigator</p>
          </div>
          <br class="figure-break" />
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Issue navigator (Command-4)
</span>
              </dt>
              <dd>
                <p class="simpara">
You’ll need this navigator primarily when your code has issues. This doesn’t refer to emotional instability; it’s Xcode’s term for warning and error messages emitted when you build your project.<a id="idm441655566736" class="indexterm"></a>
<a id="idm441655565232" class="indexterm"></a>
<a id="idm441655563984" class="indexterm"></a>
</p>
                <p class="simpara">To see the Issue navigator in action, you’ll need to give your code an issue. For example, navigate (as you already know how to do, in at least three different ways) to the file <span class="emphasis"><em>AppDelegate.m</em></span>, and in the blank line after the last comment at the top of the file’s contents, above the <code class="literal">#import</code> line, type <code class="literal">howdy</code>. Build (Command-B), saving if you’re prompted to. The Issue navigator will display numerous error messages, showing that the compiler is totally unable to cope with this illegal word appearing in an illegal place. Click an issue to see it within its file. In your code, issue “balloons” may appear to the right of lines containing issues; if you’re distracted or hampered by these, toggle their visibility with Editor → Issues → Hide/Show All Issues (Control-Command-M).</p>
                <p class="simpara">Now that you’ve made Xcode miserable, select “howdy” and delete it; build again, and your issues will be gone. If only real life were this easy!</p>
              </dd>
              <dt>
                <span class="term">
Debug navigator (Command-5)
</span>
              </dt>
              <dd>
                <p class="simpara">
By default, this navigator will appear when your code is paused while you’re debugging it. There is not a strong distinction in Xcode between running and debugging; the milieu is the same. The difference is mostly a matter of whether breakpoints are obeyed (more about that, and about debugging in general, in <a class="xref" href="ch09.html">Chapter 9</a>). If your code runs and doesn’t pause, the Debug navigator by default won’t come into play.<a id="idm441655555984" class="indexterm"></a>
<a id="idm441655554480" class="indexterm"></a>
<a id="idm441655553232" class="indexterm"></a>
</p>
                <p class="simpara">To see the Debug navigator in action, you’ll need to give your code a breakpoint. Navigate once more to the file <span class="emphasis"><em>AppDelegate.m</em></span>, select in the line that says <code class="literal">return YES</code>, and choose Product → Debug → Add Breakpoint at Current Line to make a blue breakpoint arrow appear on that line. Run the project. (If the project is already running, the Stop dialog may appear; click Stop to terminate the current run and begin a new one.) By default, as the breakpoint is encountered, the Navigator pane switches to the Debug navigator, and the Debug pane appears at the bottom of the window.</p>
                <p class="simpara">This overall layout (<a class="xref" href="ch06.html#FIGdebugLayout">Figure 6.4</a>) will rapidly become familiar as you debug your projects. The Debug navigator displays the call stack, with the names of the nested methods in which the pause occurs; as you would expect, you can click on a method name to navigate to it. You can shorten or lengthen the list with the slider at the bottom of the navigator. The Debug pane, which can be shown or hidden at will (View → Debug Area → Hide/Show Debug Area, or Shift-Command-Y), consists of two subpanes — the variables list and the console. Either of these can be hidden using the segmented control at the top right of the pane.<a id="idm441655548896" class="indexterm"></a>
<a id="idm441655546832" class="indexterm"></a> The console can also be summoned by choosing View → Debug Area → Activate Console.</p>
                <div class="itemizedlist">
                  <ul class="itemizedlist" type="disc">
                    <li class="listitem">
On the left, the variables list is populated with the variables in scope for the selected method in the call stack (and you can optionally display processor registers as well).<a id="idm441655544640" class="indexterm"></a>
<a id="idm441655543392" class="indexterm"></a>
</li>
                    <li class="listitem">
On the right is the console, where the debugger displays text messages; that’s how you learn of exceptions thrown by your running app. Exceptions are extremely important to know about, and this is your only way to know about them, so keep an eye on the console as your app runs.<a id="idm441655540720" class="indexterm"></a>
<a id="idm441655539472" class="indexterm"></a> You can also use the console to communicate via text with the debugger. This can often be a better way to explore variable values during a pause than the variables list.
</li>
                  </ul>
                </div>
              </dd>
            </dl>
          </div>
          <div class="figure">
            <a id="FIGdebugLayout"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0604.png" alt="figs/pios_0604.png" />
              </div>
            </div>
            <p class="title">Figure 6.4. The Debug layout</p>
          </div>
          <br class="figure-break" />
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Breakpoint navigator (Command-6)
</span>
              </dt>
              <dd>
This navigator lists all your breakpoints. At the moment you’ve only one, but when you’re actively debugging a large project with many breakpoints, you’ll be glad of this navigator. Also, this is where you create special breakpoints (such as symbolic breakpoints), and in general it’s your center for managing existing breakpoints. We’ll return to this topic in <a class="xref" href="ch09.html">Chapter 9</a>.<a id="idm441655532304" class="indexterm"></a>
<a id="idm441655530800" class="indexterm"></a>
<a id="idm441655529552" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Log navigator (Command-7)
</span>
              </dt>
              <dd>
                <p class="simpara">
This navigator lists your recent major actions, such as building or running (debugging) your project. Click on a listing to see the log file generated when you performed that action. The log file might contain information that isn’t displayed in any other way, and also it lets you dredge up messages from the recent past (“What was that exception I got while debugging a moment ago?”).<a id="idm441655526304" class="indexterm"></a>
<a id="idm441655524800" class="indexterm"></a>
<a id="idm441655523552" class="indexterm"></a>
</p>
                <p class="simpara">For example, by clicking on the listing for a successful build, and by choosing to display All and All Messages using the filter switches at the top of the log, we can see the steps by which a build takes place (<a class="xref" href="ch06.html#FIGlogPane">Figure 6.5</a>). To reveal the full text of a step, click on that step and then click the Expand Transcript button that appears at the far right (and see also the menu items in the Editor menu).</p>
              </dd>
            </dl>
          </div>
          <div class="figure">
            <a id="FIGlogPane"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0605.png" alt="figs/pios_0605.png" />
              </div>
            </div>
            <p class="title">Figure 6.5. Viewing a log</p>
          </div>
          <br class="figure-break" />
          <p>When navigating by clicking in the Navigator pane, modifications to your click can determine where navigation takes place. By default, Option-click navigates in an assistant pane (discussed later in this chapter), double-click navigates by opening a new window, and Shift-Option-click summons the <a id="idm441655517584" class="indexterm"></a>navigation window, a little heads-up pane where you can specify where to navigate (a new window, a new tab, or a new assistant pane). For the settings that govern these click modifications, see the General pane of Xcode’s preferences.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_the_utilities_pane"></a>The Utilities Pane</h3>
              </div>
            </div>
          </div>
          <p>The Utilities pane is the column at the right of the project window. It contains inspectors that provide information about the current selection or its settings; in some cases, these inspectors let you change those settings. It also contains libraries that function as a source of objects you may need while editing your project. The Utilities pane’s importance emerges mostly when you’re working in the nib editor (<a class="xref" href="ch07.html">Chapter 7</a>). But it can also be useful while editing code, because Quick Help, a form of documentation (<a class="xref" href="ch08.html">Chapter 8</a>), is displayed here as well, plus the Utilities pane is the source of code snippets (<a class="xref" href="ch09.html">Chapter 9</a>). To toggle the visibility of the Utilities pane, choose View → Utilities → Hide/Show Utilities (Command-Option-0). You can change the Utilities pane’s width by dragging the vertical line at its left edge.<a id="idm441655512128" class="indexterm"></a>
<a id="idm441655510880" class="indexterm"></a></p>
          <p>Many individual inspectors and libraries are discussed in subsequent chapters. Here, I’ll just describe the overall physical characteristics of the Utilities pane.</p>
          <p>The Utilities pane consists of a set of palettes. Actually, there are so many of these palettes that they are clumped into multiple sets, divided into two major groups: the top half of the pane and the bottom half of the pane. You can change the relative heights of these two halves by dragging the horizontal line that separates them.</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
The top half
</span>
              </dt>
              <dd>
                <p class="simpara">
What appears in the top half of the Utilities pane depends on what’s selected in the current editor. There are two main cases:
</p>
                <div class="variablelist">
                  <dl>
                    <dt>
                      <span class="term">
A code file is being edited
</span>
                    </dt>
                    <dd>
The top half of the Utilities pane shows either the File inspector or Quick Help. Toggle between them with the icons at the top of this half of the Utilities pane, or with their keyboard shortcuts (Command-Option-1, Command-Option-2). The File inspector is rarely needed, but Quick Help can be useful as documentation. The File inspector consists of multiple sections, each of which can be expanded or collapsed by clicking its header.<a id="idm441655505088" class="indexterm"></a>
<a id="idm441655503840" class="indexterm"></a><a id="idm441655502976" class="indexterm"></a>
<a id="idm441655501728" class="indexterm"></a>
</dd>
                    <dt>
                      <span class="term">
A nib or storyboard file is being edited
</span>
                    </dt>
                    <dd>
The top half of the Utilities pane shows, in addition to the File inspector and Quick Help, the Identity inspector (Command-Option-3), the Attributes inspector (Command-Option-4), the Size inspector (Command-Option-5), and the Connections inspector (Command-Option-6). Like the File inspector, these can consist of multiple sections, each of which can be expanded or collapsed by clicking its header.<a id="idm441655498688" class="indexterm"></a>
<a id="idm441655497440" class="indexterm"></a><a id="idm441655496576" class="indexterm"></a>
<a id="idm441655495328" class="indexterm"></a><a id="idm441655494464" class="indexterm"></a>
<a id="idm441655493216" class="indexterm"></a><a id="idm441655492352" class="indexterm"></a>
<a id="idm441655491104" class="indexterm"></a>
</dd>
                  </dl>
                </div>
              </dd>
              <dt>
                <span class="term">
The bottom half
</span>
              </dt>
              <dd>
                <p class="simpara">
The bottom half of the Utilities pane shows one of four libraries. Toggle between them with the icons at the top of this half of the Utilities pane, or with their keyboard shortcuts. They are the File Template library (Command-Option-Control-1), the Code Snippet library (Command-Option-Control-2), the Object library (Command-Option-Control-3), and the Media library (Command-Option-Control-4). The Object library is the most important; you’ll use it heavily when editing a nib or storyboard.<a id="idm441655488192" class="indexterm"></a>
<a id="idm441655485952" class="indexterm"></a><a id="idm441655485184" class="indexterm"></a>
<a id="idm441655483936" class="indexterm"></a><a id="idm441655483072" class="indexterm"></a>
<a id="idm441655481824" class="indexterm"></a><a id="idm441655480960" class="indexterm"></a>
<a id="idm441655479712" class="indexterm"></a>
</p>
                <p class="simpara">To see a help pop-up describing the currently selected item in a library, press Spacebar.</p>
              </dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_the_editor"></a>The Editor</h3>
              </div>
            </div>
          </div>
          <p>In the middle of the project window is the <span class="emphasis"><em>editor</em></span>.<a id="idm441655476096" class="indexterm"></a>
<a id="idm441655474848" class="indexterm"></a> This is where you get actual work done, reading and writing your code (<a class="xref" href="ch09.html">Chapter 9</a>), or designing your interface in a nib or storyboard file (<a class="xref" href="ch07.html">Chapter 7</a>). The editor is the core of the project window. You can eliminate the Navigator pane, the Utilities pane, and the Debug pane, but there is no such thing as a project window without an editor (though you can cover the editor completely with the Debug pane).</p>
          <p>The editor provides its own form of navigation, the <span class="emphasis"><em>jump bar</em></span> across the top.<a id="idm441655471728" class="indexterm"></a>
<a id="idm441655470480" class="indexterm"></a> Not only does the jump bar show you hierarchically what file is currently being edited, but also it allows you to switch to a different file. In particular, each path component in the jump bar is also a pop-up menu. These pop-up menus can be summoned by clicking on a path component, or by using keyboard shortcuts (shown in the second section of the View → Standard Editor submenu). For example, Control-4 summons a hierarchical pop-up menu, which can be navigated entirely with the keyboard, allowing you to choose a different file in your project to edit. Moreover, each pop-up menu in the jump bar also has a filter field; to see it, summon a pop-up menu from the jump bar and start typing. Thus you can navigate your project even if the Project navigator isn’t showing.</p>
          <p>It is extremely likely, as you develop a project, that you’ll want to edit more than one file simultaneously, or obtain multiple views of a single file so that you can edit two areas of it simultaneously. This can be achieved in three ways: assistants, tabs, and secondary windows.</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Assistants
</span>
              </dt>
              <dd>
                <p class="simpara">
You can split the editor into multiple editors by summoning an <span class="emphasis"><em>assistant</em></span> pane.<a id="idm441655466384" class="indexterm"></a>
<a id="idm441655465136" class="indexterm"></a> To do so, click the second button in the Editor segmented control in the toolbar, or choose View → Assistant Editor → Show Assistant Editor (Command-Option-Return). Also, by default, adding the Option key to navigation opens an assistant pane; for example, Option-click in the Navigator pane, or Option-choose in the jump bar, to navigate by opening an assistant pane (or to navigate in an existing assistant pane if there is one). To remove the assistant pane, click the first button in the Editor segmented control in the toolbar, or choose View → Standard Editor → Show Standard Editor (Command-Return), or click the X button at the assistant pane’s top right.
</p>
                <p class="simpara">Your first task will be to decide how you want multiple editor panes arranged with respect to one another. To do so, choose from the View → Assistant Editor submenu. I usually prefer All Editors Stacked Vertically, but it’s purely a matter of personal taste and convenience.</p>
                <p class="simpara">Once you’ve summoned an assistant pane, you can split it further into additional assistant panes. To do so, click the Plus button at the top right of an assistant pane. To dismiss an assistant pane, click the X button at its top right.</p>
                <p class="simpara">What makes an assistant pane an assistant, and not just a form of split-pane editing, is that it can bear a special relationship to the primary editor pane. The primary editor pane is the one whose contents, by default, are determined by what you click on in the Navigator pane; an assistant pane, meanwhile, can respond to what file is being edited in the primary editor pane by changing intelligently what file it (the assistant pane) is editing. This is called <span class="emphasis"><em>tracking</em></span>.</p>
                <p class="simpara">To see tracking in action, open a single assistant pane and set the first component in its jump bar to Counterparts (<a class="xref" href="ch06.html#FIGcounterparts">Figure 6.6</a>). Now use the Project navigator to select <span class="emphasis"><em>AppDelegate.m</em></span>; the primary editor pane displays this file, and the assistant automatically displays <span class="emphasis"><em>AppDelegate.h</em></span>. Next, use the Project navigator to select <span class="emphasis"><em>AppDelegate.h</em></span>; the primary editor pane displays this file, and the assistant automatically displays <span class="emphasis"><em>AppDelegate.m</em></span>. There’s a lot of convenience and power lurking here, which you’ll explore as you need it.<a id="idm441655458368" class="indexterm"></a></p>
              </dd>
            </dl>
          </div>
          <div class="figure">
            <a id="FIGcounterparts"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0606.png" alt="figs/pios_0606.png" />
              </div>
            </div>
            <p class="title">Figure 6.6. Telling an assistant pane to display counterparts</p>
          </div>
          <br class="figure-break" />
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Tabs
</span>
              </dt>
              <dd>
You can embody the entire project window interface as a tab.<a id="idm441655452672" class="indexterm"></a> To do so, choose File → New → Tab (Command-T), revealing the tab bar (just below the toolbar) if it wasn’t showing already. Use of a tabbed interface will likely be familiar from applications such as Safari. You can switch between tabs by clicking on a tab, or with Command-Shift-}. At first, your new tab will look largely identical to the original window from which it was spawned. But now you can make changes in a tab — change what panes are showing or what file is being edited, for example — without affecting any other tabs. Thus you can get multiple views of your project. You can assign a descriptive name to a tab: double-click on a tab name to make it editable.
</dd>
              <dt>
                <span class="term">
Secondary windows
</span>
              </dt>
              <dd>
A secondary project window is similar to a tab, but it appears as a separate window instead of a tab in the same window.<a id="idm441655449936" class="indexterm"></a> To create one, choose File → New → Window (Command-Shift-T). Alternatively, you can promote a tab to be a window by dragging it right out of its current window. Or choose Navigate → Open In and navigate left in the resulting dialog until the dialog offers to make a new window.
</dd>
            </dl>
          </div>
          <p>There isn’t a strong difference between a tab and a secondary window; which you use, and for what, will be a matter of taste and convenience. I find that the advantage of a secondary window is that you can see it at the same time as the main window, and that it can be small. Thus, when I have a file I frequently want to refer to, I often spawn off a secondary window displaying that file, sized fairly small and without any panes other than the editor.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_project_file_and_its_dependents"></a>The Project File and Its Dependents</h2>
            </div>
          </div>
        </div>
        <p>Now that you’re comfortable with the Xcode project window, you’re ready to explore the project and its constituents.</p>
        <p>The first item in the Project navigator (Command-1) represents the project file on disk (in our new project, this is called Empty Window). Hierarchically dependent upon it are items that contribute to the building of the project (<a class="xref" href="ch06.html#FIGprojectNavigatorAgain">Figure 6.7</a>).<a id="idm441655444016" class="indexterm"></a>
<a id="idm441655442768" class="indexterm"></a></p>
        <div class="figure">
          <a id="FIGprojectNavigatorAgain"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0607.png" alt="figs/pios_0607.png" />
            </div>
          </div>
          <p class="title">Figure 6.7. The Project navigator again</p>
        </div>
        <br class="figure-break" />
        <p>Many of these items, including the project file itself, correspond to items on disk in the project folder. To survey this correspondence, let’s examine the project folder in the Finder simultaneously with the Xcode project window. Select the project file listing in the Project navigator and choose File → Show in Finder.<a id="idm441655438528" class="indexterm"></a>
<a id="idm441655436288" class="indexterm"></a><a id="idm441655435424" class="indexterm"></a>
<a id="idm441655434176" class="indexterm"></a></p>
        <p>The Finder displays the contents of your project folder (<a class="xref" href="ch06.html#FIGprojectFolderXcode4">Figure 6.8</a>). The most important of these is <span class="emphasis"><em>Empty Window.xcodeproj</em></span>. This is the project file. All Xcode’s knowledge about your project — what files it consists of and how to build the project — is stored in this file.</p>
        <div class="figure">
          <a id="FIGprojectFolderXcode4"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0608.png" alt="figs/pios_0608.png" />
            </div>
          </div>
          <p class="title">Figure 6.8. The project folder</p>
        </div>
        <br class="figure-break" />
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>To open a project from the Finder, double-click the project file. This will launch Xcode if it isn’t already running.</p>
        </div>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Never, never, <span class="emphasis"><em>never</em></span> touch anything in a project folder by way of the Finder, except for double-clicking the project file to open the project. Don’t put anything directly into a project folder. Don’t remove anything from a project folder. Don’t rename anything in a project folder. Don’t touch anything in a project folder! Do all your interaction with the project through the project window in Xcode. (When you’re an Xcode power user, you’ll know when you can disobey this rule. Until then, just obey it blindly and rigorously.)</p>
          <p>The reason is that the project expects things in the project folder to be a certain way. If you make any alterations to the project folder directly in the Finder, behind the project’s back, you can upset those expectations and break the project. When you work in the project window, it is Xcode itself that makes any necessary changes in the project folder, and all will be well.</p>
        </div>
        <p>Consider now the groups and files shown in the Project navigator (<a class="xref" href="ch06.html#FIGprojectNavigatorAgain">Figure 6.7</a>) as hierarchically dependent upon the project file, and how they correspond to reality on disk as portrayed in the Finder (<a class="xref" href="ch06.html#FIGprojectFolderXcode4">Figure 6.8</a>). (Recall that <span class="emphasis"><em>group</em></span> is the technical term for the folder-like objects shown in the Project navigator.)</p>
        <p>Observe that groups in the Project navigator don’t necessarily correspond to folders on disk in the Finder, and folders on disk in the Finder don’t necessarily correspond to groups in the Project navigator.</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
The Empty Window group is, to some extent, real; it corresponds directly to the <span class="emphasis"><em>Empty Window</em></span> folder on disk. If you were to create additional files (which, in real life, you would almost certainly do in the course of developing your project), you would likely put them in the Empty Window group in the Project navigator so that they’d be in the <span class="emphasis"><em>Empty Window</em></span> folder on disk. (Doing so, however, is not a requirement; your files can live anywhere and your project will still work fine.)
</li>
            <li class="listitem">
The Supporting Files group, on the other hand, corresponds to nothing on disk; it’s just a way of clumping some items together in the Project navigator, so that they can be located easily and can be shown or hidden together. The things <span class="emphasis"><em>inside</em></span> this group are real, however; you can see that the four files <span class="emphasis"><em>Empty Window-Info.plist</em></span>, <span class="emphasis"><em>InfoPlist.strings</em></span>, <span class="emphasis"><em>Empty Window-Prefix.pch</em></span>, and <span class="emphasis"><em>main.m</em></span>, along with the three <span class="emphasis"><em>Default.png</em></span> files, do exist on disk — they’re just not inside anything called <span class="emphasis"><em>Supporting Files</em></span>. Rather, they’re at the top level of the <span class="emphasis"><em>Empty Window</em></span> folder.
</li>
            <li class="listitem">
Two files, <span class="emphasis"><em>InfoPlist.strings</em></span> and <span class="emphasis"><em>ViewController.xib</em></span>, appear in the Finder inside a folder called <span class="emphasis"><em>en.lproj</em></span>, which doesn’t appear in the Project navigator. The folder <span class="emphasis"><em>en.lproj</em></span> has to do with <span class="emphasis"><em>localization</em></span>, which I’ll discuss in <a class="xref" href="ch09.html">Chapter 9</a>.
</li>
          </ul>
        </div>
        <p>You may be tempted to find all this confusing. Don’t! Remember what I said about not involving yourself with the project folder on disk in the Finder. Keep your attention on the Project navigator, make your modifications to the project there, and all will be well.</p>
        <p>By convention, as you add other files to your project that are not code but need to be copied into the app as it is built, such as sound and image files, you would usually put them into yet another group — probably, though not necessarily, a group inside the Empty Window group. You might call this group Resources. (I usually do.) And as your project grows further, you should feel free to create even more groups to help organize your files. To make a new group, choose File → New → Group. To rename a group, select it in the Project navigator and press Return to make the name editable.<a id="idm441655411568" class="indexterm"></a>
<a id="idm441655408064" class="indexterm"></a></p>
        <p>When I say “feel free,” I mean it. You want navigating your project to be easy and intuitive. That’s what groups are for. They are just ways of making the Project navigator work well for you. As we’ve seen, they don’t necessarily affect how the actual files are stored on disk. Even more important, they don’t affect how the app is built. It is not the placement of files in groups or in the Finder that causes them to be built into the app; it’s their inclusion in the appropriate target build phase, as I’ll explain later in this chapter.</p>
        <p>The things in the Frameworks group and the Products group don’t correspond to anything in the project folder, but they do correspond to real things that the project needs to know about in order to build and run:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
Frameworks
</span>
            </dt>
            <dd>
This group, by convention, lists frameworks (Cocoa code) on which your code depends. Frameworks exist on disk, but they are not built into your app when it is constructed; they don’t have to be, because they are present also on the target device (an iPhone, iPod touch, or iPad). Instead, the frameworks are <span class="emphasis"><em>linked</em></span> to the app, meaning that the app knows about them and expects to find them on the device when it runs. Thus, all the framework code is omitted from the app itself, saving considerable space.
</dd>
            <dt>
              <span class="term">
Products
</span>
            </dt>
            <dd>
This group, by convention, holds an automatically generated reference to the built app.
</dd>
          </dl>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_target"></a>The Target</h2>
            </div>
          </div>
        </div>
        <p>A <span class="emphasis"><em>target</em></span> is a collection of parts along with rules and settings for how to build a product from them. It is a major determinant of how an app is built.<a id="idm441655399136" class="indexterm"></a>
<a id="idm441655397888" class="indexterm"></a> Whenever you build, what you’re really building is a target.</p>
        <p>Select the Empty Window project at the top of the Project navigator, and you’ll see two things on the left side of the editor: the project itself, and a list of your targets. In this case, there is only one target, called Empty Window (just like the project itself). But there could be more than one target, under certain circumstances. For example, you might want to write an app that can be built as an iPhone app or as an iPad app — two different apps that share a lot of the same code. So you might want one project containing two targets.</p>
        <p>If you select the project in the left side of the editor, you <span class="emphasis"><em>edit the project</em></span>. If you select the target in the left side of the editor, you <span class="emphasis"><em>edit the target</em></span>. I’ll use those expressions a lot in later instructions.<a id="idm441655396512" class="indexterm"></a><a id="idm441655394320" class="indexterm"></a></p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_build_phases"></a>Build Phases</h3>
              </div>
            </div>
          </div>
          <p>Edit the target and click Build Phases at the top of the editor (<a class="xref" href="ch06.html#FIGbuildPhases">Figure 6.9</a>). These are the stages by which your app is built.<a id="idm441655391584" class="indexterm"></a>
<a id="idm441655390336" class="indexterm"></a> By default, there are three of them with content — Compile Sources, Link Binary With Libraries, and Copy Bundle Resources — and those are the only stages you’ll usually need, though you can add others. The build phases are both a report to you on how the target will be built and a set of instructions to Xcode on how to build the target; if you change the build phases, you change the build process.</p>
          <div class="figure">
            <a id="FIGbuildPhases"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0609.png" alt="figs/pios_0609.png" />
              </div>
            </div>
            <p class="title">Figure 6.9. Build phases</p>
          </div>
          <br class="figure-break" />
          <p>The meanings of the three build phases are pretty straightforward:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Compile Sources
</span>
              </dt>
              <dd>
Certain files (your code) are compiled, and the resulting compiled code is copied into the app.<a id="idm441655384320" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Link Binary With Libraries
</span>
              </dt>
              <dd>
Certain libraries, usually frameworks, are linked to the compiled code (now referred to as the <span class="emphasis"><em>binary</em></span>), so that it will expect them to be present on the device when the app runs.<a id="idm441655381216" class="indexterm"></a><a id="idm441655380352" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Copy Bundle Resources
</span>
              </dt>
              <dd>
Certain files are copied into the app, so that your code or the system can find them there when the app runs. For example, if your app had an icon, it would need to be copied into the app so the device could find and display it.<a id="idm441655377584" class="indexterm"></a>
</dd>
            </dl>
          </div>
          <p>By opening the build phases in the editor, you can see the files to which each phase applies. The first phase, Compile Sources, presently compiles three files (<span class="emphasis"><em>main.m</em></span>, <span class="emphasis"><em>AppDelegate.m</em></span>, and <span class="emphasis"><em>ViewController.m</em></span>). The second phase, Link Binary With Libraries, presently links three libraries (frameworks). The third phase, Copy Bundle Resources, presently copies five files — <span class="emphasis"><em>InfoPlist.strings</em></span>, <span class="emphasis"><em>ViewController.xib</em></span> (a nib file), and three <span class="emphasis"><em>.png</em></span> files that supply a default image of your app as it launches, as explained in <a class="xref" href="ch09.html">Chapter 9</a>.</p>
          <p>You can alter these lists. If something in your project was not in Copy Bundle Resources and you wanted it copied into the app during the build process, you would drag it from the Project navigator into the Copy Bundle Resources list, or (easier) click the Plus button beneath the Copy Bundle Resources list to get a helpful dialog listing everything in your project. If something in your project was in Copy Bundle Resources and you didn’t want it copied in the app, you would delete it from the list; this would not delete it from your project, from the Project navigator, or from the Finder, but only from the list of things to be copied into your app.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_build_settings"></a>Build Settings</h3>
              </div>
            </div>
          </div>
          <p>Build phases are only one aspect of how a target knows how to build the app. The other aspect is build settings.<a id="idm441655369552" class="indexterm"></a>
<a id="idm441655368304" class="indexterm"></a> To see them, edit the target and click Build Settings at the top of the editor (<a class="xref" href="ch06.html#FIGbuildSettings">Figure 6.10</a>). Here you’ll find a long list of settings, most of which you’ll never touch. But Xcode examines this list in order to know what to do at various stages of the build process. Build settings are the reason your project compiles and builds the way it does.</p>
          <div class="figure">
            <a id="FIGbuildSettings"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0610.png" alt="figs/pios_0610.png" />
              </div>
            </div>
            <p class="title">Figure 6.10. Target build settings</p>
          </div>
          <br class="figure-break" />
          <p>You can determine what build settings are displayed by clicking Basic or All. The settings are combined into categories, and you can close or open each category heading to save room. If you know something about a setting you want to see, such as its name, you can use the search field at the top right to filter what settings are shown.</p>
          <p>You can determine how build settings are displayed by clicking Combined or Levels; in <a class="xref" href="ch06.html#FIGbuildSettings">Figure 6.10</a>, I’ve clicked Levels, in order to discuss what levels are. It turns out that not only does a <span class="emphasis"><em>target</em></span> contain values for the build settings, but the <span class="emphasis"><em>project</em></span> also contains values for the same build settings; furthermore, Xcode has certain built-in default build setting values. The Levels display shows all of these levels at once, so you can understand the derivation of the actual values used for every build setting.</p>
          <p>To understand the chart, read from right to left. For example, the iOS default for the Build Active Architecture Only setting’s Debug configuration (far right) is No. But then the project comes along (second column from the right) and sets it to Yes. The target (third column from the right) doesn’t change that setting, so the result (fourth column from the right) is that the setting resolves to Yes.</p>
          <p>If you wanted to change this value, you could, here and now. You could change the value at the project level or at the target level. I’m not suggesting that you should do so; indeed, you will rarely have occasion to manipulate build settings directly, as the defaults are usually acceptable. Nevertheless, you <span class="emphasis"><em>can</em></span> change build setting values, and this is where you would do so. For details on what the various build settings are, consult Apple’s documentation, especially the <span class="emphasis"><em>Xcode Build Setting Reference</em></span>. Also, you can select a build setting and show Quick Help in the Utilities pane to learn more about it.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_configurations"></a>Configurations</h3>
              </div>
            </div>
          </div>
          <p>There are actually multiple lists of build setting values — though only one such list applies when a build is performed. Each such list is called a <span class="emphasis"><em>configuration</em></span>.<a id="idm441655354352" class="indexterm"></a>
<a id="idm441655353104" class="indexterm"></a><a id="idm441655352240" class="indexterm"></a>
<a id="idm441655350992" class="indexterm"></a> Multiple configurations are needed because you build in different ways at different times for different purposes, and thus you’ll want certain build settings to take on different values under different circumstances.</p>
          <p>By default, there are two configurations:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Debug
</span>
              </dt>
              <dd>
This configuration is used throughout the development process, as you write and run your app.
</dd>
              <dt>
                <span class="term">
Release
</span>
              </dt>
              <dd>
This configuration is used for late-stage testing, when you want to check performance on a device.
</dd>
            </dl>
          </div>
          <p>Configurations exist at all because the project says so. To see where the project says so, edit the project and click Info at the top of the editor (<a class="xref" href="ch06.html#FIGConfigurations">Figure 6.11</a>). Note that these configurations are just names. You can make additional configurations, and when you do, you’re just adding to a list of names. The importance of configurations emerges only when those names are coupled with build setting values. Configurations can affect build setting values both at the project level and at the target level.</p>
          <div class="figure">
            <a id="FIGConfigurations"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0611.png" alt="figs/pios_0611.png" />
              </div>
            </div>
            <p class="title">Figure 6.11. Configurations</p>
          </div>
          <br class="figure-break" />
          <p>For example, return to the target build settings (<a class="xref" href="ch06.html#FIGbuildSettings">Figure 6.10</a>) and type “Optim” into the search field. Now you can look at the Optimization Level build setting. The Debug configuration value for Optimization Level is None: while you’re developing your app, you build with the Debug configuration, so your code is just compiled line by line in a straightforward way. The Release configuration value for Optimization Level is Fastest, Smallest; when your app is ready to ship, you build it with the Release configuration, so the resulting binary is faster and smaller, which is great for your users installing and running the app on a device, but would be no good while you’re developing the app because breakpoints and stepping in the debugger wouldn’t work properly.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_schemes_and_destinations"></a>Schemes and Destinations</h3>
              </div>
            </div>
          </div>
          <p>So far, I have said that there are configurations, and I have explained that you may need to switch between configurations in order to get the build setting values appropriate for your current purpose. But I have not said how the configuration is determined as you actually build. It’s determined by a scheme.<a id="idm441655322064" class="indexterm"></a>
<a id="idm441655320176" class="indexterm"></a></p>
          <p>A <span class="emphasis"><em>scheme</em></span> unites a target (or multiple targets) with a build configuration, with respect to the purpose for which you’re building. A new project comes by default with a single scheme, named after the project’s single target. Thus the Empty Window project’s single scheme is currently called Empty Window. To see it, choose Product → Edit Scheme. The scheme editor dialog opens. Make sure that Info at the top of the dialog is selected.</p>
          <p>On the left side of the scheme editor are listed various actions you might perform from the Product menu. Click an action to see its corresponding settings in this scheme. The first action, the Build action, is different from the other actions, because it is common to all of them (the other actions all implicitly involve building); thus the Build action merely determines what target(s) will be built when each of the other actions is performed, and for our simple project this is trivial, because we’ve only one target and we always need it built. So, now consider the Run action.</p>
          <p>When you click the Run action at the left, the editor displays the settings that will be used when you build and run (<a class="xref" href="ch06.html#FIGscheme">Figure 6.12</a>). As you can see, the Build Configuration pop-up menu is set to Debug. That explains where the current build configuration comes from. At the moment, whenever you build and run, you’re using the Debug build configuration and the build setting values that correspond to it, because you’re using this scheme, and that’s what this scheme says to do when you build and run.</p>
          <div class="figure">
            <a id="FIGscheme"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0612.png" alt="figs/pios_0612.png" />
              </div>
            </div>
            <p class="title">Figure 6.12. The scheme editor</p>
          </div>
          <br class="figure-break" />
          <p>Now dismiss the scheme editor, and consider how you might proceed if you wanted to build and run using the Release build configuration. (The Debug build configuration settings may affect the behavior of the built app, so you want to test the app as an actual user would experience it.) One way would be to return to the scheme editor and change the build configuration for the Run action for this scheme. Xcode makes this convenient: hold the Option key as you choose Product → Run (or as you click the Run button in the toolbar). The scheme editor appears, containing a Run button. So now you can make any changes you like, such as setting the Build Configuration pop-up menu to Release for the Run action, and proceed directly to build and run the app by clicking Run.</p>
          <p>(If you’re following along and you did make this change, open the scheme editor again and set the Build Configuration pop-up for the Run action in our Empty Window scheme back to Debug.)</p>
          <p>On the other hand, if you were to find yourself often wanting to switch between building and running with the Debug configuration and building and running with the Release configuration, you might create a distinct, additional scheme that uses the Release debug configuration for the Run action. This is easy to do: in the scheme editor, click Duplicate Scheme. The name of the new scheme is editable; let’s call it Release. Change the Build Configuration pop-up for the Run action in our new scheme to Release, and dismiss the scheme editor.</p>
          <p>Now you have two schemes, Empty Window (whose build configuration for running is Debug) and Release (whose build configuration for running is Release). To switch between them easily, you can use the Scheme pop-up menu in the project window toolbar (<a class="xref" href="ch06.html#FIGschemePopup">Figure 6.13</a>) before you build and run.</p>
          <div class="figure">
            <a id="FIGschemePopup"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0613.png" alt="figs/pios_0613.png" />
              </div>
            </div>
            <p class="title">Figure 6.13. The Scheme pop-up menu</p>
          </div>
          <br class="figure-break" />
          <p>The Scheme pop-up menu lists each scheme, along with each destination on which you might run your built app.<a id="idm441655305056" class="indexterm"></a>
<a id="idm441655303808" class="indexterm"></a> A <span class="emphasis"><em>destination</em></span> is effectively a machine that can run your app. For example, you might want to run the app in the Simulator or on a physical device. There is no configuration of destinations; you are automatically assigned destinations, depending on what system your project is set to run on and what devices are connected to your computer.</p>
          <p>Destinations and schemes have nothing to do with one another; your app is built the same way regardless of your chosen destination. The presence of destinations in the Scheme pop-up menu is intended as a convenience, allowing you to use this one pop-up menu to choose either a scheme or a destination, or both, in a single move. To switch easily among destinations without changing schemes, click near the right end of the Scheme pop-up menu. To switch among schemes, possibly also determining the destination (as shown in <a class="xref" href="ch06.html#FIGschemePopup">Figure 6.13</a>), click near the left end of the Scheme pop-up menu. You can also switch among schemes or among destinations by using the scheme editor.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_from_project_to_app"></a>From Project to App</h2>
            </div>
          </div>
        </div>
        <p>An app file is really a special kind of folder called a <span class="emphasis"><em>package</em></span> (and a special kind of package called a <span class="emphasis"><em>bundle</em></span>). The Finder normally disguises a package as a file and does not dive into it to reveal its contents to the user, but you can bypass this protection and investigate an app bundle with the Show Package Contents command. By doing so, you can study the internal structure of your built app bundle.</p>
        <p>We’ll use the Empty Window app that we built earlier as a sample minimal app to investigate. You’ll have to locate it in the Finder; by default, it should be somewhere in your user <span class="emphasis"><em>Library/Developer/Xcode/DerivedData</em></span> folder, as shown in <a class="xref" href="ch06.html#FIGproduct">Figure 6.14</a>. (If you’re using Mountain Lion, I presume you know how to reveal the user <span class="emphasis"><em>Library</em></span> directory. In theory, you should be able to select the app under Products in Xcode’s Navigation pane and choose File → Show in Finder, but there seems to be a long-standing bug preventing this.)</p>
        <div class="figure">
          <a id="FIGproduct"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0614.png" alt="figs/pios_0614.png" />
            </div>
          </div>
          <p class="title">Figure 6.14. The built app, in the Finder</p>
        </div>
        <br class="figure-break" />
        <p>In the Finder, Control-click the Empty Window app, and choose Show Package Contents from the contextual menu.</p>
        <div class="figure">
          <a id="FIGappInternals"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0615.png" alt="figs/pios_0615.png" />
            </div>
          </div>
          <p class="title">Figure 6.15. Contents of the app package</p>
        </div>
        <br class="figure-break" />
        <p>Looking inside our minimal app bundle (<a class="xref" href="ch06.html#FIGappInternals">Figure 6.15</a>), we see that it contains these files:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<span class="emphasis"><em>Default.png</em></span> and friends
</span>
            </dt>
            <dd>
The three launch image files have been copied to the top level of the bundle, where they can be found for display at launch time.
</dd>
            <dt>
              <span class="term">
<span class="emphasis"><em>Empty Window</em></span>
</span>
            </dt>
            <dd>
Our app’s compiled code (the binary). When the app is launched, the binary is linked to the various frameworks, and the code begins to run (starting with the entry point in the <code class="literal">main</code> function).
</dd>
            <dt>
              <span class="term">
<span class="emphasis"><em>Info.plist</em></span>
</span>
            </dt>
            <dd>
A configuration file in a strict text format (a <span class="emphasis"><em>property list</em></span> file). It is derived from the project file <span class="emphasis"><em>Empty Window-Info.plist</em></span>. It contains instructions to the system about how to treat and launch the app. For example, if our app had an icon, <span class="emphasis"><em>Info.plist</em></span> would tell the system its name, so that the system could dive into the app bundle, find it, and display it. It also tells the system things like the name of the binary, so that the system can find it and launch the app correctly.<a id="idm441655279712" class="indexterm"></a>
<a id="idm441655278464" class="indexterm"></a>
</dd>
            <dt>
              <span class="term">
<span class="emphasis"><em>PkgInfo</em></span>
</span>
            </dt>
            <dd>
A tiny text file reading <code class="literal">APPL????</code>, signifying the type and creator codes for this app. The <span class="emphasis"><em>PkgInfo</em></span> file is something of a dinosaur; it isn’t really necessary for the functioning of an iOS app and is generated automatically. You’ll never need to touch it.
</dd>
            <dt>
              <span class="term">
<span class="emphasis"><em>InfoPlist.strings</em></span>
</span>
            </dt>
            <dd>
A text file intended for text appearing in our <span class="emphasis"><em>Info.plist</em></span> that might need to be translated into different languages. It is copied directly from <span class="emphasis"><em>InfoPlist.strings</em></span> in the project. We haven’t edited this file, and our app currently appears only in English, so this file is of no interest at the moment (strings files are discussed in <a class="xref" href="ch09.html">Chapter 9</a>).
</dd>
            <dt>
              <span class="term">
<span class="emphasis"><em>ViewController.nib</em></span>
</span>
            </dt>
            <dd>
Our app’s only nib file. It contains instructions for generating the initial contents of our app’s main window (currently just a gray rectangle). It is created (“compiled”) from the <span class="emphasis"><em>ViewController.xib</em></span> file in the project; a <span class="emphasis"><em>.xib</em></span> file and a <span class="emphasis"><em>.nib</em></span> file are different forms of the same thing.
</dd>
          </dl>
        </div>
        <p>In real life, an app bundle will contain more files, but the difference will mostly be one of degree, not kind. For example, our project might have additional nib files, icon image files, and image or sound files. All of these would make their way into the app bundle.</p>
        <p>You are now in a position to appreciate, in a general sense, how the components of our project are treated and assembled into an app, and what responsibilities accrue to you, the programmer, in order to ensure that the app is built correctly. The rest of this chapter outlines what goes into the building of an app from a project.</p>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_build_settings_2"></a>Build Settings</h3>
              </div>
            </div>
          </div>
          <p>We have already talked about how build settings are determined. Xcode itself, the project, and the target all contribute to the resolved build setting values, some of which may differ depending on the build configuration. Before building, you, the programmer, will have already specified a scheme; the scheme determines the build configuration, the specific set of build setting values that will apply as this build proceeds.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_property_list_settings"></a>Property List Settings</h3>
              </div>
            </div>
          </div>
          <p>Your project contains a property list file that will be used to generate the built app’s <span class="emphasis"><em>Info.plist</em></span> file. The target knows what file it is because it is specified in the Info.plist File build setting. For example, in our project, the value of the Info.plist File build setting has been set automatically to <span class="emphasis"><em>Empty Window/Empty Window-Info.plist</em></span>. (Take a look at the build settings and see!)<a id="idm441655260912" class="indexterm"></a></p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>Because the name of the file in your project from which the built app’s <span class="emphasis"><em>Info.plist</em></span> file is generated will vary, depending on the name of the project, I’ll refer to it generically as the project’s <span class="emphasis"><em>Info.plist</em></span>.<a id="idm441655258464" class="indexterm"></a>
<a id="idm441655257216" class="indexterm"></a>
<a id="idm441655256224" class="indexterm"></a></p>
          </div>
          <p>The property list file is a collection of key–value pairs. You can edit it, and you may well need to do so. There are two main ways to edit your project’s <span class="emphasis"><em>Info.plist</em></span>:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
Select the <span class="emphasis"><em>Info.plist</em></span> file in the Project navigator and edit in the editor. By default, the key names (and some of the values) are displayed descriptively, in terms of their functionality; for example, it says “Bundle name” instead of the actual key, which is <code class="literal">CFBundleName</code>. But you can view the actual keys by choosing Editor → Show Raw Keys &amp; Values (you might have to click in the editor to enable this menu item).
</li>
              <li class="listitem">
Edit the target, and click Info at the top of the editor. This pane shows effectively the same information as editing the <span class="emphasis"><em>Info.plist</em></span> in the editor.
</li>
            </ul>
          </div>
          <p></p>
          <p>For a complete list of the possible keys and their meanings, see Apple’s document <span class="emphasis"><em>Information Property List Key Reference</em></span>. I’ll talk more in <a class="xref" href="ch09.html">Chapter 9</a> about property list settings that you’re particularly likely to edit.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_nib_files_and_storyboard_files"></a>Nib Files and Storyboard Files</h3>
              </div>
            </div>
          </div>
          <p>Every app that you write is likely to have at least one nib file (<span class="emphasis"><em>.xib</em></span>) or storyboard file (<span class="emphasis"><em>.storyboard</em></span>), and possibly more.</p>
          <p>You edit a nib file to describe graphically some objects that you want instantiated when the nib file loads (<a class="xref" href="ch05.html">Chapter 5</a>). By breaking your interface into multiple nib files, you simplify the relationship between each nib file and your code; also, if nibs that aren’t needed when your app launches aren’t loaded until they <span class="emphasis"><em>are</em></span> needed, you speed up your app’s launch time, and you streamline your app’s memory usage (because nib objects are not instantiated until the nib is loaded, and can then be destroyed when they are no longer needed).<a id="idm441655245120" class="indexterm"></a>
<a id="idm441655242848" class="indexterm"></a></p>
          <p>A storyboard file is like many nib files in one: in it, you describe graphically the various interfaces (called <span class="emphasis"><em>scenes</em></span>) that you want to appear as the user works with your app. Just as with nib files, a storyboard scene is transformed into actual interface only when it is needed for display, and the memory needed to maintain that interface can be given back when that interface is no longer showing.<a id="idm441655240800" class="indexterm"></a>
<a id="idm441655239552" class="indexterm"></a></p>
          <p>The target knows about your nib files and storyboard files because they appear in its Copy Bundle Resources build phase. In the case of a nib file in <span class="emphasis"><em>.xib</em></span> format, the file is not merely copied into the app bundle; Xcode also translates (compiles) it into a smaller <span class="emphasis"><em>.nib</em></span> file (using the <code class="literal">ibtool</code> tool). Similarly, Xcode translates (compiles) a <span class="emphasis"><em>.storyboard</em></span> file into a smaller <span class="emphasis"><em>.storyboardc</em></span> file in the built app (again, using the <code class="literal">ibtool</code> tool).</p>
          <p>Nib files located inside your app bundle are typically loaded when they are needed as the app runs, usually because code tells them to load. If you elect to use a storyboard as the basis of your main interface, however, it will need to load before any code has a chance to do so. Such a storyboard file is called the <span class="emphasis"><em>main storyboard file</em></span>.<a id="idm441655234192" class="indexterm"></a>
<a id="idm441655232688" class="indexterm"></a>
<a id="idm441655231440" class="indexterm"></a> This situation is handled through the <span class="emphasis"><em>Info.plist</em></span> file; it contains a key “Main storyboard file base name” (<code class="literal">UIMainStoryboardFile</code>), and the system sees this and loads the designated storyboard file automatically as the app launches. (Instead of a main storyboard file, it is possible to have a main nib file that loads automatically when the app launches; this was the standard approach for apps created with Xcode 3.2.x and Xcode 4.0, but none of the current Xcode project templates exemplify this approach, so I don’t discuss it in this edition of the book.)<a id="idm441655229216" class="indexterm"></a>
<a id="idm441655226864" class="indexterm"></a>
<a id="idm441655225616" class="indexterm"></a></p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>A <a id="idm441655224240" class="indexterm"></a>universal app — that is, an app that runs both on the iPad and on the iPhone — typically has nib files or storyboard files in pairs, one to be loaded on the iPad and the other to be loaded on the iPhone. Thus the app can have different basic interfaces on the two different types of device. Naming conventions and <span class="emphasis"><em>Info.plist</em></span> keys allow the runtime to know which nib or storyboard to load depending on the device type. For example, a second <span class="emphasis"><em>Info.plist</em></span> key, “Main storyboard file base name (iPad)” (<code class="literal">UIMainStoryboardFile~ipad</code>), specifies the storyboard file to be loaded at launch time on the iPad.<a id="idm441655221232" class="indexterm"></a><a id="idm441655220368" class="indexterm"></a></p>
          </div>
          <p>See <a class="xref" href="ch07.html">Chapter 7</a> for more about editing nib files (and storyboard files) and how they create instances when your code runs. Full details on how nib files and storyboard files are loaded and why — in particular, their relationship to view controllers — appear in <a class="xref" href="ch19.html">Chapter 19</a>.</p>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_other_resources"></a>Other Resources</h3>
              </div>
            </div>
          </div>
          <p>The three <span class="emphasis"><em>Default.png</em></span> launch image files are examples of resource files. The target knows about them because they appear in its Copy Bundle Resources build phase. Such resources are copied more or less unchanged into the app bundle; I say “more or less” because it turns out that some files, such as <span class="emphasis"><em>.png</em></span> files, may be optimized as they are copied when you build for a device.<a id="idm441655214688" class="indexterm"></a>
<a id="idm441655213440" class="indexterm"></a></p>
          <p>In real life, you are likely to add further resources to your project, because you want your running app to be able to fetch them out of its bundle. For example, if your app needs to display a certain image, you’d add the image to your project and make sure it appears in the Copy Bundle Resources build phase. When the app runs, your code (or possibly the code implied by a loaded nib file) reaches into the app bundle, locates the image, and displays it (<a class="xref" href="ch15.html">Chapter 15</a>).</p>
          <p>To add a resource to your project, start in the Project navigator and choose File → Add Files to Empty Window (or whatever the name of the project is). Alternatively, drag the resource from the Finder into the Project navigator. Either way, a dialog appears (<a class="xref" href="ch06.html#FIGaddItems">Figure 6.16</a>) containing a pane in which you make the following settings:</p>
          <div class="figure">
            <a id="FIGaddItems"></a>
            <div class="figure-contents">
              <div class="mediaobject">
                <img src="figs/pios_0616.png" alt="figs/pios_0616.png" />
              </div>
            </div>
            <p class="title">Figure 6.16. Options when adding a resource to a project</p>
          </div>
          <br class="figure-break" />
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Copy items into destination group’s folder (if needed)
</span>
              </dt>
              <dd>
You should almost certainly check this checkbox. Doing so causes the resource to be copied into the project folder. If you leave this checkbox unchecked, your project will be relying on a file that’s outside the project folder and that you might delete or change unintentionally. Keeping everything your project needs inside the project folder is far safer.
</dd>
              <dt>
                <span class="term">
Folders
</span>
              </dt>
              <dd>
                <p class="simpara">
This choice matters only if what you’re adding to the project is a folder. In both cases, whether the folder is copied into the project folder depends on whether you checked the checkbox discussed in the previous paragraph; the difference is in how the project references the folder contents:<a id="idm441655203040" class="indexterm"></a>
</p>
                <div class="variablelist">
                  <dl>
                    <dt>
                      <span class="term">
Create groups for any added folders
</span>
                    </dt>
                    <dd>
The folder is expressed as a group within the Project navigator, but its contents all appear individually in the Copy Bundle Resources build phase, so they will all be copied individually into the app bundle.
</dd>
                    <dt>
                      <span class="term">
Create folder references for any added folders
</span>
                    </dt>
                    <dd>
The folder itself is shown in blue in the Project navigator and appears as a folder in the Copy Bundle Resources build phase; thus, the build process will copy the entire folder and its contents into the app bundle. This means that the resources inside the folder won’t be at the top level of the bundle, but in a subfolder of it. Such an arrangement can be valuable if you have many resources and you want to separate them into categories (rather than clumping them all at the top level of the app bundle) or if the folder hierarchy among resources is meaningful to your app.
</dd>
                  </dl>
                </div>
              </dd>
              <dt>
                <span class="term">
Add to Targets
</span>
              </dt>
              <dd>
Checking this checkbox causes the resource to be added to the target’s Copy Bundle Resources build phase. Thus you will almost certainly want to check it; why else would you be adding this resource to the project? But if this checkbox is unchecked and you realize later that a resource listed in the Project navigator needs to be added to the Copy Bundle Resources build phase, you can add it manually, as I described earlier.
</dd>
            </dl>
          </div>
          <p>An alternative way to copy resources from your project into the app bundle while building is through a custom Copy Files build phase that you add to your target.<a id="idm441655194352" class="indexterm"></a> To make one, edit the target, switch to Build Phases, and click Add Build Phase (at the lower right) and choose Add Copy Files. A Copy Files build phase appears; open its triangle, and you’ll find you can specify a custom path within the app bundle. For example, if you leave the Destination pop-up menu set to Resources and type “Pix” in the Subpath field, then any resources you add to this build phase will be copied into a folder called <span class="emphasis"><em>Pix</em></span> in the app bundle.</p>
          <p>A custom Copy Files build phase of this sort can be a good way of keeping resources organized by folder inside your app bundle; I frequently use it for this purpose. Bear in mind, however, that it is entirely up to you to make sure that the desired resources are placed inside the appropriate Copy Files build phase (and that they are not placed in the normal Copy Bundle Resources build phase, because if they are, you’ll end up with two copies of the resource in your app bundle).</p>
          <div class="note" style="margin-left: 0; margin-right: 10%;">
            <h3 class="title">Note</h3>
            <p>If you copy resources into a subfolder of your app bundle, either with a folder reference or a custom Copy Files build phase, your code may have to specify that subfolder in order to fetch the resource from inside the app bundle.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_code"></a>Code</h3>
              </div>
            </div>
          </div>
          <p>Code for two classes, AppDelegate and ViewController, was created for you when the project was created; the implementation files for these classes (<span class="emphasis"><em>AppDelegate.m</em></span> and <span class="emphasis"><em>ViewController.m</em></span>) appear in the target’s Compile Sources build phase. If you create any further class files, you’ll specify that they should be added to the target, and they too will then have their implementation files listed in the Compile Sources build phase. This (the contents of the Compile Sources build phase) is how your target knows what files to compile to create the app’s binary.</p>
          <p>The binary that results from compilation of these files is your project’s <span class="emphasis"><em>executable</em></span>, and is placed into the app bundle, with its name being by default the same as the name of the target.<a id="idm441655186672" class="indexterm"></a>
<a id="idm441655185424" class="indexterm"></a> The system is able to locate the executable inside the app bundle and launch the app because the app bundle’s <span class="emphasis"><em>Info.plist</em></span> file has an “Executable file” key (<code class="literal">CFBundleExecutable</code>) whose value tells the system the name of the binary.</p>
          <p>Besides the class code files you create (or that Xcode creates for you), your project contains a <span class="emphasis"><em>main.m</em></span> file. This too is in the Compile Sources build phase; it had better be, because this file contains the all-important <code class="literal">main</code> function, the entry point to your app’s code! Here are the <code class="literal">main</code> function’s contents:<a id="idm441655180880" class="indexterm"></a></p>
          <pre class="screen">int main(int argc, char *argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil,
                                 NSStringFromClass([AppDelegate class]));
    }
}</pre>
          <p>The <code class="literal">main</code> function is very simple, but it’s crucial. It calls <code class="literal">UIApplicationMain</code>, which sets everything else in motion. <code class="literal">UIApplicationMain</code> is responsible for solving some tricky problems. As your app starts up, how will any of its code ever run? And how will its starting repertoire of instances ever be generated?<a id="idm441655176688" class="indexterm"></a> <code class="literal">UIApplicationMain</code> takes care of these issues. First, your app is a C program, and a C program’s <code class="literal">main</code> function is always called, to start the program running; thus, <code class="literal">UIApplicationMain</code> will in fact be called. Then, <code class="literal">UIApplicationMain</code> does the following things:<a id="idm441655173024" class="indexterm"></a></p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
                <p class="simpara">
It creates your very first instance — the shared application instance, subsequently accessible in code by calling <code class="literal">[UIApplication sharedApplication]</code>.<a id="idm441655170416" class="indexterm"></a>
<a id="idm441655169168" class="indexterm"></a> The third argument to <code class="literal">UIApplicationMain</code> specifies, as a string, what class the shared application instance should be an instance of. If nil, which will usually be the case, the default class is UIApplication; but you can subclass UIApplication and specify that subclass here by substituting something like this (depending on what the subclass is called) as the third argument:
</p>
                <pre class="screen">NSStringFromClass([MyUIApplicationSubclass class])</pre>
              </li>
              <li class="listitem">
Optionally, it also creates your second instance — the application instance’s <span class="emphasis"><em>delegate</em></span>. Delegation is an important and pervasive Cocoa pattern, described in detail in <a class="xref" href="ch10.html">Chapter 10</a>, but for now let’s just say that it is crucial that every app you write have an app delegate instance. The fourth argument to <code class="literal">UIApplicationMain</code> specifies, as a string, what class the app delegate instance should be. If this class is specified, as here, <code class="literal">UIApplicationMain</code> instantiates that class and ties that instance to the shared application instance as the latter’s delegate. If this class is <span class="emphasis"><em>not</em></span> specified (the fourth argument is nil), it is up to you to provide a delegate instance in some other way; since you cannot do this sufficiently early in code, you would have to do it through the loading of the main nib file. (Before iOS 5 and Xcode 4.2, this was in fact the usual way in which the app delegate was instantiated; but Apple has subsequently changed the default pattern so that the app delegate is generated in code by the call to <code class="literal">UIApplicationMain</code>.)<a id="idm441655160992" class="indexterm"></a>
</li>
              <li class="listitem">
If the <span class="emphasis"><em>Info.plist</em></span> file specifies a main storyboard file or main nib file, <code class="literal">UIApplicationMain</code> loads it. (In the latter case, the nib file’s owner is the shared application instance.)<a id="idm441655158144" class="indexterm"></a>
<a id="idm441655156736" class="indexterm"></a>
<a id="idm441655155488" class="indexterm"></a><a id="idm441655154624" class="indexterm"></a>
<a id="idm441655153120" class="indexterm"></a>
<a id="idm441655151872" class="indexterm"></a>
</li>
              <li class="listitem">
An app delegate instance has now been generated, either because <code class="literal">UIApplicationMain</code> instantiated it directly in response to the value of its fourth argument, or because <code class="literal">UIApplicationMain</code> loaded a main nib file which instantiated it. <code class="literal">UIApplicationMain</code> now turns to this app delegate instance and starts calling some of its code — in particular, it calls <code class="literal">application:didFinishLaunchingWithOptions:</code>, which is typically responsible, in turn, for displaying your app’s initial interface. (Starting in iOS 6, the sequence of calls to the app delegate’s code begins with <code class="literal">application:willFinishLaunchingWithOptions:</code> if it exists, as I’ll explain in <a class="xref" href="ch19.html">Chapter 19</a>).
</li>
              <li class="listitem">
The app is now launched and visible to the user. <code class="literal">UIApplicationMain</code> is still running (like Charlie on the M.T.A., <code class="literal">UIApplicationMain</code> never returns), and is now just sitting there, watching for the user to do something, maintaining the <span class="emphasis"><em>event loop</em></span>, which will respond to user actions as they occur.
</li>
            </ul>
          </div>
          <p>The call to <code class="literal">UIApplicationMain</code> is wrapped in some memory management functionality (the <code class="literal">@autoreleasepool</code> curly braces) that I’ll explain in <a class="xref" href="ch12.html">Chapter 12</a>.</p>
          <p>Finally, notice the file <span class="emphasis"><em>Empty Window-Prefix.pch</em></span> in the Project navigator. This is your project’s <span class="emphasis"><em>precompiled header</em></span> file. It isn’t listed in the Compile Sources build phase because it is actually compiled <span class="emphasis"><em>before</em></span> that build phase; the target knows about it because it is pointed to by the Prefix Header build setting.<a id="idm441655138608" class="indexterm"></a>
<a id="idm441655137360" class="indexterm"></a><a id="idm441655136496" class="indexterm"></a>
<a id="idm441655134992" class="indexterm"></a>
<a id="idm441655133744" class="indexterm"></a></p>
          <p>The precompiled header is a device for making compilation go faster. It’s a header file; it is compiled once (or at least, very infrequently) and the results are cached (off in the <span class="keep-together"><span class="emphasis"><em>DerivedData</em></span></span> folder) and are implicitly imported by all your code files. So the precompiled header should consist primarily of <code class="literal">#import</code> directives for headers that never change (such as the built-in Cocoa headers); it is also a reasonable place to put <code class="literal">#define</code>s that will never change and that are to be shared by all your code, as I mentioned in <a class="xref" href="ch04.html">Chapter 4</a>.</p>
          <p>The default precompiled header file imports <code class="literal">&lt;Foundation/Foundation.h&gt;</code> (the Core Foundation framework header) and <code class="literal">&lt;UIKit/UIKit.h&gt;</code> (the Cocoa framework). I’ll talk in the next section about what that means.</p>
          <div class="sidebar">
            <a id="SBrenamingProject"></a>
            <div class="titlepage">
              <div>
                <div>
                  <p class="title">Renaming Things</p>
                </div>
              </div>
            </div>
            <p>The name assigned to your project at creation time is used in many places throughout the project, leading beginners to worry that they can never rename a project without breaking something. But fear not! To rename a project, select the project listing at the top of the Project navigator, press Return to make its name editable, type the new name, and press Return again. Xcode presents a dialog proposing to change some other names to match, including the target, the built app, the precompiled header file, and the <span class="emphasis"><em>Info.plist</em></span> — and, by implication, the build settings specifying these. You can check or uncheck any name, and click Rename; your project will continue to work correctly.<a id="idm441655124720" class="indexterm"></a></p>
            <p>You can freely change the target name independently of the project name. It is the target name, not the project name, that is used to derive the name of the product and thus the bundle name, bundle display name, and bundle identifier mentioned earlier in this chapter. Thus, when you settle on a real name for your app, it might be sufficient to change the target name.<a id="idm441655123088" class="indexterm"></a></p>
            <p>Changing the project name (or target name) does not automatically change the scheme name to match. There is no particular need to do so, but you can change a scheme name freely; choose Product → Manage Schemes and click on the scheme name to make it editable.</p>
            <p>Changing the project name (or target name) does not automatically change the main group name to match. There is no particular need to do so, but you can freely change the name of a group in the Project navigator, because these names are arbitrary; they have no effect on the build settings or the build process. However, the main group is special, because (as I’ve already said) it corresponds to a real folder on disk, the folder that sits beside your project file at the top level of the project folder. You can change the group’s name (changing the project name does not do this for you automatically), but you should not delete it, and beginners should not change the name of the folder on disk to which it corresponds, as that folder name is hard-coded into several build settings.</p>
            <p>You can change the name of the project folder in the Finder at any time, and you can move the project folder in the Finder at will, because all build setting references to file and folder items in the project folder are relative.</p>
          </div>
        </div>
        <div class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="_frameworks_and_sdks"></a>Frameworks and SDKs</h3>
              </div>
            </div>
          </div>
          <p>A <span class="emphasis"><em>framework</em></span> is a library of compiled code used by your code. Most of the frameworks you are likely to use will be Apple’s built-in frameworks; they are built-in in the sense that they are part of the system on the device where your app will run — they live in <span class="keep-together"><span class="emphasis"><em>/System/Library/Frameworks</em></span></span> on the device, though you can’t tell that on an iPhone or iPad because there’s no way (normally) to view the file hierarchy directly.<a id="idm441655118352" class="indexterm"></a></p>
          <p>However, your code needs to use these frameworks not only when running on a device but also when building on your computer. It also needs them when running in the Simulator. To make all this possible, part of the device’s system — in particular, the part containing its frameworks — is duplicated on your computer, in the Developer folder. This duplicated subset of the device’s system is called an <span class="emphasis"><em>SDK</em></span> (for “software development kit”).</p>
          <p>To use a framework in your code, you must do two things:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Import the framework’s header
</span>
              </dt>
              <dd>
A framework has a header file, which provides (usually by importing other header files within the framework) the interface information about classes in that framework. Your code needs this information in order to <span class="emphasis"><em>compile</em></span> successfully. You import the header with an appropriate <code class="literal">#import</code> directive.
</dd>
              <dt>
                <span class="term">
Link to the framework
</span>
              </dt>
              <dd>
A framework is a package; you must instruct the build system to associate this package with your app’s executable binary, so that your binary’s calls to code within that framework can be routed into the framework’s compiled code. This is necessary in order for your app to <span class="emphasis"><em>run</em></span> successfully. Such an association is called <span class="emphasis"><em>linking</em></span> the binary with the framework, and this association must be formed when building. You instruct the build system to do this by including the framework in the target’s Link Binary With Libraries build phase.<a id="idm441655109856" class="indexterm"></a>
</dd>
            </dl>
          </div>
          <p>You might think that linkage is impossible because the framework that we ultimately want to use is off on a target device somewhere. But linkage is path-based, and the path is determined relative to the current SDK. When the app launches on the device, there is no SDK, and the path becomes absolute.</p>
          <p>So, for example, the linkage to the UIKit framework uses the path <span class="emphasis"><em>System/Library/Frameworks/UIKit.framework</em></span>. This path is relative to the current SDK. Thus:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
When we build for a device, we link to the <span class="emphasis"><em>System/Library/Frameworks/UIKit.framework</em></span> inside the current SDK, which is <span class="emphasis"><em>/Developer/Platforms/</em></span><span class="keep-together"><span class="emphasis"><em>iPhoneOS.platform/</em></span></span><span class="emphasis"><em>Developer/SDKs/iPhoneOS6.1.sdk</em></span>.
</li>
              <li class="listitem">
When we run on a device, there is no SDK, and the established linkage routes our code into the device’s top-level <span class="emphasis"><em>/System/Library/Frameworks/UIKit.framework</em></span>.
</li>
            </ul>
          </div>
          <p>By default, three frameworks are linked into your target:</p>
          <div class="variablelist">
            <dl>
              <dt>
                <span class="term">
Foundation
</span>
              </dt>
              <dd>
Many basic Cocoa classes, such as NSString and NSArray and others whose names begin with “NS,” are part of the Foundation framework. The Foundation framework is imported in the precompiled header file (and, by default, in the headers of new classes that you create). In turn, it imports the Core Foundation headers and loads the Core Foundation framework as a subframework; thus, there is no need for you to import or link explicitly to the Core Foundation framework (which is full of functions and pointer types whose names begin with “CF,” such as CFStringRef).<a id="idm441655098688" class="indexterm"></a>
<a id="idm441655097536" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
UIKit
</span>
              </dt>
              <dd>
Cocoa classes that are specialized for iOS, whose names begin with “UI,” are part of the UIKit framework. The UIKit framework is imported in the precompiled header file (and by class code files that constitute the app templates, such as <span class="emphasis"><em>AppDelegate.h</em></span>).<a id="idm441655093904" class="indexterm"></a>
<a id="idm441655092656" class="indexterm"></a>
</dd>
              <dt>
                <span class="term">
Core Graphics
</span>
              </dt>
              <dd>
The Core Graphics framework defines many structs and functions connected with drawing, whose names begin with “CG.” It is imported by many UIKit headers, so you don’t need to import it explicitly.<a id="idm441655095008" class="indexterm"></a>
<a id="idm441655088752" class="indexterm"></a>
</dd>
            </dl>
          </div>
          <p>You might find that the three default frameworks are sufficient to your needs, or you might find that you need other frameworks to provide additional functionality. How will you know that a class or function you want to use resides outside the three default frameworks? You might get a clue from its name, which won’t begin with “NS,” “UI,” or “CG”, but more often, if you’re like me, you’ll be alerted by banging up against the compiler.</p>
          <p>For example, let’s say you’ve just found out about animation (<a class="xref" href="ch17.html">Chapter 17</a>) and you’re raring to try it in your app. So, in your code, you create a CABasicAnimation:</p>
          <pre class="screen">CABasicAnimation* anim = [CABasicAnimation animation];</pre>
          <p>The next time you try to build your app, the compiler complains that CABasicAnimation is undeclared (and that it therefore can’t make sense of <code class="literal">anim</code> either).<a id="idm441655083264" class="indexterm"></a>
<a id="idm441655082016" class="indexterm"></a> That’s when you realize you need to import a framework header. Near the start of the CABasicAnimation class documentation is a line announcing that it’s in <span class="emphasis"><em>QuartzCore.framework</em></span>. You might guess (correctly) that the way to import the main Quartz Core framework header is to put this line near the start of your implementation file:</p>
          <pre class="screen">#import &lt;QuartzCore/QuartzCore.h&gt;</pre>
          <p>This works to quiet the compiler. Remember, though, that using a framework requires two things; we’ve done only one of them. So your code <span class="emphasis"><em>still</em></span> doesn’t build. This time, you get a build error during the link phase of the build process complaining about <code class="literal">_OBJC_CLASS_$_CABasicAnimation</code> and saying, “Symbol(s) not found.” That mysterious-sounding error merely means that you’ve forgotten to link your target to the Quartz Core framework.<a id="idm441655077120" class="indexterm"></a>
<a id="idm441655075872" class="indexterm"></a></p>
          <p>To link your target to a framework, edit the target, click Summary at the top of the editor, and scroll down to the Linked Frameworks and Libraries section. (This is the same information that appears which you click Build Phases at the top of the editor and open the Link Binary with Libraries build phase.) Click the Plus button at the left just below the frameworks. A dialog appears listing the existing frameworks that are part of the active SDK. Select <span class="emphasis"><em>QuartzCore.framework</em></span> and click Add. The Quartz Core framework is added to the target’s Link Binary With Libraries build phase. (It also appears in the Project navigator; you might like to drag it manually into the Frameworks group, for the sake of neatness.) Now you can build (and run) your app.</p>
          <p>You might wonder why the project isn’t linked by default to <span class="emphasis"><em>all</em></span> the frameworks, so that you don’t have to go through this process every time you stray beyond the default three frameworks. It’s just a matter of time and resources. Importing headers increases the size of your code; linking to frameworks slows down your app’s launch time. You should link to only the frameworks needed for your code to run.</p>
          <p>Where you import a framework header depends on how you intend to use it. It’s simply a matter of scope. If a framework’s classes are to be mentioned only within a single implementation file, then you can import it at the start of that implementation file. If you want to subclass one of the framework’s classes (or adopt one of its protocols, <a class="xref" href="ch10.html">Chapter 10</a>), you’ll need to import it at the start of the interface file that declares the subclass; in that case, every implementation file that imports this interface file imports the framework header, and there’s no need to import the framework header separately in the implementation file. Of course, for maximum scope, you can simply import the framework header in the precompiled header file, making that framework available throughout your code.</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt02.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Part II. IDE </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 7. Nib Management</td>
        </tr>
      </table>
    </div>
  </body>
</html>
