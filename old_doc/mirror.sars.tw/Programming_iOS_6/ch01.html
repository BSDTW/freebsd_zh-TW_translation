<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 1. Just Enough C</title>
    <link rel="stylesheet" type="text/css" href="docbook-xsl-mymods.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.0" />
    <link rel="home" href="index.html" />
    <link rel="up" href="pt01.html" />
    <link rel="prev" href="pt01.html" />
    <link rel="next" href="ch02.html" />
  </head>
  <body>
    <div class="mattnotice">
      <p>As a courtesy, this is a <b>full free</b> rendering of my book, <i>Programming iOS 6</i>, by Matt Neuburg. Copyright 2013 Matt Neuburg. Please note that this book has now been completely superseded by two more recent books, <a href="http://shop.oreilly.com/product/0636920032465.do">iOS 7 Fundamentals</a> and <a href="http://shop.oreilly.com/product/0636920031017.do">Programming iOS 7</a>. If my work has been of help to you, please <b>consider purchasing</b> one or both of them. Thank you!
	</p>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="pt01.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Part I. Language </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 2. Object-Based Programming</td>
        </tr>
      </table>
    </div>
    <div class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="chap_id1"></a>Chapter 1. Just Enough C</h2>
          </div>
        </div>
      </div>
      <div class="epigraph">
        <p>Do you believe in C? Do you believe in anything that has to do with me?</p>
        <div class="attribution">
          <span>—<span class="attribution">Leonard Bernstein and Stephen Schwartz, <em class="citetitle">Mass</em></span></span>
        </div>
      </div>
      <p>To program for iOS, you need to speak to iOS. Everything you say to iOS will be in accordance with the iOS <a id="idm441657682528" class="indexterm"></a>API. (An API, for <span class="emphasis"><em>application programming interface</em></span>, is a list or specification of things you are allowed to say when communicating.) Therefore, you will need some knowledge of the C programming language, for two reasons:
<a id="idxclanduage" class="indexterm"></a></p>
      <div class="itemizedlist">
        <ul class="itemizedlist" type="disc">
          <li class="listitem">
Most of the iOS API involves the Objective-C language, and most of your iOS programming will be in the Objective-C language; and Objective-C is a superset of C.<a id="idm441657679264" class="indexterm"></a> This means that Objective-C presupposes C; everything that is true of C trickles up to Objective-C. A common mistake is to forget that “<span class="keep-together">Objective-C</span> is C” and to neglect a basic understanding of C.<a id="idm441657677424" class="indexterm"></a>
<a id="idm441657676272" class="indexterm"></a>
</li>
          <li class="listitem">
Some of the iOS API involves C rather than Objective-C. Even in Objective-C code, you often need to use C data structures and C function calls. For example, a rectangle is represented as a CGRect, which is a C <span class="emphasis"><em>struct</em></span>, and to create a CGRect from four numbers you call <code class="literal">CGRectMake</code>, which is a C <span class="emphasis"><em>function</em></span>. The iOS API documentation will very often show you C expressions and expect you to understand them.
</li>
        </ul>
      </div>
      <p>The best way to learn C is to read <span class="emphasis"><em>The C Programming Language</em></span> (PTR Prentice Hall, 1988) by Brian W. Kernighan<a id="idm441657671872" class="indexterm"></a> and Dennis M. Ritchie,<a id="idm441657670976" class="indexterm"></a> commonly called K&amp;R<a id="idm441657670080" class="indexterm"></a> (Ritchie was the creator of C).<a id="idm441657669184" class="indexterm"></a>
<a id="idm441657668032" class="indexterm"></a> It is one of the best computer books ever written: brief, dense, and stunningly precise and clear. K&amp;R is so important for effective iOS (and Mac OS X) programming that I keep a physical copy beside me at all times while coding, and I recommend that you do the same. Another useful manual is <span class="emphasis"><em>The C Book</em></span>, by Mike Banahan, Declan Brady and Mark Doran, available online at
<a class="ulink" href="http://publications.gbdirect.co.uk/c_book/" target="_top">http://publications.gbdirect.co.uk/c_book/</a>.</p>
      <p>It would be impossible, and unnecessary, for me to describe all of C in a single chapter. C is not a large or difficult language, but it has some tricky corners and can be extremely subtle, powerful, and low-level. Moreover, since C is described fully and correctly in the manuals I’ve just mentioned, it would be a mistake for me to repeat what they can tell you better than I.</p>
      <p>You don’t have to know <span class="emphasis"><em>all</em></span> about C in order to use Objective-C effectively, though; so my purpose in this chapter is to outline those aspects of C that are important for you to understand at the outset, before you even start using Objective-C for iOS programming. That’s why this chapter is “Just Enough C”: it’s just enough to get you going, comfortably and safely. Just keep in mind that this chapter is <span class="emphasis"><em>not</em></span> a technical manual of C.</p>
      <p>If you know no C at all, I suggest that, as an accompaniment to this chapter, you also read select parts of K&amp;R (think of this as “C: The Good Parts Version”). Here’s my proposed K&amp;R syllabus:</p>
      <div class="itemizedlist">
        <ul class="itemizedlist" type="disc">
          <li class="listitem">
Quickly skim K&amp;R Chapter 1, the tutorial.
</li>
          <li class="listitem">
Carefully read K&amp;R Chapters 2 through 4.
</li>
          <li class="listitem">
Read the first three sections of K&amp;R Chapter 5 on pointers and arrays. You don’t need to read the rest of Chapter 5 because you won’t typically be doing any pointer arithmetic, but you do need to understand clearly what a pointer is, as Objective-C is all about objects, and every reference to an object is a pointer; you’ll be seeing and using that <code class="literal">*</code> character constantly.
</li>
          <li class="listitem">
Read also the first section of K&amp;R Chapter 6, on structures (structs); as a beginner, you probably won’t define any structs, but you will use them quite a lot, so you’ll need to know the notation (for example, as I’ve already said, a CGRect is a struct).
</li>
          <li class="listitem">
Glance over K&amp;R Appendix B, which covers the standard library, because you may find yourself making certain standard library calls, such as the mathematical functions; forgetting that the library exists is a typical beginner mistake.
</li>
        </ul>
      </div>
      <p>Just to make things a little more confusing, the C defined in K&amp;R is not precisely the C that forms the basis of Objective-C. Developments subsequent to K&amp;R have resulted in further C standards (ANSI C, C89, C99), and the Xcode compiler extends the C language in its own ways. By default, Xcode projects are treated as GNU99, which is itself an extension of C99 (though you could specify another C standard if you really wanted to). Fortunately, the most important differences between K&amp;R’s C and Xcode’s C are small, convenient improvements that are easily remembered, so K&amp;R remains the best and most reliable C reference.<a id="idm441657654688" class="indexterm"></a>
<a id="idm441657653472" class="indexterm"></a><a id="idm441657652704" class="indexterm"></a>
<a id="idm441657651552" class="indexterm"></a></p>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_compilation_statements_and_comments"></a>Compilation, Statements, and Comments</h2>
            </div>
          </div>
        </div>
        <p>C is a compiled language.<a id="idm441657649760" class="indexterm"></a>
<a id="idm441657648608" class="indexterm"></a> You write your program as text; to run the program, things proceed in two stages. First your text is compiled into machine instructions; then those machine instructions are executed. Thus, as with any compiled language, you can make two kinds of mistake:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
Any purely syntactic errors (meaning that you spoke the C language incorrectly) will be caught by the compiler, and the program won’t even begin to run.
</li>
            <li class="listitem">
If your program gets past the compiler, then it will run, but there is no guarantee that you haven’t made some other sort of mistake, which can be detected only by noticing that the program doesn’t behave as intended.
</li>
          </ul>
        </div>
        <p>The C compiler is fussy, but you should accept its interference with good grace. The compiler is your friend: learn to love it. It may emit what looks like an irrelevant or incomprehensible error message, but when it does, the fact is that you’ve done something wrong and the compiler has helpfully caught it for you. Also, the compiler can warn you if something seems like a possible mistake, even though it isn’t strictly illegal; these warnings, which differ from outright errors, are also helpful and should not be ignored.</p>
        <p>I have said that running a program requires a preceding stage: compilation. But in fact there is a third stage that precedes compilation: preprocessing.<a id="idm441657643648" class="indexterm"></a>
<a id="idm441657642416" class="indexterm"></a> (It doesn’t really matter whether you think of preprocessing as a stage preceding compilation or as the first stage of compilation.) Preprocessing modifies your text, so when your text is handed to the compiler, it is not identical to the text you wrote. Preprocessing might sound tricky and intrusive, but in fact it proceeds only according to your instructions and is helpful for making your code clearer and more compact.</p>
        <p>Xcode allows you to view the effects of preprocessing on your program text (choose Product → Generate Output → Preprocessed File), so if you think you’ve made a mistake in instructing the preprocessor, you can track it down. I’ll talk more later about some of the things you’re likely to say to the preprocessor.</p>
        <p>C is a statement-based language; every statement ends in a semicolon. (Forgetting the semicolon is a common beginner’s mistake.)<a id="idm441657639248" class="indexterm"></a>
<a id="idm441657637984" class="indexterm"></a> For readability, programs are mostly written with one statement per line, but this is by no means a hard and fast rule: long statements (which, unfortunately, arise very often because of Objective-C’s verbosity) are commonly split over multiple lines, and extremely short statements are sometimes written two or three to a line. You cannot split a line just anywhere, however; for example, a literal string can’t contain a return character. Indentation is linguistically meaningless and is purely a matter of convention (and C programmers argue over those conventions with near-religious fervor); Xcode helps “intelligently” by indenting automatically, and you can use its automatic indentation both to keep your code readable and to confirm that you’re not making any basic syntactic mistakes.</p>
        <p>Comments are delimited in K&amp;R C by <code class="literal">/* ... */</code>;<a id="idm441657636080" class="indexterm"></a>
<a id="idm441657634928" class="indexterm"></a> the material between the delimiters can consist of multiple lines (K&amp;R 1.2). In modern versions of C, a comment also can be denoted by two slashes (<code class="literal">//</code>); the rule is that if two slashes appear, they and everything after them on the same line are ignored:</p>
        <pre class="screen">int lower = 0; // lower limit of temperature table</pre>
        <p>These are sometimes called C++-style comments and are much more convenient for brief comments than the K&amp;R comment syntax.</p>
        <p>Throughout the C language (and therefore, throughout Objective-C as well), capitalization matters. All names are case-sensitive.<a id="idm441657631408" class="indexterm"></a>
<a id="idm441657630256" class="indexterm"></a> There is no such data type as Int; it’s lowercase “int.” If you declare an int called <code class="literal">lower</code> and then try to speak of the same variable as <code class="literal">Lower</code>, the compiler will complain. By convention, variable names tend to start with a lowercase letter.<a id="idm441657628096" class="indexterm"></a>
<a id="idm441657626688" class="indexterm"></a>
<a id="idm441657625536" class="indexterm"></a></p>
        <div class="sidebar">
          <a id="SBcompiler"></a>
          <div class="titlepage">
            <div>
              <div>
                <p class="title">Choosing a Compiler</p>
              </div>
            </div>
          </div>
          <p>The compiler situation in Xcode is rather complicated. Originally, Xcode’s compiler was the free open source GCC<a id="idm441657623456" class="indexterm"></a> (<a class="ulink" href="http://gcc.gnu.org" target="_top">http://gcc.gnu.org</a>). More recently, Xcode has phased in use of another free open source compiler, LLVM (<a class="ulink" href="http://llvm.org" target="_top">http://llvm.org</a>). Changing compilers is scary, so Apple has proceeded in stages, as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" type="disc">
              <li class="listitem">
A hybrid compiler, LLVM-GCC, provides the advantages of LLVM compilation, but the code is parsed with GCC for maximum backward compatibility.<a id="idm441657620496" class="indexterm"></a>
</li>
              <li class="listitem">
A pure LLVM compiler (also referred to as Clang) does its own parsing and provides more intelligent and helpful error messages and warnings.<a id="idm441657618688" class="indexterm"></a>
</li>
            </ul>
          </div>
          <p>As Xcode 3.2.x evolved, LLVM-GCC was eventually considered the best choice, but Apple was hesitant to make it the default compiler, so GCC remained the default. When Xcode 4 emerged, LLVM-GCC was the default compiler, but GCC remained available. Finally, in Xcode 4.2, LLVM 3.0 became the default compiler, and pure GCC was withdrawn; in Xcode 4.6, LLVM has advanced to version 4.2. (The choice of compiler is a project-level build setting; see <a class="xref" href="ch06.html">Chapter 6</a>.)</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_variable_declaration_initialization_and_data_types"></a>Variable Declaration, Initialization, and Data Types</h2>
            </div>
          </div>
        </div>
        <p>C is a strongly typed language.<a id="idm441657614912" class="indexterm"></a>
<a id="idm441657613504" class="indexterm"></a>
<a id="idm441657612352" class="indexterm"></a> Every variable<a id="idm441657611456" class="indexterm"></a>
<a id="idm441657610048" class="indexterm"></a>
<a id="idm441657608896" class="indexterm"></a> must be declared, indicating its data type, before it can be used.<a id="idm441657608000" class="indexterm"></a>
<a id="idm441657606848" class="indexterm"></a> Declaration can also involve explicit initialization, giving the variable a value; a variable that is declared but not explicitly initialized is of uncertain value (and should be regarded as dangerous until it <span class="emphasis"><em>is</em></span> initialized). In K&amp;R C, declarations must precede all other statements, but in modern versions of C, this rule is relaxed so that you don’t have to declare a variable until just before you start using it:</p>
        <pre class="screen">int height = 2;
int width = height * 2;
height = height + 1;
int area = height * width;</pre>
        <p>The basic built-in C data types are all numeric: char (one byte), int (four bytes), float and double (floating-point numbers), and varieties such as short (short integer), long (long integer), unsigned short, and so on.<a id="idm441657603680" class="indexterm"></a>
<a id="idm441657602528" class="indexterm"></a> A numeric literal may optionally express its type through a suffixed letter or letters: for example, <code class="literal">4</code> is an int, but <code class="literal">4UL</code> is an unsigned long; <code class="literal">4.0</code> is a double, but <code class="literal">4.0f</code> is a float.<a id="idm441657599584" class="indexterm"></a>
<a id="idm441657598432" class="indexterm"></a> Objective-C makes use of some further numeric types derived from the C numeric types (by way of the <code class="literal">typedef</code> statement, K&amp;R 6.7) designed to respond to the question of whether the processor is 64-bit; the most important of these are <a id="idm441657596736" class="indexterm"></a>NSInteger (along with NSUInteger) and <a id="idm441657596096" class="indexterm"></a>CGFloat. You don’t need to use them explicitly unless an API tells you to, and even when you do, just think of NSInteger as int and CGFloat as float, and you’ll be fine.</p>
        <p>To <span class="emphasis"><em>cast</em></span> (or <span class="emphasis"><em>typecast</em></span>) a variable’s value explicitly to another type, precede the variable’s name with the other type’s name in parentheses:<a id="idm441657593760" class="indexterm"></a>
<a id="idm441657592608" class="indexterm"></a>
<a id="idm441657591712" class="indexterm"></a></p>
        <pre class="screen">int height = 2;
float fheight = (float)height;</pre>
        <p>In that particular example, the explicit cast is unnecessary because the integer value will be cast to a float implicitly as it is assigned to a float variable, but it illustrates the notation. You’ll find yourself typecasting quite a bit in Objective-C, mostly to subdue the worries of the compiler (examples appear in <a class="xref" href="ch03.html">Chapter 3</a>).</p>
        <p>Another form of numeric initialization is the enum (K&amp;R 2.3).<a id="idm441657588672" class="indexterm"></a>
<a id="idm441657587520" class="indexterm"></a> It’s a way of assigning names to a sequence of numeric values and is useful when a value represents one of several possible options. The Cocoa API uses this device a lot. For example, the three possible types of status bar animation are defined like this:</p>
        <pre class="screen">typedef enum {
   UIStatusBarAnimationNone,
   UIStatusBarAnimationFade,
   UIStatusBarAnimationSlide,
} UIStatusBarAnimation;</pre>
        <p>That definition assigns the value 0 to the name <code class="literal">UIStatusBarAnimationNone</code>, the value 1 to the name <code class="literal">UIStatusBarAnimationFade</code>, and the value 2 to the name <code class="literal">UIStatusBarAnimationSlide</code>. The upshot is that you can use the suggestively meaningful names without caring about, or even knowing, the arbitrary numeric values they represent. It’s a useful idiom, and you may well have reason to define enums in your own code.</p>
        <div class="sidebar">
          <a id="SBnewenum"></a>
          <div class="titlepage">
            <div>
              <div>
                <p class="title">Modern Enum Notation</p>
              </div>
            </div>
          </div>
          <p>Starting with LLVM compiler version 4.0, which made its debut in Xcode 4.4, Objective-C extends the enum notation ever so slightly.<a id="idm441657581760" class="indexterm"></a> The status bar animation types, for example, are now defined like this:</p>
          <pre class="screen">typedef NS_ENUM(NSInteger, UIStatusBarAnimation) {
    UIStatusBarAnimationNone,
    UIStatusBarAnimationFade,
    UIStatusBarAnimationSlide,
};</pre>
          <p><code class="literal">NS_ENUM</code> is a macro, a form of preprocessor text substitution discussed at the end of this chapter; when the text substitution is performed, that code turns out to be shorthand for this:</p>
          <pre class="screen">typedef enum UIStatusBarAnimation : NSInteger UIStatusBarAnimation;
enum UIStatusBarAnimation : NSInteger {
    UIStatusBarAnimationNone,
    UIStatusBarAnimationFade,
    UIStatusBarAnimationSlide,
};</pre>
          <p>That looks almost exactly like the old way of expressing the same enum, but the new way involves some notation that isn’t part of standard C, telling the compiler what variety of integer value is being used here (it’s an NSInteger). This makes UIStatusBarAnimation a little more like a genuine data type. It also lets Xcode help you more intelligently — for example, when performing code completion, as discussed in <a class="xref" href="ch09.html">Chapter 9</a>. Another macro, <code class="literal">NS_OPTIONS</code>, evaluates in Objective-C as a synonym of <code class="literal">NS_ENUM</code> (they are distinct only in C++ code, which is not discussed in this book).</p>
        </div>
        <p>There appears to be a native text type (a string) in C, but this is something of an illusion; behind the scenes, it is actually a null-terminated array of char.<a id="idm441657575232" class="indexterm"></a>
<a id="idm441657574080" class="indexterm"></a> For example, in C you can write a string literal like this:
<a id="idm441657573056" class="indexterm"></a><a id="idm441657572288" class="indexterm"></a></p>
        <pre class="screen">"string"</pre>
        <p>But in fact this is stored as 7 bytes, the numeric (ASCII) equivalents of each letter followed by a byte consisting of 0 to signal the end of the string. This data structure, called a C string, is rarely encountered while programming iOS. In general, when working with strings, you’ll use an <span class="keep-together">Objective-C</span> object type called NSString. An NSString is totally different from a C string; it happens, however, that Objective-C lets you write a literal NSString in a way that looks very like a C string:<a id="idm441657569296" class="indexterm"></a>
<a id="idm441657568144" class="indexterm"></a></p>
        <pre class="screen">@"string"</pre>
        <p>Notice the at-sign! This expression is actually a directive to the Objective-C compiler to form an NSString object.<a id="idm441657566352" class="indexterm"></a>
<a id="idm441657565200" class="indexterm"></a> A common mistake is forgetting the at-sign, thus causing your expression to be interpreted as a C string, which is a completely different animal.<a id="idm441657564144" class="indexterm"></a>
<a id="idm441657562992" class="indexterm"></a></p>
        <p>Because the notation for literal NSStrings is modeled on the notation for C strings, it is worth knowing something about C strings, even though you won’t generally encounter them. For example, K&amp;R lists a number of escaped characters (K&amp;R 2.3), which you can also use in a literal NSString, including the following:<a id="idm441657561680" class="indexterm"></a>
<a id="idm441657559680" class="indexterm"></a></p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">\n</code>
</span>
            </dt>
            <dd>
A Unix newline character
</dd>
            <dt>
              <span class="term">
<code class="literal">\t</code>
</span>
            </dt>
            <dd>
A tab character
</dd>
            <dt>
              <span class="term">
<code class="literal">\"</code>
</span>
            </dt>
            <dd>
A quotation mark (escaped to show that this is not the end of the string literal)
</dd>
            <dt>
              <span class="term">
<code class="literal">\\</code>
</span>
            </dt>
            <dd>
A backslash
</dd>
          </dl>
        </div>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>NSStrings are natively Unicode-based, but because Objective-C is C, including non-ASCII characters in a literal NSString was, until quite recently, remarkably tricky, and you needed to know about such things as the <code class="literal">\x</code> and <code class="literal">\u</code> escape sequences. Now, however, it is perfectly legal to type a non-ASCII character directly into an NSString literal, and you should ignore old Internet postings (and even an occasional sentence in Apple’s own documentation) warning that it is not.<a id="idm441657547888" class="indexterm"></a>
<a id="idm441657546736" class="indexterm"></a></p>
        </div>
        <p>K&amp;R also mention a notation for concatenating string literals, in which multiple string literals separated only by white space are automatically concatenated and treated as a single string literal. This notation is useful for splitting a long string into multiple lines for legibility, and Objective-C copies this convention for literal NSStrings as well, except that you have to remember the at-sign:<a id="idm441657548528" class="indexterm"></a>
<a id="idm441657543744" class="indexterm"></a></p>
        <pre class="screen">@"This is a big long literal string "
@"which I have broken over two lines of code.";</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_structs"></a>Structs</h2>
            </div>
          </div>
        </div>
        <p>C offers few simple native data types, so how are more complex data types made? There are three ways: structures, pointers, and arrays. Both structures and pointers are going to be crucial when you’re programming iOS. You’re less likely to need a C array, because Objective-C has its own NSArray object type, but it will arise in a couple of examples later in this book.</p>
        <p>A C structure, usually called a struct (K&amp;R 6.1), is a compound data type: it combines multiple data types into a single type,<a id="idm441657541008" class="indexterm"></a>
<a id="idm441657538624" class="indexterm"></a> which can be passed around as a single entity. Moreover, the elements constituting the compound entity have names and can be accessed by those names through the compound entity, using dot-notation.<a id="idm441657537520" class="indexterm"></a> The iOS API has many commonly used structs, typically accompanied by convenience functions for working with them.</p>
        <p>For example, the iOS documentation tells you that a CGPoint is defined as follows:<a id="idm441657536112" class="indexterm"></a></p>
        <pre class="screen">struct CGPoint {
   CGFloat x;
   CGFloat y;
};
typedef struct CGPoint CGPoint;</pre>
        <p>Recall that a CGFloat is basically a float, so this is a compound data type made up of two simple native data types; in effect, a CGPoint has two CGFloat parts, and their names are <code class="literal">x</code> and <code class="literal">y</code>. (The rather odd-looking last line merely asserts that one can use the term <code class="literal">CGPoint</code> instead of the more verbose <code class="literal">struct CGPoint</code>.) So we can write:</p>
        <pre class="screen">CGPoint myPoint;
myPoint.x = 4.3;
myPoint.y = 7.1;</pre>
        <p>Just as we can assign to <code class="literal">myPoint.x</code> to <span class="emphasis"><em>set</em></span> this part of the struct, we can say <code class="literal">myPoint.x</code> to <span class="emphasis"><em>get</em></span> this part of the struct. It’s as if <code class="literal">myPoint.x</code> were the name of a variable. Moreover, an element of a struct can itself be a struct, and the dot-notation can be chained. To illustrate, first note the existence of another iOS struct, CGSize:<a id="idm441657528608" class="indexterm"></a></p>
        <pre class="screen">struct CGSize {
   CGFloat width;
   CGFloat height;
};
typedef struct CGSize CGSize;</pre>
        <p>Put a CGPoint and a CGSize together and you’ve got a CGRect:<a id="idm441657526736" class="indexterm"></a></p>
        <pre class="screen">struct CGRect {
   CGPoint origin;
   CGSize size;
};
typedef struct CGRect CGRect;</pre>
        <p>So suppose we’ve got a CGRect variable called <code class="literal">myRect</code>, already initialized. Then <code class="literal">myRect.origin</code> is a CGPoint, and <code class="literal">myRect.origin.x</code> is a CGFloat. Similarly, <code class="literal">myRect.size</code> is a CGSize, and <code class="literal">myRect.size.width</code> is a CGFloat. You could change just the <code class="literal">width</code> part of our CGRect directly, like this:</p>
        <pre class="screen">myRect.size.width = 8.6;</pre>
        <p>Instead of initializing a struct by assigning to each of its elements, you can initialize it at declaration time by assigning values for all its elements at once, in curly braces and separated by commas, like this:<a id="idm441657520528" class="indexterm"></a>
<a id="idm441657519376" class="indexterm"></a></p>
        <pre class="screen">CGPoint myPoint = { 4.3, 7.1 };
CGRect myRect = { myPoint, {10, 20} };</pre>
        <p>You don’t actually have to be assigning to a struct-typed variable to use a struct initializer; you can use an initializer anywhere the given struct type is expected, but you might also have to cast to that struct type in order to explain to the compiler what your curly braces mean, like this:</p>
        <pre class="screen">CGContextFillRect(con, (CGRect){myPoint, {10, 20}});</pre>
        <p>In that example, <code class="literal">CGContextFillRect</code> is a function. I’ll talk about functions later in this chapter, but the upshot of the example is that what comes after the first comma has to be a CGRect, and can therefore be a CGRect initializer provided this is accompanied by a CGRect cast.</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_pointers"></a>Pointers</h2>
            </div>
          </div>
        </div>
        <p>The other big way that C extends its range of data types is by means of pointers (K&amp;R 5.1).<a id="idm441657513536" class="indexterm"></a>
<a id="idm441657512384" class="indexterm"></a> A pointer is an integer (of some size or other) with a meaning: it designates the location in memory where the real data is to be found. Knowing the structure of that data and how to work with it, as well as allocating a block of memory of the required size beforehand and disposing of that block of memory when it’s no longer needed, is a very complicated business. Luckily, this is exactly the sort of complicated business that Objective-C is going to take care of for us. So all you really have to know to use pointers is what they are and what notation is used to refer to them.</p>
        <p>Let’s start with a simple declaration. If we wanted to declare an integer in C, we could say:</p>
        <pre class="screen">int i;</pre>
        <p>That line says, “<code class="literal">i</code> is an integer.” Now let’s instead declare a <span class="emphasis"><em>pointer</em></span> to an integer:<a id="idm441657508272" class="indexterm"></a>
<a id="idm441657506864" class="indexterm"></a>
<a id="idm441657505712" class="indexterm"></a></p>
        <pre class="screen">int* intPtr;</pre>
        <p>That line says, “<code class="literal">intPtr</code> is a pointer to an integer.” Never mind how we know there really is going to be an integer at the address designated by this pointer; here, I’m concerned only with the notation. It is permitted to place the asterisk in the declaration before the name rather than after the type:</p>
        <pre class="screen">int *intPtr;</pre>
        <p>You could even put a space on both sides of the asterisk (though this is rarely done):</p>
        <pre class="screen">int * intPtr;</pre>
        <p>I prefer the first form, but I do occasionally use the second form, and Apple quite often uses it, so be sure you understand that these are all ways of saying the same thing. No matter how the spaces are inserted, the name of the type is still <code class="literal">int*</code>. If you are asked what type <code class="literal">intPtr</code> is, the answer is <code class="literal">int*</code> (a pointer to an int); the asterisk is part of the name of the type of this variable. If you needed to cast a variable <code class="literal">p</code> to this type, you’d cast like this: <code class="literal">(int*)p</code>. Once again, it is possible that you’ll see code where there’s a space before the asterisk, like this: <code class="literal">(int *)p</code>.</p>
        <p>Pointers are very important in Objective-C, because Objective-C is all about objects (<a class="xref" href="ch02.html">Chapter 2</a>), and every variable referring to an object is itself a pointer. For example, I’ve already mentioned that the Objective-C string type is called NSString. So the way to declare an NSString variable is as a pointer to an NSString:</p>
        <pre class="screen">NSString* s;</pre>
        <p>An NSString literal is an NSString value, so we can even declare and initialize this NSString object, thus writing a seriously useful line of Objective-C code:</p>
        <pre class="screen">NSString* s = @"Hello, world!";</pre>
        <p>In pure C, having declared a pointer-to-integer called <code class="literal">intPtr</code>, you are liable to speak later in your code of <code class="literal">*intPtr</code>.
This notation, outside of a declaration, means “the thing pointed to by the pointer <code class="literal">intPtr</code>.”
You speak of <code class="literal">*intPtr</code> because you wish to access the integer at the far end of the pointer; this is called <span class="emphasis"><em>dereferencing</em></span> the pointer.<a id="idm441657491712" class="indexterm"></a>
<a id="idm441657490304" class="indexterm"></a>
<a id="idm441657489152" class="indexterm"></a></p>
        <p>But in Objective-C, this is generally <span class="emphasis"><em>not</em></span> the case. In your code, you’ll be treating the pointer to an object as the object; you’ll never dereference it. So, for example, having declared <code class="literal">s</code> as a pointer to an NSString, you will <span class="emphasis"><em>not</em></span> then proceed to speak of <code class="literal">*s</code>; rather, you will speak simply of <code class="literal">s</code>, as if it <span class="emphasis"><em>were</em></span> the string. All the Objective-C stuff you’ll want to do with an object will expect the pointer, not the object at the far end of the pointer; behind the scenes, Objective-C itself will take care of the messy business of following the pointer to its block of memory and doing whatever needs to be done in that block of memory. This fact is extremely convenient for you as a programmer, but it does cause Objective-C users to speak a little loosely; we tend to say that “<code class="literal">s</code> is an NSString,” when of course it is actually a pointer to an NSString.</p>
        <p>The logic of how pointers work, both in C and in Objective-C, is different from the logic of how simple data types work. The difference is particularly evident with assignment. Assignment to a simple data type changes the data value. Assignment to a pointer repoints the pointer. Suppose <code class="literal">ptr1</code> and <code class="literal">ptr2</code> are both pointers, and you say:<a id="idm441657482640" class="indexterm"></a>
<a id="idm441657481232" class="indexterm"></a>
<a id="idm441657480080" class="indexterm"></a></p>
        <pre class="screen">ptr1 = ptr2;</pre>
        <p>Now <code class="literal">ptr1</code> and <code class="literal">ptr2</code> are pointing at the same thing. Any change to the thing pointed to by <code class="literal">ptr1</code> will also change the thing pointed to by <code class="literal">ptr2</code>, because they are the same thing (<a class="xref" href="ch01.html#FIG1">Figure 1.1</a>). Meanwhile, whatever <code class="literal">ptr1</code> was pointing to before the assignment is now not being pointed to by <code class="literal">ptr1</code>; it might, indeed, be pointed to by nothing (which could be bad). A firm understanding of these facts is crucial when working in Objective-C, and I’ll return to this topic in <a class="xref" href="ch03.html">Chapter 3</a>.</p>
        <div class="figure">
          <a id="FIG1"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0101.png" alt="figs/pios_0101.png" />
            </div>
          </div>
          <p class="title">Figure 1.1. Pointers and assignment</p>
        </div>
        <br class="figure-break" />
        <p>The most general type of pointer is <span class="emphasis"><em>pointer-to-void</em></span> (<code class="literal">void*</code>),<a id="idm441657470400" class="indexterm"></a> the <span class="emphasis"><em>generic pointer</em></span>.<a id="idm441657469120" class="indexterm"></a>
<a id="idm441657467712" class="indexterm"></a>
<a id="idm441657466560" class="indexterm"></a> It is legal to use a generic pointer wherever a specific type of pointer is expected. In effect, pointer-to-void casts away type checking as to what’s at the far end of the pointer. Thus, the following is legal:</p>
        <pre class="screen">int* p1; // and pretend p1 has a value
void* p2;
p2 = p1;
p1 = p2;</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_arrays"></a>Arrays</h2>
            </div>
          </div>
        </div>
        <p>A C array (K&amp;R 5.3) consists of multiple elements of the same data type.<a id="idm441657463232" class="indexterm"></a>
<a id="idm441657462080" class="indexterm"></a> An array declaration<a id="idm441657461184" class="indexterm"></a> states the data type of the elements, followed by the name of the array, along with square brackets containing the number of elements:
<a id="idm441657459856" class="indexterm"></a><a id="idm441657459088" class="indexterm"></a></p>
        <pre class="screen">int arr[3]; // means: arr is an array consisting of 3 ints</pre>
        <p>To refer to an element of an array, use the array’s name followed by the element number in square brackets. The first element of an array is numbered <code class="literal">0</code>. So we can initialize an array by assigning values to each element in turn:</p>
        <pre class="screen">int arr[3];
arr[0] = 123;
arr[1] = 456;
arr[2] = 789;</pre>
        <p>Alternatively, you can initialize an array at declaration time by assigning a list of values in curly braces, just as with a struct.<a id="idm441657455328" class="indexterm"></a>
<a id="idm441657454176" class="indexterm"></a> In this case, the size of the array can be omitted from the declaration, because it is implicit in the initialization (K&amp;R 4.9):</p>
        <pre class="screen">int arr[] = {123, 456, 789};</pre>
        <p>Curiously, the name of an array is the name of a pointer (to the first element of the array). Thus, for example, having declared <code class="literal">arr</code> as in the preceding examples, you can use <code class="literal">arr</code> wherever a value of type <code class="literal">int*</code> (a pointer to an int) is expected. This fact is the basis of some highly sophisticated C idioms that you almost certainly won’t need to know about (which is why I don’t recommend that you read any of K&amp;R Chapter 5 beyond section 3).</p>
        <p>C arrays rarely arise in practice when programming iOS, because you’ll work mostly with the NSArray object type instead. But here’s a case where they do. The function <code class="literal">CGContextStrokeLineSegments</code> is declared like this:</p>
        <pre class="screen">void CGContextStrokeLineSegments (
   CGContextRef c,
   const CGPoint points[],
   size_t count
);</pre>
        <p>The second parameter is an array (meaning a C array) of CGPoints. That’s what the square brackets tell you. So to call this function, you’d need to know at least how to make an array of CGPoints. You might do it like this:</p>
        <pre class="screen">CGPoint arr[] = {{4,5}, {6,7}, {8,9}, {10,11}};</pre>
        <p>Having done that, you can pass <code class="literal">arr</code> as the second argument in a call to <code class="literal">CGContextStrokeLineSegments</code>.</p>
        <p>Also, a C string, as I’ve already mentioned, is actually an array. For example, the NSString method <code class="literal">stringWithUTF8String:</code> takes (according to the documentation) “a NULL-terminated C array of bytes in UTF8 encoding;” but the parameter is declared not as an array, but as a <code class="literal">char*</code>.<a id="idm441657443616" class="indexterm"></a> Those are the same thing, and are both ways of saying that this method takes a C string.<a id="idm441657442720" class="indexterm"></a></p>
        <p>(The colon at the end of the method name <code class="literal">stringWithUTF8String:</code> is not a misprint; many Objective-C method names end with a colon. I’ll explain why in <a class="xref" href="ch03.html">Chapter 3</a>.)</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_operators"></a>Operators</h2>
            </div>
          </div>
        </div>
        <p>Arithmetic operators are straightforward (K&amp;R 2.5),<a id="idm441657439232" class="indexterm"></a>
<a id="idm441657437824" class="indexterm"></a>
<a id="idm441657436672" class="indexterm"></a> but watch out for the rule that “integer division truncates any fractional part.” This rule is the cause of much novice error in C.<a id="idm441657419216" class="indexterm"></a>
<a id="idm441657418064" class="indexterm"></a> If you have two integers and you want to divide them in such a way as to get a fractional result, you must represent at least one of them as a float:</p>
        <pre class="screen">int i = 3;
float f = i/2; // beware! not 1.5</pre>
        <p>To get 1.5, you should have written <code class="literal">i/2.0</code> or <code class="literal">(float)i/2</code>.</p>
        <p>The integer increment and decrement<a id="idm441657414704" class="indexterm"></a>
<a id="idm441657413296" class="indexterm"></a>
<a id="idm441657412144" class="indexterm"></a> operators (K&amp;R 2.8), <code class="literal">++</code> and <code class="literal">--</code>, work differently depending on whether they precede or follow their variable.<a id="idm441657410224" class="indexterm"></a>
<a id="idm441657408816" class="indexterm"></a>
<a id="idm441657407664" class="indexterm"></a> The expression <code class="literal">++i</code> replaces the value of <code class="literal">i</code> by 1 more than its current value and then uses the resulting value; the expression <code class="literal">i++</code> uses the current value of <code class="literal">i</code> and then replaces it with 1 more than its current value. This is one of C’s coolest features.</p>
        <p>C also provides bitwise operators (K&amp;R 2.9), such as bitwise-and (<code class="literal">&amp;</code>) and bitwise-or (<code class="literal">|</code>); they operate on the individual binary bits that constitute integers.<a id="idm441657403152" class="indexterm"></a>
<a id="idm441657401744" class="indexterm"></a>
<a id="idm441657400592" class="indexterm"></a> Of these, the one you are most likely to need is bitwise-or, because the Cocoa API often uses bits as switches when multiple options are to be specified simultaneously. For example, there are various ways in which a UIView can be resized automatically as its superview is resized, and you’re supposed to provide one or more of these when setting a UIView’s <code class="literal">autoresizingMask</code> property. The autoresizing options are listed in the documentation as follows:</p>
        <pre class="screen">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
   UIViewAutoresizingNone                 = 0,
   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,
   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,
   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,
   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,
   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,
   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5
};</pre>
        <p>The <code class="literal">&lt;&lt;</code> symbol is the left shift operator; the right operand says how many bits to shift the left operand. So pretend that an NSUInteger is 8 bits (it isn’t, but let’s keep things simple and short). Then this enum means that the following name–value pairs are defined (using binary notation for the values):</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
<code class="literal">UIViewAutoresizingNone</code>
</span>
            </dt>
            <dd>
<code class="literal">00000000</code>
</dd>
            <dt>
              <span class="term">
<code class="literal">UIViewAutoresizingFlexibleLeftMargin</code>
</span>
            </dt>
            <dd>
<code class="literal">00000001</code>
</dd>
            <dt>
              <span class="term">
<code class="literal">UIViewAutoresizingFlexibleWidth</code>
</span>
            </dt>
            <dd>
<code class="literal">00000010</code>
</dd>
            <dt>
              <span class="term">
<code class="literal">UIViewAutoresizingFlexibleRightMargin</code>
</span>
            </dt>
            <dd>
<code class="literal">00000100</code>
</dd>
            <dt>
              <span class="term">
<code class="literal">UIViewAutoresizingFlexibleTopMargin</code>
</span>
            </dt>
            <dd>
<code class="literal">00001000</code>
</dd>
          </dl>
        </div>
        <p>and so on. The reason for this bit-based representation is that these values can be combined into a single value (a <span class="emphasis"><em>bitmask</em></span>)<a id="idm441657381088" class="indexterm"></a> that you pass to set the <code class="literal">autoresizingMask</code>. All Cocoa has to do to understand your intentions is to look to see which bits in the value that you pass are set to 1. So, for example, <code class="literal">00001010</code> would mean that <code class="literal">UIViewAutoresizingFlexibleTopMargin</code> and <code class="literal">UIViewAutoresizingFlexibleWidth</code> are true (and that the others, by implication, are all false).</p>
        <p>The question is how to form the value <code class="literal">00001010</code> in order to pass it. You could just do the math, figure out that binary <code class="literal">00001010</code> is decimal 10, and set the <code class="literal">autoresizingMask</code> property to 10, but that’s not what you’re supposed to do, and it’s not a very good idea, because it’s error-prone and makes your code incomprehensible. Instead, use the <span class="keep-together">bitwise-or</span> operator to combine the desired options:</p>
        <pre class="screen">myView.autoresizingMask =
    UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleWidth;</pre>
        <p>This notation works because the bitwise-or operator combines its operands by setting in the result any bits that are set in either of the operands, so <code class="literal">00001000 | 00000010</code> is <code class="literal">00001010</code>, which is just the value we’re trying to convey. (And how does the runtime parse the bitmask to discover whether a given bit is set? With the bitwise-and operator.)</p>
        <p>Simple assignment (K&amp;R 2.10) is by the equal sign.<a id="idm441657371936" class="indexterm"></a>
<a id="idm441657370784" class="indexterm"></a> But there are also compound assignment operators that combine assignment with some other operation.<a id="idm441657369776" class="indexterm"></a> For example:</p>
        <pre class="screen">height *= 2; // same as saying: height = height * 2;</pre>
        <p>The ternary operator (<code class="literal">?:</code>) is a way of specifying one of two values depending on a condition (K&amp;R 2.11). The scheme is as follows:<a id="idm441657367328" class="indexterm"></a>
<a id="idm441657365920" class="indexterm"></a>
<a id="idm441657364768" class="indexterm"></a></p>
        <pre class="screen">(<span class="emphasis"><em>condition</em></span>) ? <span class="emphasis"><em>exp1</em></span> : <span class="emphasis"><em>exp2</em></span></pre>
        <p>If the condition is true (see the next section for what that means), the expression <span class="emphasis"><em><code class="literal">exp1</code></em></span> is evaluated and the result is used; otherwise, the expression <span class="emphasis"><em><code class="literal">exp2</code></em></span> is evaluated and the result is used. For example, you might use the ternary operator while performing an assignment, using this schema:</p>
        <pre class="screen">myVariable = (<span class="emphasis"><em>condition</em></span>) ? <span class="emphasis"><em>exp1</em></span> : <span class="emphasis"><em>exp2</em></span>;</pre>
        <p>What gets assigned to <code class="literal">myVariable</code> depends on the truth value of the condition. There’s nothing happening here that couldn’t be accomplished more verbosely with flow control (see the next section), but the ternary operator can greatly improve clarity, and I use it a lot.</p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_flow_control_and_conditions"></a>Flow Control and Conditions</h2>
            </div>
          </div>
        </div>
        <p>Basic flow control is fairly simple and usually involves a condition in parentheses and a block of conditionally executed code in curly braces.<a id="idm441657356032" class="indexterm"></a>
<a id="idm441657354880" class="indexterm"></a> These curly braces constitute a new scope, into which new variables can be introduced.<a id="idm441657353984" class="indexterm"></a>
<a id="idm441657352832" class="indexterm"></a> So, for example:</p>
        <pre class="screen">if (x == 7) {
    int i = 0;
    i += 1;
}</pre>
        <p>After the closing curly brace in the fourth line, the <code class="literal">i</code> introduced in the second line has ceased to exist, because its scope is the inside of the curly braces. If the contents of the curly braces consist of a single statement, the curly braces can be omitted, but I would advise beginners against this shorthand, as you can confuse yourself.<a id="idm441657350240" class="indexterm"></a>
<a id="idm441657349088" class="indexterm"></a> A common beginner mistake (which will be caught by the compiler) is forgetting the parentheses around the condition.<a id="idm441657348064" class="indexterm"></a>
<a id="idm441657346912" class="indexterm"></a> The full set of flow control statements is given in K&amp;R Chapter 3, and I’ll just summarize them schematically here (<a class="xref" href="ch01.html#EXflowcontrol">Example 1.1</a>).<a id="idm441657345312" class="indexterm"></a><a id="idm441657344544" class="indexterm"></a><a id="idm441657343776" class="indexterm"></a><a id="idm441657343008" class="indexterm"></a></p>
        <div class="example">
          <a id="EXflowcontrol"></a>
          <p class="title">Example 1.1. The C flow control constructs</p>
          <div class="example-contents">
            <pre class="screen">if (<span class="emphasis"><em>condition</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
}

if (<span class="emphasis"><em>condition</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
} else {
    <span class="emphasis"><em>statements</em></span>;
}

if (<span class="emphasis"><em>condition</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
} else if (<span class="emphasis"><em>condition</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
} else {
    <span class="emphasis"><em>statements</em></span>;
}

while (<span class="emphasis"><em>condition</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
}

do {
    <span class="emphasis"><em>statements</em></span>;
} while (<span class="emphasis"><em>condition</em></span>);

for (<span class="emphasis"><em>before-all</em></span>; <span class="emphasis"><em>condition</em></span>; <span class="emphasis"><em>after-each</em></span>) {
    <span class="emphasis"><em>statements</em></span>;
}</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>The <code class="literal">if...else if...else</code> structure can have as many <code class="literal">else if</code> blocks as needed, and the <code class="literal">else</code> block is optional. Instead of an extended <code class="literal">if...else if...else if...else</code> structure, when the conditions would consist of comparing various values against a single value, you can use the <code class="literal">switch</code> statement; be careful, though, as it is rather confusing and can easily go wrong (see K&amp;R 3.4 for full details). The main trick is to remember to end every case with a <code class="literal">break</code> statement, unless you want it to “fall through” to the next case (<a class="xref" href="ch01.html#EXswitch">Example 1.2</a>).<a id="idm441657329760" class="indexterm"></a></p>
        <div class="example">
          <a id="EXswitch"></a>
          <p class="title">Example 1.2. A switch statement</p>
          <div class="example-contents">
            <pre class="screen">NSString* key;
switch (tag) {
    case 1: { // i.e., if tag is 1
        key = @"lesson";
        break;
    }
    case 2: { // i.e., if tag is 2
        key = @"lessonSection";
        break;
    }
    case 3: { // i.e., if tag is 3
        key = @"lessonSectionPartFirstWord";
        break;
    }
}</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>The C for loop<a id="idm441657326592" class="indexterm"></a>
<a id="idm441657325440" class="indexterm"></a> needs some elaboration for beginners (<a class="xref" href="ch01.html#EXflowcontrol">Example 1.1</a>). The <span class="emphasis"><em><code class="literal">before-all</code></em></span> statement is executed once as the for loop is first encountered and is usually used for initialization of the counter. The condition is then tested, and if true, the block is executed; the condition is usually used to test whether the counter has reached its limit. The <span class="emphasis"><em><code class="literal">after-each</code></em></span> statement is then executed, and is usually used to increment or decrement the counter; the condition is then immediately tested again. Thus, to execute a block using integer values 1, 2, 3, 4, and 5 for <code class="literal">i</code>, the notation is:</p>
        <pre class="screen">int i;
for (i = 1; i &lt; 6; i++) {
    // ... statements ...
}</pre>
        <p>The need for a counter intended to exist solely within the for loop is so common that C99 permits the declaration of the counter as part of the <span class="emphasis"><em><code class="literal">before-all</code></em></span> statement; the declared variable’s scope is then inside the curly braces:</p>
        <pre class="screen">for (int i = 1; i &lt; 6; i++) {
    // ... statements ...
}</pre>
        <p>The for loop is one of the few areas in which Objective-C extends C’s flow-control syntax. Certain Objective-C objects represent enumerable collections of other objects; “enumerable” basically means that you can cycle through the collection, and cycling through a collection is called <span class="emphasis"><em>enumerating</em></span> the collection.<a id="idm441657317872" class="indexterm"></a> To make enumerating easy, Objective-C provides a <code class="literal">for...in</code> operator, which works like a for loop:<a id="idm441657316464" class="indexterm"></a></p>
        <pre class="screen">SomeType* oneItem;
for (oneItem in myCollection) {
    // ... statements ....
}</pre>
        <p>On each pass through the loop, the variable <code class="literal">oneItem</code> (or whatever you call it) takes on the next value from within the collection. As with the C99 for loop, <code class="literal">oneItem</code> can be declared in the <code class="literal">for</code> statement, limiting its scope to the curly braces:</p>
        <pre class="screen">for (SomeType* oneItem in myCollection) {
    // ... statements ....
}</pre>
        <p>To abort a loop from inside the curly braces, use the <code class="literal">break</code> statement.<a id="idm441657311728" class="indexterm"></a> To abort the current iteration from within the curly braces and proceed to the next iteration, use the <code class="literal">continue</code> statement.<a id="idm441657310208" class="indexterm"></a> In the case of <code class="literal">while</code> and <code class="literal">do</code>, <code class="literal">continue</code> means to perform immediately the conditional test; in the case of a for loop, <code class="literal">continue</code> means to perform immediately the <span class="emphasis"><em><code class="literal">after-each</code></em></span> statement and then the conditional test.</p>
        <p>C also has a <code class="literal">goto</code> statement that allows you to jump to a named (labeled) line in your code (K&amp;R 3.8); even though <code class="literal">goto</code> is notoriously “considered harmful,” there are situations in which it is pretty much necessary, especially because C’s flow control is otherwise so primitive.<a id="idm441657304720" class="indexterm"></a></p>
        <div class="note" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Note</h3>
          <p>It is permissible for a C statement to be compounded of multiple statements, separated by commas,<a id="idm441657303328" class="indexterm"></a>
<a id="idm441657302176" class="indexterm"></a> to be executed sequentially.<a id="idm441657301280" class="indexterm"></a>
<a id="idm441657300128" class="indexterm"></a> The last of the multiple statements is the value of the compound statement as a whole. This construct, for instance, lets you perform some secondary action before each test of a condition or perform more than one <span class="emphasis"><em><code class="literal">after-each</code></em></span> action (an example appears in <a class="xref" href="ch17.html">Chapter 17</a>).</p>
        </div>
        <p>We can now turn to the question of what a condition consists of.<a id="idm441657297600" class="indexterm"></a>
<a id="idm441657296448" class="indexterm"></a> C has no separate boolean type; a condition either evaluates to 0, in which case it is considered false, or it doesn’t, in which case it is true. Comparisons are performed using the equality and relational<a id="idm441657295552" class="indexterm"></a>
<a id="idm441657293888" class="indexterm"></a>
<a id="idm441657292736" class="indexterm"></a> operators (K&amp;R 2.6); for example, <code class="literal">==</code> compares for equality, and <code class="literal">&lt;</code> compares for whether the first operand is less than the second.<a id="idm441657290704" class="indexterm"></a>
<a id="idm441657289552" class="indexterm"></a> Logical expressions can be combined using the logical-and operator (<code class="literal">&amp;&amp;</code>) and the logical-or operator (<code class="literal">||</code>); using these along with parentheses and the not operator (<code class="literal">!</code>) you can form complex conditions. Evaluation of logical-and and logical-or expressions is short-circuited, meaning that if the left condition settles the question, the right condition is never even evaluated.<a id="idm441657286896" class="indexterm"></a>
<a id="idm441657285488" class="indexterm"></a>
<a id="idm441657284336" class="indexterm"></a></p>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Don’t confuse the logical-and operator (<code class="literal">&amp;&amp;</code>) and the logical-or operator (<code class="literal">||</code>) with the bitwise-and operator (<code class="literal">&amp;</code>) and the bitwise-or operator (<code class="literal">|</code>) discussed earlier. Writing <code class="literal">&amp;</code> when you mean <code class="literal">&amp;&amp;</code> (or <span class="emphasis"><em>vice versa</em></span>) can result in surprising behavior.</p>
        </div>
        <p>The operator for testing basic equality, <code class="literal">==</code>, is not a simple equal sign;<a id="idm441657278592" class="indexterm"></a>
<a id="idm441657277184" class="indexterm"></a>
<a id="idm441657276032" class="indexterm"></a> forgetting the difference is a common novice mistake.<a id="idm441657275136" class="indexterm"></a>
<a id="idm441657273984" class="indexterm"></a> The problem is that such code is legal: simple assignment, which is what the equal sign means, has a value, and any value is legal in a condition. So consider this piece of (nonsense) code:</p>
        <pre class="screen">int i = 0;
while (i = 1) {
    i = 0;
}</pre>
        <p>You might think that the while condition tests whether <code class="literal">i</code> is 1. You might then think: <code class="literal">i</code> is 0, so the while body will never be performed. Right? Wrong. The while condition does not test whether <code class="literal">i</code> is 1; it assigns 1 to <code class="literal">i</code>. The value of that assignment is also 1, so the condition evaluates to 1, which means true. So the while body <span class="emphasis"><em>is</em></span> performed. Moreover, even though the while body assigns 0 to <code class="literal">i</code>, the condition is then evaluated again and assigns 1 to <code class="literal">i</code> a second time, which means true yet again. And so on, forever; we’ve written an endless loop, and the program will hang. (And, depending on what compiler and settings you’re using, you might not even get a warning of trouble ahead.)</p>
        <p>C programmers actually revel in the fact that testing for zero and testing for false are the same thing and use it to create compact conditional expressions, which are considered elegant and idiomatic. I don’t recommend that you make use of such idioms, as they can be confusing, but I must admit that even I do occasionally resort to it, especially because in Objective-C it is so common to test an object reference to see whether it is <a id="idm441657268320" class="indexterm"></a>nil (discussed further in <a class="xref" href="ch03.html">Chapter 3</a>). Since nil is a form of zero, I usually ask whether an object <code class="literal">s</code> is nil like this:</p>
        <pre class="screen">if (s) {
    // ...
}</pre>
        <p>Objective-C introduces a <a id="idm441657264864" class="indexterm"></a>BOOL type, which you should use if you need to capture or maintain a condition’s value as a variable, along with constants <a id="idm441657264048" class="indexterm"></a>YES and <a id="idm441657263408" class="indexterm"></a>NO (actually representing 1 and 0), which you should use when setting a boolean value. Don’t compare anything against a BOOL, not even YES or NO, because a value like 2 is true in a condition but is not equal to YES or NO. Just use the BOOL directly as a condition, or as part of a complex condition, and all will be well. For example:</p>
        <pre class="screen">BOOL isnil = (nil == s);
if (isnil) { // not: if (isnil == YES)
    // ...
}</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_functions"></a>Functions</h2>
            </div>
          </div>
        </div>
        <p>C is a function-based language (K&amp;R 4.1).<a id="idm441657259920" class="indexterm"></a>
<a id="idm441657258768" class="indexterm"></a> A <span class="emphasis"><em>function</em></span> is a block of code defining what should happen; when other code <span class="emphasis"><em>calls</em></span> (invokes) that function, the function’s code does happen. A function returns a value, which is substituted for the call to that function.</p>
        <p>Here’s a definition of a function that accepts an integer and returns its square:</p>
        <pre class="screen">int square(int i) {
    return i * i;
}</pre>
        <p>Now I’ll call that function:<a id="idm441657255264" class="indexterm"></a>
<a id="idm441657253856" class="indexterm"></a>
<a id="idm441657252704" class="indexterm"></a></p>
        <pre class="screen">int i = square(3);</pre>
        <p>Because of the way <code class="literal">square</code> is defined, that is exactly like saying:</p>
        <pre class="screen">int i = 9;</pre>
        <p>That example is extremely simple, but it illustrates many key aspects of functions.</p>
        <p>Let’s analyze how a function is defined:<a id="idm441657249136" class="indexterm"></a>
<a id="idm441657247728" class="indexterm"></a>
<a id="idm441657246576" class="indexterm"></a></p>
        <pre class="screen">int<a id="CO1-1"></a>❶ square<a id="CO1-2"></a>❷(<a id="CO1-3"></a>❸int i) {<a id="CO1-4"></a>❹
    return i * i;
}</pre>
        <div class="calloutlist">
          <table border="0" summary="Callout list">
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO1-1">❶</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
We start with the type of value that the function returns; here, it returns an int.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO1-2">❷</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
Then we have the name of the function, which is <code class="literal">square</code>.
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO1-3">❸</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
Then we have parentheses, and here we place the data type and name of any values that this function expects to receive. Here, <code class="literal">square</code> expects to receive one value, an int, which we are calling <code class="literal">i</code>. The name <code class="literal">i</code> (along with its expected data type) is a <span class="emphasis"><em>parameter</em></span>;<a id="idm441657238208" class="indexterm"></a> when the function is called, its value will be supplied as an <span class="emphasis"><em>argument</em></span>.<a id="idm441657236928" class="indexterm"></a> If a function expects to receive more than one value, multiple parameters in its definition are separated by a comma (and when the function is called, the arguments supplied are likewise separated by a comma).
</p>
              </td>
            </tr>
            <tr>
              <td width="5%" valign="top" align="left">
                <p><a href="#CO1-4">❹</a> </p>
              </td>
              <td valign="top" align="left">
                <p>
Finally, we have curly braces containing the statements that are to be executed when the function is called.
</p>
              </td>
            </tr>
          </table>
        </div>
        <p>Those curly braces constitute a scope;<a id="idm441657233632" class="indexterm"></a>
<a id="idm441657232224" class="indexterm"></a>
<a id="idm441657231072" class="indexterm"></a> variables declared within them are local to the function. The names used for the parameters in the function definition are also local to the function; in other words, the <code class="literal">i</code> in the first line of the function definition is the same as the <code class="literal">i</code> in the second line of the function definition, but it has nothing to do with any <code class="literal">i</code> used outside the function definition (as when the result of the function call is assigned to a variable called <code class="literal">i</code>). The value of the <code class="literal">i</code> parameter in the function definition is assigned from the corresponding argument when the function is actually called; in the previous example, it is 3, which is why the function result is 9. Supplying a function call with arguments is thus a form of assignment. Suppose a function is defined like this:</p>
        <pre class="screen">int myfunction(int i, int j) { // ...</pre>
        <p>And suppose we call that function:</p>
        <pre class="screen">int result = myfunction(3, 4);</pre>
        <p>That function call effectively assigns 3 to the function’s <code class="literal">i</code> parameter and 4 to the function’s <code class="literal">j</code> parameter.</p>
        <p>When a <code class="literal">return</code> statement is encountered, the value accompanying it is handed back as the result of the function call, and the function terminates.<a id="idm441657223008" class="indexterm"></a>
<a id="idm441657221856" class="indexterm"></a> It is legal for a function to return no value; in such a case, the <code class="literal">return</code> statement has no accompanying value, and the definition states the type of value returned by the function as <code class="literal">void</code>.<a id="idm441657219936" class="indexterm"></a> It is also legal to call a function and ignore its return value even if it has one. For example, we could say:</p>
        <pre class="screen">square(3);</pre>
        <p>That would be a somewhat silly thing to say, because we have gone to all the trouble of calling the function and having it generate the square of 3 — namely 9 — but we have done nothing to <span class="emphasis"><em>capture</em></span> that 9. It is exactly as if we had said:</p>
        <pre class="screen">9;</pre>
        <p>You’re allowed to say that, but it doesn’t seem to serve much purpose. On the other hand, the point of a function might be not so much the value it returns as other things it does as it is executing, so then it might make perfect sense to ignore its result.</p>
        <p>The parentheses in a function’s syntax are crucial. Parentheses are how C knows there’s a function. Parentheses after the function name in the function <span class="emphasis"><em>definition</em></span> are how C knows this is a function definition, and they are needed even if this function takes no parameters. Parentheses after the function name in the function <span class="emphasis"><em>call</em></span> are how C knows this is a function call, and they are needed even if this function call supplies no arguments. Using the bare name of a function is possible, because the name is the name of something, but it doesn’t call the function. (I’ll talk later about something it does do.)</p>
        <p>Let’s return to the simple C function definition and call that I used as my example earlier. Suppose we combine that function definition and the call to that function into a single program:</p>
        <pre class="screen">int square(int i) {
    return i * i;
}
int i = square(3);</pre>
        <p>That is a legal program, but only because the definition of the <code class="literal">square</code> function precedes the call to that function. If we wanted to place the definition of the <code class="literal">square</code> function elsewhere, such as after the call to it, we would need at least to precede the call with a declaration of the <code class="literal">square</code> function (<a class="xref" href="ch01.html#EXdecdef">Example 1.3</a>). The declaration looks just like the first line of the definition, but it is a statement, ending with a semicolon, rather than a left curly brace.<a id="idm441657209552" class="indexterm"></a>
<a id="idm441657208144" class="indexterm"></a>
<a id="idm441657206992" class="indexterm"></a></p>
        <div class="example">
          <a id="EXdecdef"></a>
          <p class="title">Example 1.3. Declaring, calling, and defining a function</p>
          <div class="example-contents">
            <pre class="screen">int square(int i);
int i = square(3);
int square(int i) {
    return i * i;
}</pre>
          </div>
        </div>
        <br class="example-break" />
        <p>The parameter names in the declaration do not have to match the parameter names in the definition, but all the types (and, of course, the name of the function) must match. The types constitute the <span class="emphasis"><em>signature</em></span> of this function.<a id="idm441657203680" class="indexterm"></a>
<a id="idm441657202272" class="indexterm"></a>
<a id="idm441657201120" class="indexterm"></a> In other words, it does not matter if the first line, the declaration, is rewritten thus:</p>
        <pre class="screen">int square(int j);</pre>
        <p>What does matter is that, both in the declaration and in the definition, <code class="literal">square</code> is a function taking one int parameter and returning an int. (In a modern Objective-C program, though, the function declaration usually won’t be necessary, even if the function call precedes its definition; see <a class="xref" href="ch01.html#SBdeclarationOrder">Modern Objective-C Function Declarations</a>.)</p>
        <p>In Objective-C, when you’re sending a message to an object (<a class="xref" href="ch02.html">Chapter 2</a>), you won’t use a function call; you’ll use a method call (<a class="xref" href="ch03.html">Chapter 3</a>). But you will most definitely use plenty of C function calls as well. For example, earlier we initialized a CGPoint by setting its <code class="literal">x</code> element and its <code class="literal">y</code> element and by assigning its elements values in curly braces. But what you’ll usually do to make a new CGPoint is to call <code class="literal">CGPointMake</code>, which is declared like this:<a id="idm441657194944" class="indexterm"></a></p>
        <pre class="screen">CGPoint CGPointMake (
   CGFloat x,
   CGFloat y
);</pre>
        <p>Despite its multiple lines and its indentations, this is indeed a C function declaration, just like the declaration for our simple <code class="literal">square</code> function. It says that <code class="literal">CGPointMake</code> is a C function that takes two CGFloat parameters and returns a CGPoint. So now you know (I hope) that it would be legal (and typical) to write this sort of thing:</p>
        <pre class="screen">CGPoint myPoint = CGPointMake(4.3, 7.1);</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_pointer_parameters_and_the_address_operator"></a>Pointer Parameters and the Address Operator</h2>
            </div>
          </div>
        </div>
        <p>Objective-C is chock-a-block with pointers (and asterisks). Objective-C methods typically expect pointer parameters and return a pointer value. But this doesn’t make things more complicated, because, as I’ve already mentioned, your variables referring to Objective-C objects <span class="emphasis"><em>are</em></span> pointers.<a id="idm441657189264" class="indexterm"></a>
<a id="idm441657188112" class="indexterm"></a> Pointers are what Objective-C expects, but pointers are also what Objective-C gives you. Pointers are exactly what you’ve got, so there’s no problem.</p>
        <p>For example, one way to concatenate two NSStrings is to call the NSString method <code class="literal">stringByAppendingString:</code>, which the documentation tells you is declared as follows:</p>
        <pre class="screen">- (NSString *)stringByAppendingString:(NSString *)aString</pre>
        <p>This declaration is telling you (after you allow for the Objective-C syntax) that this method expects one <code class="literal">NSString*</code> parameter and returns an <code class="literal">NSString*</code>. That sounds messy, but it isn’t, because <span class="emphasis"><em>every</em></span> NSString is really an <code class="literal">NSString*</code>. So nothing could be simpler than to obtain a new NSString consisting of two concatenated NSStrings:</p>
        <pre class="screen">NSString* s1 = @"Hello, ";
NSString* s2 = @"World!"
NSString* s3 = [s1 stringByAppendingString: s2];</pre>
        <p>Sometimes, however, a function or method expects as a parameter a pointer to a thing, but what you’ve got is not that pointer but the thing itself. Thus, you need a way to create a pointer to that thing.<a id="idm441657181200" class="indexterm"></a>
<a id="idm441657179792" class="indexterm"></a>
<a id="idm441657178640" class="indexterm"></a> The solution is the address operator (K&amp;R 5.1), which is an ampersand before the name of the thing.<a id="idm441657177744" class="indexterm"></a>
<a id="idm441657176336" class="indexterm"></a>
<a id="idm441657175184" class="indexterm"></a></p>
        <p>For example, there’s an NSString method for reading from a file into an NSString, which is declared like this:</p>
        <pre class="screen">+ (id)stringWithContentsOfFile:(NSString *)path
                      encoding:(NSStringEncoding)enc
                         error:(NSError **)error</pre>
        <p>Now, never mind what an <code class="literal">id</code> is, and don’t worry about the Objective-C method declaration syntax. Just consider the types of the parameters. The first one is an <code class="literal">NSString*</code>; that’s no problem, as every reference to an NSString is actually a pointer to an NSString. An NSStringEncoding turns out to be merely an alias to a primitive data type, an NSUInteger, so that’s no problem either. But what on earth is an <code class="literal">NSError**</code>?</p>
        <p>By all logic, it looks like an <code class="literal">NSError**</code> should be a pointer to a pointer to an NSError.<a id="idm441657169504" class="indexterm"></a><a id="idm441657168736" class="indexterm"></a> And that’s exactly what it is. This method is asking to be passed a pointer to a pointer to an NSError. Well, it’s easy to declare a pointer to an NSError:</p>
        <pre class="screen">NSError* myError;</pre>
        <p>But how can we obtain a pointer to that? With the address operator! So our code might look, schematically, like this:</p>
        <pre class="screen">NSString* myPath = // something or other;
NSStringEncoding myEnc = // something or other;
NSError* myError = nil;
NSString* result = [NSString stringWithContentsOfFile: myPath
                                             encoding: myEnc
                                                error: &amp;myError];</pre>
        <p>The important thing to notice is the ampersand. Because <code class="literal">myError</code> is a pointer to an NSError, <code class="literal">&amp;myError</code> is a pointer to a pointer to an NSError, which is just what we’re expected to provide. Thus, everything goes swimmingly.</p>
        <p>This method effectively returns <span class="emphasis"><em>two</em></span> results. It returns a real result, which we have captured by assigning it to the NSString pointer we’re calling <code class="literal">result</code>. But if there’s an error, it also wants to set the value of another object, an NSError object; the idea is that you can then study that NSError object to find out what went wrong. (Perhaps the file wasn’t where you said it was, or it wasn’t stored in the encoding you claimed it was.) By passing a pointer to a pointer to an NSError, you give the method free rein to do that. Before the call to <code class="literal">stringWithContentsOfFile:</code>, <code class="literal">myError</code> was initialized to nil; during the call to <code class="literal">stringWithContentsOfFile:</code>, if there’s an error, the pointer is repointed, thus giving <code class="literal">myError</code> a meaningful NSError value describing that error. (Repointing a pointer in this way is sometimes called <span class="emphasis"><em>indirection</em></span>.)<a id="idm441657159264" class="indexterm"></a>
<a id="idm441657158112" class="indexterm"></a></p>
        <p>So the idea is that you first check <code class="literal">result</code> to see whether it’s nil. If it isn’t, fine; it’s the string you asked for. If it is, you then study the NSError that <code class="literal">myError</code> is now pointing to, to learn what went wrong. This pattern is frequently used in Cocoa.</p>
        <p>You can use the address operator to create a pointer to any named variable. A C function is technically a kind of named variable, so you can even create a pointer to a function! This is an example of when you’d use the name of the function without the parentheses: you aren’t calling the function, you’re talking about it. For example, <code class="literal">&amp;square</code> is a pointer to the <code class="literal">square</code> function. Moreover, just as the bare name of an array is implicitly a pointer to its first element, the bare name of a function is implicitly a pointer to the function; the address operator is optional. In <a class="xref" href="ch03.html">Chapter 3</a>, I describe a situation in which specifying a pointer to a function is a useful thing to do.<a id="idm441657152928" class="indexterm"></a>
<a id="idm441657151520" class="indexterm"></a>
<a id="idm441657150368" class="indexterm"></a></p>
        <p>Another operator used in connection with pointers, or when memory must be allocated dynamically, is <code class="literal">sizeof</code>. It may be followed by a type name in parentheses or by a variable name; a variable name needn’t be in parentheses, but it <span class="emphasis"><em>can</em></span> be, so most programmers ignore the distinction and use parentheses routinely, as if <code class="literal">sizeof</code> were a function.<a id="idm441657147600" class="indexterm"></a>
<a id="idm441657146192" class="indexterm"></a>
<a id="idm441657145040" class="indexterm"></a></p>
        <p>For example, the documentation shows the declaration for the <code class="literal">CTParagraphStyleSetting</code> struct like this:</p>
        <pre class="screen">typedef struct CTParagraphStyleSetting {
    CTParagraphStyleSpecifier spec;
    size_t valueSize;
    const void* value;
} CTParagraphStyleSetting;</pre>
        <p>A CTParagraphStyleSpecifier is just an enum, so concentrate on the second and third elements of this struct, <code class="literal">valueSize</code> and <code class="literal">value</code>. The <code class="literal">value</code> element is a pointer-to-void, meaning an anonymous pointer; it’s a pointer to something-or-other. Since pointer-to-void casts away any concern for what data type the pointer is pointing to, it also casts away any knowledge of how big that data type is. The job of the second element of the struct is to provide that information. Here’s an actual example of initializing a <code class="literal">CTParagraphStyleSetting</code> struct (from <a class="xref" href="ch23.html">Chapter 23</a>):</p>
        <pre class="screen">CTTextAlignment centerValue = kCTCenterTextAlignment;
CTParagraphStyleSetting center =
    {kCTParagraphStyleSpecifierAlignment, sizeof(centerValue), &amp;centerValue};</pre>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_files"></a>Files</h2>
            </div>
          </div>
        </div>
        <p>The little dance of declaring a function before calling it (<a class="xref" href="ch01.html#EXdecdef">Example 1.3</a>) may seem rather absurd, but it is of tremendous importance in the C language, because it is what allows a C program to be arbitrarily large and complex.</p>
        <p>As your program grows, you can divide and organize it into multiple files. This kind of organization can make a large program much more maintainable — easier to read, easier to understand, easier to change without accidentally breaking things. A large C program therefore usually consists of two kinds of file: code files, whose filename extension is <span class="emphasis"><em>.c</em></span>, and header files, whose filename extension is <span class="emphasis"><em>.h</em></span>.<a id="idm441657134400" class="indexterm"></a>
<a id="idm441657133248" class="indexterm"></a> The build system will automatically “see” all the files and will know that together they constitute a single program, but there is also a rule in C that code inside one file cannot “see” another file unless it is explicitly told to do so. Thus, a file itself constitutes a scope; this is a deliberate and valuable feature of C, because it helps you keep things nicely pigeonholed.</p>
        <p>The way you tell a C file to “see” another file is with the <code class="literal">#include</code> directive.<a id="idm441657131136" class="indexterm"></a>
<a id="idm441657129984" class="indexterm"></a> The hash sign in the term <code class="literal">#include</code> is a signal that this line is an instruction to the preprocessor.<a id="idm441657128576" class="indexterm"></a>
<a id="idm441657127424" class="indexterm"></a> In this case, the word <code class="literal">#include</code> is followed by the name of another file, and the directive means that the preprocessor should simply replace the directive by the entire contents of the file that’s named.</p>
        <p>So the strategy for constructing a large C program is something like this:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
In each <span class="emphasis"><em>.c</em></span> file, put the code that only this file needs to know about; typically, each file’s code consists of related functionality.
</li>
            <li class="listitem">
In each <span class="emphasis"><em>.h</em></span> file, put the function declarations that multiple <span class="emphasis"><em>.c</em></span> files might need to know about.
</li>
            <li class="listitem">
Have each <span class="emphasis"><em>.c</em></span> file include those <span class="emphasis"><em>.h</em></span> files containing the declarations it needs to know about.
</li>
          </ul>
        </div>
        <p>So, for example, if <code class="literal">function1</code> is defined in <span class="emphasis"><em>file1.c</em></span>, but <span class="emphasis"><em>file2.c</em></span> might need to call <code class="literal">function1</code>, the declaration for <code class="literal">function1</code> can go in <span class="emphasis"><em>file1.h</em></span>. Now <span class="emphasis"><em>file1.c</em></span> can include <span class="emphasis"><em>file1.h</em></span>, so all of its functions, regardless of order, can call <code class="literal">function1</code>, and <span class="emphasis"><em>file2.c</em></span> can also include <span class="emphasis"><em>file1.h</em></span>, so all of <span class="emphasis"><em>its</em></span> functions can call <code class="literal">function1</code> (<a class="xref" href="ch01.html#FIG2">Figure 1.2</a>). In short, header files are a way of letting code files share knowledge about one another without actually sharing code (because, if they did share code, that would violate the entire point of keeping the code in separate files).</p>
        <div class="figure">
          <a id="FIG2"></a>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="figs/pios_0102.png" alt="figs/pios_0102.png" />
            </div>
          </div>
          <p class="title">Figure 1.2. How a large C program is divided into files</p>
        </div>
        <br class="figure-break" />
        <p>But how does the compiler know where, among all these multiple <span class="emphasis"><em>.c</em></span> files, to begin execution? Every real C program contains, somewhere, exactly one function called <code class="literal">main</code>, and this is always the entry point for the program as a whole: the compiler sets things up so that when the program executes, <code class="literal">main</code> is called.<a id="idm441657109136" class="indexterm"></a></p>
        <p>The organization for large C programs that I’ve just described will also be, in effect, the organization for your iOS programs. (The chief difference will be that instead of <span class="emphasis"><em>.c</em></span> files, you’ll use <span class="emphasis"><em>.m</em></span> files, because <span class="emphasis"><em>.m</em></span> is the conventional filename extension for telling Xcode that your files are written in Objective-C, not pure C.) Moreover, if you look at any iOS Xcode project, you’ll discover that it contains a file called <span class="emphasis"><em>main.m</em></span>; and if you look at that file, you’ll find that it contains a function called <code class="literal">main</code>. That’s the entry point to your application’s code when it runs.</p>
        <p>The big difference between your Objective-C code files and the C code files I’ve been discussing is that instead of saying <code class="literal">#include</code>, your files will say <code class="literal">#import</code>. The <code class="literal">#import</code> preprocessor directive<a id="idm441657102592" class="indexterm"></a>
<a id="idm441657101440" class="indexterm"></a> is not mentioned in K&amp;R. It’s an Objective-C addition to the language. It’s based on <code class="literal">#include</code>, but it is used instead of <code class="literal">#include</code> because it (<code class="literal">#import</code>) contains some logic for making sure that the same material is not included more than once. Such repeated inclusion is a danger whenever there are many cross-dependent header files; use of <code class="literal">#import</code> solves the problem neatly.<a id="idm441657098112" class="indexterm"></a>
<a id="idm441657096960" class="indexterm"></a></p>
        <p>Furthermore, your iOS programs consist not only of <span class="emphasis"><em>your</em></span> code files and their corresponding <span class="emphasis"><em>.h</em></span> files, but also of Apple’s code files and <span class="emphasis"><em>their</em></span> corresponding <span class="emphasis"><em>.h</em></span> files. The difference is that Apple’s code files (which are what constitutes Cocoa, see <a class="xref" href="pt03.html">Part III. Cocoa</a>) have already been compiled. But your code must still <code class="literal">#import</code> Apple’s <span class="emphasis"><em>.h</em></span> files so as to be able to see Apple’s declarations. If you look at an iOS Xcode project, you’ll find that any <span class="emphasis"><em>.h</em></span> files it contains by default, as well as its <span class="emphasis"><em>main.m</em></span> file, contain a line of this form:</p>
        <pre class="screen">#import &lt;UIKit/UIKit.h&gt;</pre>
        <p>That line is essentially a single massive <code class="literal">#import</code> that copies into your program the declarations for the entire basic iOS API. Moreover, each of your <span class="emphasis"><em>.m</em></span> files <code class="literal">#import</code>s its corresponding <span class="emphasis"><em>.h</em></span> file, including whatever the <span class="emphasis"><em>.h</em></span> file <code class="literal">#import</code>s. Thus, all your code files include the basic iOS declarations.</p>
        <p>For example, earlier I said that CGPoint was defined like this:</p>
        <pre class="screen">struct CGPoint {
  CGFloat x;
  CGFloat y;
};
typedef struct CGPoint CGPoint;</pre>
        <p>After the preprocessor operates on all your files, your <span class="emphasis"><em>.m</em></span> files actually <span class="emphasis"><em>contain</em></span> that definition of CGPoint. (You can even choose Product → Generate Output → Preprocessed File, as I mentioned earlier, to confirm that this is true.) And that is why your code is able to use a CGPoint!</p>
        <p>The <code class="literal">#import</code> directive, like the <code class="literal">#include</code> directive (K&amp;R 4.11), can specify a file in angle brackets or in quotation marks:<a id="idm441657083616" class="indexterm"></a><a id="idm441657082848" class="indexterm"></a></p>
        <pre class="screen">#import &lt;UIKit/UIKit.h&gt;
#import "MyHeader.h"</pre>
        <p>Here’s what those two forms of syntax mean:</p>
        <div class="variablelist">
          <dl>
            <dt>
              <span class="term">
Quotation marks
</span>
            </dt>
            <dd>
Look for the named file in the same folder as this file (the <span class="emphasis"><em>.m</em></span> file in which the <code class="literal">#import</code> line occurs).
</dd>
            <dt>
              <span class="term">
Angle brackets
</span>
            </dt>
            <dd>
Look for the named file among the various header search paths supplied in the build settings. (These search paths are set for you automatically, and you normally won’t need to modify them.)
</dd>
          </dl>
        </div>
        <p>In general, you’ll use angle brackets to refer to a header file owned by the Cocoa API and quotation marks to refer to a header file that you wrote. If you’re curious as to what an <code class="literal">#import</code> directive imports, select it (in Xcode) and choose File → Open Quickly to display the contents of the designated header file.</p>
        <div class="sidebar">
          <a id="SBdeclarationOrder"></a>
          <div class="titlepage">
            <div>
              <div>
                <p class="title">Modern Objective-C Function Declarations</p>
              </div>
            </div>
          </div>
          <p>Starting with LLVM compiler version 3.1, which made its debut in Xcode 4.3, Objective-C no longer requires that a function declaration precede the use of that function, provided that the definition of that function follows in the same file. In other words, code inside an Objective-C class can call a function — or an Objective-C method — even if that call <span class="emphasis"><em>precedes</em></span> the definition of that function or method, and even if there is no separate declaration of that function or method. Thus, in modern Objective-C, the order of functions and methods within a <span class="emphasis"><em>.m</em></span> file doesn’t matter, and it is not necessary to declare functions or methods within a <span class="emphasis"><em>.m</em></span> file at all! The only place you’ll ever need to declare functions or methods will be in a <span class="emphasis"><em>.h</em></span> file, and only so that some <span class="emphasis"><em>.m</em></span> file <span class="emphasis"><em>other</em></span> than the file where they are defined can import that <span class="emphasis"><em>.h</em></span> file and call the function (or method).<a id="idm441657069344" class="indexterm"></a>
<a id="idm441657067936" class="indexterm"></a>
<a id="idm441657066784" class="indexterm"></a><a id="idm441657066016" class="indexterm"></a>
<a id="idm441657064864" class="indexterm"></a></p>
          <p>Bear in mind that this convenience is a feature of Objective-C, not of C. I’m talking about <span class="emphasis"><em>.m</em></span> files, not <span class="emphasis"><em>.c</em></span> files. I’ll describe more precisely in <a class="xref" href="ch04.html">Chapter 4</a> the region of a <span class="emphasis"><em>.m</em></span> file in which this convenience applies — namely, a class’s implementation section.</p>
        </div>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_the_standard_library"></a>The Standard Library</h2>
            </div>
          </div>
        </div>
        <p>You also have at your disposal a large collection of built-in C library files. A library file is a centrally located collection of C functions, along with a <span class="emphasis"><em>.h</em></span> file that you can include so as to make those functions available to your code.<a id="idm441657059824" class="indexterm"></a>
<a id="idm441657058672" class="indexterm"></a><a id="idm441657057904" class="indexterm"></a></p>
        <p>For example, suppose you want to round a float up to the next highest integer. The way to do this is to call some variety of the <code class="literal">ceil</code> function.<a id="idm441657056096" class="indexterm"></a> You can read the <code class="literal">ceil</code> man page by typing <code class="literal">man ceil</code> in the Terminal. The documentation tells you what <code class="literal">#include</code> to use to incorporate the correct header and also shows you the function declarations and tells you what those functions do. A small pure C program might thus look like this:</p>
        <pre class="screen">#include &lt;math.h&gt;
float f = 4.5;
int i = ceilf(f); // now i is 5</pre>
        <p>In your iOS programs, <span class="emphasis"><em>math.h</em></span> is included for you as part of the massive UIKit <code class="literal">#import</code>, so there’s no need to include it again. But some library functions might require an explicit <code class="literal">#import</code>.</p>
        <p>The standard library is discussed in K&amp;R Appendix B. But the modern standard library has evolved since K&amp;R; it is a superset of K&amp;R’s library. The <code class="literal">ceil</code> function, for example, is listed in K&amp;R appendix B, but the <code class="literal">ceilf</code> function is not. Similarly, if you wanted to generate a random number (which is likely if you’re writing a game program that needs to incorporate some unpredictable behavior), you probably wouldn’t use the <code class="literal">rand</code> function listed in K&amp;R; you’d use the <code class="literal">random</code> function, which supersedes it.<a id="idm441657047408" class="indexterm"></a></p>
        <p>Forgetting that Objective-C is C and that the C library functions are available to your code is a common beginner mistake.<a id="idm441657046128" class="indexterm"></a>
<a id="idm441657044976" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_more_preprocessor_directives"></a>More Preprocessor Directives</h2>
            </div>
          </div>
        </div>
        <p>Of the many other available preprocessor directives,<a id="idm441657043056" class="indexterm"></a>
<a id="idm441657041904" class="indexterm"></a> the one you’ll use most often is <code class="literal">#define</code>.<a id="idm441657040384" class="indexterm"></a>
<a id="idm441657039232" class="indexterm"></a> It is followed by a name and a value; at preprocess time, the value is substituted for the name down through this code file. As K&amp;R very well explain (K&amp;R 1.4), this is a good way to prevent “magic numbers” from being hidden and hard-coded into your program in a way that makes the program difficult to understand and maintain.<a id="idm441657038192" class="indexterm"></a></p>
        <p>For example, in an iOS app that lays out some text fields vertically, I might want them all to have the same space between them. Let’s say this space is 3.0. I shouldn’t write 3.0 repeatedly throughout my code as I calculate the layout; instead, I write:</p>
        <pre class="screen">#define MIDSPACE 3.0</pre>
        <p>Now instead of the “magic number” 3.0, my code uses a meaningful name, <code class="literal">MIDSPACE</code>;
at preprocessor time, the text <code class="literal">MIDSPACE</code> is replaced with the text <code class="literal">3.0</code>. So it amounts to the same thing, but if I decide to change this value and try a different one, all I have to change is the <code class="literal">#define</code> line, not every occurrence of the number 3.0.</p>
        <p>A <code class="literal">#define</code> simply performs text substitution, so any expression can be used as the value. Sometimes you’ll want that expression to be an NSString literal. Here’s why. In Cocoa, NSString literals can be used as a key to a dictionary or the name of a notification. (Never mind for now what a dictionary or a notification is.) This situation is an invitation to error. If you have a dictionary containing a key <code class="literal">@"mykey"</code> and you mistype this elsewhere in your code as <code class="literal">@"myKey"</code> or <code class="literal">@"mikey"</code>, the compiler won’t complain, but your program will misbehave. The solution is to define a name for this literal string:</p>
        <pre class="screen">#define MYKEY @"mykey"</pre>
        <p>Now use <code class="literal">MYKEY</code> throughout your code instead of <code class="literal">@"mykey"</code>, and if you mistype it (as <code class="literal">MYKKEY</code> or what have you), the preprocessor won’t perform any substitution and the compiler <span class="emphasis"><em>will</em></span> complain, catching the mistake for you.</p>
        <p>The <code class="literal">#define</code> directive can also be used to create a macro (K&amp;R 4.11.2), a more elaborate form of text substitution. You’ll encounter a few Cocoa macros in the course of this book, but they will appear indistinguishable from functions; their secret identity as macros won’t concern you.<a id="idm441657024992" class="indexterm"></a>
<a id="idm441657023840" class="indexterm"></a></p>
        <p>The <code class="literal">#warning</code> directive<a id="idm441657022176" class="indexterm"></a>
<a id="idm441657021024" class="indexterm"></a> deliberately triggers a warning in Xcode at compile time; this can be a way to remind yourself of some impending task or requirement:<a id="idm441657019984" class="indexterm"></a>
<a id="idm441657018832" class="indexterm"></a></p>
        <pre class="screen">#warning Don't forget to fix this bit of code</pre>
        <p>There is also a <code class="literal">#pragma mark</code> directive<a id="idm441657016656" class="indexterm"></a>
<a id="idm441657015504" class="indexterm"></a> that’s useful with Xcode; I talk about it when discussing the Xcode programming environment (<a class="xref" href="ch09.html">Chapter 9</a>).<a id="idm441657014000" class="indexterm"></a>
<a id="idm441657012848" class="indexterm"></a></p>
      </div>
      <div class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="_data_type_qualifiers"></a>Data Type Qualifiers</h2>
            </div>
          </div>
        </div>
        <p>A variable’s data type can be declared with a qualifier before the name of the type, modifying something about how that variable is to be used. For example, the declaration can be preceded by the term <code class="literal">const</code>, which means (K&amp;R 2.4) that it is illegal to change the variable’s value; the variable must be initialized in the same line as the declaration, and that’s the only value it can ever have.<a id="idm441657009248" class="indexterm"></a>
<a id="idm441657008096" class="indexterm"></a><a id="idm441657007328" class="indexterm"></a>
<a id="idm441657006176" class="indexterm"></a></p>
        <p>You can use a <code class="literal">const</code> variable as an alternative way (instead of <code class="literal">#define</code>) to prevent “magic numbers” and similar expressions. For example:</p>
        <pre class="screen">NSString* const MYKEY = @"Howdy";</pre>
        <p>The Cocoa API itself makes heavy use of this device. For example, in some circumstances Cocoa will pass a dictionary of information to your code. The documentation tells you what keys this dictionary contains. But instead of telling you a key as a string, the documentation tells you the key as a <code class="literal">const</code> NSString variable name:</p>
        <pre class="screen">UIKIT_EXTERN NSString *const UIApplicationStatusBarOrientationUserInfoKey;</pre>
        <p>(Never mind what <code class="literal">UIKIT_EXTERN</code> means.) This declaration tells you that <code class="literal">UIApplicationStatusBarOrientationUserInfoKey</code> is the name of an NSString, and you are to trust that its value is set for you. You are to go ahead and use this name whenever you want to speak of this particular key, secure in the knowledge that the actual string value will be substituted. You do not have to know what that actual string value is. In this way, if you make a mistake in typing the variable name, the compiler will catch the mistake because you’ll be using the name of an undefined variable.</p>
        <p>Another commonly used qualifier is <code class="literal">static</code>.<a id="idm441656998592" class="indexterm"></a>
<a id="idm441656997440" class="indexterm"></a> This term is unfortunately used in two rather different ways in C; the way I commonly use it is inside a function. Inside a function, <code class="literal">static</code> indicates that the memory set aside for a variable should not be released after the function returns; rather, the variable remains and maintains its value for the next time the function is called. A static variable is useful, for example, when you want to call a function many times without the overhead of calculating the result each time (after the first time). First test to see whether the static value has already been calculated: if it hasn’t, this must be the first time the function is being called, so you calculate it; if it has, you just return it. Here’s a schematic version:</p>
        <pre class="screen">int myfunction() {
    static int result = 0; // 0 means we haven't done the calculation yet
    if (result == 0) {
        // calculate result and set it
    }
    return result;
}</pre>
        <p>A very common use of a static variable in Objective-C is to implement a singleton instance returned by a class factory method. If that sounds complicated, don’t worry; it isn’t. Here’s an example from my own code, which you can grasp even though we haven’t discussed Objective-C yet:</p>
        <pre class="screen">+ (CardPainter*) sharedPainter {
    static CardPainter* sp = nil;
    if (nil == sp)
        sp = [CardPainter new];
    return sp;
}</pre>
        <p>That code says: If the CardPainter instance <code class="literal">sp</code> has never been created, create it, and in any case, now return it. Thus, no matter how many times this method is called, the instance will be created just once and that same instance will be returned every time.</p>
        <div class="warning" style="margin-left: 0; margin-right: 10%;">
          <h3 class="title">Warning</h3>
          <p>Static variables are a C language feature, not an Objective-C language feature. Therefore, a static variable knows nothing of classes and instances; even if it appears inside a function or a method, it is defined at the level of a file, which means, in effect, at the level of your program as a whole. That’s fine when you’re using it in a class factory method, because a class is unique to your program as a whole. But never use a static variable in an Objective-C instance method, because your program can have multiple such instances, and the value of this one static variable will apply across all of them. In other words, don’t use a C static variable as a lazy substitute for an Objective-C instance variable (<a class="xref" href="ch02.html">Chapter 2</a>). I’ve made that mistake, and trust me, the results are not pretty.
<a id="idm441656990480" class="indexterm"></a></p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="pt01.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="pt01.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Part I. Language </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Table of Contents</a>
          </td>
          <td width="40%" align="right" valign="top"> Chapter 2. Object-Based Programming</td>
        </tr>
      </table>
    </div>
  </body>
</html>
