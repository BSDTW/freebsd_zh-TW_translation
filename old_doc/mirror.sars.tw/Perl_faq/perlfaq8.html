    <HTML> 
	<HEAD> 
	    <TITLE>perlfaq8</TITLE> 
	</HEAD>

	<BODY>

<H1>perlfaq8 - perl 常問問題集，第八篇</H1>
<p>
<p><H2><A NAME="INDEX">目錄
</A></H2>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#_g_W">篇名</A>
	<LI><A HREF="#_z">概述</A>
	<UL>

		<LI><A HREF="#_p_o_b_t_U">如何得知使用者正在哪個作業系統下執行我的 perl 程式？</A>
		<LI><A HREF="#_exec_H">為什麼 exec() 不會傳值回來？</A>
		<LI><A HREF="#_p_L_">如何對 鍵盤／螢幕／滑鼠 做些花樣？</A>
		<LI><A HREF="#_p_V_K_X_H">如何向使用者詢問密碼？</A>
		<LI><A HREF="#_p_C_g_H">如何對序列埠做讀寫動作？</A>
		<LI><A HREF="#_p_f_K_K_X_H">如何逆解加密後的密碼檔案？</A>
		<LI><A HREF="#_p_I_H">如何啟動一個背景執行的程序？</A>
		<LI><A HREF="#_p_r_T_H">如何捕捉 控制字元／訊號？</A>
		<LI><A HREF="#_p_Unix_t_W_K_X_">如何更動 Unix 系統上隱式密碼檔 (shadow password) 的內容？</A>
		<LI><A HREF="#_p_w_M_H">如何設定時間和日期？</A>
		<LI><A HREF="#_p_w_p_sle">如何能夠針對小於一秒的時間做 sleep() 或 alarm() 的動作呢？</A>
		<LI><A HREF="#_p_q_p_H">如何測量小於一秒的時間？</A>
		<LI><A HREF="#_p_atexit_setjmp_long">如何做 atexit() 或 setjmp()/longjmp() 的動作？（例外處理）</A>
		<LI><A HREF="#_sockets_b_System_V">為何我的 sockets 程式在 System V (Solaris) 系統下不能用？「不支援本協定」這個錯誤訊息又是什麼意思？</A>
		<LI><A HREF="#_p_q_Perl_I_s_t_W_S_C">如何從 Perl 裡呼叫系統中獨特的 C 函數？</A>
		<LI><A HREF="#_b_i_H_J_ioctl_">在哪裡可以找引入檔來做 ioctl() 或 syscall()？</A>
		<LI><A HREF="#_setuid_perl_">為何 setuid perl 程式會抱怨關於系統核心的問題？</A>
		<LI><A HREF="#_p_Y_J_J_S_X_">如何打開對某程式既輸入又輸出的管道 (pipe)？</A>
		<LI><A HREF="#_system_o_o_O">為何用 system() 卻得不到一個指令的輸出呢？</A>
		<LI><A HREF="#_p_O_STDERR_H">如何補捉外部指令的 STDERR？</A>
		<LI><A HREF="#_D_open_">為何當管道開啟失敗時 open() 不會傳回錯誤訊息？</A>
		<LI><A HREF="#_b_X_O_V_">在輸出值是空的情境裡使用反向引號有何不對？</A>
		<LI><A HREF="#_p_g_L_shell_B_z_I_s_V_">如何不經過 shell 處理來呼叫反向引號？</A>
		<LI><A HREF="#_F_EOF_Unix_W_O_D_AMS_D">為何給了 EOF（Unix 上是 ^D，MS-DOS 上是 ^Z）後我的程式就不能從 STDIN 讀取東西了呢？</A>
		<LI><A HREF="#_p_shell_perl_H">如何把 shell 程式轉成 perl？</A>
		<LI><A HREF="#perl_B_z_telnet_ftp_o_">perl 能處理 telnet 或 ftp 這種雙向互動嗎？</A>
		<LI><A HREF="#_p_b_Perl_F_Expect_">如何在 Perl 裡達到 Expect 的功能？</A>
		<LI><A HREF="#_S_i_N_perl_O_C_">有沒有可能將 perl 的指令列隱藏起來，以躲避像 "ps" 之類的程式？</A>
		<LI><A HREF="#_b_perl_script_A_">我在 perl script 裡 {更動目錄，更改我的使用環境}。為何這些改變在程式執行完後就消失了呢？如何讓我做的修改顯露出來？</A>
		<LI><A HREF="#_p_">如何關閉一個程序的檔案把手而不用等它完成呢？</A>
		<LI><A HREF="#_p_fork_X_I_daemon">如何 fork 出一個背景執行 (daemon) 程序？</A>
		<LI><A HREF="#_p_M_sh_csh_">如何使我的程式和 sh 及 csh 一起執行？</A>
		<LI><A HREF="#_p_o_O_b_U_">如何得知我是否正在互動模式下執行？</A>
		<LI><A HREF="#_p_w_C_L_H">如何讓一個緩慢的事件過時？</A>
		<LI><A HREF="#_p_w_CPU_H">如何設定 CPU 使用限制？</A>
		<LI><A HREF="#_b_Unix_t_W_p_K_">在 Unix 系統上如何避免產生僵屍程序 (zombies)？</A>
		<LI><A HREF="#_p_SQL_w_H">如何使用一個 SQL 資料庫？</A>
		<LI><A HREF="#_p_system_b_control_C">如何讓 system() 在收到 control-C 後就離開？</A>
		<LI><A HREF="#_p_L_">如何開啟一個檔案但不阻擋其他程序的閱讀？</A>
		<LI><A HREF="#_p_w_CPAN_H">如何安裝一個 CPAN 模組？</A>
		<LI><A HREF="#_p_O_v_w_">如何保有一份自己的 模組／程式庫 目錄？</A>
		<LI><A HREF="#_p_b_m_J_">如何把我的程式所在位置加入 模組／程式庫 搜尋路徑？</A>
		<LI><A HREF="#_p_b_K_v_J">如何在執行時添加目錄到自己的引入路徑中？</A>
	</UL>

	<LI><A HREF="#_p_q_i_H_p">如何從終端機一次抓進一個按鍵？如果用 POSIX 模組時又該怎麼做？</A>
	<LI><A HREF="#_B_P_v">作者、譯者與版權</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="_g_W">篇名

</A></H1>
perlfaq8 - 系統互動（原文版 Revision: 1.21, Date: 1997/04/24 22:44:19. 中文版 $Revision: 1.1 $, $Date: 1998/03/25 03:19:06 $）

<P>

<P>
<HR>
<H1><A NAME="_z">概述

</A></H1>
這部份的 Perl 常見問題集涵蓋關於與作業系統互動的問題。這包括了程序間通訊 [interprocess communication 
(IPC)]、使用者介面的控制（鍵盤、螢幕以及指標 裝置），以及幾乎所有和資料處理無關的事情。

<P>

請閱讀特別針對你所使用的作業系統下的 perl 所寫的常見問題集和文件（例如，
<EM>perlvms</EM>
、<EM>perlplan9</EM>，...），以取得 perl 在個別差異方面更詳盡的資料。

<P>

<P>
<HR>
<H2><A NAME="_p_o_b_t_U">如何得知使用者正在哪個作業系統下執行我的 perl 程式？

</A></H2>

<FONT SIZE=-1>$^O</FONT> 這個變數（若使用 English 
模組就是 
$OSTYPE）會指出你的 perl 解譯器執 行檔是替哪個作業系統、平台所建的。

<P>

<P>
<HR>
<H2><A NAME="_exec_H">為什麼 exec() 不會傳值回來？

</A></H2>
因為這正是它所做的：它用另一個不同的程式來取代你當時所執行的。如果你的程 式需要繼續跑下去（這可能正是你問此問題的原因吧？），改用 <CODE>system()</CODE> 
。

<P>

<P>
<HR>
<H2><A NAME="_p_L_">如何對 鍵盤／螢幕／滑鼠 做些花樣？

</A></H2>
連接／控制 鍵盤、螢幕和指標裝置（「滑鼠」）的方法因作業系統的不同而有不 
同；不妨試試下列模組：

<P>

<DL>
<DT><STRONG><A NAME="item__L">鍵盤

</A></STRONG><DD>
<PRE>    Term::Cap                   perl 標準內建模組
    Term::ReadKey               CPAN
    Term::ReadLine::Gnu         CPAN
    Term::ReadLine::Perl        CPAN
    Term::Screen                CPAN
</PRE>

<P>

<DT><STRONG><A NAME="item__">螢幕

</A></STRONG><DD>
<PRE>    Term::Cap                   perl 標準內建模組
    Curses                      CPAN
    Term::ANSIColor             CPAN
</PRE>

<P>

<DT><STRONG><A NAME="item__">滑鼠

</A></STRONG><DD>
<PRE>    Tk                          CPAN
</PRE>

<P>

</DL>
<P>
<HR>
<H2><A NAME="_p_V_K_X_H">如何向使用者詢問密碼？

</A></H2>
（這個問題跟全球資訊網一點關係也沒有。如果你要找的是跟 
<FONT SIZE=-1>WWW</FONT> 
有關的，那就 看另一份常見問題集吧。）

<P>

【譯註：中文版的 Perl 
<FONT SIZE=-1>CGI</FONT> 程式設計常見問題集可以在下列網址中找到：
<A
HREF="http://www.math.ncu.edu.tw/~chenym/FAQ/Perl/perl-cgi-faq/">http://www.math.ncu.edu.tw/~chenym/FAQ/Perl/perl-cgi-faq/</A>
<BR>
<A
HREF="http://2tigers.net/perl/perl-cgi-faq-chi/">http://2tigers.net/perl/perl-cgi-faq-chi/</A> 】

<P>

在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#crypt">crypt</A> 裡面有個範例。首先，將你的終端機設為「無回應」[no echo] 模式，然後就用平常的方法將密碼讀入。你可以用老式的 <CODE>ioctl()</CODE> 
函數、 
<FONT SIZE=-1>POSIX</FONT> 終端機控制函數（參看
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/POSIX.html#">POSIX</A>
，和 Camel 書第七章），或是呼叫 
<STRONG>stty</STRONG> 程式，這些方法的可攜性／移植性程度都不一樣。

<P>

你也可以在大部份系統上使用 
<FONT SIZE=-1>CPAN</FONT> 裡的 Term::ReadKey 模組，這個模組較易使
用而且理論上也較據可攜性／移植性。

<P>

<P>
<HR>
<H2><A NAME="_p_C_g_H">如何對序列埠做讀寫動作？

</A></H2>
這端看你在什麼作業系統上執行你的程式。以 Unix 來說，序列埠可以透過 /dev 
目錄下的檔案來擷取;
而在其他系統上，設備的名稱無疑地會不一樣。以下是一些
在設備互動時可能遭遇的共同問題：

<P>

<DL>
<DT><STRONG><A NAME="item__">鎖檔 (lockfiles)

</A></STRONG><DD>
你的系統可能會使用鎖檔來控制多重讀寫的情況。確定你用的是正確的協定。因為
當多個程序同時對一個裝置做讀取時可能會發生意想不到的情況。

<P>

<DT><STRONG><A NAME="item__">開檔模式

</A></STRONG><DD>
如果你打算對一個裝置同時做讀與寫的動作，你得將它開到更新的模式（ 在
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#open">open</A> 裡有更詳細的解說）。如果你不希望冒著阻擋其他程序讀取 這個裝置的風險，那就得用 <CODE>sysopen()</CODE> 
和 Fcntl 模組（標準 perl 的一部分）內 的
 <CODE>O_RDWR|O_NDELAY|O_NOCTTY</CODE>。在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#sysopen">sysopen</A> 裡有對此方法更 
詳盡的解說。

<P>

<DT><STRONG><A NAME="item__">檔案尾

</A></STRONG><DD>
有些裝置會等著在每行結尾處看到一個 ``\r''，而非 ``\n''。在某些平台上的 perl， ``\r''和 ``\n'' 與它們平常（在 Unix 
上）所指的 
<FONT SIZE=-1>ASCII</FONT> 值 ``\015'' 
和 ``\012'' 有 所不同。你也許得直接給定數值，例如用八進位 (``\015'')、十六進位 (``0x0D'')， 或指定控制字元 (``\cM'')。

<P>

<PRE>    print DEV &quot;atv1\012&quot;;       # 對某些裝置來說是錯誤的
    print DEV &quot;atv1\015&quot;;       # 對某些裝置來說是對的
</PRE>

<P>

儘管對普通的文字檔案，一個 ``\n'' 便可解決斷行的問題，但目前在不同作業系統 間（Unix、DOS/Win 
和 Macintosh），對於斷行記號仍無統一標準，而只有用 ``\015\012'' 來當成
 <EM>每行</EM>的結尾，然後再視需要去掉輸出中不想要的部份。這 個做法尤其常用於 socket輸出／輸入 
與自動洗清 (autoflushing)，也是接下來 要討論的主題。

<P>

<DT><STRONG><A NAME="item__M_X">洗清輸出

</A></STRONG><DD>
如果你希望 <CODE>print()</CODE>
的時候每個字元都要送到你指定的裝置去，那你應自動清洗
你的檔案把手，舊方法是：

<P>

<PRE>    use FileHandle;
    DEV-&gt;autoflush(1);
</PRE>

<P>

比較新的方法是：

<P>

<PRE>    use IO::Handle;
    DEV-&gt;autoflush(1);
</PRE>

<P>

你可以用 <CODE>select()</CODE> 
和 <CODE>$|</CODE> 
變數來控制自動清洗的動作（參考 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlvar.html#_">$|</A> 

和<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#select">select</A>
）：

<P>

<PRE>    $oldh = select(DEV);
    $| = 1;
    select($oldh);
</PRE>

<P>

你也可能看到不使用額外的暫存變數的寫法，例如：

<P>

<PRE>    select((select(DEV), $| = 1)[0]）;
</PRE>

<P>

如同前一個項目所說的，這方法對 Unix 
和 Macintosh 間的 socket 
輸出／入 
沒 用。在這種情況下，你得把你的行末字元寫死在程式碼內。

<P>

<DT><STRONG><A NAME="item__J">不擋式輸入 (non-blocking input)

</A></STRONG><DD>
如果你正在做一個具阻擋性的 <CODE>read()</CODE> 或 <CODE>sysread()</CODE>
動作，則你需要安排一個鬧 鈴把手或提供一個逾時設定（參看 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#alarm">alarm</A>）。如果你是用非阻擋式的 開檔，那麼就要配合非阻擋性的讀取，也就是說得用到4 個參數的 <CODE>select()</CODE> 
來確 定此裝置的 
輸出／入 是否已準備好了（參考
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#select">select</A>
）。

<P>

</DL>
<P>
<HR>
<H2><A NAME="_p_f_K_K_X_H">如何逆解加密後的密碼檔案？

</A></H2>
花大把大把的錢去買破解專用的硬體，這會讓你成為焦點話題。

<P>

說正經的，如果是碰到 Unix 
密碼檔的話就不行 - Unix 密碼系統用的是單向的加 
密函數。像 Crack 之類的程式可以暴力地（並聰明地）試著猜出密碼，但無法 （也不能）保證速戰速決。

<P>

如果你耽心的是使用者選取不良的密碼，你應該在使用者換密碼時主動審核（例如
說修改 <CODE>passwd(1)</CODE> 程式加入這個功能）。

<P>

<P>
<HR>
<H2><A NAME="_p_I_H">如何啟動一個背景執行的程序？

</A></H2>
你可以使用：

<P>

<PRE>    system(&quot;cmd &amp;&quot;)
</PRE>

<P>

或是用 fork，像 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#fork">fork</A> 裡寫的（在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#">perlipc</A> 裡有更進一步的 範例）。如果你在 Unix 類的系統上的話，請注意以下幾件事情：

<P>

<DL>
<DT><STRONG><A NAME="item_STDIN">STDIN, STDOUT 和 STDERR 是共享的

</A></STRONG><DD>
主程序和背景程序（即「子」程序）共用同一個 
STDIN、STDOUT 
和 
<FONT SIZE=-1>STDERR</FONT> 檔案 把手。如果兩個程序想同時去讀、寫同一個檔案把手，就可能有怪事會發生。你也 許應該替子程序關閉或重新開啟這些把手。你可以用開啟一個管道 (pipe) 的方法 避免這些問題（參看
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#open">open</A>）但是在某些系統上這樣做會強迫子程序 
必須比父程序早死。

<P>

<DT><STRONG><A NAME="item__T_">訊號

</A></STRONG><DD>
SIGCHLD、可能還有 
<FONT SIZE=-1>SIGPIPE</FONT> 這兩個訊號要抓到。當背景程序執行完成後就會送出 
<FONT SIZE=-1>SIGCHLD</FONT> 訊號。而當你寫入一個子程序已經關閉的檔案把手時就會收到 
<FONT SIZE=-1>SIGPIPE</FONT> 
訊號（一個未抓住的 
<FONT SIZE=-1>SIGPIPE</FONT> 可能導致你的程式無聲無息地死去）。用
 
<CODE>system("cmd&")</CODE> 的話不會有這樣的問題。

<P>

<DT><STRONG><A NAME="item__">僵屍程序

</A></STRONG><DD>
你得做準備，在子程序結束時「收成」它：

<P>

<PRE>    $SIG{CHLD} = sub { wait };
</PRE>

<P>

在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 有範例程式教你怎麼做。用 <CODE>system("prog &")</CODE> 的 
話不會有僵屍程序的問題。

<P>

</DL>
<P>
<HR>
<H2><A NAME="_p_r_T_H">如何捕捉 控制字元／訊號？

</A></H2>
你並不能真的 ``捕捉'' 一個控制字元。而是控制字元產生一個訊號讓你捕捉。關於
訊號的資料可以在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 
以及 Camel 
書第六章裡找到。

<P>

要小心的是，大多 
<FONT SIZE=-1>C</FONT> 程式庫無法重新進入 [re-entrant]。因此當你要嘗試著在一 個處理器裡做 <CODE>print()</CODE> 動作，而這個處理器是由另一個stdio 的動作所叫出來的 話，你的內部結構可能會處於失調狀態，而程式可能會丟出記憶核心 (dump core)。 有的時候你可以用 <CODE>syswrite()</CODE> 
取代 <CODE>print()</CODE> 以避免這個狀況。

<P>

除非你極為小心，否則在一個訊號處理器中，唯一安全可做的是：設定一個變數後
離開。而在第一個情況下，你在設定變數的時候應確定 <CODE>malloc()</CODE>
不會被叫出來 （譬如，設定一個已經有值的變數）。

<P>

例如：

<P>

<PRE>    $Interrupted = 0;   # 確定它有個值
    $SIG{INT} = sub {
        $Interrupted++;
        syswrite(STDERR, &quot;哇\n&quot;, 5);
    }
</PRE>

<P>

然而，因為系統呼叫會自己重新啟動，你將會發現如果你用的是「慢的」呼叫，像
&lt;
<FONT SIZE=-1>FH</FONT>&gt;、read()、connect() 或 <CODE>wait()，那麼將它們停下的唯一辦法是使</CODE> 用
「跳遠」的方式跳出來；也就是產生一個例外訊號。參看在 
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 裡對阻擋性 <CODE>flock()</CODE> 的逾時處理器的說明，或駱駝書第六 
章。

<P>

<P>
<HR>
<H2><A NAME="_p_Unix_t_W_K_X_">如何更動 Unix 系統上隱式密碼檔 (shadow password) 的內容？

</A></H2>
如果你的 perl 安裝正確的話，在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#">perlfunc</A> 裡描述的 getpw*() 
函數應該就
能夠讀取隱式密碼檔了（只有讀取權）。要更動該檔案內容，做一個新的密碼檔
（這個檔案的格式因系統而異，請看 <EM>passwd(5)</EM>
）然後用 <CODE>pwd_mkdb(8)（參考</CODE> 
<EM>pwd_mkdb(5)</EM>）來安裝新的密碼檔。

<P>

<P>
<HR>
<H2><A NAME="_p_w_M_H">如何設定時間和日期？

</A></H2>
假設你有足夠的權限，你應該可以用 <CODE>date(1)</CODE> 程式來設定系統的時間與日期。 （但沒有針對個別程序修改時間日期的方法）這機制在 Unix、MS-DOS、Windows 
和 
<FONT SIZE=-1>NT</FONT> 
下都能用；VMS 下則要用
 <CODE>set time</CODE>
。

<P>

然而，如果你只是要更動你的時區，只消設定一個環境變數即可：

<P>

<PRE>    $ENV{TZ} = &quot;MST7MDT&quot;;                  # unix 下
    $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}=&quot;-5&quot; # vms
    system &quot;trn comp.lang.perl&quot;;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_w_p_sle">如何能夠針對小於一秒的時間做 sleep() 或 alarm() 的動作呢？

</A></H2>
如果你要比 <CODE>sleep()</CODE>
所提供的最小單位一秒更精細的話，最簡單的方法就是用 
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#select">select</A> 裡面寫的 <CODE>select()</CODE> 函數。如果你的系統有 itimers 並支
援syscall()，你可以試試下面這個老範例 <A
HREF="http://www.perl.com/CPAN/doc/misc/ancient/tutorial/eg/itimers.pl">http://www.perl.com/CPAN/doc/misc/ancient/tutorial/eg/itimers.pl</A>
.

<P>

<P>
<HR>
<H2><A NAME="_p_q_p_H">如何測量小於一秒的時間？

</A></H2>
一般來說，你可能做不到。 Time::HiRes 
模組（CPAN 有）在某些系統上能達到此 
功能。

<P>

總之，你可能做不到。但是如果你的 Perl 支援 <CODE>syscall()</CODE>
函數並支援類似 <CODE>gettimeofday(2)</CODE> 的系統呼叫，你也許可以這麼做：

<P>

<PRE>    require 'sys/syscall.ph';
</PRE>

<P>

<PRE>    $TIMEVAL_T = &quot;LL&quot;;
</PRE>

<P>

<PRE>    $done = $start = pack($TIMEVAL_T, ());
</PRE>

<P>

<PRE>    syscall( &amp;SYS_gettimeofday, $start, 0)) != -1
               or die &quot;gettimeofday: $!&quot;;
</PRE>

<P>

<PRE>       ##########################
       #    在這做你要做的事    #
       ##########################
</PRE>

<P>

<PRE>    syscall( &amp;SYS_gettimeofday, $done, 0) != -1
           or die &quot;gettimeofday: $!&quot;;
</PRE>

<P>

<PRE>    @start = unpack($TIMEVAL_T, $start);
    @done  = unpack($TIMEVAL_T, $done);
</PRE>

<P>

<PRE>    # fix microseconds
    for ($done[1], $start[1]) { $_ /= 1_000_000 }
</PRE>

<P>

<PRE>    $delta_time = sprintf &quot;%.4f&quot;, ($done[0]  + $done[1] )
                                            -
                                 ($start[0] + $start[1] );
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_atexit_setjmp_long">如何做 atexit() 或 setjmp()/longjmp() 的動作？（例外處理）

</A></H2>
第五版的 Perl 
增加了 
<FONT SIZE=-1>END</FONT> 區塊，可以用來模擬 <CODE>atexit()的效果。當程式或執行</CODE> 緒(thread) 終了時就會去呼叫該包裝的 
<FONT SIZE=-1>END</FONT> 區塊（參考
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlmod.html#">perlmod</A> 
文件）。但 是如果當程式被沒有抓到的訊號終結了，END 區塊就不會被呼叫到，所以當你用 
<FONT SIZE=-1>END</FONT> 
時應再加上

<P>

<PRE>        use sigtrap qw(die normal-signals);
</PRE>

<P>

Perl 的例外處理機制就是它的 <CODE>eval()</CODE> 運算子。你可以把 <CODE>eval()</CODE> 當做 setjmp 而die()當做 longjmp 
來使用。更詳細的說明請參考
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 
和 Camel書第六章裡關於訊號的那段，尤其是描述有關
<CODE>flock()</CODE> 的逾時處理器那段。

<P>

如果你只對例外處理的部分有興趣，試試 exceptions.pl 程式庫（包含在標準
perl裡）。

<P>

如果你要的是 <CODE>atexit()</CODE> 語法（以及 <CODE>rmexit()），試試</CODE> 
<FONT SIZE=-1>CPAN</FONT> 裡的 AtExit 
模組。

<P>

<P>
<HR>
<H2><A NAME="_sockets_b_System_V">為何我的 sockets 程式在 System V (Solaris) 系統下不能用？「不支援本協定」這個錯誤訊息又是什麼意思？

</A></H2>
有些 Sys-V 根底的系統，特別像 Solaris 2.X，已重新將一些標準的 socket常數 定義過了。由於這些常數在各種架構下都是定值，所以在 perl程式碼中常被人寫 死在裡面。處理此問題的適當方式 
是用 ``use Socket'' 來取得正確的值。

<P>

須注意儘管 SunOS 
和 Solaris 在二進位執行檔上相容，這些值是相異的。自己去 想為什麼吧。

<P>

<P>
<HR>
<H2><A NAME="_p_q_Perl_I_s_t_W_S_C">如何從 Perl 裡呼叫系統中獨特的 C 函數？

</A></H2>
通常是寫個外部的模組來處理 - 參看「我要如何學到將 
<FONT SIZE=-1>C</FONT> 
與 Perl 連結在一起？ [h2xs, xsubpp]」 這問題的答案。然而，如果此函數是個系統呼叫，而你的系統 有支援 <CODE>syscall()，那麼可以用</CODE> syscall 函數（說明在
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#">perlfunc</A> 
裡）。

<P>

切記先查查看你的 perl 
版本中所附的模組以及 
<FONT SIZE=-1>CPAN</FONT> 裡的模組，因為也許某人已 經寫了個這樣的模組。

<P>

<P>
<HR>
<H2><A NAME="_b_i_H_J_ioctl_">在哪裡可以找引入檔來做 ioctl() 或 syscall()？

</A></H2>
以前這些檔案會由標準 perl 發行中所附的 h2ph 工具來產生。這個程式將 
<FONT SIZE=-1>C</FONT> 標 
頭檔案裡的 <CODE>cpp(1)指令轉換成內含副程式定義的檔案，像</CODE> &amp;SYS_getitimer，你可 以把它當做函數的參數。這樣做並不怎麼完美，但通常可達成任務。簡單的像
 
<EM>errno.h</EM>
、<EM>syscall.h</EM> 
和<EM>socket.h</EM> 這些檔案都沒問題，但像 <EM>ioctl.h</EM>
這種較難的檔案總是需要人工編輯。以下是安裝 *.ph 
檔案的步驟：

<P>

<PRE>    1.  進入最高使用者帳戶
    2.  cd /usr/include
    3.  h2ph *.h */*.h
</PRE>

<P>

如果你的系統支援動態載入，那麼為了可攜性、而且合理的做法是使用 h2xs（也 
是 perl的標準配備）。這個工具將 
<FONT SIZE=-1>C</FONT> 
標頭檔案轉換成 Perl 的衍伸檔案 (extensions)。 h2xs 的入門要看
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlxstut.html#">perlxstut</A>
。

<P>

如果你的系統不支援動態載入，你可能仍應使用 h2xs。參看 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlxstut.html#">perlxstut</A> 
和
<A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/ExtUtils/MakeMaker.html">MakeMaker</A>
（簡單來說，就是用 <STRONG>make perl</STRONG>
、而非 <STRONG>make</STRONG>來重 建一份使用新的靜態連結的 perl）。

<P>

<P>
<HR>
<H2><A NAME="_setuid_perl_">為何 setuid perl 程式會抱怨關於系統核心的問題？

</A></H2>
有些作業系統的核心有臭蟲使得 setuid 程式在先天上就不安全。Perl提供你一些
方法（在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlsec.html#">perlsec</A> 裡有寫）可跳過這些系統的缺陷。

<P>

<P>
<HR>
<H2><A NAME="_p_Y_J_J_S_X_">如何打開對某程式既輸入又輸出的管道 (pipe)？

</A></H2>
IPC::Open2 模組（perl 的標準配件）是個好用的方法，它在內部是藉著pipe()、 <CODE>fork()</CODE> 
和 <CODE>exec()</CODE> 來完成此工作。不過切記要讀它文件裡關於鎖死的警告 (
<A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/IPC/Open2.html">Open2</A>
)。

<P>

<P>
<HR>
<H2><A NAME="_system_o_o_O">為何用 system() 卻得不到一個指令的輸出呢？

</A></H2>

你把 <CODE>system()</CODE> 
和反向引號 (``) 的用法搞混了。 <CODE>system()</CODE> 
會執行一個指令然後 傳回指令結束時的狀況資訊（以一個 16 進位值表示：低位元是程序中止所收到的 訊號，高位元才是真正離開時的傳回值）。反向引號 (``) 
執行一個指令並且把它 所送出的東西送到 
STDOUT。

<P>

<PRE>    $exit_status = system(&quot;mail-users&quot;);
    $output_string = `ls`;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_O_STDERR_H">如何補捉外部指令的 STDERR？

</A></H2>

有三種基本方式執行外部指令：

<P>

<PRE>    system $cmd;                # 使用 system()
    $output = `$cmd`;           # 使用 反向引號 (``)
    open (PIPE, &quot;cmd |&quot;);       # 使用 open()
</PRE>

<P>

在 <CODE>system()</CODE> 
下，STDOUT 
和 
<FONT SIZE=-1>STDERR</FONT> 
都會輸出到和 script 本身的 
<FONT SIZE=-1>STDOUT,</FONT> 
STDERR相同的出處，除非指令本身將它們導向它處。反向引號和 <CODE>open()</CODE> 則
 <STRONG>只</STRONG>

讀取指令的 
<FONT SIZE=-1>STDOUT</FONT> 
部份。

<P>

在上述方法中，你可以在呼叫前更改檔案描述元 (file descriptor) 
名稱：

<P>

<PRE>    open(STDOUT, &quot;&gt;logfile&quot;);
    system(&quot;ls&quot;);
</PRE>

<P>

或者使用 Bourne shell 的檔案描述元重導功能：

<P>

<PRE>    $output = `$cmd 2&gt;some_file`;
    open (PIPE, &quot;cmd 2&gt;some_file |&quot;);
</PRE>

<P>

也可以用檔案描述元重導功能將 
<FONT SIZE=-1>STDERR</FONT> 
導向到 
STDOUT：

<P>

<PRE>    $output = `$cmd 2&gt;&amp;1`;
    open (PIPE, &quot;cmd 2&gt;&amp;1 |&quot;);
</PRE>

<P>

注意你 <EM>不能</EM> 
光是將 
<FONT SIZE=-1>STDERR</FONT> 開成 
<FONT SIZE=-1>STDOUT</FONT> 的複製，而不呼叫 shell來做這個 重導的工作。這樣是不行的：

<P>

<PRE>    open(STDERR, &quot;&gt;&amp;STDOUT&quot;);
    $alloutput = `cmd args`; # stderr 仍然會跑掉
</PRE>

<P>

失敗的原因是，open() 讓 
<FONT SIZE=-1>STDERR</FONT> 在呼叫 <CODE>open()</CODE> 時往 
STDOUT的方向走。然後反 
向引號讓 STDOUT的內容跑到一個字串變數裡，但是沒有改變 
<FONT SIZE=-1>STDERR</FONT> 的去向（它 
仍然往舊的 
STDOUT那裡跑）。

<P>

注意，在反向引號裡你 <EM>必須</EM> 使用 Bourne shell (sh(1)) 重導的語法而非 <CODE>csh(1)的！至於為何</CODE>
Perl 的 <CODE>system()、反向引號和開管道都用</CODE> Bourne shell語
法的原因，可在下址找到： <A
HREF="http://www.perl.com/CPAN/doc/FMTEYEWTK/versus/csh.whynot">http://www.perl.com/CPAN/doc/FMTEYEWTK/versus/csh.whynot</A>

<P>

你也可以使用 IPC::Open3 模組（perl 標準配備），但注意它的參數順序和
IPC::Open2不一樣（參看 <A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/IPC/Open3.html">Open3</A>
）。

<P>

<P>
<HR>
<H2><A NAME="_D_open_">為何當管道開啟失敗時 open() 不會傳回錯誤訊息？

</A></H2>
其實會，只是或許並非以你期望的方式。在遵循標準 <CODE>fork()/exec()</CODE> 機制的系統 上（例如，Unix），運作原理是這樣的：open() 
導致一個 <CODE>fork()。在父程序裡，</CODE> <CODE>open()傳回子程序的ID。然後子程序</CODE> <CODE>exec()</CODE> 從管道傳來／出 
的指令。父程序無 法得知 <CODE>exec()</CODE> 的動作成功與否－它能傳回的只有 <CODE>fork()</CODE> 
動作成功與否的消息。 要找出這指令是否順利執行，你得補捉 
SIGCHLD訊號並 <CODE>wait()</CODE> 以得到子程序離開 時的狀態。如果你要寫資料到子程序，則 SIGPIPE也該一並捕捉－否則在你寫入之 前可能無法察覺 <CODE>exec()</CODE> 動作已失敗了。這些在
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#">perlipc</A> 
文件裡都有說明。

<P>

在使用 <CODE>spawn()</CODE> 機制的系統裡，open() <EM>也許</EM> 
能達到你所期望的－除非 perl 使用一個 shell 來起始你的指令。在這情況下以上對 <CODE>fork()/exec()</CODE> 的描述仍適 
用。

<P>

<P>
<HR>
<H2><A NAME="_b_X_O_V_">在輸出值是空的情境裡使用反向引號有何不對？

</A></H2>
嚴格說起來，沒啥不對。但從程式寫作嚴謹與否來說，這樣無法寫出較易維護的程
式碼，因為反向引號有一個（可能很巨大的）傳回值，而你卻忽略它。同時這也是
缺乏效率的方法，因為你得把每行所有的輸出讀進來、留一塊記憶體給它們，然後
再把它們丟開。人們常常做下列這種事：

<P>

<PRE>    `cp file file.bak`;
</PRE>

<P>

然後它們就會想：「嘿，乾脆以後都用反向引號來執行程式好了。」這是餿主意， 因為反向引號的目的在補捉程式的輸出；system() 
函數才是用來執行程式的。

<P>

再看看下列這一行：

<P>

<PRE>    `cat /etc/termcap`;
</PRE>

<P>

你還沒有指定輸出，所以它會浪費記憶體（就那麼一下子)。另外你也忘了檢查 
<CODE>$?</CODE> 看看程式是否正確的執行。即使你寫成

<P>

<PRE>    print `cat /etc/termcap`;
</PRE>

<P>

但在大部份情況下，這本來可以、而且也應該寫成

<P>

<PRE>    system(&quot;cat /etc/termcap&quot;) == 0
        or die &quot;cat program failed!&quot;;
</PRE>

<P>

這樣可快速地得到輸出（一產生出來就會得到，不用等到最後），並且檢查傳回值。

<P>

<CODE>system()</CODE> 同時具有直接決定是否先做 shell 萬用字元 (wildcard)處理的功能， 
反向引號就不行。

<P>

<P>
<HR>
<H2><A NAME="_p_g_L_shell_B_z_I_s_V_">如何不經過 shell 處理來呼叫反向引號？

</A></H2>
這需要些技巧。本來是寫成

<P>

<PRE>    @ok = `grep @opts '$search_string' @filenames`;
</PRE>

<P>

你得改成：

<P>

<PRE>    my @ok = ();
    if (open(GREP, &quot;-|&quot;)) {
        while (&lt;GREP&gt;) {
            chomp;
            push(@ok, $_);
        }
        close GREP;
    } else {
        exec 'grep', @opts, $search_string, @filenames;
    }
</PRE>

<P>

一如 <CODE>system()，當你</CODE> <CODE>exec()</CODE> 
一個序列時不會有 shell 解譯的情況發生。

<P>

<P>
<HR>
<H2><A NAME="_F_EOF_Unix_W_O_D_AMS_D">為何給了 EOF（Unix 上是 ^D，MS-DOS 上是 ^Z）後我的程式就不能從 STDIN 讀取東西了呢？

</A></H2>

因為某些 stdio 的 set error 
和 eof 旗標需要清除。你可以用 
<FONT SIZE=-1>POSIX</FONT> 模組裡定 義的clearerr()。這是在技術上正確的解決之道。還有一些較不保險的方法：

<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
試著保存搜尋指標然後去找它，例如：

<P>

<PRE>    $where = tell(LOG);
    seek(LOG, $where, 0);
</PRE>

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
如果那樣行不通，試著去 <CODE>seek()</CODE> 檔案的另一部份然後再找回來。

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
如果還是行不通，試著 <CODE>seek()</CODE>
檔案另一個相異的的部份，讀點東西，再回去找。

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
如果依然不行，放棄使用 stdio 改用 sysread。

<P>

</OL>
<P>
<HR>
<H2><A NAME="_p_shell_perl_H">如何把 shell 程式轉成 perl？

</A></H2>
學習 Perl 然後重寫。說真的，沒有簡單的轉換方式。用 shell 做起來很笨的工 作可以用 Perl 很輕鬆的做到，而就是這些麻煩之處使得 shell-&gt;perl 轉換程式 非常不可能寫得出來。在重新撰寫程式的過程裡，你會認清自己真正要做的工作為 
何，也希望能夠跳脫 shell 的管線資料流機制 [pipeline datastream paradigm]， 這東西雖對某些事情很方便，但也常造成低效率。

<P>

<P>
<HR>
<H2><A NAME="perl_B_z_telnet_ftp_o_">perl 能處理 telnet 或 ftp 這種雙向互動嗎？

</A></H2>
試試 Net::FTP、TCP::Client 
和 NET::Telnet 
模組（CPAN 
有）。 <A HREF="http://www.perl.com/CPAN/scripts/netstuff/telnet.emul.shar">http://www.perl.com/CPAN/scripts/netstuff/telnet.emul.shar</A>也有助於模擬 telnet 協定，但是 Net::Telnet 可能較容易使用。

<P>

如果你所要做的只是假裝 telnet 但又不要起始 telnet 時的溝通程序，那麼以下
這個標準的雙程序方式就可以滿足你的需要了：

<P>

<PRE>    use IO::Socket;             # 5.004 才有的新模組
    $handle = IO::Socket::INET-&gt;new('www.perl.com:80')
            || die &quot;無法接上 www.perl.com 的 port 80： $!&quot;;
    $handle-&gt;autoflush(1);
    if (fork()) {               # XXX: undef 表示失敗
        select($handle);
        print while &lt;STDIN&gt;;    # 將所有從 stdin 來的丟到 socket
    } else {
        print while &lt;$handle&gt;;  # 將所有 socket 來的丟到 stdout
    }
    close $handle;
    exit;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_b_Perl_F_Expect_">如何在 Perl 裡達到 Expect 的功能？

</A></H2>
很久很久以前，有個叫做 chat2.pl 的程式庫（perl 標準配備之一），但一直沒 真正完工。現在，你的最佳選擇就是從 
<FONT SIZE=-1>CPAN</FONT> 來的 Comm.pl 程式庫。

<P>

<P>
<HR>
<H2><A NAME="_S_i_N_perl_O_C_">有沒有可能將 perl 的指令列隱藏起來，以躲避像 "ps" 之類的程式？

</A></H2>
首先要注意的是，如果你的目的是為了安全（例如避免人們偷看到密碼），那你應
該重寫你的程式，把重要的資訊從參數中剔除。光是隱藏起來不會讓你的程式變得
完全安全。

<P>

如要真的把看得見的指令列改掉，你可以設定 <CODE>$0</CODE> 這個變數值，如同 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlvar.html#">perlvar</A>
裡寫的。但這方法並非各種作業系統都適用。像 sendmail之類的背景程式 (daemons)
就將它們的狀態放在那兒：

<P>

<PRE>    $0 = &quot;orcus [accepting connections]&quot;;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_b_perl_script_A_">我在 perl script 裡 {更動目錄，更改我的使用環境}。為何這些改變在程式執行完後就消失了呢？如何讓我做的修改顯露出來？

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Unix">Unix

</A></STRONG><DD>
嚴格的說起來，這是做不到的－一個 script 的執行是從啟動它的 shell 
生出一 個不同的程序來執行。這個程序的任何變動不會反映到它的父程序，只會反映到更 改之後它自己創造出來的子程序。有個 shell 魔術可以讓你藉著在 shell 裡 <CODE>eval()你</CODE> script 的輸出來裝出這種效果，在 comp.unix.questions 
<FONT SIZE=-1>FAQ</FONT> 裡有詳 細內容。

<P>

<DT><STRONG><A NAME="item_VMS">VMS

</A></STRONG><DD>
對 <CODE>%ENV</CODE> 的更改會持續到 Perl 離開，但是目錄更動則不會。

<P>

</DL>
<P>
<HR>
<H2><A NAME="_p_">如何關閉一個程序的檔案把手而不用等它完成呢？

</A></H2>
假設你的系統支援這種功能，那就只要送個適當的訊號給此程序（參看 
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#kill">kill</A>）。通常是先送一個 
<FONT SIZE=-1>TERM</FONT> 訊號，等一下下，然後再送個 
<FONT SIZE=-1>KILL</FONT> 訊號去終結它。

<P>

<P>
<HR>
<H2><A NAME="_p_fork_X_I_daemon">如何 fork 出一個背景執行 (daemon) 程序？

</A></H2>
如果你所指的是離線的程序（未與 tty 連線者），那下列的程序據說在大部份的 Unix系統都能用。非 Unix 系統的使用者應該檢查 Your_OS::Process 模組看看有 
沒有其他的解決方案。

<P>

<UL>
<LI><STRONG></STRONG>
打開 /dev/tty 
然後對它用 
<FONT SIZE=-1>TIOCNOTTY</FONT> ioctl。請參考
 <EM>tty(4)</EM>
。

<P>

<LI><STRONG></STRONG>
把目錄換到 /

<P>

<LI><STRONG></STRONG>
重開 
STDIN、STDOUT 
和 
<FONT SIZE=-1>STDERR</FONT> 
使它們不會與舊的 tty 連接。

<P>

<LI><STRONG></STRONG>
用下列方法把程式丟到背景：

<P>

<PRE>    fork &amp;&amp; exit;
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="_p_M_sh_csh_">如何使我的程式和 sh 及 csh 一起執行？

</A></H2>
參看 <EM>eg/nih</EM> 這 script（perl 原始碼發行的一部分）。

<P>

<P>
<HR>
<H2><A NAME="_p_o_O_b_U_">如何得知我是否正在互動模式下執行？

</A></H2>
問得好。有的時候 <CODE>-t STDIN</CODE> 
和 <CODE>-t STDOUT</CODE> 可以提供線索，有時不行。

<P>

<PRE>    if (-t STDIN &amp;&amp; -t STDOUT) {
        print &quot;Now what? &quot;;
    }
</PRE>

<P>

在 
<FONT SIZE=-1>POSIX</FONT> 系統中，你可以用以下方法測試你自己的程序群組與現在控制你終端機 
的是否相同：

<P>

<PRE>    use POSIX qw/getpgrp tcgetpgrp/;
    open(TTY, &quot;/dev/tty&quot;) or die $!;
    $tpgrp = tcgetpgrp(TTY);
    $pgrp = getpgrp();
    if ($tpgrp == $pgrp) {
        print &quot;前景\n&quot;;
    } else {
        print &quot;背景\n&quot;;
    }
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_w_C_L_H">如何讓一個緩慢的事件過時？

</A></H2>
如同 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 
和 Camel 書第六章裡所描述的，用 <CODE>alarm()</CODE> 
函數， 或許再配合上一個訊號處理器。你也可以改用 
<FONT SIZE=-1>CPAN</FONT> 裡更具彈性的 Sys::AlarmCall 
模組來做。

<P>

<P>
<HR>
<H2><A NAME="_p_w_CPU_H">如何設定 CPU 使用限制？

</A></H2>
使用 
<FONT SIZE=-1>CPAN</FONT> 裡的 BSD::Resource 
模組。

<P>

<P>
<HR>
<H2><A NAME="_b_Unix_t_W_p_K_">在 Unix 系統上如何避免產生僵屍程序 (zombies)？

</A></H2>
使用 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#Signals">Signals</A> 裡面叫 reaper 的程式碼，在接到 
<FONT SIZE=-1>SIGCHLD</FONT> 
時會呼 叫wait()，或是用
 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlfunc.html#fork">fork</A> 裡面寫的雙 fork 
技巧。

<P>

<P>
<HR>
<H2><A NAME="_p_SQL_w_H">如何使用一個 SQL 資料庫？

</A></H2>
有幾個連接 
<FONT SIZE=-1>SQL</FONT> 資料庫非常好的界面。參看 <A HREF="http://www.perl.com/CPAN/modules/dbperl/DBD">http://www.perl.com/CPAN/modules/dbperl/DBD</A> 裡的 
<FONT SIZE=-1>DBD::*</FONT> 
模組。

<P>

<P>
<HR>
<H2><A NAME="_p_system_b_control_C">如何讓 system() 在收到 control-C 後就離開？

</A></H2>
做不到。你需要摹仿 <CODE>system()</CODE> 呼叫（參看 <A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlipc.html#">perlipc</A>
裡的範例程式），然後設計一個訊號處理器，讓它把 
<FONT SIZE=-1>INT</FONT> 訊號傳給子程序。

<P>

<P>
<HR>
<H2><A NAME="_p_L_">如何開啟一個檔案但不阻擋其他程序的閱讀？

</A></H2>
如果你有幸使用到支援非阻擋性讀取的系統（大部份 Unix 般的系統都有支援）， 你只需要用 Fcntl 模組裡的 
<FONT SIZE=-1>O_NDELAY</FONT> 或 
<FONT SIZE=-1>O_NONBLOCK</FONT> 旗標，配合 <CODE>sysopen()：</CODE>

<P>

<PRE>    use Fcntl;
    sysopen(FH, &quot;/tmp/somefile&quot;, O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die &quot;can't open /tmp/somefile: $!&quot;;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_w_CPAN_H">如何安裝一個 CPAN 模組？

</A></H2>
最簡單的方法就是讓 
<FONT SIZE=-1>CPAN</FONT> 這個模組替你代勞。這個模組包含在 
5.004及以後的版 本中。如要手動安裝 
<FONT SIZE=-1>CPAN</FONT> 模組，或是任何按規矩發展的 
CPAN模組，遵循以下步 
驟：

<P>

<OL>
<LI><STRONG><A NAME="item_">

</A></STRONG>
把原始碼解開放到一個暫存區域

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
<PRE>    perl Makefile.PL
</PRE>

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
<PRE>    make
</PRE>

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
<PRE>    make test
</PRE>

<P>

<LI><STRONG><A NAME="item_">

</A></STRONG>
<PRE>    make install
</PRE>

<P>

</OL>
如果你用的 perl 版本在編譯時沒有建入動態連結的功能，那你只消把第三步 (<STRONG>make</STRONG>)換成 <STRONG>make perl</STRONG> 然後你就會得到一個新的 <EM>perl</EM> 執行檔，裡頭連 有你新加入的延伸。

<P>

在 <A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/ExtUtils/MakeMaker.html">MakeMaker</A>裡面有更多關於建構模組的細節，並參考「如何保有 一份自己的
模組／程式庫目錄？」這個問題。

<P>

<P>
<HR>
<H2><A NAME="_p_O_v_w_">如何保有一份自己的 模組／程式庫 目錄？

</A></H2>
當你建構模組時，在產生 Makefiles 時使用 
<FONT SIZE=-1>PREFIX</FONT> 
選項：

<P>

<PRE>    perl Makefile.PL PREFIX=/u/mydir/perl
</PRE>

<P>

然後在執行用到此 模組／程式庫 的程式前先設好 
<FONT SIZE=-1>PERL5LIB</FONT> 環境變數（參考 
<A HREF="http://www.perl.org/CPAN/doc/manual/html/pod/perlrun.html#">perlrun</A>
），或是用

<P>

<PRE>    use lib '/u/mydir/perl';
</PRE>

<P>

進一步的資料可在 Perl 的 <A HREF="http://www.perl.org/CPAN/doc/manual/html/lib/lib.html#">lib</A> 
手冊中找到。

<P>

<P>
<HR>
<H2><A NAME="_p_b_m_J_">如何把我的程式所在位置加入 模組／程式庫 搜尋路徑？

</A></H2>
<PRE>    use FindBin;
    use lib &quot;$FindBin:Bin&quot;;
    use your_own_modules;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="_p_b_K_v_J">如何在執行時添加目錄到自己的引入路徑中？

</A></H2>
以下是我們建議更動引入路徑的方法：

<P>

<PRE>    PERLLIB 環境變數
    PERL5LIB 環境變數
    perl -Idir 指令列參數
    use lib pragma, as in
        use lib &quot;$ENV{HOME}/myown_perllib&quot;;
</PRE>

<P>

後者特別有用，因為它知道與機器相關的架構。lib.pm 機制模組是從 5.002 版開 始包含在 Perl 
裡面的。

<P>

<P>
<HR>
<H1><A NAME="_p_q_i_H_p">如何從終端機一次抓進一個按鍵？如果用 POSIX 模組時又該怎麼做？

</A></H1>
<PRE>    #!/usr/bin/perl -w
    use strict;
    $| = 1;
    for (1..4) {
        my $got;
        print '給我： ';
        $got = getone();
        print &quot;--&gt; $got\n&quot;;
    }
    exit;
</PRE>

<P>

<PRE>    BEGIN {
        use POSIX qw(:termios_h);
</PRE>

<P>

<PRE>        my ($term, $oterm, $echo, $noecho, $fd_stdin);
</PRE>

<P>

<PRE>        $fd_stdin = fileno(STDIN);
</PRE>

<P>

<PRE>        $term     = POSIX::Termios-&gt;new();
        $term-&gt;getattr($fd_stdin);
        $oterm     = $term-&gt;getlflag();
</PRE>

<P>

<PRE>        $echo     = ECHO | ECHOK | ICANON;
        $noecho   = $oterm &amp; ~$echo;
</PRE>

<P>

<PRE>        sub cbreak {
            $term-&gt;setlflag($noecho);
            $term-&gt;setcc(VTIME, 1);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
</PRE>

<P>

<PRE>        sub cooked {
            $term-&gt;setlflag($oterm);
            $term-&gt;setcc(VTIME, 0);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
</PRE>

<P>

<PRE>        sub getone {
            my $key = '';
            cbreak();
            sysread(STDIN, $key, 1);
            cooked();
            return $key;
        }
</PRE>

<P>

<PRE>    }
    END { cooked() }
</PRE>

<P>

<P>
<HR>
<H1><A NAME="_B_P_v">作者、譯者與版權

</A></H1>
Copyright (c) 1997 Tom Christiansen and Nathan Torkington. All rights reserved. 
有關使用、（ 轉 ）發行事宜，詳見
 <A HREF="perlfaq.html">perlfaq</A>

<P>

譯者：陳彥銘、蕭百齡

<P>

中譯版著作權所有：陳彥銘、蕭百齡及兩隻老虎工作室。本中譯版遵守並使用與原
文版相同的使用條款發行。

</BODY>
</HTML>
