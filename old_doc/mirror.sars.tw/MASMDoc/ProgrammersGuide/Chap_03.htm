<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
		<meta name="ProgId" content="Word.Document">
		<meta name="Generator" content="Microsoft Word 9">
		<meta name="Originator" content="Microsoft Word 9">
		<link rel="File-List" href="Chap_03_files/filelist.xml">
		<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
		<title>CHAPTER 3</title>
		<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Terri Sharkey</o:Author>
  <o:Keywords>{artman 1,M:\SLM\SRC\MASM61\APPS\ART\mpchp03.doc}</o:Keywords>
  <o:Description>Converted with 6/12/92 version of Win2Word</o:Description>
  <o:Template>MSGRIDA1.DOT</o:Template>
  <o:LastAuthor>Randall Hyde</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>435</o:TotalTime>
  <o:LastPrinted>1992-10-30T00:05:00Z</o:LastPrinted>
  <o:Created>2001-09-06T22:19:00Z</o:Created>
  <o:LastSaved>2001-09-06T22:19:00Z</o:LastSaved>
  <o:Pages>33</o:Pages>
  <o:Words>9469</o:Words>
  <o:Characters>60089</o:Characters>
  <o:Company>Dell Computer Corporation</o:Company>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
		<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:PrintColBlack/>
   <w:ShowBreaksInFrames/>
   <w:SuppressSpBfAfterPgBrk/>
   <w:SwapBordersFacingPages/>
   <w:ConvMailMergeEsc/>
   <w:UsePrinterMetrics/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:NoSpaceRaiseLower/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
		<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Times;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Helvetica-Narrow;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Arial Narrow";
	panose-1:2 11 5 6 2 2 2 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Lucida Sans Typewriter";
	panose-1:2 11 5 9 3 5 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:-1.25in;
	line-height:22.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:20.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-font-kerning:0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-parent:"Heading 1";
	mso-style-next:Normal;
	margin-top:7.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-1.25in;
	line-height:19.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:17.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-bidi-font-weight:normal;}
h3
	{mso-style-parent:"Heading 1";
	mso-style-next:Normal;
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:17.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:15.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-bidi-font-weight:normal;}
h4
	{mso-style-parent:"Heading 1";
	mso-style-next:Normal;
	margin-top:3.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:14.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:4;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-bidi-font-weight:normal;}
h5
	{mso-style-parent:"Heading 1";
	mso-style-next:Normal;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:5;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-bidi-font-weight:normal;}
h6
	{mso-style-parent:"Heading 1";
	mso-style-next:H6p;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:11.9pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:6;
	mso-element:frame;
	mso-element-frame-height:12.75pt;
	mso-element-frame-hspace:6.5pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:column;
	mso-element-top:.05pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-bidi-font-weight:normal;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-next:"Normal Indent";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	mso-outline-level:7;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-next:"Normal Indent";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	mso-outline-level:8;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-next:"Normal Indent";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	mso-outline-level:9;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex1, li.MsoIndex1, div.MsoIndex1
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex2, li.MsoIndex2, div.MsoIndex2
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex3, li.MsoIndex3, div.MsoIndex3
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex4, li.MsoIndex4, div.MsoIndex4
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.75in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex5, li.MsoIndex5, div.MsoIndex5
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:1.0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex6, li.MsoIndex6, div.MsoIndex6
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:1.25in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndex7, li.MsoIndex7, div.MsoIndex7
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:1.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right dotted 348.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{mso-style-parent:"TOC 1";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right dotted 348.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{mso-style-parent:"TOC 1";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:28.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right dotted 348.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:.5in;
	margin-bottom:8.0pt;
	margin-left:1.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:dotted 5.75in right blank 6.0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:.5in;
	margin-bottom:8.0pt;
	margin-left:2.0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:dotted 5.75in right blank 6.0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:.5in;
	margin-bottom:8.0pt;
	margin-left:2.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:dotted 5.75in right blank 6.0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:.5in;
	margin-bottom:8.0pt;
	margin-left:3.0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:dotted 5.75in right blank 6.0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{mso-style-next:Normal;
	margin-top:0in;
	margin-right:.5in;
	margin-bottom:8.0pt;
	margin-left:3.5in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:dotted 5.75in right blank 6.0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:green;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-parent:"";
	mso-style-next:"header rule";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:-1.25in;
	margin-bottom:.0001pt;
	line-height:10.5pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	tab-stops:right 348.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:7.0pt;
	mso-pagination:widow-orphan;
	mso-element:frame;
	mso-element-wrap:around;
	mso-element-anchor-vertical:page;
	mso-element-anchor-horizontal:page;
	mso-element-left:100.0pt;
	mso-element-top:735.15pt;
	mso-height-rule:exactly;
	font-size:5.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoIndexHeading, li.MsoIndexHeading, div.MsoIndexHeading
	{mso-style-next:"Index 1";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.MsoFootnoteReference
	{mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	mso-text-raise:3.0pt;}
span.MsoCommentReference
	{color:green;}
p.Wh, li.Wh, div.Wh
	{mso-style-name:Wh;
	mso-style-parent:Nh;
	mso-style-next:Np1;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:11.9pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-height:11.75pt;
	mso-element-frame-hspace:6.5pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:column;
	mso-element-top:.05pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:blue;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Ws, li.Ws, div.Ws
	{mso-style-name:Ws;
	mso-style-parent:"";
	mso-style-next:Wh;
	margin-top:2.0pt;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:1.5pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-bottom-alt:double blue 2.25pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.We, li.We, div.We
	{mso-style-name:We;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:1.5pt;
	margin-bottom:.0001pt;
	line-height:10.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-top-alt:double blue 2.25pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Np1, li.Np1, div.Np1
	{mso-style-name:Np1;
	mso-style-parent:Np2;
	mso-style-next:Ne;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Nh, li.Nh, div.Nh
	{mso-style-name:Nh;
	mso-style-parent:"";
	mso-style-next:Np1;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:11.9pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-height:11.75pt;
	mso-element-frame-hspace:6.5pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:column;
	mso-element-top:.05pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Ne, li.Ne, div.Ne
	{mso-style-name:Ne;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:2.0pt;
	margin-left:1.5pt;
	line-height:7.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Ns, li.Ns, div.Ns
	{mso-style-name:Ns;
	mso-style-parent:"";
	mso-style-next:Nh;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:1.5pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-bottom-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 1.0pt 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Nhi, li.Nhi, div.Nhi
	{mso-style-name:Nhi;
	mso-style-parent:Nh;
	mso-style-next:Np1i;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:11.9pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-height:11.75pt;
	mso-element-frame-hspace:6.5pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:column;
	mso-element-top:.05pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Nsi, li.Nsi, div.Nsi
	{mso-style-name:Nsi;
	mso-style-parent:Ns;
	mso-style-next:Nhi;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:15.5pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-bottom-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 1.0pt 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Np1i, li.Np1i, div.Np1i
	{mso-style-name:Np1i;
	mso-style-parent:Np1;
	mso-style-next:Nei;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Nei, li.Nei, div.Nei
	{mso-style-name:Nei;
	mso-style-parent:Ne;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:15.5pt;
	margin-bottom:.0001pt;
	line-height:7.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Wsi, li.Wsi, div.Wsi
	{mso-style-name:Wsi;
	mso-style-parent:Ws;
	mso-style-next:Whi;
	margin-top:2.0pt;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:15.5pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-bottom-alt:double blue 2.25pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Whi, li.Whi, div.Whi
	{mso-style-name:Whi;
	mso-style-parent:Nhi;
	mso-style-next:Np1i;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:11.9pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-height:11.75pt;
	mso-element-frame-hspace:6.5pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:column;
	mso-element-top:.05pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:blue;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Wei, li.Wei, div.Wei
	{mso-style-name:Wei;
	mso-style-parent:We;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:15.5pt;
	margin-bottom:.0001pt;
	line-height:7.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-top-alt:double blue 2.25pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Sbre, li.Sbre, div.Sbre
	{mso-style-name:Sbre;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:-12.0pt;
	line-height:10.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Sbrh, li.Sbrh, div.Sbrh
	{mso-style-name:Sbrh;
	mso-style-parent:"";
	mso-style-next:Sbrp;
	margin-top:3.0pt;
	margin-right:14.0pt;
	margin-bottom:2.0pt;
	margin-left:14.0pt;
	line-height:14.0pt;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Sbrs, li.Sbrs, div.Sbrs
	{mso-style-name:Sbrs;
	mso-style-parent:"";
	mso-style-next:Sbrh;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:5.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:4.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tt, li.Tt, div.Tt
	{mso-style-name:Tt;
	mso-style-parent:"";
	mso-style-next:Th;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Th, li.Th, div.Th
	{mso-style-name:Th;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Tp, li.Tp, div.Tp
	{mso-style-name:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt 28.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Te, li.Te, div.Te
	{mso-style-name:Te;
	mso-style-next:Normal;
	margin-top:4.0pt;
	margin-right:1.5pt;
	margin-bottom:4.0pt;
	margin-left:1.5pt;
	text-align:right;
	line-height:9.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Le, li.Le, div.Le
	{mso-style-name:Le;
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:8.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.H6p, li.H6p, div.H6p
	{mso-style-name:H6p;
	mso-style-next:Normal;
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Ttw, li.Ttw, div.Ttw
	{mso-style-name:Ttw;
	mso-style-parent:Tt;
	mso-style-next:Th;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-1.25in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.ih, li.ih, div.ih
	{mso-style-name:ih;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:21.0pt;
	margin-left:-1.25in;
	line-height:30.0pt;
	mso-line-height-rule:exactly;
	page-break-before:always;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:24.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Ch, li.Ch, div.Ch
	{mso-style-name:Ch;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	line-height:27.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-width:336.0pt;
	mso-element-frame-height:123.0pt;
	mso-element-wrap:no-wrap-beside;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:margin;
	mso-element-left:-1.25in;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:24.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Ln1, li.Ln1, div.Ln1
	{mso-style-name:Ln1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	text-indent:-22.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 8.0pt left 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Lb1, li.Lb1, div.Lb1
	{mso-style-name:Lb1;
	mso-style-parent:Ln1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Ex, li.Ex, div.Ex
	{mso-style-name:Ex;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:19.0pt 38.0pt 57.0pt 76.0pt 95.0pt 114.0pt 133.0pt 152.0pt 171.0pt 190.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Proch, li.Proch, div.Proch
	{mso-style-name:Proch;
	mso-style-parent:"";
	mso-style-next:Ln1;
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	text-indent:-.25in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:0in;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Hn1, li.Hn1, div.Hn1
	{mso-style-name:Hn1;
	mso-style-parent:"Heading 1";
	mso-style-next:Normal;
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:-1.25in;
	line-height:22.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:20.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Hn2, li.Hn2, div.Hn2
	{mso-style-name:Hn2;
	mso-style-parent:"Heading 2";
	mso-style-next:Normal;
	margin-top:7.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-1.25in;
	line-height:19.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:17.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Mp, li.Mp, div.Mp
	{mso-style-name:Mp;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-width:78.0pt;
	mso-element-frame-hspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:page;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Lp1, li.Lp1, div.Lp1
	{mso-style-name:Lp1;
	mso-style-parent:Ln1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 8.0pt left 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Np2, li.Np2, div.Np2
	{mso-style-name:Np2;
	mso-style-next:Ne;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Erm, li.Erm, div.Erm
	{mso-style-name:Erm;
	mso-style-next:Erp;
	margin-top:5.0pt;
	margin-right:12.0pt;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Erp, li.Erp, div.Erp
	{mso-style-name:Erp;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cn, li.Cn, div.Cn
	{mso-style-name:Cn;
	mso-style-parent:"";
	mso-style-next:Ch;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:14.0pt;
	margin-left:-1.25in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	text-transform:uppercase;
	letter-spacing:6.0pt;}
p.Lb2, li.Lb2, div.Lb2
	{mso-style-name:Lb2;
	mso-style-parent:Lb1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:28.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Exl, li.Exl, div.Exl
	{mso-style-name:Exl;
	mso-style-parent:Ex;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:33.0pt 52.0pt 71.0pt 1.25in 109.0pt 128.0pt 147.0pt 166.0pt 185.0pt 204.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cap, li.Cap, div.Cap
	{mso-style-name:Cap;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt 28.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Ln2, li.Ln2, div.Ln2
	{mso-style-name:Ln2;
	mso-style-parent:Ln1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	text-indent:-30.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 22.0pt left 28.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Lp2, li.Lp2, div.Lp2
	{mso-style-name:Lp2;
	mso-style-parent:Lp1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 8.0pt left 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Rh1, li.Rh1, div.Rh1
	{mso-style-name:Rh1;
	mso-style-parent:"Heading 1";
	mso-style-next:Rmh;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:13.0pt;
	margin-left:-1.25in;
	line-height:22.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:20.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Rmh, li.Rmh, div.Rmh
	{mso-style-name:Rmh;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-width:78.0pt;
	mso-element-frame-hspace:12.0pt;
	mso-element-frame-vspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:page;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.headerrule, li.headerrule, div.headerrule
	{mso-style-name:"header rule";
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:2.5pt;
	margin-right:1.5pt;
	margin-bottom:0in;
	margin-left:-88.5pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-top-alt:solid blue .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Ermn, li.Ermn, div.Ermn
	{mso-style-name:Ermn;
	mso-style-parent:Erm;
	margin-top:1.0pt;
	margin-right:12.0pt;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Sbrp, li.Sbrp, div.Sbrp
	{mso-style-name:Sbrp;
	mso-style-parent:"";
	mso-style-next:Sbre;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:8.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Hn3, li.Hn3, div.Hn3
	{mso-style-name:Hn3;
	mso-style-parent:"Heading 3";
	mso-style-next:Normal;
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:17.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:15.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Term1, li.Term1, div.Term1
	{mso-style-name:Term1;
	mso-style-parent:"";
	mso-style-next:Def1;
	margin:0in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Lbp, li.Lbp, div.Lbp
	{mso-style-name:Lbp;
	mso-style-parent:Lb1;
	mso-style-next:Le;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Np2i, li.Np2i, div.Np2i
	{mso-style-name:Np2i;
	mso-style-parent:Np2;
	mso-style-next:Nei;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Term2, li.Term2, div.Term2
	{mso-style-name:Term2;
	mso-style-parent:Term1;
	mso-style-next:Def2;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Def1, li.Def1, div.Def1
	{mso-style-name:Def1;
	mso-style-next:Term1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Def2, li.Def2, div.Def2
	{mso-style-name:Def2;
	mso-style-parent:Def1;
	mso-style-next:Term2;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Rule, li.Rule, div.Rule
	{mso-style-name:Rule;
	mso-style-parent:"";
	mso-style-next:Rh1;
	margin-top:14.0pt;
	margin-right:1.5pt;
	margin-bottom:8.0pt;
	margin-left:-88.5pt;
	line-height:6.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	border:none;
	mso-border-bottom-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:4.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.Exw, li.Exw, div.Exw
	{mso-style-name:Exw;
	mso-style-parent:Ex;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:-1.25in;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:-71.0pt -52.0pt -33.0pt -14.0pt 5.0pt 24.0pt 43.0pt 62.0pt 81.0pt 100.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Syn, li.Syn, div.Syn
	{mso-style-name:Syn;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:14.0pt 21.0pt 28.0pt 35.0pt 42.0pt 49.0pt 56.0pt 63.0pt 70.0pt 77.0pt 84.0pt 91.0pt 98.0pt 105.0pt 112.0pt 119.0pt 1.75in 133.0pt 140.0pt 147.0pt 154.0pt 161.0pt 168.0pt 175.0pt 182.0pt 189.0pt 196.0pt 203.0pt 210.0pt 217.0pt 224.0pt 231.0pt 238.0pt 245.0pt 3.5in 259.0pt 266.0pt 273.0pt 280.0pt 287.0pt 294.0pt 301.0pt 308.0pt 315.0pt 322.0pt 329.0pt 336.0pt 343.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Synw, li.Synw, div.Synw
	{mso-style-name:Synw;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:-1.25in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:-76.0pt -62.0pt -48.0pt -34.0pt -20.0pt -6.0pt 8.0pt 14.0pt 21.0pt 28.0pt 35.0pt 42.0pt 49.0pt 56.0pt 63.0pt 70.0pt 77.0pt 84.0pt 91.0pt 98.0pt 105.0pt 112.0pt 119.0pt 1.75in 133.0pt 140.0pt 147.0pt 154.0pt 161.0pt 168.0pt 175.0pt 182.0pt 189.0pt 196.0pt 203.0pt 210.0pt 217.0pt 224.0pt 231.0pt 238.0pt 245.0pt 3.5in 259.0pt 266.0pt 273.0pt 280.0pt 287.0pt 294.0pt 301.0pt 308.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Leh, li.Leh, div.Leh
	{mso-style-name:Leh;
	mso-style-parent:Le;
	mso-style-next:"Heading 1";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Lmc, li.Lmc, div.Lmc
	{mso-style-name:Lmc;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Pb, li.Pb, div.Pb
	{mso-style-name:Pb;
	mso-style-parent:"";
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:-14.0pt;
	margin-bottom:.0001pt;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	page-break-before:always;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-hspace:9.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:page;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Procp, li.Procp, div.Procp
	{mso-style-name:Procp;
	mso-style-next:Ln1;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tpi, li.Tpi, div.Tpi
	{mso-style-name:Tpi;
	mso-style-parent:Tp;
	mso-style-next:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:26.0pt;
	text-indent:-14.0pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:26.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tpr, li.Tpr, div.Tpr
	{mso-style-name:Tpr;
	mso-style-parent:Tp;
	mso-style-next:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	text-align:right;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Texf, li.Texf, div.Texf
	{mso-style-name:Texf;
	mso-style-parent:Ex;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:19.0pt 38.0pt 57.0pt 76.0pt 95.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Tf, li.Tf, div.Tf
	{mso-style-name:Tf;
	mso-style-parent:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:7.0pt;
	text-indent:-7.0pt;
	line-height:10.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt;
	font-size:8.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tpf, li.Tpf, div.Tpf
	{mso-style-name:Tpf;
	mso-style-parent:Tp;
	mso-style-next:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt 28.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tew, li.Tew, div.Tew
	{mso-style-name:Tew;
	mso-style-parent:Te;
	mso-style-next:Normal;
	margin-top:4.0pt;
	margin-right:1.5pt;
	margin-bottom:4.0pt;
	margin-left:-88.5pt;
	text-align:right;
	line-height:9.0pt;
	mso-pagination:widow-orphan lines-together;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Art, li.Art, div.Art
	{mso-style-name:Art;
	mso-style-parent:"";
	mso-style-next:Cap;
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:-1.25in;
	mso-pagination:widow-orphan lines-together;
	tab-stops:0in 14.0pt 28.0pt;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Thf, li.Thf, div.Thf
	{mso-style-name:Thf;
	mso-style-parent:Th;
	mso-style-next:Th;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Tpif, li.Tpif, div.Tpif
	{mso-style-name:Tpif;
	mso-style-parent:Tpi;
	mso-style-next:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:14.0pt;
	text-indent:-14.0pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:14.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tr, li.Tr, div.Tr
	{mso-style-name:Tr;
	mso-style-parent:"";
	mso-style-next:Tpf;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:1.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:4.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Ph, li.Ph, div.Ph
	{mso-style-name:Ph;
	mso-style-parent:Ch;
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	line-height:32.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-element:frame;
	mso-element-frame-width:336.0pt;
	mso-element-frame-height:123.0pt;
	mso-element-frame-hspace:9.0pt;
	mso-element-wrap:no-wrap-beside;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:margin;
	mso-element-left:-1.25in;
	mso-element-top:.15pt;
	mso-height-rule:exactly;
	font-size:30.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:blue;}
p.index, li.index, div.index
	{mso-style-name:index;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:fuchsia;
	display:none;
	mso-hide:all;}
p.CapSd, li.CapSd, div.CapSd
	{mso-style-name:CapSd;
	mso-style-parent:Cap;
	margin:0in;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:right 78.0pt;
	mso-element:frame;
	mso-element-frame-width:78.0pt;
	mso-element-frame-hspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:page;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.ArtSd, li.ArtSd, div.ArtSd
	{mso-style-name:ArtSd;
	mso-style-parent:Art;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:right 78.0pt;
	mso-element:frame;
	mso-element-frame-width:78.0pt;
	mso-element-frame-hspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:page;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tex, li.Tex, div.Tex
	{mso-style-name:Tex;
	mso-style-parent:Texf;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:31.0pt 50.0pt 69.0pt 88.0pt 107.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.hb1, li.hb1, div.hb1
	{mso-style-name:*hb1;
	mso-style-parent:"Heading 4";
	mso-style-next:"Heading 4";
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	text-align:center;
	line-height:17.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:4;
	background:#9C9CFF;
	mso-shading:windowtext;
	mso-pattern:gray-60 blue;
	mso-element:frame;
	mso-element-frame-width:75.0pt;
	mso-element-frame-hspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:margin;
	mso-element-left:-1.25in;
	mso-element-top:.05pt;
	mso-height-rule:exactly;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:white;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.hb2, li.hb2, div.hb2
	{mso-style-name:*hb2;
	mso-style-parent:*hb1;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:1.0pt;
	margin-left:0in;
	text-indent:4.0pt;
	line-height:18.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:4;
	background:#9C9CFF;
	mso-shading:windowtext;
	mso-pattern:gray-60 blue;
	mso-element:frame;
	mso-element-frame-hspace:12.0pt;
	mso-element-wrap:around;
	mso-element-anchor-vertical:paragraph;
	mso-element-anchor-horizontal:margin;
	mso-element-left:right;
	mso-element-top:.1pt;
	mso-height-rule:exactly;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:white;
	mso-text-raise:1.5pt;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.Cbx, li.Cbx, div.Cbx
	{mso-style-name:*Cbx;
	mso-style-parent:"";
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:8.0pt;
	line-height:10.5pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:22.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbxe, li.Cbxe, div.Cbxe
	{mso-style-name:*Cbxe;
	mso-style-parent:Te;
	margin-top:0in;
	margin-right:1.5pt;
	margin-bottom:4.0pt;
	margin-left:-9.0pt;
	line-height:10.5pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:lined 348.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tart, li.Tart, div.Tart
	{mso-style-name:Tart;
	mso-style-parent:Tp;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan lines-together;
	tab-stops:12.0pt 14.0pt 28.0pt;
	font-size:9.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Sbrh2, li.Sbrh2, div.Sbrh2
	{mso-style-name:Sbrh2;
	mso-style-parent:"Heading 5";
	mso-style-next:Sbrp;
	margin-top:2.0pt;
	margin-right:14.0pt;
	margin-bottom:2.0pt;
	margin-left:14.0pt;
	line-height:12.0pt;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	mso-outline-level:5;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial Narrow";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.SbrLb, li.SbrLb, div.SbrLb
	{mso-style-name:SbrLb;
	mso-style-parent:Lb2;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:28.0pt;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tei, li.Tei, div.Tei
	{mso-style-name:Tei;
	margin-top:4.0pt;
	margin-right:1.5pt;
	margin-bottom:4.0pt;
	margin-left:15.5pt;
	text-align:right;
	line-height:9.0pt;
	mso-pagination:widow-orphan lines-together;
	border:none;
	mso-border-top-alt:solid windowtext .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.SbrLp, li.SbrLp, div.SbrLp
	{mso-style-name:SbrLp;
	mso-style-parent:SbrLb;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:4.0pt;
	margin-left:28.0pt;
	text-indent:-14.0pt;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	tab-stops:28.0pt;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.SbrEx, li.SbrEx, div.SbrEx
	{mso-style-name:SbrEx;
	mso-style-parent:Exl;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:33.0pt 52.0pt 71.0pt 1.25in 109.0pt 128.0pt 147.0pt 166.0pt 185.0pt 204.0pt;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Exl2, li.Exl2, div.Exl2
	{mso-style-name:Exl2;
	mso-style-parent:Exl;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:28.0pt;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:33.0pt 52.0pt 71.0pt 1.25in 109.0pt 128.0pt 147.0pt 166.0pt 185.0pt 204.0pt;
	font-size:8.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Lucida Sans Typewriter";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Tes, li.Tes, div.Tes
	{mso-style-name:Tes;
	mso-style-parent:Le;
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:8.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Teh, li.Teh, div.Teh
	{mso-style-name:Teh;
	mso-style-parent:Leh;
	mso-style-next:"Heading 1";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:4.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.SbrLe, li.SbrLe, div.SbrLe
	{mso-style-name:SbrLe;
	mso-style-parent:Le;
	mso-style-next:Sbrp;
	margin-top:0in;
	margin-right:14.0pt;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:8.0pt;
	mso-pagination:widow-orphan lines-together;
	background:#FFFFBA;
	mso-shading:windowtext;
	mso-pattern:gray-40 yellow;
	border:none;
	mso-border-alt:solid white 1.5pt;
	padding:0in;
	mso-padding-alt:14.0pt 14.0pt 14.0pt 14.0pt;
	font-size:6.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Tsyn, li.Tsyn, div.Tsyn
	{mso-style-name:Tsyn;
	mso-style-parent:Syn;
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:12.0pt;
	mso-line-height-rule:exactly;
	mso-pagination:widow-orphan lines-together;
	page-break-after:avoid;
	tab-stops:14.0pt 21.0pt 28.0pt 35.0pt 42.0pt 49.0pt 56.0pt 63.0pt 70.0pt 77.0pt 84.0pt 91.0pt 98.0pt 105.0pt 112.0pt 119.0pt 1.75in 133.0pt 140.0pt 147.0pt 154.0pt 161.0pt 168.0pt 175.0pt 182.0pt 189.0pt 196.0pt 203.0pt 210.0pt 217.0pt 224.0pt 231.0pt 238.0pt 245.0pt 3.5in 259.0pt 266.0pt 273.0pt 280.0pt 287.0pt 294.0pt 301.0pt 308.0pt 315.0pt 322.0pt 329.0pt 336.0pt 343.0pt;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
 /* Page Definitions */
@page
	{mso-facing-pages:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:-127.0pt 76.5pt -115.0pt 166.5pt;
	mso-header-margin:99.5pt;
	mso-footer-margin:.25in;
	mso-gutter-margin:21.0pt;
	mso-page-numbers:53;
	mso-title-page:yes;
	mso-even-header:url("./Chap_03_files/header.htm") eh1;
	mso-header:url("./Chap_03_files/header.htm") h1;
	mso-even-footer:url("./Chap_03_files/header.htm") ef1;
	mso-footer:url("./Chap_03_files/header.htm") f1;
	mso-first-header:url("./Chap_03_files/header.htm") fh1;
	mso-first-footer:url("./Chap_03_files/header.htm") ff1;
	mso-paper-source:1;}
div.Section1
	{page:Section1;}
-->
</style>
	</head>

	<body lang="EN-US" style="tab-interval:14.0pt">
		<div class="Section1">
			<p class="Cn" style="margin-left:0in">Chapter <span style='mso-field-code:"SEQ CHAPTER \\R 3"'>3</span></p>
			<div style="mso-element:frame;mso-element-wrap:no-wrap-beside">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="448" height="164">
					<tr>
						<td valign="top" align="left" height="164" style="padding-top:0in;padding-right:
  0in;padding-bottom:0in;padding-left:0in">
							<p class="Ch">Using Addresses and Pointers</p>
						</td>
					</tr>
				</table>
			</div>
			<![if !supportTextWrap]><br clear="ALL">
			<![endif]>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1275&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">MASM applications running in real mode require segmented addresses to access code and data. The address of the code or data in a segment is relative to a segment address in a segment register. You can also use pointers to access data in assembly language programs. (A pointer is a variable that contains an address as its value.)</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1276&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The first section of this chapter describes how to initialize default segment registers to access near and far addresses. The next section describes how to access code and data. It also describes related operators, syntax, and displacements. The discussion of memory operands lays the foundation for the third section, which describes the stack.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1277&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The fourth section of this chapter explains how to use the <b style="mso-bidi-font-weight:normal">TYPEDEF</b> directive to declare pointers and the <b style="mso-bidi-font-weight:normal">ASSUME</b> directive to give the assembler information about registers containing pointers. This section also shows you how to do typical pointer operations and how to write code that works for pointer variables in any memory model.</p>
			<h1 style="margin-left:0in">Programming Segmented Addresses</h1>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:segmented&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1001&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Before you use segmented addresses in your programs, you need to initialize the segment registers. The initialization process depends on the registers used and on your choice of simplified segment directives or full segment definitions. The simplified segment directives (introduced in Chapter 2) handle most of the initialization process for you. This section explains how to inform the assembler and the processor of segment addresses, and how to access the near and far code and data in those segments.</p>
			<h2 style="margin-left:0in">Initializing Default Segment Registers</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1278&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The segmented architecture of the 8086-family of processors does not require that you specify two addresses every time you access memory. As explained in Chapter 2, &#147;Organizing Segments,&#148; the 8086 family of processors uses a system of default segment registers to simplify access to the most commonly used data and code.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segment registers:initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1002&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The segment registers DS, SS, and CS are normally initialized to default segments at the beginning of a program. If you write the main module in a high-level language, the compiler initializes the segment registers. If you write the main module in assembly language, you must initialize the segment registers yourself. Follow these steps to initialize segments:</p>
			<p class="Ln1" style="margin-left:22.0pt"><span style="mso-tab-count:1"></span>1.<span style="mso-tab-count:1">&nbsp; </span>Tell the assembler which segment is associated with a register. The assembler must know the default segments at assembly time.</p>
			<p class="Ln1" style="margin-left:22.0pt"><span style="mso-tab-count:1"></span>2.<span style="mso-tab-count:1">&nbsp; </span>Tell the processor which segment is associated with a register by writing the necessary code to load the correct segment value into the segment register on the processor.</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1279&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">These steps are discussed separately in the following sections.</p>
			<h3>Informing the Assembler About Segment Values</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segments:data:default&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1003&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The first step in initializing segments is to tell the assembler which segment to associate with a register. You do this with the <b style="mso-bidi-font-weight:normal">ASSUME</b> directive. If you use simplified segment directives, the assembler automatically generates the appropriate <b style="mso-bidi-font-weight:normal">ASSUME</b> statements. If you use full segment definitions, you must code the <b style="mso-bidi-font-weight:normal">ASSUME</b> statements for registers other than CS yourself. (<b style="mso-bidi-font-weight:
normal">ASSUME</b> can also be used on general-purpose registers, as explained in &#147;Defining Register Types with ASSUME&#148; later in this chapter.)</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Directives:.STARTUP \t &quot;See .STARTUP directive&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1004&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;ASSUME directive:segment
registers, setting&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1005&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Simplified segment
directives:segment registers, initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1006&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Full segment
definitions:segment registers, initializing&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1007&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.STARTUP directive:initializing
segments&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1008&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">.STARTUP</b> directive generates startup code that sets DS equal to SS (unless you specify <b style="mso-bidi-font-weight:normal">FARSTACK</b>), allowing default data to be accessed through either SS or DS. This can improve efficiency in the code generated by compilers. The &#147;DS equals SS&#148; convention may not work with certain applications, such as memory-resident programs in MS-DOS and Windows dynamic-link libraries (see Chapter 10). The code generated for <b style="mso-bidi-font-weight:normal">.STARTUP</b> is shown in &#147;Starting and Ending Code with .STARTUP and .EXIT&#148; in Chapter 2. You can use similar code to set DS equal to SS in programs using full segment definitions.<span style="mso-spacerun: yes">&nbsp; </span></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1280&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Here is an example of <b style="mso-bidi-font-weight:normal">ASSUME</b> using full segment definitions:</p>
			<p class="Ex">ASSUME cs:_TEXT, ds:DGROUP, ss:DGROUP<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;NEARSTACK operand:ASSUME statement, with&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1009&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This example is equivalent to the <b style="mso-bidi-font-weight:
normal">ASSUME</b> statement generated with simplified segment directives in small model with <b style="mso-bidi-font-weight:normal">NEARSTACK</b>. Note that DS and SS are part of the same segment group. It is also possible to have different segments for data and code, and to use <b style="mso-bidi-font-weight:
normal">ASSUME</b> to set ES, as shown here:</p>
			<p class="Ex">ASSUME cs:MYCODE, ds:MYDATA, ss:MYSTACK, es:OTHER<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:errors in&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1010&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Correct use of the <b style="mso-bidi-font-weight:normal">ASSUME</b> statement can help find addressing errors. With <b style="mso-bidi-font-weight:
normal">.CODE</b>, the assembler assumes CS is the current segment. When you use the simplified segment directives .<b style="mso-bidi-font-weight:normal">DATA</b>, .<b style="mso-bidi-font-weight:normal">DATA?</b>, .<b style="mso-bidi-font-weight:
normal">CONST</b>, .<b style="mso-bidi-font-weight:normal">FARDATA</b>, or <b style="mso-bidi-font-weight:normal">.FARDATA?</b>, the assembler automatically assumes CS is the <b style="mso-bidi-font-weight:normal">ERROR</b> segment. This prevents instructions from appearing in these segments. If you use full segment definitions, you can accomplish the same by placing <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>ASSUME CS:ERROR</span> in a data segment.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;ASSUME directive:segment registers, setting&quot;<span style='mso-hide:
none'> \z &quot;ADDREW.DOC-1011&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segments:data:default&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1012&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">With simple or full segments, you can cancel the control of an <b style="mso-bidi-font-weight:normal">ASSUME</b> statement by assuming <b style="mso-bidi-font-weight:normal">NOTHING</b>. You can cancel the previous assumption for ES with the following statement:</p>
			<p class="Ex">ASSUME es:NOTHING<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1281&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Prior to the <b style="mso-bidi-font-weight:normal">.MODEL</b> statement (or in its absence), the assembler sets the<br>
			<b style="mso-bidi-font-weight:normal">ASSUME</b> statement for DS, ES, and SS to the current segment.</p>
			<h3>Informing the Processor About Segment Values</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segment registers:initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1013&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment
registers:initializing&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1014&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segments:initializing&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1015&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segments:values&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1016&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The second and final step in initializing segments is to inform the processor of segment values at run time. How segment values are initialized at run time differs for each segment register and depends on the operating system and on your use of simplified segment directives or full segment definitions.</p>
			<h4>Specifying a Starting Address</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1282&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A program&#146;s starting address determines where execution begins. After the operating system loads a program, it simply jumps to the starting address, giving processor control to the program. The true starting address is known only to the loader; the linker determines only the offset of the address within an undetermined code segment. That&#146;s why a normal application is often referred to as &#147;relocatable code,&#148; because it runs regardless of where the loader places it in memory.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1283&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The offset of the starting address depends on the program type. Programs with an .EXE extension contain a header from which the loader reads the offset and combines it with a segment to form the starting address. Programs with a .COM extension (tiny model) have no such header, so by convention the loader jumps to the first byte of the program.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1284&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In either case, the <b style="mso-bidi-font-weight:normal">.STARTUP</b> directive identifies where execution begins, provided you use simplified segment directives. For an .EXE program, place <b style="mso-bidi-font-weight:
normal">.STARTUP</b> immediately before the instruction where you want execution to start. In a .COM program, place <b style="mso-bidi-font-weight:
normal">.STARTUP</b> before the first assembly instruction in your source code.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1285&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If you use full segment directives or prefer not to use <b style="mso-bidi-font-weight:normal">.STARTUP</b>, you must identify the starting instruction in two steps:</p>
			<p class="Ln1" style="margin-left:22.0pt"><span style="mso-tab-count:1"></span>1.<span style="mso-tab-count:1">&nbsp; </span>Label the starting instruction.</p>
			<p class="Ln1" style="margin-left:22.0pt"><span style="mso-tab-count:1"></span>2.<span style="mso-tab-count:1">&nbsp; </span>Provide the same label in the <b style="mso-bidi-font-weight:normal">END</b> directive.</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Simplified segment directives:segment registers, initializing&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1017&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Full segment definitions:segment
registers, initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1018&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Directives:.STARTUP \t &quot;See
.STARTUP directive&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1019&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Directives:END&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1020&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;END directive&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1021&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.STARTUP directive:initializing
segments&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1022&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">These steps tell the linker where execution begins in the program. The following example illustrates the two steps for a tiny model program:</p>
			<p class="Ex">_TEXT<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>SEGMENT WORD PUBLIC 'CODE'<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ORG<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>100h<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Use this declaration for .COM files only<br>
			start:<span style="mso-spacerun: yes">&nbsp; </span>.<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; First instruction here<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			_TEXT<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>ENDS<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>END<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>start<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Name of starting label<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Program Segment Prefix (PSP)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1023&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.COM files:starting
address&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1024&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Files:.COM:starting
address&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1025&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Directives:ORG&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1026&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;ORG directive&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1027&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;DGROUP group name:DS registers,
initializing to&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1028&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Notice the <b style="mso-bidi-font-weight:normal">ORG</b> statement in this example. This statement is mandatory in a tiny model program without the <b style="mso-bidi-font-weight:normal">.STARTUP</b> directive. It places the first instruction at offset 100h in the code segment to create space for a 256-byte (100h) data area called the Program Segment Prefix (PSP). The operating system takes care of initializing the PSP, so you need only make sure the area exists. (For a description of what data resides in the PSP, refer to the &#147;Tables&#148; chapter in the <i style="mso-bidi-font-style:normal">Reference</i>.)</p>
			<h4>Initializing DS</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1286&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The DS register is automatically initialized to the correct value (DGROUP) if you use <b style="mso-bidi-font-weight:normal">.STARTUP</b> or if you are writing a program for Windows. If you do not use <b style="mso-bidi-font-weight:normal">.STARTUP</b> with MS-DOS, you must initialize DS using the following instructions:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, DGROUP<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ds, ax<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1287&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The initialization requires two instructions because the segment name is a constant and the assembler does not allow a constant to be loaded directly to a segment register. The previous example loads DGROUP, but you can load any valid segment or group.</p>
			<h4>Initializing SS and SP</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Directives:.STACK \t &quot;See STACK directive&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1029&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Directives:.STARTUP \t &quot;See
.STARTUP directive&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1030&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.STACK directive:segment
registers, setting&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1031&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.STARTUP directive:initializing
segments&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1032&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The SS and SP registers are initialized automatically if you use the <b style="mso-bidi-font-weight:normal">.STACK</b> directive with simplified segments or if you define a segment that has the <b style="mso-bidi-font-weight:normal">STACK</b> combine type with full segment definitions. Using the <b style="mso-bidi-font-weight:normal">STACK</b> directive initializes SS to the stack segment. If you want SS to be equal to DS, use <b style="mso-bidi-font-weight:normal">.STARTUP</b> or its equivalent. (See &#147;Combining Segments,&#148; page 45.) For an .EXE file, the stack address is encoded into the executable header and resolved at load time. For a .COM file, the loader sets SS equal to CS and initializes SP to 0FFFEh.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segment registers:initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1033&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If your program does not access far data, you do not need to initialize the ES register. If you choose to initialize, use the same technique as for the DS register. You can initialize SS to a far stack in the same way.</p>
			<h2 style="margin-left:0in">Near and Far Addresses</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:near&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1034&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addresses:far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1035&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;DGROUP group
name:segment:placement&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1036&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Addresses that have an implied segment name or segment registers associated with them are called &#147;near addresses.&#148; Addresses that have an explicit segment associated with them are called &#147;far addresses.&#148; The assembler handles near and far code automatically, as described in the following sections. You must specify how to handle far data.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1288&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The Microsoft segment model puts all near data and the stack in a group called DGROUP. Near code is put in a segment called _TEXT. Each module&#146;s far code or far data is placed in a separate segment. This convention is described in &#147;Controlling the Segment Order&#148; in Chapter 2.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Relocatable:addresses&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1037&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addresses:relocatable&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1038&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment
registers:changing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1039&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The assembler cannot determine the address for some program components; these are said to be relocatable. The assembler generates a fixup record and the linker provides the address once it has determined the location of all segments. Usually a relocatable operand references a label, but there are exceptions. Examples in the next two sections include information about relocating near and far data.</p>
			<h4>Near Code</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Code, near or far&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1040&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Control transfers within near code do not require changes to segment registers. The processor automatically handles changes to the offset in the IP register when control-flow instructions such as <b style="mso-bidi-font-weight:
normal">JMP</b>, <b style="mso-bidi-font-weight:normal">CALL</b>, and <b style="mso-bidi-font-weight:normal">RET</b> are used. The statement</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>nearproc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Change code offset<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Instruction Pointer (IP) register&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1041&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment registers:near
code&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1042&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">changes the IP register to the new address but leaves the segment unchanged. When the procedure returns, the processor resets IP to the offset of the next instruction after the <b style="mso-bidi-font-weight:normal">CALL</b> instruction.</p>
			<h4>Far Code</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Far code&quot; \z &quot;ADDREW.DOC-1043&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Code, near or far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1044&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The processor automatically handles segment register changes when dealing with far code. The statement</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>farproc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Change code segment and offset<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Instruction Pointer (IP) register&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1045&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">automatically moves the segment and offset of the <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>farproc</span> procedure to the CS and IP registers. When the procedure returns, the processor sets CS to the original code segment and sets IP to the offset of the next instruction after the call.</p>
			<h4>Near Data</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;DGROUP group name:near data, accessing&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1046&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment
registers:initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1047&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Data:near or far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1048&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A program can access near data directly, because a segment register already holds the correct segment for the data item. The term &#147;near data&#148; is often used to refer to the data in the DGROUP group.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1289&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">After the first initialization of the DS and SS registers, these registers normally point into DGROUP. If you modify the contents of either of these registers during the execution of the program, you must reload the register with DGROUP&#146;s address before referencing any DGROUP data.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1290&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The processor assumes all memory references are relative to the segment in the DS register, with the exception of references using BP or SP. The processor associates these registers with the SS register. (You can override these assumptions with the segment override operator, described in &#147;Direct Memory Operands,&#148; on page 62.)</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1291&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The following lines illustrate how the processor accesses either the DS or SS segments, depending on whether the pointer operand contains BP or SP. Note the distinction loses significance when DS and SS are equal.</p>
			<p class="Ex">nearvar WORD<span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;</span>0<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, nearvar ; Reads from DS:[nearvar]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, [bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Reads from DS:[bx]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[di], cx<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Writes to<span style="mso-spacerun: yes">&nbsp; </span>DS:[di]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bp+6], ax<span style="mso-spacerun: yes">&nbsp; </span>; Writes to<span style="mso-spacerun: yes">&nbsp; </span>SS:[bp+6]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, [bp]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Reads from SS:[bp]<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Far Data</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Far data&quot; \z &quot;ADDREW.DOC-1049&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;ASSUME directive:segment
registers, setting&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1050&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Data:near or far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1051&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">To read or modify a far address, a segment register must point to the segment of the data. This requires two steps. First load the segment (normally either ES or DS) with the correct value, and then (optionally) set an assume of the segment register to the segment of the address.</p>
			<div style="border:none;border-bottom:solid windowtext .75pt;padding:0in 0in 1.0pt 0in">
				<p class="Ns"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			</div>
			<div style="mso-element:frame;mso-element-wrap:around">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="16" align="left">
					<tr>
						<td valign="top" align="left" height="16" style="padding-top:0in;padding-right:
  6.5pt;padding-bottom:0in;padding-left:6.5pt">
							<p class="Nh">Note</p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Memory models:flat&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1052&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Np1">Flat model does not require far addresses. By default, all addressing is relative to the initial values of the segment registers. Therefore, this section on far addressing does not apply to flat model programs.</p>
			<div style="border:none;border-top:solid windowtext .75pt;padding:1.0pt 0in 0in 0in">
				<p class="Ne"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1292&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">One method commonly used to access far data is to initialize the ES segment register. This example shows two ways to do this:</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Far data&quot; \z &quot;ADDREW.DOC-1053&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Ex">; First method<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG farvar<span style="mso-spacerun: yes">&nbsp; </span>; Load segment of the<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es, ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>,<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>far address into ES<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, es:farvar<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Provide an explicit segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>override on the addressing</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="Ex">; Second method<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG farvar2 ; Load the segment of the<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es, ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>far address into ES<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSUME<span style="mso-spacerun:
yes">&nbsp; </span>ES:SEG farvar2<span style="mso-spacerun: yes">&nbsp; </span>; Tell the assembler that ES points<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>to the segment containing farvar2<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, farvar2<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; The assembler provides the ES<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>override since it knows that<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>the label is addressable<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segment registers:assigning&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1054&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;ASSUME directive:segment
registers, setting&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1055&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment-override operator
(\\:)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1056&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operators:segment-override
(\\:)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1057&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment-override operator
(\\:)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1058&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;\\: (segment-override
operator)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1059&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">After loading the segment of the address into the ES segment register, you can explicitly override the segment register so that the addressing is correct (method 1) or allow the assembler to insert the override for you (method 2). The assembler uses <b style="mso-bidi-font-weight:normal">ASSUME</b> statements to determine which segment register can be used to address a segment of memory. To use the segment override operator, the left operand must be a segment register, not a segment name. (For more information on segment overrides, see &#147;Direct Memory Operands&#148; on page 62.)</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1293&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If an instruction needs a segment override, the resulting code is slightly larger and slower, since the override must be encoded into the instruction. However, the resulting code may still be smaller than the code for multiple loads of the default segment register for the instruction.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1294&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The DS, SS, FS, and GS segment registers (FS and GS are available only on the 80386/486 processors) may also be used for addressing through other segments.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segment registers:restoring&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1060&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If a program uses ES to access far data, it need not restore ES when finished (unless the program uses flat model). However, some compilers require that you restore ES before returning to a module written in a high-level language.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Segments:data:default&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1061&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">To access far data, first set DS to the far segment and then restore the original DS when finished. Use the <b style="mso-bidi-font-weight:
normal">ASSUME</b> directive to let the assembler know that DS no longer points to the default data segment, as shown here:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>ds<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Save original segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG fararray ; Move segment into data register<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ds, ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Initialize segment register<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSUME<span style="mso-spacerun:
yes">&nbsp; </span>ds:SEG fararray<span style="mso-spacerun: yes">&nbsp; </span>; Tell assembler where data is<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, fararray[0]<span style="mso-spacerun: yes">&nbsp; </span>; Set DX:AX = dword variable<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>dx, fararray[2]<span style="mso-spacerun: yes">&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>fararray<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ds<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Restore segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSUME<span style="mso-spacerun:
yes">&nbsp; </span>ds:@DATA<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>and default assumption</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;\\: (segment-override operator)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1062&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment registers:default&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1063&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment-override operator
(\\:)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1064&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">&#147;Direct Memory Operands,&#148;on page 62, describes an alternative method for accessing far data. The technique of resetting DS as shown in the previous example is best for a lengthy series of far data references. The segment override method described in &#147;Direct Memory Operands&#148; serves best when accessing only one or two far variables.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Far data&quot; \z &quot;ADDREW.DOC-1065&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If your program changes DS to access far data, it should restore DS when finished. This allows procedures to assume that DS is the segment for near data. Many compilers, including Microsoft compilers, use this convention.</p>
			<h1 style="margin-left:0in">Operands</h1>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1295&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">With few exceptions, assembly language instructions work on sources of data called operands. In a listing of assembly code (such as the examples in this book), operands appear in the operand field immediately to the right of the instructions.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Instructions:operands for&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1066&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing:specifying&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1067&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Immediate operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1068&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Direct memory operands:overview&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1069&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Indirect memory operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1070&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operands:indirect memory&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1071&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This section describes the four kinds of instruction operands: register, immediate, direct memory, and indirect memory. Some instructions, such as POPF and STI, have implied operands which do not appear in the operand field. Otherwise, an implied operand is just as real as one stated explicitly.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1296&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Certain other instructions such as NOP and WAIT deserve special mention. These instructions affect only processor control and do not require an operand.</p>
			<p class="MsoNormal">The following four types of operands are described in the rest of this section:</p>
			<table border="0" cellspacing="0" cellpadding="0" style="margin-left:.4pt;border-collapse:
 collapse;mso-padding-alt:0in 0in 0in 0in">
				<tr>
					<td width="92" valign="top" style="width:68.65pt;padding:0in 0in 0in 0in">
						<p class="Thf">Operand Type</p>
						<p class="Thf"></p>
					</td>
					<td width="372" valign="top" style="width:279.3pt;padding:0in 0in 0in 0in">
						<p class="Th">Addressing Mode</p>
						<p class="Th"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="464" colspan="2" valign="top" style="width:347.95pt;padding:0in 0in 0in 0in">
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="92" valign="top" style="width:68.65pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Register</p>
						<p class="Tpf"></p>
					</td>
					<td width="372" valign="top" style="width:279.3pt;padding:0in 0in 0in 0in">
						<p class="Tp">An 8-bit or 16-bit register on the 8086&#150;80486; can also be 32-bit on the 80386/486.</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"><b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>
				</tr>
				<tr>
					<td width="92" valign="top" style="width:68.65pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Immediate</p>
						<p class="Tpf"></p>
					</td>
					<td width="372" valign="top" style="width:279.3pt;padding:0in 0in 0in 0in">
						<p class="Tp">A constant value contained in the instruction itself.</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="92" valign="top" style="width:68.65pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Direct memory</p>
						<p class="Tpf"></p>
					</td>
					<td width="372" valign="top" style="width:279.3pt;padding:0in 0in 0in 0in">
						<p class="Tp">A fixed location in memory.</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="92" valign="top" style="width:68.65pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Indirect memory</p>
						<p class="Tpf"></p>
					</td>
					<td width="372" valign="top" style="width:279.3pt;padding:0in 0in 0in 0in">
						<p class="Tp">A memory location determined at run time by using the address stored in one or two registers.</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
			</table>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1297&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Instructions that take two or more operands always work right to left. The right operand is the source operand. It specifies data that will be read, but not changed, in the operation. The left operand is the destination operand. It specifies the data that will be acted on and possibly changed by the instruction.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h2 style="margin-left:0in">Register Operands</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operands:registers&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1072&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Register operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1073&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Register operands refer to data stored in registers. The following examples show typical register operands:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 10<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load constant to BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>add<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, bx<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Add BX to AX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>jmp<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Jump to the address in DI<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1298&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">An offset stored in a base or index register often serves as a pointer into memory. You can store an offset in one of the base or index registers, then use the register as an indirect memory operand. (See &#147;Indirect Memory Operands,&#148; following.) For example:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bx], dl ; Store DL in indirect memory operand<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Increment register operand<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bx], dl ; Store DL in new indirect memory operand<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1299&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This example moves the value in DL to 2 consecutive bytes of a memory location pointed to by BX. Any instruction that changes the register value also changes the data item pointed to by the register.</p>
			<h2 style="margin-left:0in">Immediate Operands</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Immediate operands&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1074&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Constants:immediate&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1075&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">An immediate operand is a constant or the result of a constant expression. The assembler encodes immediate values into the instruction at assembly time. Here are some typical examples showing immediate operands:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>cx, 20<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load constant to register<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>add<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>var, 1Fh<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Add hex constant to variable<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>sub<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 25 * 80<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Subtract constant expression<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1300&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Immediate data is never permitted in the destination operand. If the source operand is immediate, the destination operand must be either a register or direct memory to provide a place to store the result of the operation.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1301&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Immediate expressions often involve the useful <b style="mso-bidi-font-weight:normal">OFFSET</b> and <b style="mso-bidi-font-weight:
normal">SEG</b> operators, described in the following paragraphs.</p>
			<h4>The OFFSET Operator</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;OFFSET operator&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1076&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operators:OFFSET&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1077&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">An address constant is a special type of immediate operand that consists of an offset or segment value. The <b style="mso-bidi-font-weight:
normal">OFFSET</b> operator returns the offset of a memory location, as shown here:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, OFFSET var<span style="mso-spacerun:
yes">&nbsp; </span>; Load offset address<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1302&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">For information on differences between MASM 5.1 behavior and MASM 6.1 behavior related to <b style="mso-bidi-font-weight:normal">OFFSET</b>, see Appendix A.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1303&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Since data in different modules may belong to a single segment, the assembler cannot know for each module the true offsets within a segment. Thus, the offset for <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>var</span>, although an immediate value, is not determined until link time.</p>
			<h4>The SEG Operator</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Immediate operands&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1078&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;SEG operator&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1079&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operators:SEG&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1080&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">SEG</b> operator returns the segment of a memory location:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG farvar<span style="mso-spacerun:
yes">&nbsp; </span>; Load segment address<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es, ax<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;.COM files:relocatable segment expression, lacking&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1081&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Files:.COM:relocatable segment
expression, lacking&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1082&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Relocatable:expressions&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1083&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The actual value of a particular segment is not known until the program is loaded into memory. For .EXE programs, the linker makes a list in the program&#146;s header of all locations in which the <b style="mso-bidi-font-weight:
normal">SEG</b> operator appears. The loader reads this list and fills in the required segment address at each location. Since .COM programs have no header, the assembler does not allow relocatable segment expressions in tiny model programs.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1304&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">SEG</b> operator returns a variable&#146;s &#147;frame&#148; if it appears in the instruction. The frame is the value of the segment, group, or segment override of a nonexternal variable. For example, the instruction</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG DGROUP:var<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Frame&quot; \z &quot;ADDREW.DOC-1084&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Groups:SEG operator, returned
by&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1085&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment
registers:assigning&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1086&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">places in AX the value of DGROUP, where <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>var</span> is located. If you do not include a frame, <b style="mso-bidi-font-weight:normal">SEG</b> returns the value of the variable&#146;s group if one exists. If the variable is not defined in a group, <b style="mso-bidi-font-weight:normal">SEG</b> returns the variable&#146;s segment address.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;ML:Command-line options:/Zm&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1087&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;OPTION directive:OFFSET&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1088&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;OFFSET\\:SEGMENT argument,
OPTION directive&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1089&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This behavior can be changed with the /Zm command-line option or with the <b style="mso-bidi-font-weight:normal">OPTION OFFSET:SEGMENT</b> statement. (See Appendix A, &#147;Differences between MASM 6.1 and 5.1.&#148;) &#147;Using the OPTION Directive&#148; in Chapter 1 introduces the <b style="mso-bidi-font-weight:
normal">OPTION</b> directive.</p>
			<h2 style="margin-left:0in">Direct Memory Operands</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Direct memory operands:overview&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1090&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing:direct registers,
used in&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1091&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A direct memory operand specifies the data at a given address. The instruction acts on the contents of the address, not the address itself. Except when size is implied by another operand, you must specify the size of a direct memory operand so the instruction accesses the correct amount of memory. The following example shows how to explicitly specify data size with the <b style="mso-bidi-font-weight:normal">BYTE</b> directive:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.DATA?<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Segment for uninitialized data<br>
			var<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>?<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Reserve one byte, labeled &quot;var&quot;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.CODE<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>var, al<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Copy AL to byte at var<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Direct memory operands:overview&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1092&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing:direct registers,
used in&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1093&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Any location in memory can be a direct memory operand as long as a size is specified (or implied) and the location is fixed. The data at the address can change, but the address cannot. By default, instructions that use direct memory addressing use the DS register. You can create an expression that points to a memory location using any of the following operators:</p>
			<table border="0" cellspacing="0" cellpadding="0" style="margin-left:.4pt;border-collapse:
 collapse;mso-padding-alt:0in 0in 0in 0in">
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Thf">Operator Name</p>
						<p class="Thf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Th">Symbol</p>
						<p class="Th"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="464" colspan="2" valign="top" style="width:348.0pt;padding:0in 0in 0in 0in">
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Plus</p>
						<p class="Tpf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">+</b></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"><b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>
				</tr>
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Minus</p>
						<p class="Tpf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">&#150;</b></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Index</p>
						<p class="Tpf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">[ ]</b></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Structure member</p>
						<p class="Tpf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">.</b></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="99" valign="top" style="width:74.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Segment override</p>
						<p class="Tpf"></p>
					</td>
					<td width="365" valign="top" style="width:274.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">:</b></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
			</table>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1305&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">These operators are discussed in more detail in the following section.</p>
			<h4>Plus, Minus, and Index</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:plus (+)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1094&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;+ (plus operator)&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1095&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The plus and index operators perform in exactly the same way when applied to direct memory operands. For example, both the following statements move the second word value from an array into the AX register:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, array[2]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, array+2<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:index([ ])&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1096&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;[ ] (index operator)&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1097&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Index operator ([ ])&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1098&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The index operator can contain any direct memory operand. The following statements are equivalent:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, var<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [var]<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1306&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Some programmers prefer to enclose the operand in brackets to show that the contents, not the address, are used.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:minus (-)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1099&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Minus operator (-)&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1100&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The minus operator behaves as you would expect. Both the following instructions retrieve the value located at the word preceding <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>array</span>:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, array[-2]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, array-2<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Structure Field</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:structure-member (.)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1101&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;. (structure-member
operator)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1102&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Direct memory
operands:overview&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1103&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Structures:fields,
accessing&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1104&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Structure-member operator
(.)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1105&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The structure operator (<b style="mso-bidi-font-weight:normal">.</b>) references a particular element of a structure or &#147;field,&#148; to use C terminology:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, structvar.field1<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1307&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The address of the structure operand is the sum of the offsets of <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>structvar</span> and <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>field1</span>. For more information about structures, see &#147;Structures and Unions&#148; in Chapter 5.</p>
			<h4>Segment Override</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:segment-override (\\:)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1106&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;\\: (segment-override
operator)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1107&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment registers:default&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1108&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segment-override operator
(\\:)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1109&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The segment override operator (<b style="mso-bidi-font-weight:
normal">:</b>) specifies a segment portion of the address that is different from the default segment. When used with instructions, this operator can apply to segment registers or segment names:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, es:farvar<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Use segment override<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1308&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The assembler will not generate a segment override if the default segment is explicitly provided. Thus, the following two statements assemble in exactly the same way:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bx], ax<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ds:[bx], ax<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1309&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A segment name override or the segment override operator identifies the operand as an address expression.</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR FARSEG:0, ax<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Segment name override<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR es:100h, ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Legal and equivalent<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR es:[100h], ax<span style="mso-spacerun: yes">&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>expressions<br>
			;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR [100h], ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Illegal, not an address<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1310&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">As the example shows, a constant expression cannot be an address expression unless it has a segment override.</p>
			<h2 style="margin-left:0in">Indirect Memory Operands</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Indirect memory operands&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1110&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Memory:access, dynamic&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1111&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operands:indirect memory&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1112&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Like direct memory operands, indirect memory operands specify the contents of a given address. However, the processor calculates the address at run time by referring to the contents of registers. Since values in the registers can change at run time, indirect memory operands provide dynamic access to memory.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1311&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Indirect memory operands make possible run-time operations such as pointer indirection and dynamic indexing of array elements, including indexing of multidimensional arrays.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:indirect addressing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1113&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing modes:indirect
registers, used in&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1114&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Strict rules govern which registers you can use for indirect memory operands under 16-bit versions of the 8086-based processors. The rules change significantly for 32-bit processors starting with the 80386. However, the new rules apply only to code that does not need to be compatible with earlier processors.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1312&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This section covers features of indirect operands in either mode. The specific 16-bit rules and 32-bit rules are then explained separately.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Indirect memory operands&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1115&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<h3>Indirect Operands with 16- and 32-Bit Registers</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:indirect addressing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1116&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Some rules and options for indirect memory operands always apply, regardless of the size of the register. For example, you must always specify the register and operand size for indirect memory operands. But you can use various syntaxes to indicate an indirect memory operand. This section describes the rules that apply to both 16-bit and 32-bit register modes.</p>
			<h4>Specifying Indirect Memory Operands</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:base&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1117&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:index&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1118&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The index operator specifies the register or registers for indirect operands. The processor uses the data pointed to by the register. For example, the following instruction moves into AX the word value at the address in DS:BX.</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, WORD PTR [bx]<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:effective&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1119&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addresses:displacement of&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1120&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing:indirect registers,
used in&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1121&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">When you specify more than one register, the processor adds the contents of the two addresses together to determine the effective address (the address of the data to operate on):</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx+si]<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Specifying Displacements</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1313&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can specify an address displacement, which is a constant value added to the effective address. A direct memory specifier is the most common displacement:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, table[si]<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Relocatable:expressions&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1122&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In this relocatable expression, the displacement <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>table</span> is the base address of an array; SI holds an index to an array element. The SI value is calculated at run time, often in a loop. The element loaded into AX depends on the value of SI at the time the instruction executes.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Displacement&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1123&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operands:indirect memory&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1124&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Each displacement can be an address or numeric constant. If there is more than one displacement, the assembler totals them at assembly time and encodes the total displacement. For example, in the statement</p>
			<p class="Ex">table<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>WORD<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>100 DUP (0)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, table[bx][di]+6<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1314&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">both <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>table</span> and <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>6</span> are displacements. The assembler adds the value of <span style='font-size:9.5pt;
font-family:"Lucida Sans Typewriter"'>6</span> to <span style='font-size:9.5pt;
font-family:"Lucida Sans Typewriter"'>table</span> to get the total displacement. However, the statement</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov ax, mem1[si] + mem2<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1315&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">is not legal, because it attempts to use a single command to join the contents of two different addresses.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operands:size&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1125&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<h4>Specifying Operand Size</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1316&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You must give the size of an indirect memory operand in one of three ways:</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1317&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Lb1"><!--[if supportFields]><span style='mso-element:field-begin'></span>SYMBOL
117 \f &quot;MSIcons&quot; \s 9.5 \h <![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-tab-count:
1">&nbsp; </span>By the variable&#146;s declared size</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1318&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Lb1"><!--[if supportFields]><span style='mso-element:field-begin'></span>SYMBOL
117 \f &quot;MSIcons&quot; \s 9.5 \h <![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-tab-count:
1">&nbsp; </span>With the <b style="mso-bidi-font-weight:normal">PTR</b> operator</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1319&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Lb1"><!--[if supportFields]><span style='mso-element:field-begin'></span>SYMBOL
117 \f &quot;MSIcons&quot; \s 9.5 \h <![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-tab-count:
1">&nbsp; </span>Implied by the size of the other operand</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1320&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The following lines illustrate all three methods. Assume the size of the <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>table</span> array is <b style="mso-bidi-font-weight:normal">WORD</b>, as declared earlier.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Operators:PTR \t &quot;See PTR operator&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1126&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operators:plus (+)&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1127&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Plus operator (+)&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1128&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PTR operator:size,
specifying&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1129&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>table[bx], 0<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes - from size of table<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE PTR table, 0 ; 1 byte<span style="mso-spacerun: yes">&nbsp; </span>- specified by BYTE<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes - implied by AX<br>
			<span style="mso-spacerun: yes">&nbsp; </span></p>
			<h4>Syntax Options</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;+ (plus operator)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1130&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The assembler allows a variety of syntaxes for indirect memory operands. However, all registers must be inside brackets. You can enclose each register in its own pair of brackets, or you can place the registers in the same pair of brackets separated by a plus operator (<b style="mso-bidi-font-weight:normal">+</b>). All the following variations are legal and assemble the same way:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, table[bx][di]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, table[di][bx]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, table[bx+di]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [table+bx+di]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx][di]+table<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1321&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">All of these statements move the value in <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>table</span> indexed by BX+DI into AX.</p>
			<h4>Scaling Indexes</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:index&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1131&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:scaling&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1132&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Scaling index registers&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1133&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The value of index registers pointing into arrays must often be adjusted for zero-based arrays and scaled according to the size of the array items. For a word array, the item number must be multiplied by two (shifted left by one place). When using 16-bit registers, you must scale with separate instructions, as shown here:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 5<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Get sixth element (adjust for 0)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Scale by two (word size)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>wtable[bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Increment sixth element in table<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operands:indirect memory&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1134&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">When using 32-bit registers on the 80386/486 processor, you can include scaling in the operand, as described in &#147;Indirect Memory Operands with 32-Bit Registers,&#148; following.</p>
			<h4>Accessing Structure Elements</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operators:structure-member (.)&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1135&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;. (structure-member
operator)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1136&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Structures:fields,
accessing&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1137&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The structure member operator can be used in indirect memory operands to access structure elements. In this example, the structure member operator loads the <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>year</span> field of the fourth element of the <span style='font-size:9.5pt;font-family:
"Lucida Sans Typewriter"'>students</span> array into AL:</p>
			<p class="Ex">STUDENT STRUCT<br>
			<span style="mso-spacerun: yes">&nbsp; </span>grade WORD<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>?<br>
			<span style="mso-spacerun: yes">&nbsp; </span>name<span style="mso-spacerun: yes">&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>20 DUP (?)<br>
			<span style="mso-spacerun: yes">&nbsp; </span>year<span style="mso-spacerun: yes">&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>?<br>
			STUDENT ENDS<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="Ex">students<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>STUDENT<span style="mso-spacerun: yes">&nbsp; </span>&lt; &gt;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Assume array is initialized<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, OFFSET students<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Point to array of students<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 4<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Get fourth element<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, SIZE STUDENT<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Get size of STUDENT<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mul<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Multiply size times<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>elements to point DI<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>to current element<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>al, (STUDENT PTR[bx+di]).year<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span><br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1322&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">For more information on MASM structures, see &#147;Structures and Unions&#148; in<br>
			Chapter 5.<a name="a"></a></p>
			<h3>Indirect Memory Operands with 16-Bit Registers</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Indirect memory operands&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1138&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:indirect
operands&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1139&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:16-bit&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1140&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">For 8086-based computers and MS-DOS, you must follow the strict indexing rules established for the 8086 processor. Only four registers are allowed<span style="letter-spacing:-1.75pt"> </span>&#151;<span style="letter-spacing:-1.75pt"> </span>BP, BX, SI, and DI<span style="letter-spacing:-1.75pt"> </span>&#151;<span style="letter-spacing:-1.75pt"> </span>those only in certain combinations.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:base&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1141&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:index&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1142&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">BP and BX are base registers. SI and DI are index registers. You can use either a base or an index register by itself. But if you combine two registers, one must be a base and one an index. Here are legal and illegal forms:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx+di]<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Legal<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx+si]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Legal<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bp+di]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Legal<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bp+si]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Legal<br>
			;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx+bp]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Illegal - two base registers<br>
			;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [di+si]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Illegal - two index registers<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addressing:indirect registers, used in&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1143&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operands:indirect memory&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1144&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Table 3.1 shows the register modes in which you can specify indirect memory operands.</p>
			<p class="Tt">Table <a name="table"></a>3.1<a name="CurrentCell"></a><span style="letter-spacing:-1.75pt"> </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>Indirect Addressing with 16-Bit Registers</p>
			<table border="0" cellspacing="0" cellpadding="0" style="margin-left:.4pt;border-collapse:
 collapse;mso-padding-alt:0in 0in 0in 0in">
				<tr>
					<td width="464" colspan="3" valign="top" style="width:348.0pt;padding:0in 0in 0in 0in">
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"><b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>
				</tr>
				<tr>
					<td width="128" valign="top" style="width:96.0pt;padding:0in 0in 0in 0in">
						<p class="Thf">Mode</p>
						<p class="Thf"></p>
					</td>
					<td width="160" valign="top" style="width:120.0pt;padding:0in 0in 0in 0in">
						<p class="Th">Syntax</p>
						<p class="Th"></p>
					</td>
					<td width="176" valign="top" style="width:132.0pt;padding:0in 0in 0in 0in">
						<p class="Th">Effective Address</p>
						<p class="Th"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="464" colspan="3" valign="top" style="width:348.0pt;padding:0in 0in 0in 0in">
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="128" valign="top" style="width:96.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Register indirect</p>
						<p class="Tpf"></p>
					</td>
					<td width="160" valign="top" style="width:120.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">[</b>BX<b style="mso-bidi-font-weight:normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>BP<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>DI<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>SI<b style="mso-bidi-font-weight:
  normal">]</b></p>
						<p class="Tp"></p>
					</td>
					<td width="176" valign="top" style="width:132.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Contents of register</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"><b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>
				</tr>
				<tr>
					<td width="128" valign="top" style="width:96.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Base or index</p>
						<p class="Tpf"></p>
					</td>
					<td width="160" valign="top" style="width:120.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><i style="mso-bidi-font-style:normal"><span style='font-family:
  "Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BX<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BP<b style="mso-bidi-font-weight:normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>DI<b style="mso-bidi-font-weight:normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>SI<b style="mso-bidi-font-weight:normal">]</b></p>
						<p class="Tp"></p>
					</td>
					<td width="176" valign="top" style="width:132.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Contents of register plus <i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement </span></i></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="128" valign="top" style="width:96.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Base plus index</p>
						<p class="Tpf"></p>
					</td>
					<td width="160" valign="top" style="width:120.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><b style="mso-bidi-font-weight:normal">[</b>BX<b style="mso-bidi-font-weight:normal">][</b>DI<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>BP<b style="mso-bidi-font-weight:
  normal">][</b>DI<b style="mso-bidi-font-weight:normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>BX<b style="mso-bidi-font-weight:
  normal">][</b>SI<b style="mso-bidi-font-weight:normal">]</b><br>
						<b style="mso-bidi-font-weight:normal">[</b>BP<b style="mso-bidi-font-weight:
  normal">][</b>SI<b style="mso-bidi-font-weight:normal">]</b></p>
						<p class="Tp"></p>
					</td>
					<td width="176" valign="top" style="width:132.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Contents of base register plus contents of index register</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="128" valign="top" style="width:96.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">Base plus index with<br>
						displacement</p>
						<p class="Tpf"></p>
					</td>
					<td width="160" valign="top" style="width:120.0pt;padding:0in 0in 0in 0in">
						<p class="Tp"><i style="mso-bidi-font-style:normal"><span style='font-family:
  "Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BX<b style="mso-bidi-font-weight:
  normal">][</b>DI<b style="mso-bidi-font-weight:normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BP<b style="mso-bidi-font-weight:normal">][</b>DI<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BX<b style="mso-bidi-font-weight:normal">][</b>SI<b style="mso-bidi-font-weight:
  normal">]</b><br>
						<i style="mso-bidi-font-style:normal"><span style='font-family:"Tms Rmn"'>displacement</span></i><b style="mso-bidi-font-weight:normal"><span style='font-family:"Tms Rmn"'>[</span></b>BP<b style="mso-bidi-font-weight:normal">][</b>SI<b style="mso-bidi-font-weight:
  normal">]</b></p>
						<p class="Tp"></p>
					</td>
					<td width="176" valign="top" style="width:132.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Sum of base register, index register, and <i style="mso-bidi-font-style:
  normal"><span style='font-family:"Tms Rmn"'>displacement</span></i></p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
			</table>
			<div style="border:none;border-top:solid windowtext .75pt;padding:1.0pt 0in 0in 0in">
				<p class="Te"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1323&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Different combinations of registers and displacements have different timings, as shown in <i style="mso-bidi-font-style:normal">Reference</i>.</p>
			<h3>Indirect Memory Operands with 32-Bit Registers</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addressing:indirect registers, used in&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1145&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:indirect
operands&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1146&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Indirect memory operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1147&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Indirect memory operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1148&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can write instructions for the 80386/486 processor using either 16-bit or 32-bit segments. Indirect memory operands are different in each case.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Directives:.386 \t &quot;See .386 directive&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1149&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Directives:.486 \t &quot;See .486
directive&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1150&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.386 directive:segment mode,
setting&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1151&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;.486 directive:segment mode,
setting&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1152&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In 16-bit real mode, the 80386/486 operates the same way as earlier 8086-based processors, with one difference: you can use 32-bit registers. If the 80386/486 processor is enabled (with the <b style="mso-bidi-font-weight:
normal">.386</b> or <b style="mso-bidi-font-weight:normal">.486</b> directive), 32-bit general-purpose registers are available with either 16-bit or 32-bit segments. Thirty-two&#150;bit</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="MsoNormal">registers eliminate many of the limitations of 16-bit indirect memory operands. You can use 80386/486 features to make your MS-DOS programs run faster and more efficiently if you are willing to sacrifice compatibility with earlier processors.<span style="mso-spacerun: yes">&nbsp; </span></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Operands:indirect memory&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1153&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In 32-bit mode, an offset address can be up to 4 gigabytes. (Segments are still represented in 16 bits.) This effectively eliminates size restrictions on each segment, since few programs need 4 gigabytes of memory. Windows NT uses 32-bit mode and flat model, which spans all segments. XENIX 386 uses 32-bit mode with multiple segments.</p>
			<h4>80386/486 Enhancements</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:base&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1154&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:index&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1155&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Indirect memory operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1156&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">On the 80386/486, the processor allows you to use any general-purpose 32-bit register as a base or index register, except ESP, which can be a base but not an index. However, you cannot combine 16-bit and 32-bit registers. Several examples are shown here:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>add<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>edx, [eax]<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Add double<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>dl, [esp+10]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Copy byte from stack<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>dec<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR [edx][eax]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Decrement word<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cmp<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, array[ebx][ecx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Compare word from array<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>jmp<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>FWORD PTR table[ecx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Jump into pointer table<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:scaling&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1157&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Scaling index registers&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1158&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<h4>Scaling Factors</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1324&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">With 80386/486 registers, the index register can have a scaling factor of 1, 2, 4, or 8. Any register except ESP can be the index register and can have a scaling factor. To specify the scaling factor, use the multiplication operator (<b style="mso-bidi-font-weight:normal"><sub>*</sub></b>) adjacent to the register.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:scaling&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1159&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can use scaling to index into arrays with different sizes of elements. For example, the scaling factor is 1 for byte arrays (no scaling needed), 2 for word arrays, 4 for doubleword arrays, and 8 for quadword arrays. There is no performance penalty for using a scaling factor. Scaling is illustrated in the following examples:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>eax, darray[edx*4]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load double of double array<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>eax, [esi*8][edi]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load double of quad array<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, wtbl[ecx+2][edx*2] ; Load word of word array<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1325&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Scaling is also necessary on earlier processors, but it must be done with separate instructions before the indirect memory operand is used, as described in &#147;Indirect Memory Operands with 16-Bit Registers,&#148; previous.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1326&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The default segment register is SS if the base register is EBP or ESP. However, if EBP is scaled, the processor treats it as an index register with a value relative to DS, not SS.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:base&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1160&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addressing modes:scaling
operands&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1161&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Indirect memory operands&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1162&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">All other base registers are relative to DS. If two registers are used, only one can have a scaling factor. The register with the scaling factor is defined as the index register. The other register is defined as the base. If scaling is not used, the first register is the base. If only one register is used, it is considered the base for deciding the default segment unless it is scaled. The following examples illustrate how to determine the base register:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>eax, [edx][ebp*4] ; EDX base (not scaled - seg DS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>eax, [edx*1][ebp] ; EBP base (not scaled - seg SS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>eax, [edx][ebp]<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; EDX base (first - seg DS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>eax, [ebp][edx]<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; EBP base (first - seg SS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>eax, [ebp]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; EBP base (only - seg SS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>eax, [ebp*2]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; EBP*2 index (seg DS)<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Mixing 16-Bit and 32-Bit Registers</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:mixed 16-bit, 32-bit&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1163&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Assembly statements can mix 16-bit and 32-bit registers. For example, the following statement is legal for 16-bit and 32-bit segments:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>eax, [bx]<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1327&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This statement moves the 32-bit value pointed to by BX into the EAX register. Although BX is a 16-bit pointer, it can still point into a 32-bit segment.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1328&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">However, the following statement is never legal, since you cannot use the CX register as a 16-bit pointer:</p>
			<p class="Ex">;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>eax, [cx]<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; illegal<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1329&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Operands that mix 16-bit and 32-bit registers are also illegal:</p>
			<p class="Ex">;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>eax, [ebx+si]<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>; illegal<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1330&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The following statement is legal in either 16-bit or 32-bit mode:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, [eax]<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1331&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This statement moves the 16-bit value pointed to by EAX into the BX register. This works in 32-bit mode. However, in 16-bit mode, moving a 32-bit pointer into a 16-bit segment is illegal. If EAX contains a 16-bit value (the top half of the 32-bit register is 0), the statement works. However, if the top half of the EAX register is not 0, the operand points into a part of the segment that doesn&#146;t exist, generating an error. If you use 32-bit registers as indexes in 16-bit mode, you must make sure that the index registers contain valid 16-bit addresses.</p>
			<h1 style="margin-left:0in">The Program Stack</h1>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Integers:stack&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1164&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Integers:pushing onto
stack&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1165&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Integers:popping off
stack&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1166&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:PUSH instructions&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1167&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:POP instructions&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1168&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:described&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1169&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The preceding discussion on memory operands lays the groundwork for understanding the important data area known as the &#147;stack.&#148;</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1332&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A stack is an area of memory for storing data temporarily. Unlike other segments that store data starting from low memory, the stack stores data starting from high memory. Data is always pushed onto, or &#147;popped&#148; from the top of the stack.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1333&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The stack gets its name from its similarity to the spring-loaded plate holders in cafeterias. You add and remove plates from only the top of the stack. To retrieve the third plate, you must remove<span style="letter-spacing:-1.75pt"> </span>&#151;<span style="letter-spacing:-1.75pt"> </span>that is, &#147;pop&#148;<span style="letter-spacing:-1.75pt"> </span>&#151;<span style="letter-spacing:
-1.75pt"> </span>the first two plates. Stacks are often referred to as LIFO buffers, from their last-in-first-out operation.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1334&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A stack is an essential part of any nontrivial program. A program continually uses its stack to temporarily store return addresses, procedure arguments, memory data, flags, or registers.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1335&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The SP register serves as an indirect memory operand to the top of the stack. At first, the stack is an uninitialized segment of a finite size. As your program adds data to the stack, the stack grows downward from high memory to low memory. When you remove items from the stack, it shrinks upward from low to high memory.</p>
			<h2 style="margin-left:0in">Saving Operands on the Stack</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;SP (Stack Pointer) register&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1170&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PUSH instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1171&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;POP instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1172&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:PUSH&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1173&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:POP&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1174&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:operators with&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1175&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1176&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">PUSH</b> instruction stores a 2-byte operand on the stack. The <b style="mso-bidi-font-weight:
normal">POP</b> instruction retrieves the most recent pushed value. When a value is pushed onto the stack, the assembler decreases the SP (Stack Pointer) register by 2. On 8086-based processors, the SP register always points to the top of the stack. The <b style="mso-bidi-font-weight:normal">PUSH</b> and <b style="mso-bidi-font-weight:normal">POP</b> instructions use the SP register to keep track of the current position.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1336&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">When a value is popped off the stack, the assembler increases the SP register by 2. Since the stack always contains word values, the SP register changes in multiples of two. When a <b style="mso-bidi-font-weight:
normal">PUSH</b> or <b style="mso-bidi-font-weight:normal">POP</b> instruction executes in a 32-bit code segment (one with <b style="mso-bidi-font-weight:
normal">USE32</b> use type), the assembler transfers a 4-byte value, and ESP changes in multiples of four.</p>
			<div style="border:none;border-bottom:solid windowtext .75pt;padding:0in 0in 1.0pt 0in">
				<p class="Ns"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			</div>
			<div style="mso-element:frame;mso-element-wrap:around">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="16" align="left">
					<tr>
						<td valign="top" align="left" height="16" style="padding-top:0in;padding-right:
  6.5pt;padding-bottom:0in;padding-left:6.5pt">
							<p class="Nh">Note</p>
						</td>
					</tr>
				</table>
			</div>
			<p class="Np1">The 8086 and 8088 processors differ from later Intel processors in how they push and pop the SP register. If you give the statement <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>push sp</span> with the 8086 or 8088, the word pushed is the word in SP after the push operation.</p>
			<div style="border:none;border-top:solid windowtext .75pt;padding:1.0pt 0in 0in 0in">
				<p class="Ne"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			</div>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1337&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Figure 3.1 illustrates how pushes and pops change the SP register.</p>
			<p class="Art" style="margin-left:0in"><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span><span style='mso-field-code:"include M\:\\\\SLM\\\\SRC\\\\MASM61\\\\APPS\\\\ART\\\\mpchp03\.doc art_mp0301_eps  \\\\* mergeformat"'><a name="art_mp0301_eps"></a><a name="space_mp0301_eps"><span style="mso-bookmark:
art_mp0301_eps"></span></a><!--[if supportFields]><span style='mso-bookmark:
space_mp0301_eps'><span style='mso-bookmark:art_mp0301_eps'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:space_mp0301_eps'><span
style='mso-bookmark:art_mp0301_eps'>IMPORT
M:\\SLM\\SRC\\MASM61\\APPS\\ART\\MP0301.EPS \* mergeformat<span
style='mso-element:field-separator'></span></span></span><![endif]-->
			<span style="mso-bookmark:space_mp0301_eps"><span style="mso-bookmark:art_mp0301_eps"><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:257.25pt;
 height:306pt'>
 <v:imagedata src="./Chap_03_files/image001.wmz" o:href="file:///M:/SLM/SRC/MASM61/APPS/ART/MP0301.EPS"/>
</v:shape><![endif]-->
			<![if !vml]><img width="343" height="408" src="Chap_03_files/image002.gif" v:shapes="_x0000_i1025"><![endif]></span></span><!--[if supportFields]><span
style='mso-bookmark:space_mp0301_eps'><span style='mso-bookmark:art_mp0301_eps'></span></span><span
style='mso-element:field-end'></span><![endif]-->
			 <span style="mso-bookmark:
space_mp0301_eps"><span style="mso-bookmark:art_mp0301_eps"></span></span></span></p>
			<p class="Cap">Figure <!--[if supportFields]><span style='font-family:Times'><span
style='mso-element:field-begin'></span>SEQ chapter \c<span style='mso-element:
field-separator'></span></span><![endif]-->
			<span style="font-family:Times">3</span><!--[if supportFields]><span
style='font-family:Times'><span style='mso-element:field-end'></span></span><![endif]-->
			 <span style="font-family:Times">.</span><!--[if supportFields]><span
style='font-family:Times'><span style='mso-element:field-begin'></span>SEQ
figure<span style='mso-element:field-separator'></span></span><![endif]-->
			 <span style="font-family:Times">1</span><!--[if supportFields]><span
style='font-family:Times'><span style='mso-element:field-end'></span></span><![endif]-->
			 <span style="font-family:Helvetica-Narrow"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span>Stack Status Before and After Pushes and Pops</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Stacks:operations with&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1177&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;SP (Stack Pointer)
register&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1178&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1179&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">On the 8086,<b style="mso-bidi-font-weight:normal"> PUSH</b> and <b style="mso-bidi-font-weight:normal">POP</b> take only registers or memory expressions as their operands. The other processors allow an immediate value to be an operand for <b style="mso-bidi-font-weight:normal">PUSH</b>. For example, the following statement is legal on the 80186&#150;80486<br>
			processors:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>7<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 3 clocks on 80286<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1338&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">That statement is faster than these equivalent statements, which are required on the 8088 or 8086:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 7<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</span>; 2 clocks plus<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 3 clocks on 80286<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1339&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Words are popped off the stack in reverse order: the last item pushed is the first popped. To return the stack to its original status, you do the same number of pops as pushes. You can subtract the correct number of words from the SP register if you want to restore the stack without using the values on it.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;BP (Base Pointer) register&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1180&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;SP (Stack Pointer)
register&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1181&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;SS (Stack Segment)
register&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1182&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Base Pointer (BP)
register&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1183&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1184&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stack frame&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1185&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:Stack Segment
(SS)&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1186&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stack Segment (SS)
register&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1187&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe &quot;aa&quot; \z
&quot;ADDREW.DOC-1340&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">To reference operands on the stack, remember that the values pointed to by the BP (Base Pointer) and SP registers are relative to the SS (Stack Segment) register. The BP register is often used to point to the base of a frame of reference (a stack frame) within the stack. This example shows how you can access values on the stack using indirect memory operands with BP as the base register.</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>bp<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Save current value of BP<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bp, sp<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Set stack frame<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ax<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push first;<span style="mso-spacerun: yes">&nbsp; </span>SP = BP - 2<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>bx<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push second; SP = BP - 4<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>cx<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push third;<span style="mso-spacerun: yes">&nbsp; </span>SP = BP - 6<br>
			<span style="mso-spacerun: yes">&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bp-6]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Put third word in AX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, [bp-4]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Put second word in BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>cx, [bp-2]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Put first word in CX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>add<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>sp, 6<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Restore stack pointer<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>(two bytes per push)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bp<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Restore BP<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1341&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If you often use these stack values in your program, you may want to give them labels. For example, you can use <b style="mso-bidi-font-weight:
normal">TEXTEQU</b> to create a label such as <span style='font-size:9.5pt;
font-family:"Lucida Sans Typewriter"'>count TEXTEQU &lt;[bp-6]&gt;</span>. Now you can replace the <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>mov ax, [bp - 6]</span> statement in the previous example with <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>mov ax, count</span>. For more information about the <b style="mso-bidi-font-weight:normal">TEXTEQU</b> directive, see &#147;Text Macros&#148; in Chapter 9.</p>
			<h2 style="margin-left:0in">Saving Flags on the Stack</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Flags:stack, saving on&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1188&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:operations with&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1189&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:saving flags on&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1190&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Status flags, saving&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1191&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:PUSHF&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1192&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:POPF&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1193&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:PUSHFD&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1194&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:POPFD&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1195&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:LAHF&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1196&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PUSHF instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1197&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;POPF instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1198&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PUSHFD instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1199&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;POPFD instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1200&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;LAHF instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1201&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Your program can push and pop flags onto the stack with the <b style="mso-bidi-font-weight:normal">PUSHF</b> and <b style="mso-bidi-font-weight:
normal">POPF</b> instructions. These instructions save and then restore the status of the flags. You can also use them within a procedure to save and restore the flag status of the caller. The 32-bit versions of these instructions are <b style="mso-bidi-font-weight:normal">PUSHFD</b> and <b style="mso-bidi-font-weight:normal">POPFD</b>.<span style="mso-spacerun: yes">&nbsp; </span></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1342&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">This example saves the flags register before calling the <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>systask</span> procedure:</p>
			<p class="Ex" style="page-break-after:auto"><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pushf<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>systask<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>popf<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1343&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If you do not need to store the entire flags register, you can use the <b style="mso-bidi-font-weight:normal">LAHF</b> instruction to manually load and store the status of the lower byte of the flag register in the AH register. <b style="mso-bidi-font-weight:normal">SAHF</b> restores the value.</p>
			<h2 style="margin-left:0in">Saving Registers on the Stack (80186&#150;80486 Only)</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:stack, saving on&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1202&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:operations with&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1203&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Stacks:saving registers
on&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1204&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:PUSHA&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1205&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:POPA&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1206&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:PUSHAD&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1207&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:POPAD&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1208&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PUSHA instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1209&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;POPA instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1210&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PUSHAD instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1211&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;POPAD instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1212&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Starting with the 80186 processor, the <b style="mso-bidi-font-weight:
normal">PUSHA</b> and <b style="mso-bidi-font-weight:normal">POPA</b> instructions push or pop all the general-purpose registers with only one instruction. These instructions save the status of all registers before a procedure call and restore them after the return. Using <b style="mso-bidi-font-weight:
normal">PUSHA</b> and<b style="mso-bidi-font-weight:normal"> POPA</b> is significantly faster and takes fewer bytes of code than pushing and popping each register individually.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1344&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The processor pushes the registers in the following order: AX, CX, DX, BX, SP, BP, SI, and DI. The SP word pushed is the value before the first register is pushed.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1345&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The processor pops the registers in the opposite order. The 32-bit versions of these instructions are <b style="mso-bidi-font-weight:normal">PUSHAD</b> and <b style="mso-bidi-font-weight:normal">POPAD</b>.</p>
			<h1 style="margin-left:0in">Accessing Data with Pointers and Addresses</h1>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Variables:pointer \t &quot;See Pointer variables&quot;<span style='mso-hide:
none'> \z &quot;ADDREW.DOC-1213&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:accessing data
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1214&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1215&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:location&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1216&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointer variables&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1217&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A pointer is simply a variable that contains an address of some other variable. The address in the pointer &#147;points&#148; to the other object. Pointers are useful when transferring a large data object (such as an array) to a procedure. The caller places only the pointer on the stack, which the called procedure uses to locate the array. This eliminates the impractical step of having to pass the entire array back and forth through the stack.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Far address&quot; \z &quot;ADDREW.DOC-1218&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Far pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1219&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Segments:accessing data
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1220&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Offsets:accessing data
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1221&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Far pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1222&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">There is a difference between a far address and a far pointer. A &#147;far address&#148; is the address of a variable located in a far data segment. A &#147;far pointer&#148; is a variable that contains the segment address and offset of some other data. Like any other variable, a pointer can be located in either the default (near) data segment or in a far segment.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1346&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Previous versions of MASM allow pointer variables but provide little support for them. In previous versions, any address loaded into a variable can be considered a pointer, as in the following statements:</p>
			<p class="Ex">Var<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>0<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Variable<br>
			npVar<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>WORD<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>Var<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Near pointer to variable<br>
			fpVar<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>DWORD<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>Var<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Far pointer to variable<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1347&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If a variable is initialized with the name of another variable, the initialized variable is a pointer, as shown in this example. However, in previous versions of MASM, the CodeView debugger recognizes <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>npVar</span> and <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>fpVar</span> as word and doubleword variables. CodeView does not treat them as pointers, nor does it recognize the type of data they point to (bytes, in the example).</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1348&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">TYPEDEF</b> directive and enhanced capabilities of <b style="mso-bidi-font-weight:normal">ASSUME</b> (introduced in MASM 6.0) make it easier to manage pointers in registers and variables. The rest of this chapter describes these directives and how they apply to basic pointer operations.</p>
			<h2 style="margin-left:0in">Defining Pointer Types with TYPEDEF</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;TYPEDEF directive:pointers, defined by&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1223&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">TYPEDEF</b> directive can define types for pointer variables. A type so defined is considered the same as the intrinsic types provided by the assembler and can be used in the same contexts. When used to define pointers, the syntax for <b style="mso-bidi-font-weight:normal">TYPEDEF</b> is:</p>
			<p class="Syn"><i style="mso-bidi-font-style:normal">typename</i> <b style="mso-bidi-font-weight:normal">TYPEDEF</b> <span style="letter-spacing:
-1.5pt">[</span>[<i style="mso-bidi-font-style:normal">distance</i><span style="letter-spacing:-1.5pt">]</span>] <b style="mso-bidi-font-weight:normal">PTR</b> <i style="mso-bidi-font-style:normal">qualifiedtype</i></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointers:TYPEDEF, defined with&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1224&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Operators:PTR \t &quot;See PTR
operator&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1225&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;PTR operator:TYPEDEF, used
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1226&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Qualifiedtypes:pointers,
defining&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1227&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointer variables&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1228&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <i style="mso-bidi-font-style:normal">typename</i> is the name assigned to the new type. The <i style="mso-bidi-font-style:normal">distance</i> can be <b style="mso-bidi-font-weight:normal">NEAR</b>, <b style="mso-bidi-font-weight:
normal">FAR</b>, or any distance modifier. The <i style="mso-bidi-font-style:
normal">qualifiedtype</i> can be any previously intrinsic or defined MASM type, or a type previously defined with <b style="mso-bidi-font-weight:normal">TYPEDEF</b>. (For a full definition of <i style="mso-bidi-font-style:normal">qualifiedtype</i>, see &#147;Data Types&#148; in Chapter 1.)</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1349&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Here are some examples of user-defined types:</p>
			<p class="Ex">PBYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>; Pointer to bytes<br>
			NPBYTE<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF NEAR PTR BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Near pointer to bytes<br>
			FPBYTE<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF FAR<span style="mso-spacerun: yes">&nbsp; </span>PTR BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Far pointer to bytes<br>
			PWORD<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR WORD<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>; Pointer to words<br>
			NPWORD<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF NEAR PTR WORD<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Near pointer to words<br>
			FPWORD<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF FAR<span style="mso-spacerun: yes">&nbsp; </span>PTR WORD<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Far pointer to words<br>
			<br>
			PPBYTE<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR PBYTE<span style="mso-spacerun:
yes">&nbsp; </span>; Pointer to pointer to bytes<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>(in C, an array of strings)<br>
			PVOID<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Pointer to any type of data<br>
			<br>
			PERSON<span style="mso-spacerun: yes">&nbsp; </span>STRUCT<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Structure type<br>
			<span style="mso-spacerun: yes">&nbsp; </span>name<span style="mso-spacerun: yes">&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>20 DUP (?)<br>
			<span style="mso-spacerun: yes">&nbsp; </span>num<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>WORD<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>?<br>
			PERSON<span style="mso-spacerun: yes">&nbsp; </span>ENDS<br>
			PPERSON TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR PERSON ; Pointer to structure type<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1350&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The distance of a pointer can be set specifically or determined automatically by the memory model (set by <b style="mso-bidi-font-weight:
normal">.MODEL</b>) and the segment size (16 or 32 bits). If you don&#146;t use <b style="mso-bidi-font-weight:normal">.MODEL</b>, near pointers are the default.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1351&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In 16-bit mode, a near pointer is 2 bytes that contain the offset of the object pointed to. A far pointer requires 4 bytes, and contains both the segment and offset. In 32-bit mode, a near pointer is 4 bytes and a far pointer is 6 bytes, since segments are</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="MsoNormal">still word values in 32-bit mode. If you specify the distance with <b style="mso-bidi-font-weight:normal">NEAR</b> or <b style="mso-bidi-font-weight:normal">FAR</b>, the processor uses the default distance of the current segment size. You can use<b style="mso-bidi-font-weight:
normal"> NEAR16</b>, <b style="mso-bidi-font-weight:normal">NEAR32</b>, <b style="mso-bidi-font-weight:normal">FAR16</b>, and <b style="mso-bidi-font-weight:
normal">FAR32</b> to override the defaults set by the current segment size. In flat model, <b style="mso-bidi-font-weight:normal">NEAR</b> is the default.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointer variables&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1229&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can declare pointer variables with a pointer type created with <b style="mso-bidi-font-weight:normal">TYPEDEF</b>. Here are some examples using these pointer types.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;TYPEDEF directive:pointers, defined by&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1230&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:TYPEDEF, defined
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1231&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Qualifiedtypes:pointers,
defining&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1232&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Ex">; Type declarations<br>
			Array<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>WORD<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>25 DUP (0)<br>
			Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;This is a string&quot;, 0<br>
			pMsg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PBYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Pointer to string<br>
			pArray<span style="mso-spacerun: yes">&nbsp; </span>PWORD<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>Array<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Pointer to word array<br>
			npMsg<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>NPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Near pointer to string<br>
			npArray NPWORD<span style="mso-spacerun: yes">&nbsp; </span>Array<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Near pointer to word array<br>
			fpArray FPWORD<span style="mso-spacerun: yes">&nbsp; </span>Array<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Far pointer to word array<br>
			fpMsg<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>FPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Far pointer to string<br>
			<br>
			S1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;first&quot;, 0<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Some strings<br>
			S2<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;second&quot;, 0<br>
			S3<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;third&quot;, 0<br>
			pS123<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>PBYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>S1, S2, S3, 0<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Array of pointers to strings<br>
			ppS123<span style="mso-spacerun: yes">&nbsp; </span>PPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>pS123<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; A pointer to pointers to strings<br>
			<br>
			Andy<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PERSON<span style="mso-spacerun:
yes">&nbsp; </span>&lt;&gt;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Structure variable<br>
			pAndy<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>PPERSON Andy<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Pointer to structure variable<br>
			<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Procedure prototype<br>
			<br>
			EXTERN<span style="mso-spacerun: yes">&nbsp; </span>ptrArray:PBYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; External variable<br>
			Sort<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PROTO<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>pArray:PBYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Parameter for prototype<br>
			<br>
			; Parameter for procedure<br>
			Sort<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PROC<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>pArray:PBYTE<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LOCAL<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>pTmp:PBYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Local variable<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ret<br>
			Sort<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>ENDP<span style="mso-spacerun:
yes">&nbsp; </span><br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1352&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Once defined, pointer types can be used in any context where intrinsic types are allowed.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h2 style="margin-left:0in">Defining Register Types with ASSUME</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;ASSUME directive:general-purpose registers&quot;<span style='mso-hide:
none'> \z &quot;ADDREW.DOC-1233&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:pointers as&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1234&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Registers:types, defined with
ASSUME&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1235&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can use the <b style="mso-bidi-font-weight:normal">ASSUME</b> directive with general-purpose registers to specify that a register is a pointer to a certain size of object. For example:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSUME<span style="mso-spacerun: yes">&nbsp; </span>bx:PTR WORD<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Assume BX is now a word pointer<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Increment word pointed to by BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>add<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 2<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Point to next word<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>[bx], 0<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Word pointed to by BX = 0<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Other pointer operations with BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<span style="mso-spacerun:
yes">&nbsp; </span><br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun:
yes">&nbsp;&nbsp;</span>ASSUME<span style="mso-spacerun: yes">&nbsp; </span>bx:NOTHING<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Cancel assumption<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1353&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In this example, BX is specified as a pointer to a word. After a sequence of using BX as a pointer, the assumption is canceled by assuming <b style="mso-bidi-font-weight:normal">NOTHING</b>.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;ASSUME directive:general-purpose registers&quot;<span style='mso-hide:
none'> \z &quot;ADDREW.DOC-1236&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Without the assumption to <b style="mso-bidi-font-weight:
normal">PTR WORD</b>, many instructions need a size specifier. The <b style="mso-bidi-font-weight:normal">INC</b> and <b style="mso-bidi-font-weight:
normal">MOV</b> statements from the previous examples would have to be written like this to specify the sizes of the memory operands:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>inc<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR [bx]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR [bx], 0<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1354&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">When you have used <b style="mso-bidi-font-weight:normal">ASSUME</b>, attempts to use the register for other purposes generate assembly errors. In this example, while the <b style="mso-bidi-font-weight:normal">PTR WORD</b> assumption is in effect, any use of BX inconsistent with its <b style="mso-bidi-font-weight:normal">ASSUME</b> declaration generates an error. For example,</p>
			<p class="Ex">;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>al, [bx]<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Can't move word to byte register<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1355&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can also use the <b style="mso-bidi-font-weight:normal">PTR</b> operator to override defaults:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>al, BYTE PTR [bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Legal<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:types, defined with ASSUME&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1237&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Similarly, you can use <b style="mso-bidi-font-weight:normal">ASSUME</b> to prevent the use of a register as a pointer, or even to disable a register:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSUME<span style="mso-spacerun: yes">&nbsp; </span>bx:WORD, dx:ERROR<br>
			;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>al, [bx] ; Error - BX is an integer, not a pointer<br>
			;<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, dx<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Error - DX disabled<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1356&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">For information on using <b style="mso-bidi-font-weight:
normal">ASSUME</b> with segment registers, refer to &#147;Setting the ASSUME Directive for Segment Registers&#148; in Chapter 2.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h2 style="margin-left:0in">Basic Pointer and Address Operations</h2>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointers:operations&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1238&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:TYPEDEF, defined
with&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1239&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:initializing&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1240&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointer variables&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1241&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">A program can perform the following basic operations with pointers and addresses:</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1357&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Lb1"><!--[if supportFields]><span style='mso-element:field-begin'></span>SYMBOL
117 \f &quot;MSIcons&quot; \s 9.5 \h <![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-tab-count:
1">&nbsp; </span>Initialize a pointer variable by storing an address in it.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1358&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="Lb1"><!--[if supportFields]><span style='mso-element:field-begin'></span>SYMBOL
117 \f &quot;MSIcons&quot; \s 9.5 \h <![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-tab-count:
1">&nbsp; </span>Load an address into registers, directly or from a pointer.</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1359&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The sections in the rest of this chapter describe variations of these tasks with pointers and addresses. The examples are used with the assumption that you have previously defined the following pointer types with the <b style="mso-bidi-font-weight:normal">TYPEDEF</b> directive:</p>
			<p class="Ex">PBYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TYPEDEF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PTR BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>; Pointer to bytes<br>
			NPBYTE<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF NEAR PTR BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Near pointer to bytes<br>
			FPBYTE<span style="mso-spacerun: yes">&nbsp; </span>TYPEDEF FAR<span style="mso-spacerun: yes">&nbsp; </span>PTR BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Far pointer to bytes<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h3>Initializing Pointer Variables</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1360&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If the value of a pointer is known at assembly time, the assembler can initialize it automatically so that no processing time is wasted on the task at run time. The following example shows how to do this, placing the address of <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>msg</span> in the pointer <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>pmsg</span>.</p>
			<p class="Ex">Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&quot;String&quot;, 0<br>
			pMsg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PBYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>Msg<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointers:initializing&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1242&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If a pointer variable can be conditionally defined to one of several constant addresses, initialization must be delayed until run time. The technique is different for near pointers than for far pointers, as shown here:</p>
			<p class="Ex">Msg1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&quot;String1&quot;<br>
			Msg2<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;String2&quot;<br>
			npMsg<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>NPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>?<br>
			fpMsg<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>FPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>?<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>npMsg, OFFSET Msg1<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load near pointer<br>
			<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpMsg[0], OFFSET Msg2<span style="mso-spacerun:
yes">&nbsp; </span>; Load far offset<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpMsg[2], SEG Msg2<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load far segment<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1361&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If you know that the segment for a far pointer is in a register, you can load it directly:</p>
			<p class="Ex" style="page-break-after:auto"><span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpMsg[2], ds<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load segment of<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>far pointer<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Dynamic Addresses</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:dynamic&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1243&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Often a pointer must point to a dynamic address, meaning the address depends on a run-time condition. Typical situations include memory allocated by MS-DOS (see &#147;Interrupt 21h Function 48h&#148; in Help) and addresses found by the <b style="mso-bidi-font-weight:normal">SCAS</b> or <b style="mso-bidi-font-weight:normal">CMPS</b> instructions (see &#147;Processing Strings&#148; in Chapter 5). The following illustrates the technique for saving dynamic addresses:</p>
			<p class="Ex">; Dynamically allocated buffer<br>
			fpBuf<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>FPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>0<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Initialize so offset will be zero<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ah, 48h<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Allocate memory<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, 10h<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Request 16 paragraphs<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>int<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>21h<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Call DOS<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>jc<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>error<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Return segment in AX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf[2], ax<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Load segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>(offset is already 0)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			error:<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Handle error<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Copying Pointers</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointers:copying&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1244&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Sometimes one pointer variable must be initialized by copying from another. Here are two ways to copy a far pointer:</p>
			<p class="Ex">fpBuf1<span style="mso-spacerun: yes">&nbsp; </span>FPBYTE<span style="mso-spacerun: yes">&nbsp; </span>?<br>
			fpBuf2<span style="mso-spacerun: yes">&nbsp; </span>FPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>?<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			; Copy through registers is faster, but requires a spare register<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, WORD PTR fpBuf1[0]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf2[0], ax<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, WORD PTR fpBuf1[2]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf2[2], ax<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="Ex">; Copy through stack is slower, but does not use a register<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf1[0]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf1[2]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf2[2]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR fpBuf2[0]<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h4>Pointers as Arguments</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Pointers:arguments, as&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1245&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE
&quot;Procedures:arguments:pointers&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1246&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Most high-level-language procedures and library functions accept arguments passed on the stack. &#147;Passing Arguments on the Stack&#148; in Chapter 7 covers this subject in detail. A pointer is passed in the same way as any other variable, as this fragment shows:</p>
			<p class="Ex">; Push a far pointer (segment always pushed first)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>WORD PTR fpMsg[2]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>WORD PTR fpMsg[0]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push offset<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1362&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Pushing an address has the same result as pushing a pointer to the address:</p>
			<p class="Ex">; Push a far address as a far pointer<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG fVar<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Load and push segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ax<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, OFFSET fVar ; Load and push offset<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ax<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1363&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">On the 80186 and later processors, you can push a constant in one step:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>SEG fVar<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>OFFSET fVar<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Push offset<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h3>Loading Addresses into Registers</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:registers, loading into&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1247&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Loading a near address into a register (or a far address into a pair of registers) is a common task in assembly-language programming. To reference data pointed to by a pointer, your program must first place the pointer into a register or pair of registers.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:loading addresses into&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1248&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Load far addresses as <i style="mso-bidi-font-style:normal">segment</i><b style="mso-bidi-font-weight:normal">:</b><i style="mso-bidi-font-style:normal">offset</i> pairs. The following pairs have specific uses:</p>
			<table border="0" cellspacing="0" cellpadding="0" style="margin-left:.4pt;border-collapse:
 collapse;mso-padding-alt:0in 0in 0in 0in">
				<tr>
					<td width="136" valign="top" style="width:102.0pt;padding:0in 0in 0in 0in">
						<p class="Thf">Segment:Offset Pair</p>
						<p class="Thf"></p>
					</td>
					<td width="328" valign="top" style="width:246.0pt;padding:0in 0in 0in 0in">
						<p class="Th">Standard Use</p>
						<p class="Th"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="464" colspan="2" valign="top" style="width:348.0pt;padding:0in 0in 0in 0in">
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
						<div style="border:none;border-top:solid windowtext .75pt;padding:0in 0in 0in 0in">
							<p class="Tr"></p>
						</div>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="136" valign="top" style="width:102.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">DS:SI</p>
						<p class="Tpf"></p>
					</td>
					<td width="328" valign="top" style="width:246.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Source for string operations</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"><b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>
				</tr>
				<tr>
					<td width="136" valign="top" style="width:102.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">ES:DI</p>
						<p class="Tpf"></p>
					</td>
					<td width="328" valign="top" style="width:246.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Destination for string operations</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="136" valign="top" style="width:102.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">DS:DX</p>
						<p class="Tpf"></p>
					</td>
					<td width="328" valign="top" style="width:246.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Input for certain DOS functions</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
				<tr>
					<td width="136" valign="top" style="width:102.0pt;padding:0in 0in 0in 0in">
						<p class="Tpf">ES:BX</p>
						<p class="Tpf"></p>
					</td>
					<td width="328" valign="top" style="width:246.0pt;padding:0in 0in 0in 0in">
						<p class="Tp">Output from certain DOS functions</p>
						<p class="Tp"></p>
					</td>
					<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
  normal"></p>
				</tr>
			</table>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<h4>Addresses from Data Segments</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Addresses:near&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1249&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Addresses:far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1250&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Far pointer&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1251&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">For near addresses, you need only load the offset; the segment is assumed as SS for stack-based data and as DS for other data. You must load both segment and offset for far pointers.</p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1364&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Here is an example of loading an address into DS:BX from a near data segment:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.DATA<br>
			Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;String&quot;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, OFFSET Msg<span style="mso-spacerun: yes">&nbsp; </span>; Load address to BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>;<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>(DS already loaded)<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1365&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Far data can be loaded like this:</p>
			<p class="Ex">.FARDATA<br>
			Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>&quot;String&quot;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, SEG Msg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load address to ES:BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es, ax<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, OFFSET Msg<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1366&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">You can also read a far address from a pointer in one step, using the <b style="mso-bidi-font-weight:normal">LES</b> and <b style="mso-bidi-font-weight:normal">LDS</b> instructions described next.</p>
			<h4>Far Pointers</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Instructions:LDS&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1252&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:LES&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1253&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The <b style="mso-bidi-font-weight:normal">LES</b> and <b style="mso-bidi-font-weight:normal">LDS</b> instructions load a far pointer into a segment pair. The instructions copy the pointer&#146;s low word into either ES or DS, and the high word into a given register. The following example shows how to load a far pointer into ES:DI:</p>
			<p class="Ex">OutBuf<span style="mso-spacerun: yes">&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>20 DUP (0)<br>
			<br>
			fpOut<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>FPBYTE<span style="mso-spacerun:
yes">&nbsp; </span>OutBuf<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>les<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, fpOut<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load far pointer into ES:DI<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h4>Stack Variables</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
Variables:stack \t &quot;See Local variables&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1254&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Variables:local address,
loading&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1255&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Stacks:variables \t &quot;See Local
variables&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1256&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Local variables:loading
addresses of&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1257&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The technique for loading the address of a stack variable is significantly different from the technique for loading near addresses. You may need to put the correct segment value into ES for string operations. The following example illustrates how to load the address of a local (stack) variable to ES:DI:</p>
			<p class="Ex">Task<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PROC<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LOCAL<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>Arg[4]:BYTE<br>
			<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ss<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Since it's stack-based, segment is SS<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Copy SS to ES<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lea<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, Arg ; Load offset to DI<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1367&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">The local variable in this case actually evaluates to SS:[BP-4]. This is an offset from the stack frame (described in &#147;Passing Arguments on the Stack,&#148; Chapter 7). Since you cannot use the <b style="mso-bidi-font-weight:normal">OFFSET</b> operator to get the offset of an indirect memory operand, you must use the <b style="mso-bidi-font-weight:normal">LEA</b> (Load Effective Address) instruction.</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
			<h4>Direct Memory Operands</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Direct memory operands:loading offset of&quot;<span style='mso-hide:none'>
\z &quot;ADDREW.DOC-1258&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:LEA&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1259&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Instructions:MOV&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1260&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;OFFSET operator&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1261&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;LEA instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1262&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;MOV instruction&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1263&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Pointers:far&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1264&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Operators:OFFSET&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1265&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">To get the address of a direct memory operand, use either the <b style="mso-bidi-font-weight:normal">LEA</b> instruction or the <b style="mso-bidi-font-weight:normal">MOV</b> instruction with <b style="mso-bidi-font-weight:normal">OFFSET</b>. Though both methods have the same effect, the <b style="mso-bidi-font-weight:normal">MOV</b> instruction produces smaller and faster code, as shown in this example:</p>
			<p class="Ex"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lea<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>si, Msg<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Four byte instruction<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>si, OFFSET Msg ; Three byte equivalent<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<h4>Copying Between Segment Pairs</h4>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Registers:copying pairs of&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1266&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Copying from one register pair to another is complicated by the fact that you cannot copy one segment register directly to another. Two copying methods are shown here. Timings are for the 8088 processor.</p>
			<p class="Ex">; Copy DS:SI to ES:DI, generating smaller code<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>push<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>ds<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 1 byte, 14 clocks<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pop<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 1 byte, 12 clocks<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, si<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes, 2 clocks<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="Ex">; Copy DS:SI to ES:DI, generating faster code<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, ds<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes, 2 clocks<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>es, di<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes, 2 clocks<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>di, si<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; 2 bytes, 2 clocks<br style="mso-special-character:line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<h3>Model-Independent Techniques</h3>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;@Model predefined symbol&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1267&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Often you may want to write code that is memory-model independent. If you are writing libraries that must be available for different memory models, you can use conditional assembly to handle different sizes of pointers. You can use the predefined symbols <b style="mso-bidi-font-weight:
normal"><span style="font-size:10.0pt">@DataSize</span></b> and <b style="mso-bidi-font-weight:normal"><span style="font-size:10.0pt">@Model</span></b> to test the current assumptions.</p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>XE
&quot;Conditional assembly:pointers, with&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1268&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>xe Assembly:conditional \t &quot;See
Conditional assembly&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1269&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Predefined
symbols:@Datasize[DATASIZE&quot;<span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1270&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;Predefined symbols:@Model&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1271&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;@DataSize predefined
symbol&quot;<span style='mso-hide:none'> \z &quot;ADDREW.DOC-1272&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-begin'></span>XE &quot;@Model predefined symbol&quot;<span
style='mso-hide:none'> \z &quot;ADDREW.DOC-1273&quot;</span><![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			<a name="bmXETemp"></a><a name="FindXETemp1"><span style="mso-bookmark:bmXETemp"></span></a><!--[if supportFields]><span
style='mso-bookmark:FindXETemp1'><span style='mso-bookmark:bmXETemp'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:FindXETemp1'><span
style='mso-bookmark:bmXETemp'>XE &quot;Memory models:model-independent
code&quot;</span></span><span style='mso-bookmark:FindXETemp1'><span
style='mso-bookmark:bmXETemp'><span style='mso-hide:none'> \z
&quot;ADDREW.DOC-1274&quot;</span></span></span><![endif]-->
			<span style="mso-bookmark:FindXETemp1"><span style="mso-bookmark:bmXETemp"></span></span><!--[if supportFields]><span
style='mso-bookmark:FindXETemp1'><span style='mso-bookmark:bmXETemp'></span></span><span
style='mso-element:field-end'></span><![endif]-->
			<span style="mso-bookmark:
FindXETemp1"><span style="mso-bookmark:bmXETemp"></span></span></p>
			<p class="MsoNormal"><a name="FindXETemp">You can use conditional assembly to write code that works with pointer variables that have no specified distance. The predefined symbol </a><span style="mso-bookmark:FindXETemp"><b style="mso-bidi-font-weight:normal"><span style="font-size:10.0pt">@DataSize</span></b> tests the pointer size for the current memory model:<span style="mso-spacerun:
yes">&nbsp; </span></span></p>
			<span style="mso-bookmark:FindXETemp"></span>
			<p class="Ex">Msg1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>BYTE<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&quot;String1&quot;<br>
			pMsg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PBYTE<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>?<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>.<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>IF<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>@DataSize<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; @DataSize &gt; 0 for far<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR pMsg[0], OFFSET Msg1<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>; Load far offset<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>WORD PTR pMsg[2], SEG Msg1<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load far segment<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ELSE<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; @DataSize = 0 for near<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>pMsg, OFFSET Msg1<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load near pointer<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ENDIF<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1368&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">In the following example, a procedure receives as an argument a pointer to a word variable. The code inside the procedure uses <b style="mso-bidi-font-weight:normal"><span style="font-size:10.0pt">@DataSize</span></b> to determine whether the current memory model supports far or near data. It loads and processes the data accordingly:</p>
			<p class="Ex" style="page-break-after:auto">; Procedure that receives an argument by reference<br>
			mul8<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PROC<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp; </span>arg:PTR WORD<br>
			<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>IF<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>@DataSize<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>les<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, arg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load far pointer to ES:BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, es:[bx] ; Load the data pointed to<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ELSE<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>bx, arg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load near pointer to BX (assume DS)<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, [bx]<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>; Load the data pointed to<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ENDIF<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Multiply by 8<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ret<br>
			mul8<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>ENDP<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<div style="mso-element:frame;mso-element-wrap:around;mso-height-rule:exactly">
				<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="left">
					<tr>
						<td valign="top" align="left" style="padding-top:0in;padding-right:9.0pt;
  padding-bottom:0in;padding-left:9.0pt">
							<p class="Pb" style="margin-left:0in"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
						</td>
					</tr>
				</table>
			</div>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1369&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">If you have many routines, writing the conditionals for each case can be tedious. The following conditional statements automatically generate the proper instructions and segment overrides.</p>
			<p class="Ex">; Equates for conditional handling of pointers<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>IF @DataSize<br>
			lesIF<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;les&gt;<br>
			ldsIF<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;lds&gt;<br>
			esIF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;es:&gt;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ELSE<br>
			lesIF<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;mov&gt;<br>
			ldsIF<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;mov&gt;<br>
			esIF<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>TEXTEQU<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>&lt;&gt;<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ENDIF<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><!--[if supportFields]><span style='mso-element:field-begin'></span>xe
&quot;aa&quot; \z &quot;ADDREW.DOC-1370&quot;<![endif]-->
			<!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->
			</p>
			<p class="MsoNormal">Once you define these conditionals, you can use them to simplify code that must handle several types of pointers. This next example rewrites the above <span style='font-size:9.5pt;font-family:"Lucida Sans Typewriter"'>mul8</span> procedure to use conditional code.</p>
			<p class="Ex">mul8<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>PROC<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>arg:PTR WORD<br>
			<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lesIF<span style="mso-spacerun:
yes">&nbsp;&nbsp; </span>bx, arg<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Load pointer to BX or ES:BX<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>mov<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, esIF [bx]<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>; Load the data from [BX] or ES:[BX]<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>; Multiply by 8<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>shl<span style="mso-spacerun:
yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>ax, 1<br>
			<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ret<br>
			mul8<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>ENDP<br style="mso-special-character:
line-break">
			<![if !supportLineBreakNewLine]><br style="mso-special-character:line-break">
			<![endif]></p>
			<p class="index"><a name="bkEntry"></a><!--[if supportFields]><span
style='mso-bookmark:bkEntry'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bkEntry'>xe &quot;aa&quot; \z &quot;ADDREW.DOC-1371&quot;</span><![endif]-->
			<span style="mso-bookmark:bkEntry"></span><!--[if supportFields]><span
style='mso-bookmark:bkEntry'></span><span style='mso-element:field-end'></span><![endif]-->
			<span style="mso-bookmark:bkEntry"></span></p>
			<p class="MsoNormal"><a name="BeginSelect"></a>The conditional statements from these examples can be defined once in an include file and used whenever you need to handle pointers.</p>
			<p class="Le"><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
		</div>
	</body>

</html>
