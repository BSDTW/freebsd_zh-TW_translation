<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Debian Reference - Debian tutorials</title>

</head>

<body>

<p><a name="ch-tutorial"></a></p>
<hr>

<p>
[ <a href="ch-install.en.html">previous</a> ]
[ <a href="index.en.html#contents">Contents</a> ]
[ <a href="ch-preface.en.html">1</a> ]
[ <a href="ch-system.en.html">2</a> ]
[ <a href="ch-install.en.html">3</a> ]
[ 4 ]
[ <a href="ch-woody.en.html">5</a> ]
[ <a href="ch-package.en.html">6</a> ]
[ <a href="ch-kernel.en.html">7</a> ]
[ <a href="ch-tips.en.html">8</a> ]
[ <a href="ch-tune.en.html">9</a> ]
[ <a href="ch-gateway.en.html">10</a> ]
[ <a href="ch-edit.en.html">11</a> ]
[ <a href="ch-vcs.en.html">12</a> ]
[ <a href="ch-program.en.html">13</a> ]
[ <a href="ch-gnupg.en.html">14</a> ]
[ <a href="ch-support.en.html">15</a> ]
[ <a href="ap-appendix.en.html">A</a> ]
[ <a href="ch-woody.en.html">next</a> ]
</p>

<hr>

<h1>
Debian Reference
<br>Chapter 4 - Debian tutorials
</h1>

<hr>

<p>
This section provides a basic orientation to the Debian world for the real
newbie.  If you have been using any Unix-like system for a while, you probably
know everything I explained here.  Please use this as a reality check.
</p>

<hr>

<h2><a name="s-first"></a>4.1 Getting started</h2>

<p>
After the installation of the Debian system on your PC, you need to learn few
things to make it useful.  Let us give you an express training.
</p>

<hr>

<h3><a name="s-login-root"></a>4.1.1 Login to a shell prompt as root</h3>

<p>
Upon rebooting the system, you will be presented either the graphical login
screen or the character based login screen depending on your initial selection
of packages.  For the sake of simplicity, if you are presented with the
graphical login screen, press Ctrl-Alt-F1 [<a href="footnotes.en.html#f3"
name="fr3">3</a>] to gain the character based login screen.
</p>

<p>
Suppose your hostname is <samp><var>foo</var></samp>, the login prompt looks
like:
</p>

<pre>
     <var>foo</var> login:
</pre>

<p>
Type <samp>root</samp> , press the Enter-key and type the password which you
selected during the install process.  In the Debian system, following the Unix
tradition, the password is case sensitive.  Then the system starts with the
greeting message and presents you with the root command prompt waiting for your
input.  [<a href="footnotes.en.html#f4" name="fr4">4</a>]
</p>

<pre>
     <var>foo</var> login: root
     Password: 
     Last login: Sun Oct 26 19:04:09 2003 on tty3
     Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux
     
     Most of the programs included with the Debian GNU/Linux system are
     freely redistributable; the exact distribution terms for each program
     are described in the individual files in /usr/share/doc/*/copyright
     
     Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
     permitted by applicable law.
     
     root@<var>foo</var>:root#
</pre>

<p>
You are ready to perform the system administration from this root command
prompt.  This root account is also called superuser or privileged user.  From
this account, you can do anything:
</p>
<ul>
<li>
<p>
read, write, and remove any files on the system irrespective of their file
permissions
</p>
</li>
<li>
<p>
set file ownership and permission of any files on the system
</p>
</li>
<li>
<p>
set the password of any non-privileged users on the system
</p>
</li>
<li>
<p>
login to any accounts without their passwords
</p>
</li>
</ul>

<p>
It is extremely bad idea to share the access to the root account by sharing the
password.  Use of program such as <code>sudo(8)</code> is the good way to share
the administrative privileges.
</p>

<p>
Please note that it is considered a good Unix habit to login to the
non-privileged user account first even when you plan to perform administrative
activities.  Use commands <samp>sudo</samp>, <samp>super</samp>, or <samp>su
-c</samp> to gain the limited root privileged when needed.  See <a
href="ch-tune.en.html#s-sudo">Working more safely &ndash; <code>sudo</code>,
Section 9.2.4</a>.  [<a href="footnotes.en.html#f5" name="fr5">5</a>]
</p>

<hr>

<h3><a name="s-newbiefix"></a>4.1.2 Set up minimal newbie environment</h3>

<p>
I think learning a computer system is like learning a new foreign language.
Although tutorial books are helpful, you have to practice it with helper tools.
In this context, I think it is a good idea to install few additional packages
such as <code>mc</code>, <code>vim</code>, <code>lynx</code>,
<code>doc-linux-text</code>, and <code>debian-policy</code>.  [<a
href="footnotes.en.html#f6" name="fr6">6</a>]
</p>

<pre>
     # apt-get update
      ...
     # apt-get install mc vim lynx doc-linux-text debian-policy 
      ...
</pre>

<p>
If you already had these packages installed, nothing will be installed.
</p>

<hr>

<h3><a name="s-newuser"></a>4.1.3 Add a user account</h3>

<p>
During the installation, you usually created a non-privileged user account who
receives e-mails sent to the root account.  [<a href="footnotes.en.html#f7"
name="fr7">7</a>] Since you do not want to use this special user account for
the following training activities either, you should create another new user
account.
</p>

<p>
Suppose you wish this new username to be <samp><var>penguin</var></samp>, type:
</p>

<pre>
     root@<var>foo</var>:root# adduser <var>penguin</var>
     ... answer all the questions
</pre>

<p>
will create it.  [<a href="footnotes.en.html#f8" name="fr8">8</a>] Before going
further, let's learn few things first.
</p>

<hr>

<h3><a name="s-sw-console"></a>4.1.4 Switch between virtual console</h3>

<p>
In the default Debian system, there are six independent pseudo-terminals
available, i.e., you can use the PC's VGA character console screen as 6
switchable VT-100 terminals.  Switch from one to another by pressing the
Left-Alt-key and one of the F1&ndash;F6 keys simultaneously.  Each
pseudo-terminal allows independent login to accounts.  The multiuser
environment is a great Unix feature, and very addictive.
</p>

<p>
If you accidentally typed Alt-F7 on a system running the X Window System and
the console screen displays graphic screen, regain the access to the character
console by pressing Ctrl-Alt-F1.  Just try to move to different console and
come back to the original one to get used to this.
</p>

<hr>

<h3><a name="s-shutdown"></a>4.1.5 How to shut down</h3>

<p>
Just like any other modern OSs where the file operation involves caching data
in the memory, the Debian system needs the proper shutdown procedure before
power can safely be turned off to maintain the integrity of files.  Use the
following command from the root command prompt to shutdown the system:
</p>

<pre>
     # shutdown -h now
</pre>

<p>
This is for the normal multiuser mode.  If you are in the single-user mode, use
following from the root command prompt:
</p>

<pre>
     # poweroff -i -f
</pre>

<p>
Alternatively, you may type Ctrl-Alt-Delete to shutdown.  [<a
href="footnotes.en.html#f9" name="fr9">9</a>]
</p>

<p>
Wait until the system displays &quot;System halted&quot; then shut off power.
If the APM or ACPI function has been turned on by the BIOS and Linux properly,
the system will power down by itself.  See <a
href="ch-install.en.html#s-apm">Large memory and auto power-off, Section
3.8.4</a> for the detail.
</p>

<hr>

<h3><a name="s-playtime"></a>4.1.6 Play time</h3>

<p>
Now you are ready to play with the Debian system without risks as long as you
use this non-privileged user account <samp><var>penguin</var></samp>.  [<a
href="footnotes.en.html#f10" name="fr10">10</a>]
</p>

<p>
Let's login to the <samp><var>penguin</var></samp>.  If you are at root shell
prompt, type Ctrl-D [<a href="footnotes.en.html#f11" name="fr11">11</a>] at the
root command prompt to close the root shell activity and return to the login
prompt.  Enter your newly created username <samp><var>penguin</var></samp> and
the corresponding password.  [<a href="footnotes.en.html#f12"
name="fr12">12</a>] You will be presented with the following command prompt.
</p>

<pre>
     <var>penguin</var>@<var>foo</var>:<var>penguin</var>$
</pre>

<p>
From here on, the example given will use simplified command prompt for the sake
of simplicity.  I will use:
</p>
<ul>
<li>
<p>
<samp>#</samp> : root shell prompt
</p>
</li>
<li>
<p>
<samp>$</samp> : non-privileged user shell prompt
</p>
</li>
</ul>

<p>
We will start learning the Debian system first with the easy way <a
href="#s-mc">Midnight Commander (MC), Section 4.2</a> and later with the proper
way <a href="#s-unixlike">Unix-like work environment, Section 4.3</a>.
</p>

<hr>

<h2><a name="s-mc"></a>4.2 Midnight Commander (MC)</h2>

<p>
Midnight Commander (MC) is a GNU &quot;Swiss army knife&quot; for the Linux
console and other terminal environments.  This gives newbie a menu driven
console experience which is much easier to learn than standard Unix commands.
</p>

<p>
Use this command to explore the Debian system.  This is the best way to learn.
Please explore few key locations just using the cursor keys and Enter key:
</p>
<ul>
<li>
<p>
<code>/etc</code> and its subdirectories.
</p>
</li>
<li>
<p>
<code>/var/log</code> and its subdirectories.
</p>
</li>
<li>
<p>
<code>/usr/share/doc</code> and its subdirectories.
</p>
</li>
<li>
<p>
<code>/sbin</code> and <code>/bin</code>
</p>
</li>
</ul>

<hr>

<h3><a name="s-mc-enhance"></a>4.2.1 Enhance MC</h3>

<p>
In order to make MC to change working directory upon exit, you need to modify
<code>~/.bashrc</code> (or <code>/etc/bash.bashrc</code>, called from
<code>.bashrc</code>), as detailed in its manual page, <code>mc(1)</code>,
under the <samp>-P</samp> option.  [<a href="footnotes.en.html#f13"
name="fr13">13</a>]
</p>

<hr>

<h3><a name="s-mc-start"></a>4.2.2 Start MC</h3>

<pre>
     $ mc
</pre>

<p>
MC takes care of all file operations through its menu, requiring minimal user
effort.  Just press F1 to get the help screen.  You can play with MC just by
pressing cursor-keys and function-keys.  [<a href="footnotes.en.html#f14"
name="fr14">14</a>]
</p>

<hr>

<h3><a name="s-mc-fm"></a>4.2.3 File manager in MC</h3>

<p>
The default is two directory panels containing file lists.  Another useful mode
is to set the right window to &quot;information&quot; to see file access
privilege information, etc.  Following are some essential keystrokes.  With the
<code>gpm</code> daemon running, one can use a mouse, too.  (Make sure to press
the shift-key to obtain the normal behavior of cut and paste in MC.)
</p>
<ul>
<li>
<p>
F1: Help menu
</p>
</li>
<li>
<p>
F3: Internal file viewer
</p>
</li>
<li>
<p>
F4: Internal editor
</p>
</li>
<li>
<p>
F9: Activate pulldown menu
</p>
</li>
<li>
<p>
F10: Exit Midnight Commander
</p>
</li>
<li>
<p>
Tab: Move between two windows
</p>
</li>
<li>
<p>
Insert: Mark file for a multiple-file operation such as copy
</p>
</li>
<li>
<p>
Del: Delete file (be careful&mdash;set MC to safe delete mode)
</p>
</li>
<li>
<p>
Cursor keys: Self-explanatory
</p>
</li>
</ul>

<hr>

<h3><a name="s-mc-cl"></a>4.2.4 Command-line tricks in MC</h3>

<ul>
<li>
<p>
Any <code>cd</code> command will change the directory shown on the selected
screen.
</p>
</li>
<li>
<p>
Ctrl-Enter or Alt-Enter will copy a filename to the command line.  Use this
with the <code>cp</code> or <code>mv</code> command together with command-line
editing.
</p>
</li>
<li>
<p>
Alt-Tab will show shell filename expansion choices.
</p>
</li>
<li>
<p>
One can specify the starting directory for both windows as arguments to MC; for
example, <samp>mc /etc /root</samp>.
</p>
</li>
<li>
<p>
Esc + <var>numberkey</var> == F<var>n</var> (i.e., Esc + `1' = F1, etc.; Esc +
`0' = F10)
</p>
</li>
<li>
<p>
Esc-key == Alt-key (= Meta, M-); i.e., type Esc + `c' for Alt-C.
</p>
</li>
</ul>

<hr>

<h3><a name="s-mcedit"></a>4.2.5 Editor in MC</h3>

<p>
The internal editor has an interesting cut-and-paste scheme.  Pressing F3 marks
the start of a selection, a second F3 marks the end of selection and highlights
the selection.  Then you can move your cursor.  If you press F6, the selected
area will be moved to the cursor location.  If you press F5, the selected area
will be copied and inserted at the cursor location.  F2 will save the file.
F10 will get you out.  Most cursor keys work intuitively.
</p>

<p>
This editor can be directly started on a file:
</p>

<pre>
     $ mc -e filename_to_edit
     $ mcedit filename_to_edit
</pre>

<p>
This is not a multi-window editor, but one can use multiple Linux consoles to
achieve the same effect.  To copy between windows, use Alt-F<var>n</var> keys
to switch virtual consoles and use &quot;File-&gt;Insert file&quot; or
&quot;File-&gt;Copy to file&quot; to move a portion of a file to another file.
</p>

<p>
This internal editor can be replaced with any external editor of choice.
</p>

<p>
Also, many programs use environment variables <samp>EDITOR</samp> or
<samp>VISUAL</samp> to decide which editor to use.  If you are uncomfortable
with <code>vim</code>, set these to <samp>mcedit</samp> by adding these lines
to <code>~/.bashrc</code>:
</p>

<pre>
     ...
     export EDITOR=mcedit
     export VISUAL=mcedit
     ...
</pre>

<p>
I do recommend setting these to <samp>vim</samp> if possible.  Getting used to
<code>vim</code> commands is the right thing to do, since Vi-editor is always
there in the Linux/Unix world.  [<a href="footnotes.en.html#f15"
name="fr15">15</a>]
</p>

<hr>

<h3><a name="s-mc-view"></a>4.2.6 Viewer in MC</h3>

<p>
Very smart viewer.  This is a great tool for searching words in documents.  I
always use this for files in the <code>/usr/share/doc</code> directory.  This
is the fastest way to browse through masses of Linux information.  This viewer
can be directly started like so:
</p>

<pre>
     $ mc -v filename_to_view
</pre>

<hr>

<h3><a name="s-ma-auto"></a>4.2.7 Auto-start features of MC</h3>

<p>
Press Enter on a file, and the appropriate program will handle the content of
the file.  This is a very convenient MC feature.
</p>

<pre>
     executable file:   Execute command
     man, html file:    Pipe content to viewer software
     tar.gz, deb file:  Browse its contents as if subdirectory
</pre>

<p>
In order to allow these viewer and virtual file features to function, viewable
files should not be set as executable.  Change their status using the
<code>chmod</code> command or via the MC file menu.
</p>

<hr>

<h3><a name="s-mc-ftp"></a>4.2.8 FTP virtual filesystem of MC</h3>

<p>
MC can be used to access files over the Internet using FTP.  Go to the menu by
pressing F9, then type `p' to activate the FTP virtual filesystem.  Enter a URL
in the form <samp>username:passwd@hostname.domainname</samp>, which will
retrieve a remote directory that appears like a local one.
</p>

<p>
Try <samp>http.us.debian.org/debian</samp> as URL and browse Debian file
archive.  See <a href="ch-system.en.html#s-ftparchives">The Debian archives,
Section 2.1</a> for how these are organized.
</p>

<hr>

<h2><a name="s-unixlike"></a>4.3 Unix-like work environment</h2>

<p>
Although MC enables you to do almost everything, it is very important for you
to learn how to use the command line tools invoked from the shell prompt and
become familiar with the Unix-like work environment.  [<a
href="footnotes.en.html#f16" name="fr16">16</a>]
</p>

<hr>

<h3><a name="s-sp-keys"></a>4.3.1 Special key strokes</h3>

<p>
In the Unix-like environment, there are few key strokes which have special
meanings.  [<a href="footnotes.en.html#f17" name="fr17">17</a>]
</p>
<ul>
<li>
<p>
Ctrl-U: Erase line before cursor.
</p>
</li>
<li>
<p>
Ctrl-H: Erase a character before cursor.
</p>
</li>
<li>
<p>
Ctrl-D: Terminate input.  (exit shell if you are using shell)
</p>
</li>
<li>
<p>
Ctrl-C: Terminate a running program.
</p>
</li>
<li>
<p>
Ctrl-Z: Temporarily stop program.  (put it to the background job, see <a
href="#s-cmd-back"><samp>command &amp;</samp>, Section 4.3.10.1</a>)
</p>
</li>
<li>
<p>
Ctrl-S: Halt output to screen.  [<a href="footnotes.en.html#f18"
name="fr18">18</a>]
</p>
</li>
<li>
<p>
Ctrl-Q: Reactivate output to screen.
</p>
</li>
</ul>

<p>
The default shell, <code>bash</code>, has history-editing and tab-completion
capabilities to aide the interactive use.
</p>
<ul>
<li>
<p>
up-arrow: Start command history search.
</p>
</li>
<li>
<p>
Ctrl-R: Start incremental command history search.
</p>
</li>
<li>
<p>
TAB: Complete input of the filename to the command line.
</p>
</li>
<li>
<p>
Ctrl-V TAB: Input TAB without expansion to the command line.
</p>
</li>
</ul>

<p>
Other important keystrokes to remember:
</p>
<ul>
<li>
<p>
Ctrl-Alt-Del: Reboot/halt the system, see <a
href="ch-install.en.html#s-post-inst">Install a few more packages after initial
install, Section 3.8.1</a>.
</p>
</li>
<li>
<p>
Left-click-and-drag mouse: Select and copy to the clipboard.
</p>
</li>
<li>
<p>
Click middle mouse button: Paste clipboard at the cursor.
</p>
</li>
<li>
<p>
Meta-key (Emacs terminology) is assigned traditionally to Left-Alt-key.  Some
system may be configured to use Windows-key for Meta-key.
</p>
</li>
</ul>

<p>
Here, in order to use a mouse in the Linux character console, you need to have
<code>gpm</code> running as daemon.  [<a href="footnotes.en.html#f19"
name="fr19">19</a>] See <a href="ch-install.en.html#s-gpm">Mouse configuration,
Section 3.3</a>.
</p>

<hr>

<h3><a name="s-unixcmds"></a>4.3.2 Basic Unix commands</h3>

<p>
Let's learn the basic Unix commands.  [<a href="footnotes.en.html#f20"
name="fr20">20</a>] Try all the following commands from the non-privileged user
account <samp><var>penguin</var></samp> :
</p>
<ul>
<li>
<p>
<samp>pwd</samp>
</p>
<ul>
<li>
<p>
Display name of current/working directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>whoami</samp>
</p>
<ul>
<li>
<p>
Display current user name.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>file <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Display a type of file for the file <var>foo</var>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>type -p <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
Display a file location of command <samp><var>commandname</var></samp>.
</p>
</li>
<li>
<p>
<samp>which <var>commandname</var></samp> does the same.  [<a
href="footnotes.en.html#f21" name="fr21">21</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>type <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
Display information on command <samp><var>commandname</var></samp>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>apropos <var>key-word</var></samp>
</p>
<ul>
<li>
<p>
Find commands related to <samp><var>key-word</var></samp>.
</p>
</li>
<li>
<p>
<samp>man -k <var>key-word</var></samp> does the same.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>whatis <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
Display one line explanation on command <samp><var>commandname</var></samp>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>man -a <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
Display explanation on command <samp><var>commandname</var></samp>.  (Unix
style)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>info <var>commandname</var></samp>
</p>
<ul>
<li>
<p>
Display rather long explanation on command <samp><var>commandname</var></samp>.
(GNU style)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls</samp>
</p>
<ul>
<li>
<p>
List contents of directory.  (non-dot files and directories) [<a
href="footnotes.en.html#f22" name="fr22">22</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -a</samp>
</p>
<ul>
<li>
<p>
List contents of directory.  (all files and directories)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -A</samp>
</p>
<ul>
<li>
<p>
List contents of directory.  (almost all files and directories, i.e., skip
&quot;<code>..</code>&quot; and &quot;<code>.</code>&quot;)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -la</samp>
</p>
<ul>
<li>
<p>
List all contents of directory with detail information.  See <a
href="#s-file-system">The filesystem concept in Debian, Section 4.5.2</a>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ls -d</samp>
</p>
<ul>
<li>
<p>
List all directories under the current directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>lsof <var>foo</var></samp>
</p>
<ul>
<li>
<p>
List open status of file <samp><var>foo</var></samp>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mkdir <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Make a new directory <samp><var>foo</var></samp> in the current directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>rmdir <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Remove a directory <samp><var>foo</var></samp> in the current directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Change directory to the directory <code><var>foo</var></code> in the current
directory or in the directory listed in the variable <samp>CDPATH</samp>.  See
<code>cd</code> command in <code>builtins(7)</code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd /</samp>
</p>
<ul>
<li>
<p>
Change directory to the root directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd</samp>
</p>
<ul>
<li>
<p>
Change directory to the current user's home directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd /<var>foo</var></samp>
</p>
<ul>
<li>
<p>
Change directory to the absolute path directory <code>/<var>foo</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd ..</samp>
</p>
<ul>
<li>
<p>
Change directory to the parent directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd ~<var>foo</var></samp>
</p>
<ul>
<li>
<p>
Change directory to the home directory of the user <samp><var>foo</var></samp>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cd -</samp>
</p>
<ul>
<li>
<p>
Change directory to the previous directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>&lt;/etc/motd pager</samp>
</p>
<ul>
<li>
<p>
Display contents of <code>/etc/motd</code> using the default pager.  See <a
href="#s-cmd-stdin"><samp>command &lt; <var>foo</var></samp>, Section
4.3.10.9</a>.  [<a href="footnotes.en.html#f23" name="fr23">23</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>touch <var>junkfile</var></samp>
</p>
<ul>
<li>
<p>
Create a empty file <code><var>junkfile</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>cp <var>foo</var> <var>bar</var></samp>
</p>
<ul>
<li>
<p>
Copy a existing file <code><var>foo</var></code> to a new file
<code><var>bar</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>rm <var>junkfile</var></samp>
</p>
<ul>
<li>
<p>
Remove a file <code><var>junkfile</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mv <var>foo</var> <var>bar</var></samp>
</p>
<ul>
<li>
<p>
Rename an existing file <code><var>foo</var></code> to a new name
<code><var>bar</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>mv <var>foo</var> <var>bar/baz</var></samp>
</p>
<ul>
<li>
<p>
Move an existing file <code><var>foo</var></code> to a new location with a new
name <code><var>bar/baz</var></code>.  The directory
<code><var>bar</var></code> must exist.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 600 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Make an existing file <code><var>foo</var></code> to be non-readable and
non-writable by the other people.  (non-executable for all)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 644 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Make an existing file <code><var>foo</var></code> to be readable but
non-writable by the other people.  (non-executable for all)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>chmod 755 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Make an existing file <code><var>foo</var></code> to be readable but
non-writable by the other people.  (executable for all)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>top</samp>
</p>
<ul>
<li>
<p>
Display process information using full screen.  Type &quot;q&quot; to quit.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps aux | pager</samp>
</p>
<ul>
<li>
<p>
Display information on all the running processes using BSD style output.  See
<a href="#s-cmd-pipe"><samp>command1 | command2</samp>, Section 4.3.10.2</a>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps -ef | pager</samp>
</p>
<ul>
<li>
<p>
Display information on all the running processes using Unix system-V style
output.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps aux | grep -e &quot;[e]xim4*&quot;</samp>
</p>
<ul>
<li>
<p>
Display all processes running <code>exim</code> or <code>exim4</code>.  Learn
the regular expression from <code>grep(1)</code> manual page by typing
<samp>man grep</samp>.  [<a href="footnotes.en.html#f24" name="fr24">24</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>ps axf | pager</samp>
</p>
<ul>
<li>
<p>
Display information on all the running processes with ASCII art output.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>kill <var>1234</var></samp>
</p>
<ul>
<li>
<p>
Kill a process identified by the process ID: <var>1234</var>.  See <a
href="ch-tips.en.html#s-kill">Kill a process, Section 8.5.1</a>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>grep -e &quot;<var>pattern</var>&quot; *.html</samp>
</p>
<ul>
<li>
<p>
Find a &quot;<var>pattern</var>&quot; in all of the files ending with
<samp>.html</samp> in current directory and display them all.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>gzip <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Compress <code><var>foo</var></code> to create <code><var>foo</var>.gz</code>
using the Lempel-Ziv coding (LZ77).
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>gunzip <var>foo</var>.gz</samp>
</p>
<ul>
<li>
<p>
Decompress <code><var>foo</var>.gz</code> to create
<code><var>foo</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>bzip2 <var>foo</var></samp>
</p>
<ul>
<li>
<p>
Compress <code><var>foo</var></code> to create <code><var>foo</var>.bz2</code>
using the Burrows-Wheeler block sorting text compression algorithm, and Huffman
coding.  (Better compression than <code>gzip</code>)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>bunzip2 <var>foo</var>.bz2</samp>
</p>
<ul>
<li>
<p>
Decompress <code><var>foo</var>.bz2</code> to create
<code><var>foo</var></code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvf <var>foo.tar</var></samp>
</p>
<ul>
<li>
<p>
Extract files from <code><var>foo</var>.tar</code> archive.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvzf <var>foo</var>.tar.gz</samp>
</p>
<ul>
<li>
<p>
Extract files from gzipped <code><var>foo</var>.tar.gz</code> archive.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -xvvf --bzip2 <var>foo.tar.bz2</var></samp>
</p>
<ul>
<li>
<p>
Extract files from <code><var>foo</var>.tar.bz2</code> archive.  [<a
href="footnotes.en.html#f25" name="fr25">25</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvf <var>foo</var>.tar <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
Archive contents of folder <code><var>bar</var>/</code> in
<code><var>foo</var>.tar</code> archive.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
Archive contents of folder <code><var>bar</var>/</code> in compressed
<code><var>foo</var>.tar.gz</code> archive.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</samp>
</p>
<ul>
<li>
<p>
Archive contents of folder <code><var>bar</var>/</code> in
<code><var>foo</var>.tar.bz2</code> archive.  [<a href="footnotes.en.html#f26"
name="fr26">26</a>]
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz | pager</samp>
</p>
<ul>
<li>
<p>
Display contents of compressed <code>README.gz</code> using the default pager.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz &gt; foo</samp>
</p>
<ul>
<li>
<p>
Create a file <code>foo</code> with the decompressed content of
<code>README.gz</code>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>zcat README.gz &gt;&gt; foo</samp>
</p>
<ul>
<li>
<p>
Append the decompressed content of <code>README.gz</code> to the end of the
file <code>foo</code>.  (If it does not exist, create it first.)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>find .  -name <var>pattern</var></samp>
</p>
<ul>
<li>
<p>
find matching filenames using shell <samp><var>pattern</var></samp>.  (slower)
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>locate -d .  <var>pattern</var></samp>
</p>
<ul>
<li>
<p>
find matching filenames using shell <samp><var>pattern</var></samp>.  (quicker
using regularly generated database)
</p>
</li>
</ul>
</li>
</ul>

<p>
Please traverse directories and peek into the system using above commands as a
training.  If you have questions on any of the console commands, please make
sure to read the manual page.  For example, these commands are the good start:
</p>

<pre>
     $ man man
     $ man bash
     $ man ls
</pre>

<p>
Also this is a good timing to start <code>vim</code> and press F1-key.  You
should at least read the first 35 lines.  Then do the online training course by
moving cursor to <samp>|tutor|</samp> and pressing Ctrl-].  See <a
href="ch-edit.en.html">Editors, Chapter 11</a> to learn more about editors.
</p>

<p>
Please note that many Unix-like commands including ones from GNU and BSD will
display brief help information if you invoke them in one of the following ways
(or without any arguments in some cases):
</p>

<pre>
     $ <var>commandname</var> --help
     $ <var>commandname</var> -h
</pre>

<p>
Try also examples in <a href="ch-tips.en.html">Debian tips, Chapter 8</a> as
your self training.
</p>

<hr>

<h3><a name="s-cmd-exec"></a>4.3.3 The command execution</h3>

<p>
Now you have some feel on how to use the Debian system.  Let's look deep into
the mechanism of the command execution in the Debian system.  [<a
href="footnotes.en.html#f27" name="fr27">27</a>]
</p>

<hr>

<h3><a name="s-cmd-simple"></a>4.3.4 Simple command</h3>

<p>
A simple command is a sequence of
</p>
<!-- ol type="1" start="1"  -->
<li>
<p>
variable assignments (optional)
</p>
</li>
<li>
<p>
command name
</p>
</li>
<li>
<p>
arguments (optional)
</p>
</li>
<li>
<p>
redirections (optional: <samp>&gt;</samp> , <samp>&gt;&gt;</samp> ,
<samp>&lt;</samp> , <samp>&lt;&lt;</samp> , etc.)
</p>
</li>
<li>
<p>
control operator (optional: <samp>&amp;&amp;</samp> , <samp>||</samp> ;
&lt;newline&gt; , <samp>;</samp> , <samp>&amp;</samp> , <samp>(</samp> ,
<samp>)</samp> )
</p>
</li>
</ol>

<p>
For more complex commands with quotations and substitutions, see <a
href="ch-program.en.html#s-clprocess">Command-line processing, Section
13.2.6</a>.
</p>

<hr>

<h3><a name="s-cmd-env"></a>4.3.5 Command execution and environment variable</h3>

<p>
Typical command execution uses a shell line sequence like the following: [<a
href="footnotes.en.html#f28" name="fr28">28</a>]
</p>

<pre>
     $ date
     Sun Oct 26 08:17:20 CET 2003
     $ LC_ALL=fr_FR date
     dim oct 26 08:17:39 CET 2003
</pre>

<p>
Here, the program <code>date</code> is executed in the foreground job.  The
environment variable <samp>LC_ALL</samp> is:
</p>
<ul>
<li>
<p>
unset (system default, same as <samp>C</samp>) for the first command
</p>
</li>
<li>
<p>
set to <samp>fr_FR</samp> (French locale) for the second command
</p>
</li>
</ul>

<p>
Most command executions usually do not have preceding environment variable
definition.  For the above example, you can alternatively execute:
</p>

<pre>
     $ LC_ALL=fr_FR
     $ date
     dim oct 26 08:17:39 CET 2003
</pre>

<p>
As you can see here, the output of command is affected by the environment
variable to produce French output.  If you want the environment variable to be
inherited to the subprocesses (e.g., when calling shell script), you need to
&quot;export&quot; it instead by using:
</p>

<pre>
     $ export LC_ALL
</pre>

<hr>

<h3><a name="s-cmd-path"></a>4.3.6 Command search path</h3>

<p>
When you type a command into the shell, the shell searches the command in the
list of directories contained in the <samp>PATH</samp> environment variable.
The value of the <samp>PATH</samp> environment variable is also called the
shell's search path.
</p>

<p>
In the default Debian installation, the <samp>PATH</samp> environment variable
of user accounts may not include <code>/sbin/</code>.  So if you want to run
any commands such as <code>ifconfig</code> from <code>/sbin/</code>, you must
change the <samp>PATH</samp> environment variable to include it.  The
<samp>PATH</samp> environment variable is usually set by the initialization
file <code>~/.bash_profile</code>, see <a
href="ch-install.en.html#s-bashconf">Bash configuration, Section 3.2</a>.
</p>

<hr>

<h3><a name="s-cmd-opt"></a>4.3.7 Command line options</h3>

<p>
Some commands take arguments.  The arguments starting with <samp>-</samp> or
<samp>--</samp> are called options and control the behavior of the command.
</p>

<pre>
     $ date
     Mon Oct 27 23:02:09 CET 2003
     $ date -R
     Mon, 27 Oct 2003 23:02:40 +0100
</pre>

<p>
Here the command-line argument <samp>-R</samp> changes the <code>date</code>
command behavior to output RFC-2822 compliant date string.
</p>

<hr>

<h3><a name="s-cmd-wild"></a>4.3.8 Shell wildcards</h3>

<p>
Often you want a command to work with a group of files without typing all of
them.  The filename expansion pattern using the shell
<strong>wildcards</strong> facilitate this needs.
</p>
<ul>
<li>
<p>
<samp>*</samp>
</p>
<ul>
<li>
<p>
This matches any group of 0 or more characters.
</p>
</li>
<li>
<p>
This does not match a filename started with &quot;<samp>.</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>?</samp>
</p>
<ul>
<li>
<p>
This matches exactly one character.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[...]</samp>
</p>
<ul>
<li>
<p>
This matches exactly one character with any character enclosed in brackets
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[a-z]</samp>
</p>
<ul>
<li>
<p>
This matches exactly one character with any character between <samp>a</samp>
and <samp>z</samp>.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[^...]</samp>
</p>
<ul>
<li>
<p>
This matches exactly one character other than any character enclosed in
brackets (excluding &quot;^&quot;).
</p>
</li>
</ul>
</li>
</ul>

<p>
For example, try the following and think yourself:
</p>

<pre>
     $ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
     $ echo *.txt
     1.txt 2.txt
     $ echo *
     1.txt 2.txt 3.c 4.h
     $ echo *.[hc]
     3.c 4.h
     $ echo .*
     . .. .5.txt
     $ echo .[^.]*
     .5.txt
     $ echo [^1-3]*
     4.h
     $ cd ..; rm -rf junk
</pre>

<hr>

<h3><a name="s-cmd-return"></a>4.3.9 Return value of the command</h3>

<p>
Each command returns its exit status as the return value.
</p>
<ul>
<li>
<p>
return value = 0 if the command executes successfully.
</p>
</li>
<li>
<p>
return value = non-zero if the command exits with error.
</p>
</li>
</ul>

<p>
This return value can be accessed by the <samp>$?</samp> shell variable
immediately after the execution.
</p>

<pre>
     $ [ 1 = 1 ] ; echo $?
     0
     $ [ 1 = 2 ] ; echo $?
     1
</pre>

<p>
Please note that, when the return value is used in the logical context for the
shell, <strong>success</strong> is treated as the logical
<strong>TRUE</strong>.  This is somewhat non-intuitive since
<strong>success</strong> bears value <strong>zero</strong>.
</p>

<p>
See <a href="ch-program.en.html#s-shell-cond">Shell conditionals, Section
13.2.5</a>.
</p>

<hr>

<h3><a name="s-cmd-typical"></a>4.3.10 Typical command sequences</h3>

<p>
Let's try to remember following shell command idioms.  See <a
href="ch-program.en.html#s-shell-param">Shell parameters, Section 13.2.3</a>,
<a href="ch-program.en.html#s-shell-redirect">Shell redirection, Section
13.2.4</a>, <a href="ch-program.en.html#s-shell-cond">Shell conditionals,
Section 13.2.5</a>, and <a href="ch-program.en.html#s-clprocess">Command-line
processing, Section 13.2.6</a> after reading these idioms.
</p>

<hr>

<h4><a name="s-cmd-back"></a>4.3.10.1 <samp>command &amp;</samp></h4>

<p>
The <code>command</code> is executed in the subshell in the
<strong>background</strong>.  Background jobs allow users to run multiple
programs in a single shell.
</p>

<p>
The management of the background process involves the shell built-ins:
<code>jobs</code>, <code>fg</code>, <code>bg</code>, and <code>kill</code>.
Please read the sections of the <code>bash(1)</code> manual page under
&quot;SIGNALS&quot;, &quot;JOB CONTROL&quot;, and &quot;SHELL BUILTIN
COMMANDS&quot;.  [<a href="footnotes.en.html#f29" name="fr29">29</a>]
</p>

<hr>

<h4><a name="s-cmd-pipe"></a>4.3.10.2 <samp>command1 | command2</samp></h4>

<p>
The standard output of <code>command1</code> is fed to the standard input of
<code>command2</code> .  Both commands may be running
<strong>concurrently</strong>.  This is called <strong>pipeline</strong>.
</p>

<hr>

<h4><a name="s-cmd-list"></a>4.3.10.3 <samp>command1 ; command2</samp></h4>

<p>
The <code>command1</code> and <code>command2</code> are executed
<strong>sequentially</strong>.
</p>

<hr>

<h4><a name="s-cmd-and"></a>4.3.10.4 <samp>command1 &amp;&amp; command2</samp></h4>

<p>
The <code>command1</code> is executed.  If successful, <code>command2</code> is
also executed <strong>sequentially</strong>.  Return success if both
<code>command1</code> <strong>and</strong> <code>command2</code> are
successful.
</p>

<hr>

<h4><a name="s-cmd-or"></a>4.3.10.5 <samp>command1 || command2</samp></h4>

<p>
The <code>command1</code> is executed.  If not successful,
<code>command2</code> is also executed <strong>sequentially</strong>.  Return
success if <code>command1</code> <strong>or</strong> <code>command2</code> are
successful.
</p>

<hr>

<h4><a name="s-cmd-stdout"></a>4.3.10.6 <samp>command &gt; <var>foo</var></samp></h4>

<p>
Redirect standard output of <code>command</code> to a file
<samp><var>foo</var></samp>.  (overwrite)
</p>

<hr>

<h4><a name="s-cmd-stdout2"></a>4.3.10.7 <samp>command &gt;&gt; <var>foo</var></samp></h4>

<p>
Redirect standard output of <code>command</code> to a file
<samp><var>foo</var></samp>.  (append)
</p>

<hr>

<h4><a name="s-cmd-stderr"></a>4.3.10.8 <samp>command &gt; <var>foo</var> 2&gt;&amp;1</samp></h4>

<p>
Redirect both standard output and standard error of <code>command</code> to a
file <samp><var>foo</var></samp>.
</p>

<hr>

<h4><a name="s-cmd-stdin"></a>4.3.10.9 <samp>command &lt; <var>foo</var></samp></h4>

<p>
Redirect standard input of <code>command</code> to a file
<samp><var>foo</var></samp>.  Try:
</p>

<pre>
     $ &lt;/etc/motd pager
      ... (the greetings)
     $ pager &lt;/etc/motd
      ... (the greetings)
     $ pager /etc/motd
      ... (the greetings)
     $ cat /etc/motd | pager
      ... (the greetings)
</pre>

<p>
Although all 4 syntaxes display the same thing, the last example runs extra
<code>cat</code> command and wastes resources with no reason.
</p>

<hr>

<h3><a name="s-cmd-alias"></a>4.3.11 Command alias</h3>

<p>
You can set an alias for the frequently used command.  For example:
</p>

<pre>
     $ alias la='ls -la'
</pre>

<p>
Now, <code>la</code> works as a short hand for <samp>ls -la</samp> which lists
all files in the long listing format.
</p>

<p>
You can identity exact path or identity of the command using <code>type</code>
command.  For example:
</p>

<pre>
     $ type ls
     ls is hashed (/bin/ls)
     $ type la
     la is aliased to `ls -la'
     $ type echo
     echo is a shell builtin
     $ type file
     file is /usr/bin/file
</pre>

<p>
Here <code>ls</code> was recently searched while <code>file</code> was not,
thus <code>ls</code> is &quot;hashed&quot;, i.e., the shell has an internal
record for the quick access to the location of the <code>ls</code> command.
</p>

<hr>

<h2><a name="s-text-process"></a>4.4 Unix-like text processing</h2>

<p>
There are few standard text processing tools which are used very often on the
Unix-like system.
</p>
<ul>
<li>
<p>
No regular expression is used:
</p>
<ul>
<li>
<p>
<code>head</code> outputs the first part of files.
</p>
</li>
<li>
<p>
<code>tail</code> outputs the last part of files.
</p>
</li>
<li>
<p>
<code>sort</code> sorts lines of text files.
</p>
</li>
<li>
<p>
<code>uniq</code> removes duplicate lines from a sorted file.
</p>
</li>
<li>
<p>
<code>tr</code> translates or deletes characters.
</p>
</li>
<li>
<p>
<code>diff</code> compares files line by line.
</p>
</li>
</ul>
</li>
<li>
<p>
Basic regular expression (BRE) is used:
</p>
<ul>
<li>
<p>
<code>grep</code> matches text with the pattern.
</p>
</li>
<li>
<p>
<code>ed</code> is a primitive line editor.
</p>
</li>
<li>
<p>
<code>sed</code> is a stream editor.
</p>
</li>
<li>
<p>
<code>vi</code> is a screen editor.
</p>
</li>
<li>
<p>
<code>emacs</code> is a screen editor.
</p>
</li>
</ul>
</li>
<li>
<p>
Extended regular expression (ERE) is used:
</p>
<ul>
<li>
<p>
<code>egrep</code> matches text with pattern.
</p>
</li>
<li>
<p>
<code>awk</code> does simple text processing.  See <a
href="ch-program.en.html#s-awk">Awk, Section 13.3</a>.
</p>
</li>
<li>
<p>
<code>perl</code> does every conceivable text processing.  See <a
href="ch-program.en.html#s-perl">Perl, Section 13.4</a>.
</p>
</li>
</ul>
</li>
</ul>

<p>
See <a href="ch-tips.en.html#s-perl-i">Regular-expression substitution, Section
8.6.13</a>, <a href="ch-tips.en.html#s-scrp-snip">Script snippets for piping
commands, Section 8.6.18</a>, and <a href="ch-tips.en.html#s-perl-mad">Perl
short script madness, Section 8.6.20</a> for some script examples.
</p>

<hr>

<h3><a name="s-regex"></a>4.4.1 Regular expressions</h3>

<p>
Regular expressions are used in many text processing tools.  They are analogous
to the shell wildcards (see <a href="#s-cmd-wild">Shell wildcards, Section
4.3.8</a>), but they are both more complicated and more powerful.
</p>

<p>
The regular expression describes the matching pattern and is made up of text
characters and <strong>metacharacters</strong>.  The metacharacter is just a
character with a special meaning.  There are 2 major styles, BRE and ERE,
depending on the text tools as described in <a href="#s-text-process">Unix-like
text processing, Section 4.4</a>.
</p>

<p>
For the EREs, the <strong>metacharacters</strong> include &quot;<samp>\ .  [ ]
^ $ * + ?  ( ) { } |</samp>&quot;.  The regular expression means:
</p>
<ul>
<li>
<p>
<samp>c</samp>
</p>
<ul>
<li>
<p>
This matches the non-metacharacter &quot;<samp>c</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\c</samp>
</p>
<ul>
<li>
<p>
This matches the literal character &quot;<samp>c</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>.</samp>
</p>
<ul>
<li>
<p>
This matches any character including newline.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>^</samp>
</p>
<ul>
<li>
<p>
This matches the beginning of a string.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>$</samp>
</p>
<ul>
<li>
<p>
This matches the end of a string.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\&lt;</samp>
</p>
<ul>
<li>
<p>
This matches the beginning of a word.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>\&gt;</samp>
</p>
<ul>
<li>
<p>
This matches the end of a word.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[abc...]</samp>
</p>
<ul>
<li>
<p>
This character list matches any of the characters
&quot;<samp>abc...</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>[^abc...]</samp>
</p>
<ul>
<li>
<p>
This negated character list matches any of the characters except
&quot;<samp>abc...</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r*</samp>
</p>
<ul>
<li>
<p>
This matches zero or more regular expressions identified by
&quot;<samp>r</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r+</samp>
</p>
<ul>
<li>
<p>
This matches one or more regular expressions identified by
&quot;<samp>r</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r?</samp>
</p>
<ul>
<li>
<p>
This matches zero or one regular expressions identified by
&quot;<samp>r</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>r1|r2</samp>
</p>
<ul>
<li>
<p>
This matches one of the regular expressions identified by
&quot;<samp>r1</samp>&quot; or &quot;<samp>r2</samp>&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
<samp>(r1|r2)</samp>
</p>
<ul>
<li>
<p>
This matches one of the regular expressions identified by
&quot;<samp>r1</samp>&quot; or &quot;<samp>r2</samp>&quot; and treats it as a
<strong>bracketed</strong> regular expression.
</p>
</li>
</ul>
</li>
</ul>

<p>
In BREs the <strong>metacharacters</strong> &quot;<samp>+ ?  ( ) { }
|</samp>&quot; lose their special meaning; instead use the backslashed versions
&quot;<samp>\+ \?  \( \) \{ \} \|</samp>&quot;.  Thus the grouping construct
<samp>(r1|r2)</samp> needs to be quoted as <samp>\(r1|r2\)</samp> in BREs.
Since <code>emacs</code>, although being basically BRE, treats &quot;<samp>+
?</samp>&quot; as the <strong>metacharacters</strong>.  Thus there are no needs
to quote them.  See <a href="#s-replaceex">Replacement expressions, Section
4.4.2</a> for how the grouping construct is used.
</p>

<p>
For example, <code>grep</code> can be used to perform the text search using the
regular expression:
</p>

<pre>
     $ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                         GNU GENERAL PUBLIC LICENSE
                         GNU GENERAL PUBLIC LICENSE
       Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</pre>

<hr>

<h3><a name="s-replaceex"></a>4.4.2 Replacement expressions</h3>

<p>
For the replacement expression, following characters have special meanings:
</p>
<ul>
<li>
<p>
<samp>&amp;</samp>
</p>
<ul>
<li>
<p>
This represents what the regular expression matched.  (use <samp>\&amp;</samp>
in <code>emacs</code>)
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>
<samp>\<var>n</var></samp>
</p>
<ul>
<li>
<p>
This represents what the <var>n</var>-th <strong>bracketed</strong> regular
expression matched.
</p>
</li>
</ul>
</li>
</ul>

<p>
For Perl replacement string, <samp>$<var>n</var></samp> is used instead of
<samp>\<var>n</var></samp> and <samp>&amp;</samp> has no special meaning.
</p>

<p>
For example:
</p>

<pre>
     $ echo zzz1abc2efg3hij4 | \
       sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&amp;=/'
     zzz=1abc2efg3hij4=
     $ echo zzz1abc2efg3hij4 | \
       sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
     zzzefg3hij4===1abc
     $ echo zzz1abc2efg3hij4 | \
       perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
     zzzefg3hij4===1abc
     $ echo zzz1abc2efg3hij4 | \
       perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&amp;=/'
     zzz=&amp;=
</pre>

<p>
Here please pay extra attention to the style of the <strong>bracketed</strong>
regular expression and how the matched strings are used in the text replacement
process on different tools.
</p>

<p>
These regular expressions can be used for the cursor movements and the text
replacement actions in the editors too.
</p>

<p>
Please read all the related manual pages to learn these commands.
</p>

<hr>

<h2><a name="s-unixfile"></a>4.5 Unix-like filesystem</h2>

<p>
In the GNU/Linux and other Unix-like OS systems, the <strong>files</strong> are
organized into <strong>directories</strong>.  [<a href="footnotes.en.html#f30"
name="fr30">30</a>] All <strong>files</strong> and <strong>directories</strong>
are arranged in one big tree, the file hierarchy, rooted at <code>/</code>.
</p>

<p>
These files and directories can be spread out over several devices.  The
<code>mount(8)</code> command serves to attach the file system found on some
device to the big file tree.  Conversely, the <code>umount(8)</code> command
will detach it again.
</p>

<hr>

<h3><a name="s-file-basics"></a>4.5.1 Unix file basics</h3>

<p>
Here are the basics:
</p>
<ul>
<li>
<p>
Filenames are case sensitive.  That is, <code>MYFILE</code> and
<code>MyFile</code> are <strong>different</strong> files.
</p>
</li>
<li>
<p>
The root directory is referred to as simply <code>/</code>.  Don't confuse this
&quot;root&quot; with the root user.  See <a href="#s-login-root">Login to a
shell prompt as root, Section 4.1.1</a>.
</p>
</li>
<li>
<p>
Every directory has a name which can contain any letters or symbols
<strong>except</strong> <code>/</code>.  [<a href="footnotes.en.html#f31"
name="fr31">31</a>] The root directory is an exception; its name is
<code>/</code> (pronounced &quot;slash&quot; or &quot;the root directory&quot;)
and it cannot be renamed.
</p>
</li>
<li>
<p>
Each file or directory is designated by a <strong>fully-qualified
filename</strong>, <strong>absolute filename</strong>, or
<strong>path</strong>, giving the sequence of directories which must be passed
through to reach it.  The three terms are synonymous.  All absolute filenames
begin with the <code>/</code> directory, and there's a <code>/</code> between
each directory or file in the filename.  The first <code>/</code> is the name
of a directory, but the others are simply separators to distinguish the parts
of the filename.
</p>
<p>
The words used here can be confusing.  Take the following example:
</p>
<pre>
     /usr/share/keytables/us.map.gz
</pre>
<p>
This is a fully-qualified filename; some people call it a
<strong>path</strong>.  However, people will also refer to
<code>us.map.gz</code> alone as a filename.  [<a href="footnotes.en.html#f32"
name="fr32">32</a>]
</p>
</li>
<li>
<p>
The root directory has a number of branches, such as <code>/etc/</code> and
<code>/usr/</code>.  These subdirectories in turn branch into still more
subdirectories, such as <code>/etc/init.d/</code> and <code>/usr/local/</code>.
The whole thing together is called the <strong>directory tree</strong>.
</p>
<p>
You can think of an absolute filename as a route from the base of the tree
(<code>/</code>) to the end of some branch (a file).  You'll also hear people
talk about the directory tree as if it were a <strong>family</strong> tree:
thus subdirectories have <strong>parents</strong>, and a path shows the
complete ancestry of a file.
</p>
<p>
There are also relative paths that begin somewhere other than the root
directory.  You should remember that the directory <code>../</code> refers to
the parent directory.
</p>
</li>
<li>
<p>
There's no directory that corresponds to a physical device, such as your hard
disk.  This differs from CP/M, DOS, and Windows, where all paths begin with a
device name such as <samp>C:\</samp>.  See <a href="#s-file-system">The
filesystem concept in Debian, Section 4.5.2</a>.
</p>
</li>
</ul>

<p>
The detailed best practices for the file hierarchy are described in the
<code><a href="file:///usr/share/doc/debian-policy/fhs/fhs.txt.gz">Filesystem
Hierarchy Standard</a></code>.  You should remember the following facts as the
starter:
</p>
<ul>
<li>
<p>
<code>/</code>
</p>
<ul>
<li>
<p>
A simple <code>/</code> represents the root directory.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/etc/</code>
</p>
<ul>
<li>
<p>
This is the place for the system wide configuration files.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/var/log/</code>
</p>
<ul>
<li>
<p>
This is the place for the system log files.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>/home/</code>
</p>
<ul>
<li>
<p>
This is the directory which contains all the home directories for all
non-privileged users.
</p>
</li>
</ul>
</li>
</ul>

<hr>

<h3><a name="s-file-system"></a>4.5.2 The filesystem concept in Debian</h3>

<p>
Following the Unix tradition, the Debian system provides the filesystem under
which physical data on harddisks and other storage devices, and the interaction
with the hardware devices such as console screens and remote serial consoles
are represented in an unified manner.
</p>

<p>
Each file, directory, named pipe, or physical device on a Debian system has a
data structure called an <strong>inode</strong> which describes its associated
attributes such as the user who owns it (owner), the group that it belongs to,
the time last accessed, etc.  See <code><a
href="/usr/include/linux/fs.h">/usr/include/linux/fs.h</a></code> for the exact
definition of <samp>struct inode</samp> in the Debian GNU/Linux system.
</p>

<p>
This unified representation of physical entities is very powerful since this
allows us to use the same command for the same kind of operation on many
totally different devices.
</p>

<p>
All your files could be on one disk --- or you could have 20 disks, some of
them connected to a different computer elsewhere on the network.  You can't
tell just by looking at the directory tree, and nearly all commands work just
the same way no matter what physical device(s) your files are really on.
</p>

<hr>

<h3><a name="s-file-perm"></a>4.5.3 File and directory access permissions</h3>

<p>
File and directory access permissions are defined separately for the following
three categories of affected users:
</p>
<ul>
<li>
<p>
the <strong>user</strong> who owns the file (u),
</p>
</li>
<li>
<p>
other users in the <strong>group</strong> which the file belongs to (g), and
</p>
</li>
<li>
<p>
all <strong>other</strong> users (o).
</p>
</li>
</ul>

<p>
For a file, each corresponding permission allows:
</p>
<ul>
<li>
<p>
<strong>read</strong> (r): to examine contents of the file,
</p>
</li>
<li>
<p>
<strong>write</strong> (w): to modify the file, and
</p>
</li>
<li>
<p>
<strong>execute</strong> (x): to run the file as a command.
</p>
</li>
</ul>

<p>
For a directory, each corresponding permission allows:
</p>
<ul>
<li>
<p>
<strong>read</strong> (r): to list contents of the directory,
</p>
</li>
<li>
<p>
<strong>write</strong> (w): to add or remove files in the directory, and
</p>
</li>
<li>
<p>
<strong>execute</strong> (x): to access files in the directory.
</p>
</li>
</ul>

<p>
Here, <strong>execute</strong> permission on the directory means not only to
allow reading of files in its directory but also to allow viewing their
attributes, such as the size and the modification time.
</p>

<p>
To display permission information (and more) for files and directories,
<code>ls</code> is used.  See <code>ls(1)</code>.  When <code>ls</code> invoked
with the <samp>-l</samp> option, it displays the following information in the
order given:
</p>
<ul>
<li>
<p>
the <strong>type of file</strong> (first character)
</p>
<ul>
<li>
<p>
<samp>-</samp>: normal file
</p>
</li>
<li>
<p>
<samp>d</samp>: directory
</p>
</li>
<li>
<p>
<samp>l</samp>: symlink
</p>
</li>
<li>
<p>
<samp>c</samp>: character device node
</p>
</li>
<li>
<p>
<samp>b</samp>: block device node
</p>
</li>
<li>
<p>
<samp>p</samp>: named pipe
</p>
</li>
<li>
<p>
<samp>s</samp>: socket
</p>
</li>
</ul>
</li>
<li>
<p>
the file's access <strong>permissions</strong> (the next nine characters,
consisting of three characters each for user, group, and other in this order)
</p>
</li>
<li>
<p>
the <strong>number of hard links</strong> to the file
</p>
</li>
<li>
<p>
the name of the <strong>user</strong> who owns the file
</p>
</li>
<li>
<p>
the name of the <strong>group</strong> which the file belongs to
</p>
</li>
<li>
<p>
the <strong>size</strong> of the file in characters (bytes)
</p>
</li>
<li>
<p>
the <strong>date and time</strong> of the file (mtime)
</p>
</li>
<li>
<p>
the <strong>name</strong> of the file.
</p>
</li>
</ul>

<p>
To change the owner of the file, <code>chown</code> is used from the root
account.  To change the group of the file, <code>chgrp</code> is used from the
file's owner or root account.  To change file and directory access permissions,
<code>chmod</code> is used from the file's owner or root account.  Basic syntax
to manipulate <code>foo</code> file is:
</p>

<pre>
     # chown <var>newowner</var> foo
     # chgrp <var>newgroup</var> foo 
     # chmod  [ugoa][+-=][rwx][,...] foo
</pre>

<p>
See <code>chown(1)</code>, <code>chgrp(1)</code>, and <code>chmod(1)</code> for
the detail.
</p>

<p>
For example, in order to make a directory tree to be owned by a user
<var>foo</var> and shared by a group <var>bar</var>, issue the following
commands from the root account:
</p>

<pre>
     # cd /some/location/
     # chown -R <var>foo</var>:<var>bar</var> .
     # chmod -R ug+rwX,o=rX .
</pre>

<p>
There are three more special permission bits:
</p>
<ul>
<li>
<p>
<strong>set user ID</strong> (s or S instead of user's x),
</p>
</li>
<li>
<p>
<strong>set group ID</strong> (s or S instead of group's x), and
</p>
</li>
<li>
<p>
<strong>sticky bit</strong> (t or T instead of other's x).
</p>
</li>
</ul>

<p>
Here the output of <code>ls -l</code> for these bits is capitalized if
execution bits hidden by these outputs are unset.
</p>

<p>
Setting <strong>set user ID</strong> on an executable file allows a user to
execute the executable file with the owner ID of the file (for example
<strong>root</strong>).  Similarly, setting <strong>set group ID</strong> on an
executable file allows a user to execute the executable file with the group ID
of the file (for example <strong>root</strong>).  Because these settings can
cause security risks, enabling them requires extra caution.
</p>

<p>
Setting <strong>set group ID</strong> on a directory enables the BSD-like file
creation scheme where all files created in the directory belong to the
<strong>group</strong> of the directory.
</p>

<p>
Setting the <strong>sticky bit</strong> on a directory prevents a file in the
directory from being removed by a user who is not the owner of the file.  In
order to secure the contents of a file in world-writable directories such as
<code>/tmp</code> or in group-writable directories, one must not only set
<strong>write</strong> permission off for the file but also set the
<strong>sticky bit</strong> on the directory.  Otherwise, the file can be
removed and a new file can be created with the same name by any user who has
write access to the directory.
</p>

<p>
Here are a few interesting examples of the file permissions.
</p>

<pre>
     $ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
     crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
     -rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
     -rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
     -rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
     $ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
     drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
     drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
     drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
     drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
     drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</pre>

<p>
There is an alternative numeric mode to describe file permissions in
<code>chmod(1)</code> commands.  This numeric mode uses 3 to 4 digit wide octal
(radix=8) numbers.  Each digit corresponds to:
</p>
<ul>
<li>
<p>
1st optional digit: sum of <strong>set user ID</strong> (=4), <strong>set group
ID</strong> (=2), and <strong>sticky bit</strong> (=1)
</p>
</li>
<li>
<p>
2nd digit: sum of <strong>read</strong> (=4), <strong>write</strong> (=2), and
<strong>execute</strong> (=1) permissions for <strong>user</strong>
</p>
</li>
<li>
<p>
3rd digit: ditto for <strong>group</strong>
</p>
</li>
<li>
<p>
4th digit: ditto for <strong>other</strong>
</p>
</li>
</ul>

<p>
This sounds complicated but it is actually quite simple.  If you look at the
first few (2-10) columns from <samp>ls -l</samp> command output and read it as
a binary (radix=2) representation of file permissions (&quot;-&quot; being
&quot;0&quot; and &quot;rwx&quot; being &quot;1&quot;), this numeric mode value
should make sense as an octal (radix=8) representation of file permissions to
you.  [<a href="footnotes.en.html#f33" name="fr33">33</a>] For example, try:
</p>

<pre>
     $ touch <var>foo</var> <var>bar</var>
     $ chmod u=rw,go=r <var>foo</var>
     $ chmod 644 <var>bar</var>
     $ ls -l <var>foo</var> <var>bar</var>
     -rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
     -rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</pre>

<p>
The default file permission mask can be set by using the <code>umask</code>
shell built-in command.  See <code>builtins(7)</code>.
</p>

<hr>

<h3><a name="s-timestamp"></a>4.5.4 Timestamps</h3>

<p>
There are three types of timestamps for a GNU/Linux file:
</p>
<ul>
<li>
<p>
<strong>mtime</strong>: the modification time (<samp>ls -l</samp>),
</p>
</li>
<li>
<p>
<strong>ctime</strong>: the status change time (<samp>ls -lc</samp>), and
</p>
</li>
<li>
<p>
<strong>atime</strong>: the last access time (<samp>ls -lu</samp>).
</p>
</li>
</ul>

<p>
Note that <strong>ctime</strong> is not file creation time.
</p>
<ul>
<li>
<p>
Overwriting a file will change all of <strong>mtime</strong>,
<strong>ctime</strong>, and <strong>atime</strong> of the file.
</p>
</li>
<li>
<p>
Changing permission or owner of a file will change <strong>ctime</strong> and
<strong>atime</strong> of the file.
</p>
</li>
<li>
<p>
Reading a file will change <strong>atime</strong> of the file.
</p>
</li>
</ul>

<p>
Note that even simply reading a file on the Debian system will normally cause a
file write operation to update <strong>atime</strong> information in the
<strong>inode</strong>.  Mounting a filesystem with the <samp>noatime</samp>
option will let the system skip this operation and will result in faster file
access for the read.  See <code>mount(8)</code>.
</p>

<p>
Use <code>touch(1)</code> command to change timestamps of existing files.
</p>

<hr>

<h3><a name="s-links"></a>4.5.5 Links</h3>

<p>
There are two methods of associating a file <var>foo</var> with a different
filename <var>bar</var>.
</p>
<ul>
<li>
<p>
a <strong>hard link</strong> is a duplicate name for an existing file (<samp>ln
<var>foo</var> <var>bar</var></samp>),
</p>
</li>
<li>
<p>
a <strong>symbolic link</strong>, or &quot;symlink&quot;, is a special file
that points to another file by name (<samp>ln -s <var>foo</var>
<var>bar</var></samp>).
</p>
</li>
</ul>

<p>
See the following example for the changes in link counts and the subtle
differences in the result of the <code>rm</code> command.
</p>

<pre>
     $ echo &quot;Original Content&quot; &gt; <var>foo</var>
     $ ls -l <var>foo</var>
     -rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
     $ ln <var>foo</var> <var>bar</var>     # hard link
     $ ln -s <var>foo</var> <var>baz</var>  # symlink
     $ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
     -rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
     lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
     -rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
     $ rm <var>foo</var>
     $ echo &quot;New Content&quot; &gt; <var>foo</var>
     $ cat <var>bar</var>
     Original Content
     $ cat <var>baz</var>
     New Content
</pre>

<p>
The symlink always has nominal file access permissions of
&quot;rwxrwxrwx&quot;, as shown in the above example, with the effective access
permissions dictated by the permissions of the file that it points to.
</p>

<p>
The <code>.</code> directory links to the directory that it appears in, thus
the link count of any new directory starts at 2.  The <code>..</code> directory
links to the parent directory, thus the link count of the directory increases
with the addition of new subdirectories.
</p>

<hr>

<h3><a name="s-fifo"></a>4.5.6 Named pipes (FIFOs)</h3>

<p>
A named pipe is a file that acts like a pipe.  You put something into the file,
and it comes out the other end.  Thus it's called a FIFO, or
First-In-First-Out: the first thing you put in the pipe is the first thing to
come out the other end.
</p>

<p>
If you write to a named pipe, the process which is writing to the pipe doesn't
terminate until the information being written is read from the pipe.  If you
read from a named pipe, the reading process waits until there's something to
read before terminating.  The size of the pipe is always zero --- it doesn't
store data, it just links two processes like the shell <samp>|</samp>.
However, since this pipe has a name, the two processes don't have to be on the
same command line or even be run by the same user.
</p>

<p>
You can try it by doing the following:
</p>

<pre>
     $ cd; mkfifo mypipe
     $ echo &quot;hello&quot; &gt;mypipe &amp; # put into background
     [1] <var>5952</var>
     $ ls -l mypipe
     prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
     $ cat mypipe
     hello
     [1]+  Done                    echo hello &gt;mypipe
     $ ls mypipe
     prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
     $ rm mypipe
</pre>

<hr>

<h3><a name="s-sockets"></a>4.5.7 Sockets</h3>

<p>
The socket is similar to the named pipe (FIFO) and allows processes to exchange
information.  For the socket, those processes do not need to be running at the
same time nor need to be the children of the same ancestor process.  This is
the endpoint for the inter process communication.  The exchange of information
may occur over the network between different hosts.
</p>

<hr>

<h3><a name="s-device"></a>4.5.8 Device files</h3>

<p>
Device files refer to physical or virtual devices on your system, such as your
hard disk, video card, screen, or keyboard.  An example of a virtual device is
the console, represented by <samp>/dev/console</samp>.
</p>

<p>
There are two types of devices:
</p>
<ul>
<li>
<p>
<strong>character device</strong>
</p>
<ul>
<li>
<p>
This can be accessed one character at a time, that is, the smallest unit of
data which can be written to or read from the device is a character (byte).
</p>
</li>
</ul>
</li>
<li>
<p>
<strong>block device</strong>
</p>
<ul>
<li>
<p>
This must be accessed in larger units called blocks, which contain a number of
characters.  Your hard disk is a block device.
</p>
</li>
</ul>
</li>
</ul>

<p>
You can read and write device files, though the file may well contain binary
data which may be an incomprehensible-to-humans gibberish.  Writing data
directly to these files is sometimes useful for the troubleshooting of hardware
connections.  For example, you can dump a text file to the printer device
<code>/dev/lp0</code> or send modem commands to the appropriate serial port
<code>/dev/ttyS0</code>.  But, unless this is done carefully, it may cause a
major disaster.  So be cautious.
</p>

<hr>

<h4><a name="s-devnull"></a>4.5.8.1 <code>/dev/null</code> etc.</h4>

<p>
<code>/dev/null</code> is a special device file that discards anything you
write to it.  If you don't want something, throw it in <code>/dev/null</code>.
It's essentially a bottomless pit.  If you read <code>/dev/null</code>, you'll
get an end-of-file (EOF) character immediately.
</p>

<p>
<code>/dev/zero</code> is similar, only if you read from it you get the
<samp>\0</samp> character (not the same as the number zero ASCII).  See <a
href="ch-tips.en.html#s-dummyfile">Dummy files, Section 8.6.34</a>.
</p>

<hr>

<h4><a name="s-node"></a>4.5.8.2 Device node number</h4>

<p>
The device node number are displayed by executing <code>ls</code> as:
</p>

<pre>
     $ ls -l /dev/hda /dev/ttyS0 /dev/zero
     brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
     crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
     crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</pre>

<p>
Here,
</p>
<ul>
<li>
<p>
<code>/dev/hda</code> has the major device number 3 and the minor device number
0.  This is read/write accessible by the user who belongs to <samp>disk</samp>
group,
</p>
</li>
<li>
<p>
<code>/dev/ttyS0</code> has the major device number 4 and the minor device
number 64.  This is read/write accessible by the user who belongs to
<samp>dialout</samp> group, and
</p>
</li>
<li>
<p>
<code>/dev/zero</code> has the major device number 1 and the minor device
number 5.  This is read/write accessible by anyone.
</p>
</li>
</ul>

<p>
In the older system, the installation process creates the device nodes using
<code>/sbin/MAKEDEV</code> command.  See <code>MAKEDEV(8)</code>.
</p>

<p>
In the newer system, the filesystem under in the <code>/dev</code> is
automatically populated by the device filesystem similar to the
<code>/proc</code> filesystem.
</p>

<hr>

<h3><a name="s-procfs"></a>4.5.9 <code>/proc</code> filesystem</h3>

<p>
The <code>/proc</code> filesystem is a pseudo-filesystem and contains
information about the system and running processes.
</p>

<p>
People frequently panic when they notice one file in particular -
<code>/proc/kcore</code> - which is generally huge.  This is (more or less) a
copy of the contents of your computer's memory.  It's used to debug the kernel.
It doesn't actually exist anywhere, so don't worry about its size.
</p>

<p>
See <a href="ch-kernel.en.html#s-proc-sys">Tuning the kernel through the proc
filesystem, Section 7.2</a> and <code>proc(5)</code>.
</p>

<hr>

<h2><a name="s-xtuto"></a>4.6 X Window System</h2>

<p>
See <a href="ch-tune.en.html#s-x">X, Section 9.4</a>.
</p>

<hr>

<h3><a name="s-xstart"></a>4.6.1 Start the X Window System</h3>

<p>
The X Window System can be started automatically with <code>xdm</code>-like
graphical login daemon or type following from the console.
</p>

<pre>
     $ exec startx
</pre>

<hr>

<h3><a name="s-xmenu"></a>4.6.2 Menu in the X Window System</h3>

<p>
Since X environment can accommodate many window managers, their user interfaces
vary quite a bit.  Please remember that right-clicking the root window will
bring up menu selections.  This is always available.
</p>
<ul>
<li>
<p>
To gain the shell command prompt, start Xterm from menu:
</p>
<ul>
<li>
<p>
&quot;XShells&quot; --&gt; &quot;XTerm&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
For graphical browsing of the web pages, start Mozilla from menu:
</p>
<ul>
<li>
<p>
&quot;Apps&quot; --&gt; &quot;Net&quot; --&gt; &quot;Mozilla Navigator&quot;.
</p>
</li>
</ul>
</li>
<li>
<p>
For graphical browsing of the PDF files, start Xpdf from menu:
</p>
<ul>
<li>
<p>
&quot;Apps&quot; --&gt; &quot;Viewers&quot; --&gt; &quot;Xpdf&quot;.
</p>
</li>
</ul>
</li>
</ul>

<p>
If you do not find menu entry, install the pertinent packages.  See <a
href="ch-package.en.html#s-apt-install">Beginning Debian package management,
Section 6.2</a>.
</p>

<hr>

<h3><a name="s-xkeys"></a>4.6.3 Keyboard sequence for the X Window System</h3>

<p>
Followings are the important keystrokes to remember when running the X Window
System.
</p>
<ul>
<li>
<p>
Ctrl-Alt-F1 through F6: Switch to other pseudo-terminals (from an X window,
DOSEMU, etc.)
</p>
</li>
<li>
<p>
Alt-F7: Switch back to X window
</p>
</li>
<li>
<p>
Ctrl-Alt-minus: Change screen resolution in X window (minus refers to the keys
on the numeric keypad)
</p>
</li>
<li>
<p>
Ctrl-Alt-plus: Change screen resolution opposite way in X window (plus refers
to the keys on the numeric keypad)
</p>
</li>
<li>
<p>
Ctrl-Alt-Backspace: Terminate the X Server program
</p>
</li>
<li>
<p>
Alt-X, Alt-C, Alt-V: Usual Windows/Mac Cut, Copy, Paste keys combinations with
Ctrl- keys are replaced by these Alt- keys in some programs such as Netscape
Composer.
</p>
</li>
</ul>

<hr>

<h2><a name="s-cmd-study"></a>4.7 Further study</h2>

<p>
At this moment, I recommend you to read the key guide books from <code><a
href="http://www.tldp.org/guides.html">The Linux Documentation Project:
Guides</a></code>:
</p>
<ul>
<li>
<p>
&quot;The Linux System Administrators' Guide&quot;,
</p>
<ul>
<li>
<p>
This covers all of the aspects of keeping the system running, handling user
accounts, backups, configuration of the system.
</p>
</li>
<li>
<p>
package: <code>sysadmin-guide</code>
</p>
</li>
<li>
<p>
file: <code><a
href="file:///usr/share/doc/sysadmin-guide/html/index.html">file:///usr/share/doc/sysadmin-guide/html/index.html</a></code>
</p>
</li>
<li>
<p>
web: <code><a
href="http://www.tldp.org/LDP/sag/index.html">http://www.tldp.org/LDP/sag/index.html</a></code>
</p>
</li>
</ul>
</li>
<li>
<p>
&quot;The Linux Network Administrator's Guide, Second Edition&quot;,
</p>
<ul>
<li>
<p>
This is a single reference for network administration in a Linux environment.
</p>
</li>
<li>
<p>
package: <code>(not available)</code>
</p>
</li>
<li>
<p>
file: <code><a href="(not%20applicable)">(not applicable)</a></code>
</p>
</li>
<li>
<p>
web: <code><a
href="http://www.tldp.org/LDP/nag2/index.html">http://www.tldp.org/LDP/nag2/index.html</a></code>
</p>
</li>
</ul>
</li>
<li>
<p>
&quot;Linux: Rute User's Tutorial and Exposition&quot;
</p>
<ul>
<li>
<p>
A nice online and hardcover book covering GNU/Linux system administration.
</p>
</li>
<li>
<p>
By Paul Sheer
</p>
</li>
<li>
<p>
Published by Prentice Hall
</p>
</li>
<li>
<p>
Package: <code>rutebook</code> (from <samp>non-free</samp>)
</p>
</li>
<li>
<p>
File: <code>file:///usr/share/doc/rutebook/</code>
</p>
</li>
</ul>
</li>
</ul>

<p>
See <a href="ch-support.en.html">Support for Debian, Chapter 15</a> for more
learning resources.
</p>

<hr>

<p>
[ <a href="ch-install.en.html">previous</a> ]
[ <a href="index.en.html#contents">Contents</a> ]
[ <a href="ch-preface.en.html">1</a> ]
[ <a href="ch-system.en.html">2</a> ]
[ <a href="ch-install.en.html">3</a> ]
[ 4 ]
[ <a href="ch-woody.en.html">5</a> ]
[ <a href="ch-package.en.html">6</a> ]
[ <a href="ch-kernel.en.html">7</a> ]
[ <a href="ch-tips.en.html">8</a> ]
[ <a href="ch-tune.en.html">9</a> ]
[ <a href="ch-gateway.en.html">10</a> ]
[ <a href="ch-edit.en.html">11</a> ]
[ <a href="ch-vcs.en.html">12</a> ]
[ <a href="ch-program.en.html">13</a> ]
[ <a href="ch-gnupg.en.html">14</a> ]
[ <a href="ch-support.en.html">15</a> ]
[ <a href="ap-appendix.en.html">A</a> ]
[ <a href="ch-woody.en.html">next</a> ]
</p>

<hr>

<p>
Debian Reference
</p>

<address>
CVS, Mon Jun 16 21:20:26 UTC 2008<br>
<br>
Osamu Aoki <code><a href="mailto:osamu#at#debian.org">osamu#at#debian.org</a></code><br>
<a href="ap-appendix.en.html#s-authors">Authors, Section A.1</a><br>
<br>
</address>
<hr>

</body>

</html>

